<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Type4py practical  deep similarity learning-based type inference for python | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Type4py: practical  deep similarity learning-based type inference for pythonBasic Information: Title: Type4Py: Practical Deep Similarity Learning-Based Type Inference for Python (论文题目：Type4Py: 基于深度相似度">
<meta property="og:type" content="article">
<meta property="og:title" content="Type4py practical  deep similarity learning-based type inference for python">
<meta property="og:url" content="http://example.com/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Type4py: practical  deep similarity learning-based type inference for pythonBasic Information: Title: Type4Py: Practical Deep Similarity Learning-Based Type Inference for Python (论文题目：Type4Py: 基于深度相似度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-23T08:43:17.000Z">
<meta property="article:modified_time" content="2023-05-24T08:29:42.469Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Type4py practical  deep similarity learning-based type inference for python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-24 16:29:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Type4py practical  deep similarity learning-based type inference for python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T08:43:17.000Z" title="发表于 2023-05-23 16:43:17">2023-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-24T08:29:42.469Z" title="更新于 2023-05-24 16:29:42">2023-05-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Type4py practical  deep similarity learning-based type inference for python"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Type4py-practical-deep-similarity-learning-based-type-inference-for-python"><a href="#Type4py-practical-deep-similarity-learning-based-type-inference-for-python" class="headerlink" title="Type4py: practical  deep similarity learning-based type inference for python"></a>Type4py: practical  deep similarity learning-based type inference for python</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Type4Py: Practical Deep Similarity Learning-Based Type Inference for Python</li>
<li>(论文题目：Type4Py: 基于深度相似度学习的 Python 类型推断)</li>
<li>Authors: Amir M. Mir, Evaldas Latoškinas, Sebastian Proksch, Georgios Gousios</li>
<li>Affiliation: Delft University of Technology, Delft, The Netherlands; Facebook, Menlo Park, USA</li>
<li>Keywords: Type Inference, Similarity Learning, Machine Learning, Mean Reciprocal Rank, Python</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://doi.org/10.1145/3510003.3510124">https://doi.org/10.1145/3510003.3510124</a>, GitHub: <a target="_blank" rel="noopener" href="https://github.com/saltudelft/type4py">https://github.com/saltudelft/type4py</a></li>
</ul>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><font color="red">相关工作概述： </font></p>
<p>该论文涉及两个方面的相关工作：静态类型推断和基于机器学习的类型推断。静态类型推断方法通过分析代码的语法和上下文信息，尽可能地确定变量的类型。而基于机器学习的类型推断方法则利用机器学习技术从数据中学习变量的类型模式。</p>
<p><font color="red">分类：</font></p>
<p><em>Machine Learning</em> (ML)：[2] [16] [31] [51]</p>
<p>ML with static methods ：[2] [51]</p>
<p>[2] Miltiadis Allamanis, Earl T Barr, Soline Ducousso, and Zheng Gao. 2020. Typilus: neural type hints. In <em>Proceedings of the 41st ACM SIGPLAN Conference on**Programming Language Design and Implementation</em>. 91–105.</p>
<p>[16] Vincent J Hellendoorn, Christian Bird, Earl T Barr, and Miltiadis Allamanis. 2018.Deep learning type inference. In <em>Proceedings of the 2018 26th acm joint meeting</em> on european software engineering conference and symposium on the foundations of <em>software engineering</em>. 152–162.</p>
<p>[31] Rabee Sohail Malik, Jibesh Patra, and Michael Pradel. 2019. NL2Type: inferringJavaScript function types from natural language information. In <em>2019 IEEE&#x2F;ACM**41st International Conference on Software Engineering (ICSE)</em>. IEEE, 304–315.</p>
<p>[51] Michael Pradel, Georgios Gousios, Jason Liu, and Satish Chandra. 2020. Typewriter: Neural type prediction with search-based validation. In <em>Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference an</em>Symposium on the Foundations of Software Engineering*. 209–220.</p>
<p>Machine Learning的局限性：</p>
<ol>
<li>静态类型推断方法依赖于开发者提供的类型注释，而这些注释可能不准确。</li>
<li>先前的方法在给出类型预测时通常只关注前几个可能的类型，而未考虑正确类型在推荐列表中的排名。（Top1是很重要的）</li>
</ol>
<p><font color="red">Type4py：</font></p>
<p>为了克服上述局限性，该论文提出了Type4Py方法，并做出了以下创新和贡献：</p>
<ol>
<li>Type4Py采用了基于深度相似度学习的方法，能够处理包含大量类型的词汇表。</li>
<li>作者通过使用一个类型检查器来检测和删除数据集中的错误类型注释，提高了数据集的准确性。(TypeWriter也提到了利用类型检查器来检查)</li>
</ol>
<p><font color="red">贡献：</font></p>
<ol>
<li>提出了基于深度相似度学习的类型推断方法Type4Py，能够处理大规模且多样化的类型词汇表。</li>
<li>构建了一个经过类型检查的数据集，包含大量Python项目和类型注释。</li>
<li>提供了针对Python的基于机器学习的类型自动完成功能的Visual Studio Code扩展。</li>
<li>通过在GitHub上公开发布Type4Py模型的实现和数据集，促进了未来研究的发展。</li>
</ol>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230522172538585.png" alt="image-20230522172538585"></p>
<h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work:"></a>Related work:</h3><p>Learning-based type inference是指使用机器学习方法来进行类型推断的技术。下面是相关工作的发展进程以及各个方法的改进或启发：</p>
<ol>
<li>JSNice: 在2015年，Rachev等人提出了JSNice，这是一个使用条件随机场（CRF）预测JavaScript标识符名称和类型注释的概率模型。JSNice的核心思想是捕捉程序元素之间的依赖关系。然而，JSNice的主要问题在于其依赖网络无法考虑程序或函数内的广泛上下文。</li>
<li>Xu et al.: Xu等人采用了概率图模型（PGM）来预测Python变量的类型。他们的方法提取了几种不确定的类型提示，例如属性访问、变量名和变量之间的数据流。虽然Xu等人的概率模型在性能上优于静态类型推断系统，但其系统速度较慢且缺乏可扩展性。</li>
<li>DeepTyper: Hellendoorn等人提出了DeepTyper，这是一个基于序列到序列神经网络模型，它在一个对齐的TypeScript代码语料库上进行训练。DeepTyper模型可以通过考虑更广泛的上下文来预测源代码文件中的类型注释。然而，DeepTyper在同一变量的标记级别出现的不一致预测方面存在问题。</li>
<li>NL2Type: Malik等人提出了NL2Type，这是一个预测JavaScript函数类型注释的神经网络模型。NL2Type的基本思想是利用源代码中的自然语言信息，如标识符名称和注释。NL2Type模型在类型注释预测任务上表现出优于JSNice和DeepTyper的性能。</li>
<li>TypeWriter: Pradel等人提出了TypeWriter，它为Python推断类型注释的深度神经网络模型。TypeWriter考虑了代码上下文和源代码中的自然语言信息。此外，TypeWriter通过采用组合搜索策略和外部类型检查器验证其神经模型的类型预测。TypeWriter在性能上超过了LAMBDANET和DeepTyper。</li>
<li>LAMBDANET: Wei等人引入了LAMBDANET，这是一种基于图神经网络的TypeScript类型推断方法。其主要思想是创建一个将待推断变量与逻辑约束和上下文提示（如变量赋值和名称）关联起来的类型依赖图。LAMBDANET采用类似指针网络的模型进行类型预测，可以预测未见过的用户定义类型。</li>
<li>OptTyper: Pandi等人提出了OptTyper，用于预测TypeScript语言中的类型。他们的方法的核心思想是从类型系统中提取确定性信息或逻辑约束，并将其与自然约束结合在一起形成一个优化问题。这使得OptTyper能够在不违反语言的类型规则的情况下进行类型正确的预测。OptTyper在性能上超过了LAMBDANET和DeepTyper。</li>
</ol>
<p>除了LAMBDANET外，所有讨论的基于学习的类型推断方法都使用了一个（较小的）固定大小的类型词汇表，例如1,000个类型。这限制了它们对用户定义和稀有类型的推断能力。为了解决这个问题，Allamanis等人提出了Typilus，它是一种基于图神经网络（GNN）的模型，将多个信息源（如标识符、语法模式和数据流）集成在一起，用于推断Python的类型注释。Typilus基于度量学习，学习区分相似的待推断符号和不同的符号。然而，Typilus需要复杂的源代码分析来创建其图表示，即数据流分析。最近，受到”Big Data”的启发，Jesse等人提出了TypeBert，这是一个使用简单的令牌序列表示的预训练BERT模型。实证结果显示，TypeBert通常优于LAMBDANET。Type4Py与其他基于学习的方法的区别总结在Table 1中。</p>
<p>这些相关工作的发展进程展示了学习型类型推断方法的不断演进和改进。从传统的概率模型到神经网络模型，这些方法在利用源代码中的信息、上下文和自然语言方面取得了进步，并在类型注释预测任务上取得了更好的性能。此外，一些方法还尝试解决固定类型词汇表的限制，以提高对用户定义和稀有类型的推断能力。这些工作为进一步研究和改进学习型类型推断方法提供了启示和参考。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h3><ul>
<li>a. Research background of this article:<ul>
<li>本文提出了一种新的Python类型推断模型Type4Py，通过使用深度相似度学习的神经网络模型，训练一个类型检查数据集以区别高维空间中的相似和不相似类型，从而得到类型聚类，有效地推断参数、变量和返回值的可能类型。</li>
</ul>
</li>
<li>b. Past methods, their problems, and motivation:<ul>
<li>过去的方法缺乏有效的数据集和性能评估，并且可能依赖不准确的人工类型注释。</li>
</ul>
</li>
<li>c. Research methodology proposed in this paper:<ul>
<li>本文提出了一种使用word embeddings表示自然信息、代码上下文和可见类型注释，用于训练神经网络模型预测类型的新模型Type4Py。</li>
</ul>
</li>
<li>d. Task and performance achieved by the methods in this paper:<ul>
<li>Type4Py在预测Python类型注释方面表现优秀，具有无限的类型词汇量，并通过Visual Studio Code扩展为开发人员提供基于ML的类型自动完成。</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h3><ul>
<li>a. Subject and characteristics:<ul>
<li>本研究的主题是基于机器学习的Python类型推断模型。</li>
</ul>
</li>
<li>b. Historical development:<ul>
<li>以往的方法往往依赖缺乏有效性能检测的数据集和不准确的人工类型注释。</li>
</ul>
</li>
<li>c. Past methods:<ul>
<li>以往的方法包括NL2Type模型、TypeWriter模型、LAMBDANET、OptTyper和Typilus。</li>
</ul>
</li>
<li>d. Past research shortcomings:<ul>
<li>过去的方法缺乏有效的数据集和性能评估，并且可能依赖不准确的人工类型注释。</li>
</ul>
</li>
<li>e. Current issues to address:<ul>
<li>当前需要解决的问题包括如何通过自然语言信息、代码上下文和可见类型注释推断参数、变量和返回值的可能类型。</li>
</ul>
</li>
</ul>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods:"></a>Methods:</h3><ul>
<li>a. Theoretical basis of the study:<ul>
<li>本文所提出的Type4Py模型的理论基础是深度相似度学习和神经网络模型。</li>
</ul>
</li>
<li>b. Technical route of the article (step by step):<ul>
<li>本文提出了一种新的Python类型推断模型Type4Py，通过使用深度相似度学习的神经网络模型，训练一个类型检查数据集以区别高维空间中的相似和不相似类型，从而得到类型聚类，有效地推断参数、变量和返回值的可能类型。本文还使用Word embeddings表示自然信息、代码上下文和可见类型注释，并将其用于训练神经网络模型，从而提高模型的性能表现。最后，本文还为开发人员提供了一个Visual Studio Code扩展，提供了基于ML的类型自动完成。</li>
</ul>
</li>
</ul>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230523144109712.png" alt="image-20230523144109712"></p>
<h4 id="3-1-Type-Hints"><a href="#3-1-Type-Hints" class="headerlink" title="3.1 Type Hints"></a>3.1 Type Hints</h4><p>在这段文本中，”Type hints”（类型提示）是指从Python源代码文件中提取的有价值的类型提示信息，用于预测函数参数、变量和返回类型的类型。根据文本描述，类型提示包含以下几个部分：</p>
<ol>
<li>自然信息（Natural Information）：源代码中包含有用的非正式自然语言信息，可以作为类型提示的来源。在这里，标识符的名称被视为主要的自然信息和类型提示来源。特别地，提取函数的名称（𝑁𝑓）和它们的参数名称（𝑁𝑎𝑟𝑔𝑠），这些信息可能提供关于函数的返回类型和参数类型的提示。对于变量，提取它们的名称（𝑁𝑣）作为类型提示。</li>
<li>代码上下文（Code Context）：提取函数体中参数的所有使用情况作为类型提示。这意味着包含使用参数的完整语句将作为令牌序列的一部分。类似地，提取变量在其当前和内部作用域中的所有使用情况。还提取函数内的所有返回语句，因为它们可能包含有关函数返回类型的提示。</li>
<li>可见类型提示（Visible type hints，VTH）：与以往仅分析直接导入的工作不同，这里递归提取给定模块及其传递依赖的所有导入语句。为所有用户定义的类、类型别名和NewType声明构建一个依赖图。例如，如果模块A导入了B.Type和C.D.E，那么将在图中添加边(A, B.Type)和(A, C.D.E)。还会扩展通配符导入，如from foo import *，并解析具体的类型引用。被识别的类型被视为可见类型，并以其完全限定名称存储，以减少歧义。例如，tf.Tensor和torch.Tensor是不同的类型。虽然所描述的基于检查的方法比纯AST（抽象语法树）分析更慢，但实验结果表明可见类型提示显著提高了Type4Py的性能。</li>
</ol>
<p>因此，类型提示由自然信息、代码上下文和可见类型提示组成，它们共同提供了对于函数参数、变量和返回类型的类型推断所需的信息。</p>
<h4 id="3-2-Vector-Representation"><a href="#3-2-Vector-Representation" class="headerlink" title="3.2 Vector Representation"></a><strong>3.2 Vector Representation</strong></h4><p>根据文本描述，作者将AST的信息转化为向量的过程如下：</p>
<ol>
<li><p>预处理：首先，对提取的标识符和代码上下文进行预处理，应用常见的自然语言处理（NLP）技术，包括分词（tokenization）、停用词去除（stop word removal）和词形还原（lemmatization）。</p>
</li>
<li><p>使用Word2Vec嵌入：然后，使用Word2Vec嵌入方法将单词映射到一个d维的实值向量空间（R^d）。作者训练了一个代码嵌入（code embedding）Ec: w1, …, wl -&gt; R^(l×d)，用于表示代码上下文和标识符的标记。</p>
</li>
<li><p>标识符向量表示：对于函数参数的类型提示，将参数的向量序列表示如下：</p>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230523151007803.png" alt="image-20230523151007803"></p>
<p>其中◦表示连接和扁平化序列的操作，s是一个分隔符。</p>
<p>对于返回类型，其向量序列表示如下</p>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230523151012324.png" alt="image-20230523151012324"></p>
<p>最后，将变量的标识符表示为Ec(𝑁𝑣)。</p>
</li>
<li><p>代码上下文向量表示：对于函数参数和变量，将它们的使用序列连接成一个单一的序列。对于返回类型，将一个函数的所有返回语句连接成一个单一的序列。为了缩短长序列，作者使用一个窗口（默认为n&#x3D;7）选取序列的中心n个标记。与标识符类似，使用函数嵌入Ec将代码上下文序列转换为实值向量。</p>
</li>
<li><p><font color="red">可见类型提示向量表示：</font>对于所有源代码文件，作者构建了一个固定大小的可见类型提示词汇表。该词汇表涵盖了大多数可见类型出现的情况。如果一个类型不在可见类型提示词汇表中，它将被表示为特殊的其他类型。对于函数参数、变量和返回类型，作者创建了一个大小为T的稀疏二进制向量，其中的元素表示一个类型。如果该类型在词汇表中出现，二进制向量的相应元素设置为1。否则，其他类型的元素设置为1。<font color="red">(int,str,list)如果是int则表示成(1,0,0)</font></p>
</li>
</ol>
<p>通过以上步骤，作者将AST的信息转化为向量表示，以便机器学习模型能够从类型提示中学习。</p>
<h4 id="3-3-Neural-model"><a href="#3-3-Neural-model" class="headerlink" title="3.3 Neural model"></a><strong>3.3 Neural model</strong></h4><p>作者使用了一种称为Hierarchical Neural Network (HNN)的神经网络模型。HNN由两个循环神经网络（Recurrent Neural Networks，RNNs）组成，这些RNNs基于长短期记忆（Long Short-Term Memory，LSTM）单元。HNN能够捕捉标识符和代码上下文的不同方面，并将捕获到的信息汇总为两个单一向量。这两个单一向量与可见类型提示向量进行拼接，并通过全连接线性层进行处理。</p>
<p>HNN模型中的两个层级的RNNs能够捕获来自标识符和代码标记的输入序列的不同方面。然后，捕获到的信息被总结为两个单一向量，这些向量是从对应RNN的最终隐藏状态中获取的。然后将来自RNN的两个单一向量与可见类型提示向量进行拼接，通过一个全连接线性层进行处理。</p>
<p>相较于之前的工作，该模型可以处理非常大的类型词汇表，并使用Triplet loss函数来创建描述的类型聚类。Triplet loss函数是近期在计算机视觉任务（如人脸识别）中使用的一种函数，它使得神经模型能够通过将样本映射到连续空间中的自身聚类，区分相似样本和不相似样本。</p>
<p>因此，作者提出的神经模型使用了Hierarchical Neural Network (HNN)，它由两个LSTM单元组成，用于捕捉标识符和代码上下文的不同方面，并结合可见类型提示进行预测。</p>
<h3 id="Dataset-ManyTypes4Py"><a href="#Dataset-ManyTypes4Py" class="headerlink" title="Dataset(ManyTypes4Py):"></a>Dataset(ManyTypes4Py):</h3><p>作者使用了ManyTypes4Py数据集的新版本（v0.7）[15]，以下是该数据集的构建过程。</p>
<p>[15] Amir M. Mir, Evaldas Latoskinas, and Georgios Gousios. Manytypes4py: Abenchmark python dataset for machine learning-based type inference. <em>CoRR</em>,abs&#x2F;2104.04706, 2021.</p>
<p>作者通过搜索依赖于mypy包的Python项目来获取数据集，并使用CD4Py进行代码去重。然后，他们使用Pyre进行类型注释的增强，并使用mypy进行类型检查和基本分析来清理数据集中的错误类型注释。这些步骤帮助作者构建了ManyTypes4Py数据集的新版本（v0.7）。</p>
<p><strong>Pre-processing</strong></p>
<p>作者在进行预处理之前执行了几个步骤：</p>
<ol>
<li>排除无关的函数：例如，作者从数据集中排除了一些简单的函数，如<code>__str__</code>和<code>__len__</code>。这些函数的返回类型非常直接，例如<code>__len__</code>始终返回int类型，它们对结果预测没有太大帮助，并且可能会模糊结果。</li>
<li>排除无用的类型注释：作者排除了Any和None类型的注释，因为它们对于类型预测没有帮助。</li>
<li>类型别名解析：作者执行了简单的类型别名解析，以使相同类型的注释保持一致。例如，将<code>[]</code>解析为<code>List</code>，将<code>&#123;&#125;</code>解析为<code>Dict</code>，将<code>Text</code>解析为<code>str</code>。这样可以使数据集中所有相同类型注释的出现保持一致。</li>
<li>类型注释的限定名解析：作者解析了类型注释的限定名，例如，将<code>array</code>解析为<code>numpy.array</code>。这样可以使数据集中所有类型注释的出现保持一致。</li>
<li>重写嵌套层级大于2的基础类型组件：与Allamanis等人的工作类似，作者将嵌套层级大于2的基础类型组件重写为Any类型。例如，将<code>List[List[Tuple[int]]]</code>重写为<code>List[List[Any]]</code>。这样做可以删除非常罕见的类型或异常值。</li>
</ol>
<p>这些预处理步骤有助于清理和规范化数据集中的类型注释，使其更适合用于训练机器学习模型。</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation:"></a>Evaluation:</h3><p><font color="red">Baselines:</font></p>
<p>Typilus [2] and TypeWriter [51]</p>
<p><font color="red">Metrics</font></p>
<p>文章使用了以下评估指标：</p>
<ol>
<li>精确匹配（Exact Match）：通过将预测类型（𝑡𝑝）与真实类型（𝑡𝑔）进行比较，衡量类型预测的准确性。如果预测完全匹配真实类型，则认为预测是正确的。</li>
<li>基础类型匹配（Base Type Match）：该指标忽略类型参数，仅关注基础类型的匹配。例如，如果预测类型为<code>List[str]</code>，而真实类型为<code>List[int]</code>，它们将被认为是匹配的，因为它们的基础类型（<code>List</code>）是相同的。</li>
<li>平均倒数排名（Mean Reciprocal Rank，MRR）：MRR用于评估神经模型在给定查询时预测类型列表的性能。MRR根据正确类型注释在预测列表中的排名进行计算。它定义为排名的倒数的均值倒数。MRR指标对于正确类型注释在较低排名时的预测给予更高的奖励。</li>
<li>MRR@𝑛：指在考虑前𝑛个预测的情况下计算的MRR值。在该研究中，作者评估神经模型的预测性能，考虑了前10个预测结果，这是评估基于机器学习的代码模型常用的方法。</li>
</ol>
<p>除了这些评估指标外，作者根据在训练集中的出现频率将类型分为常见类型和罕见类型。在训练集中出现超过100次的类型被视为常见类型，而出现频率较低的类型被视为罕见类型。其中包括<code>str</code>、<code>int</code>、<code>list</code>、<code>bool</code>和<code>float</code>等常见类型，并排除在常见类型的集合之外。</p>
<p>需要注意的是，与Type4Py和Typilus不同，TypeWriter在其类型词汇表中没有找到预期类型时，会预测为”unknown”。因此，为了与其他两种方法进行有效比较，作者在计算评估指标时考虑了TypeWriter做出的其他预测。</p>
<p><font color="red">Benchmark</font></p>
<p>ManyTypes4Py</p>
<p>70%的训练数据、10%的验证数据和20%的测试数据</p>
<p><font color="red">Results</font></p>
<p>作者评估了Type4Py的类型预测性能，并回答了以下研究问题：</p>
<ul>
<li>RQ1：Type4Py的一般类型预测性能如何？ </li>
<li>RQ2：在不同的预测任务下，Type4Py的表现如何？ </li>
<li>RQ3：每个提出的类型提示和类型词汇表的大小对Type4Py的性能有何影响？</li>
</ul>
<p>作者使用了一些基准模型进行比较。结果显示，在考虑不同的前𝑛个预测结果时，Type4Py在精确匹配和基础类型匹配方面的表现优于其他模型。特别是在考虑精确匹配标准下，Type4Py在<strong>前10个</strong>预测结果中的表现比Typilus和TypeWriter高出5.9%和11%。Type4Py在减少𝑛值时性能下降较小，对于常见类型的预测实现了100%的精确匹配。此外，在MRR@10指标上，Type4Py的性能优于其他模型。</p>
<p>在不同的预测任务下，Type4Py在精确匹配和MRR@10指标上表现良好。对于常见类型的预测任务，TypeWriter的表现稍好于Type4Py和Typilus。在RQ3的分析中，作者发现代码上下文和可见类型提示是Type4Py性能的主要因素，而标识符类型提示对整体性能的影响较小。此外，缩小Type4Py的类型词汇表会略微提高对常见类型的预测性能，但对罕见类型的预测性能有所降低。</p>
<p>总体而言，Type4Py在类型预测性能方面取得了良好的结果，并且在不同的预测任务中显示出竞争优势。</p>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230523162615911.png" alt="image-20230523162615911"></p>
<p><img src="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/image-20230523162625105.png" alt="image-20230523162625105"></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ul>
<li>a. Significance of the work:<ul>
<li>Type4Py推动了基于机器学习的Python类型推断的未来研究。</li>
</ul>
</li>
<li>b. Innovation, performance, and workload:<ul>
<li>与以往的方法相比，Type4Py具有更高的预测准确率和MRR，能够处理大量的类型词汇量，并且不依赖于可能不准确的人工类型注释。</li>
</ul>
</li>
<li>c. Research conclusions (list points):<ul>
<li>本文提出了一种新的Python类型推断模型Type4Py，并使用Word embeddings表示自然信息、代码上下文和可见类型注释以提高模型的性能表现。</li>
<li>实验表明，Type4Py在预测Python类型注释方面表现优秀，具有无限的类型词汇量，并通过Visual Studio Code扩展为开发人员提供基于ML的类型自动完成。</li>
<li>本文提供了一个类型检查数据集和可公开使用的Type4Py实现。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/">http://example.com/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/24/Static-Inference-Meets-Deep-Learning-A-Hybrid-Type-Inference-Approach-for-Python/" title="Static Inference Meets Deep Learning A Hybrid Type Inference Approach for Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Static Inference Meets Deep Learning A Hybrid Type Inference Approach for Python</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/19/Typilus-Neural-Type-Hints/" title="Typilus: Neural Type Hints"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Typilus: Neural Type Hints</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Type4py-practical-deep-similarity-learning-based-type-inference-for-python"><span class="toc-number">1.</span> <span class="toc-text">Type4py: practical  deep similarity learning-based type inference for python</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Related-work"><span class="toc-number">1.3.</span> <span class="toc-text">Related work:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary"><span class="toc-number">1.4.</span> <span class="toc-text">Summary:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background"><span class="toc-number">1.5.</span> <span class="toc-text">Background:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Methods"><span class="toc-number">1.6.</span> <span class="toc-text">Methods:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Type-Hints"><span class="toc-number">1.6.1.</span> <span class="toc-text">3.1 Type Hints</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Vector-Representation"><span class="toc-number">1.6.2.</span> <span class="toc-text">3.2 Vector Representation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Neural-model"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.3 Neural model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dataset-ManyTypes4Py"><span class="toc-number">1.7.</span> <span class="toc-text">Dataset(ManyTypes4Py):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.8.</span> <span class="toc-text">Evaluation:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion"><span class="toc-number">1.9.</span> <span class="toc-text">Conclusion:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/24/Static-Inference-Meets-Deep-Learning-A-Hybrid-Type-Inference-Approach-for-Python/" title="Static Inference Meets Deep Learning A Hybrid Type Inference Approach for Python">Static Inference Meets Deep Learning A Hybrid Type Inference Approach for Python</a><time datetime="2023-05-24T08:38:35.000Z" title="发表于 2023-05-24 16:38:35">2023-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/23/Type4py-practical-deep-similarity-learning-based-type-inference-for-python/" title="Type4py practical  deep similarity learning-based type inference for python">Type4py practical  deep similarity learning-based type inference for python</a><time datetime="2023-05-23T08:43:17.000Z" title="发表于 2023-05-23 16:43:17">2023-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/19/Typilus-Neural-Type-Hints/" title="Typilus: Neural Type Hints">Typilus: Neural Type Hints</a><time datetime="2023-05-19T14:53:02.000Z" title="发表于 2023-05-19 22:53:02">2023-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/18/Deep-Learning-Type-Inference/" title="Deep Learning Type Inference">Deep Learning Type Inference</a><time datetime="2023-05-18T10:39:33.000Z" title="发表于 2023-05-18 18:39:33">2023-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/17/TypeWriter-Neural-Type-Prediction-with-Search-based-Validation/" title="TypeWriter Neural Type Prediction with Search-based Validation">TypeWriter Neural Type Prediction with Search-based Validation</a><time datetime="2023-05-17T12:30:53.000Z" title="发表于 2023-05-17 20:30:53">2023-05-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>