<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Griffin Grammar-Free DBMS Fuzzing | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Griffin: Grammar-Free DBMS FuzzingBasic Information: Title: Griffin: Grammar-Free DBMS Fuzzing (Griffin：无语法的数据库管理系统模糊测试) Authors: Jingzhou Fu, Jie Liang, Zhiyong Wu, Mingzhe Wang, Yu Jiang (傅靖洲, 梁杰, 吴">
<meta property="og:type" content="article">
<meta property="og:title" content="Griffin Grammar-Free DBMS Fuzzing">
<meta property="og:url" content="http://example.com/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Griffin: Grammar-Free DBMS FuzzingBasic Information: Title: Griffin: Grammar-Free DBMS Fuzzing (Griffin：无语法的数据库管理系统模糊测试) Authors: Jingzhou Fu, Jie Liang, Zhiyong Wu, Mingzhe Wang, Yu Jiang (傅靖洲, 梁杰, 吴">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-08-18T07:28:26.000Z">
<meta property="article:modified_time" content="2023-08-18T07:29:20.779Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Griffin Grammar-Free DBMS Fuzzing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-18 15:29:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Griffin Grammar-Free DBMS Fuzzing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-18T07:28:26.000Z" title="发表于 2023-08-18 15:28:26">2023-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-18T07:29:20.779Z" title="更新于 2023-08-18 15:29:20">2023-08-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Griffin Grammar-Free DBMS Fuzzing"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Griffin-Grammar-Free-DBMS-Fuzzing"><a href="#Griffin-Grammar-Free-DBMS-Fuzzing" class="headerlink" title="Griffin: Grammar-Free DBMS Fuzzing"></a>Griffin: Grammar-Free DBMS Fuzzing</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Griffin: Grammar-Free DBMS Fuzzing (Griffin：无语法的数据库管理系统模糊测试)</li>
<li>Authors: Jingzhou Fu, Jie Liang, Zhiyong Wu, Mingzhe Wang, Yu Jiang (傅靖洲, 梁杰, 吴志勇, 王明哲, 蒋宇)</li>
<li>Affiliation: Tsinghua University, China (清华大学，中国)</li>
<li>Keywords: DBMS Fuzzing, Grammar-Free, Vulnerability Detection (数据库管理系统模糊测试，无语法，漏洞检测)</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://doi.org/10.1145/3551349.3560431">Paper</a>, <a href="github:">GitHub</a></li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>本文提出了一种无语法的数据库管理系统模糊测试方法，通过构建元数据图来指导变异，从而生成有效的SQL语句，并在多个DBMS上进行了评估，发现了大量的漏洞。</li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息:"></a>背景信息:</h3><ul>
<li>论文背景: 数据库管理系统（DBMS）的模糊测试是一种发现漏洞的有效方法，但现有的方法往往依赖于目标DBMS的语法，导致适应不同DBMS的工作量巨大。</li>
<li>过去方案: 过去的方法主要是基于语法的生成和变异，但需要大量的人工适应工作，限制了其适用范围。</li>
<li>论文的Motivation: 鉴于大量DBMS尚未经过充分测试，需要一种无语法依赖的高效DBMS模糊测试方法。本文提出了Griffin，一种基于元数据图的无语法变异型DBMS模糊测试工具，通过追踪内置SQL测试用例中语句的元数据，并构建元数据图来描述元数据和语句之间的依赖关系，从而实现语义错误的修正。通过在多个DBMS上的评估，Griffin在12小时内比SQLancer、SQLsmith和Sqirrel分别发现了更多的分支和漏洞，总共发现了55个以前未知的漏洞，其中13个被确认为CVE漏洞。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文介绍了模糊测试在数据库管理系统（DBMSs）测试中的重要性以及不同DBMSs的复杂语法所带来的挑战。强调了需要一种无语法的DBMS模糊测试方法，并介绍了Griffin，一种基于变异的DBMS模糊测试工具，它依赖于元数据图而不是语法来提高变异的正确性。评估结果表明，Griffin在分支覆盖率和漏洞检测方面优于现有的模糊测试工具，发现了55个以前未知的漏洞，并分配了13个CVE编号。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>Griffin是一种无语法的DBMS模糊测试工具，旨在生成保持语法和语义正确性的SQL测试用例。它利用DBMS中的元数据将系统的状态总结为元数据图，这是一种轻量级的数据结构。Griffin的设计包括两个主要步骤：元数据分析和基于元数据的变异。</li>
</ul>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:<ul>
<li>Griffin的核心是基于元数据的变异。它首先从现有的有效SQL测试用例中重新排列语句，以保持新生成的SQL测试用例的语法正确性。然后，它根据DBMS的元数据信息对每个SQL语句的变量进行变异，以确保语义正确性。通过根据元数据替换不正确的变量为正确的变量，Griffin不断生成语义正确的SQL测试用例来发现DBMS中的漏洞。</li>
</ul>
</li>
<li>b. 详细的实验结果:<ul>
<li>Griffin的优势在于它不受特定DBMS的语法限制，使其能够轻松适应各种数据库。它可以有效地触发DBMS的各种行为，并降低对不同DBMS的模糊测试的适应成本。</li>
</ul>
</li>
</ul>
<h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>该论文提出了一种名为Griffin的语法无关的数据库管理系统(DBMS)突变基础模糊测试器。当前的DBMS模糊测试方法依赖于语法来生成语法正确和语义正确的SQL语句，但由于各种DBMS的复杂语法存在巨大差异，使得适应这些模糊测试器非常费力。鉴于许多DBMS尚未得到充分测试，因此迫切需要一种不依赖于语法的有效DBMS模糊测试方法。</p>
<p>Griffin不依赖于语法，而是将DBMS的状态总结为元数据图 <font color="red">Metadata Graph</font>，这是一种轻量级数据结构，可以提高模糊测试中的突变正确性。具体来说，它首先追踪内置SQL测试用例中语句的元数据，并迭代地构建元数据图以描述元数据和语句之间的依赖关系。基于这些图，Griffin重新洗牌语句，并使用元数据引导替换来修正语义错误。</p>
<p>论文对Griffin进行了评估，测试了MariaDB, SQLite, PostgreSQL, 和DuckDB。与SQLancer, SQLsmith, 和Sqirrel相比，Griffin在12小时内覆盖了更多的分支（分别提高了73.43%-274.70%，80.47%-312.89%，43.80%-199.11%），并发现了更多的错误（分别多了27，27和22个）。总的来说，Griffin发现了55个以前未知的错误，其中13个已经被分配了CVE编号。</p>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION:"></a>INTRODUCTION:</h3><p><font color="red">背景：</font> </p>
<p>数据库管理系统(DBMS)广泛用于软件的数据存储。为了满足不同的软件需求，已经开发了具有不同特性和功能的数百种DBMS。然而，由于DBMS是大型系统，它们通常包含漏洞，可能导致拒绝服务、远程代码执行、数据泄露等。这些漏洞对DBMS和存储的数据的安全造成威胁。</p>
<p><font color="red">相关工作和局限性：</font></p>
<p>模糊测试是一种自动化技术，用于发现漏洞，近年来已经应用于DBMS测试，并发现了大量漏洞。目前，已有的DBMS模糊测试方法主要依赖于目标DBMS的语法来生成有效的SQL语句。然而，不同的DBMS具有不同的语法，需要大量的手工适配工作。</p>
<p>相关工作通常采取以下两种方法来生成语法和语义上正确的SQL语句：</p>
<ol>
<li><strong>基于生成的方法</strong>：这些方法模拟SQL的语法作为抽象语法树（AST）进行输入生成。例如，**SQLancer[32]**会提取关于数据库的基本信息（例如数据库对象和文件），然后使用AST生成有效的INSERT或SELECT语句。</li>
<li><strong>基于突变的方法</strong>：这些方法应用突变模糊测试技术于DBMS，生成各种类型的语句，并导入覆盖率反馈。例如，**Sqirrel[51]<strong>会根据目标DBMS的语法深度定制不同的语法解析器。使用解析器，它可以减少从现有语句突变得到的SQL语句中的语法和语义错误。</strong>Ratel[39]**进一步通过为不支持的语法构建词典来扩展它。</li>
</ol>
<p>[32] Manuel Rigger and Zhendong Su. 2020. Testing database engines via pivoted query synthesis. In <em>14th USENIX Symposium on Operating Systems Design and</em> Implementation OSDI 20)*. 667–682. </p>
<p>[51] Rui Zhong, Yongheng Chen, Hong Hu, Hangfan Zhang, Wenke Lee, and Dinghao Wu. 2020. Squirrel: Testing Database Management Systems with Language Validity and Coverage Feedback. In <em>The ACM Conference on Computer and Communications Security (CCS), 2020</em>.</p>
<p>[39] Mingzhe Wang, Zhiyong Wu, Xinyi Xu, Jie Liang, Chijin Zhou, Huafeng Zhang, and Yu Jiang. 2021. Industry Practice of Coverage-Guided Enterprise-Level DBMS Fuzzing. In *2021 IEEE&#x2F;ACM 43rd International Conference on Software Engineering: <em>Software Engineering in Practice (ICSE-SEIP)</em>. IEEE, 328–337.</p>
<p>例如，为了支持MariaDB的大部分语法，Sqirrel需要增加9,050行代码。现有的DBMS模糊测试方法大多只覆盖了少数最流行的DBMS，如PostgreSQL、MariaDB和SQLite。然而，目前市场上有391种不同的DBMS，它们大多使用不同的语法。尽管其他DBMS同样迫切需要提高安全性，但将这些先进的模糊测试器适应它们将耗时过长，并需要太多的人力资源，不切实际。</p>
<p><font color="red">挑战</font>：</p>
<p>不依赖于语法的DBMS模糊测试的主要挑战是如何正确地维护新生成查询的语法和语义正确性。与像libpng这样的模糊化C库的实践不同，由于在语法和语义上的复杂检查，为dbms生成高质量的输入可能具有挑战性。具体来说，DBMS将首先检查SQL语句的语法正确性。不正确的陈述将被直接拒绝。接下来，DBMS将检查语句的语义是否具有正确性（例如，不使用不存在的元素）。同样，带有错误的语句将被删除。因此，为了充分测试dbms，生成语法和语义上正确的SQL语句是一个先决条件。</p>
<p>例如，在突变语句“SELECT Name, Department FROM  Student”时，随机突变很容易导致语法错误，因为它可能破坏SQL关键词。更重要的是，为了确保语义正确性，变量“Name”应该突变并替换为另一个符合约束的类型匹配变量（即，也是一个列名，并且存在于表中）。如果使用其他名称，如“Price”，它可能没有意义，或者可能不是列名，甚至如果它是列名，它可能不存在于表“Student”中。然而，没有语法，很难识别像列名这样的变量，并获得SQL语句的依赖关系，以确保语义正确性。</p>
<p><font color="red">方法</font>： </p>
<p>作者提出了Griffin，一个不依赖于语法的DBMS模糊测试器。Griffin通过将DBMS的状态总结为元数据图来生成有效的SQL语句。它首先追踪执行内置SQL测试用例的语句的元数据，并根据元数据构建元数据图以描述元数据和语句之间的依赖关系。通过元数据图，Griffin重新排列现有测试用例中的语句，并通过替换元数据节点来重构元数据图，纠正语义错误。与其他传统DBMS模糊测试器相比，Griffin更方便地适应各种DBMS，因为它不依赖于语法。</p>
<p><font color="cornflowerblue">（可能就是通过test case 构造metadata graph，然后知道里面的数据依赖关系，然后重排测试样例的字段？）</font></p>
<p>Insight： 针对现有DBMS模糊测试方法的局限性，本文提出了一种不依赖于语法的DBMS模糊测试方法。这种方法通过分析和构建元数据图来生成有效的SQL语句，指导突变过程。</p>
<p><font color="red">评估</font>： </p>
<p>作者直接将Griffin应用于三个经过充分测试的DBMS（MariaDB、SQLite和PostgreSQL）以及一个新开发的DBMS（DuckDB），没有进行任何特定的适配。与SQLancer、SQLsmith和Sqirrel相比，Griffin在12小时内覆盖了更多的分支，并找到了更多的错误。Griffin在MariaDB、SQLite、PostgreSQL和DuckDB中分别发现了24、16、3和12个未知错误，其中13个错误在国家漏洞数据库中被确认为CVE。</p>
<p><font color="red">贡献</font>：</p>
<ol>
<li>确定了现有的DBMS模糊测试器依赖于语法，密集型劳动限制了它们的应用。</li>
<li>提出了一种不依赖于语法的DBMS模糊测试方法，通过分析和构建元数据图来生成有效的SQL语句，指导突变过程。</li>
<li>在Griffin中实现了这种方法。在评估中，Griffin发现了55个以前未知的漏洞，其中13个漏洞被确认为CVE。</li>
</ol>
<h3 id="BACKGROUND-AND-MOTIVATION："><a href="#BACKGROUND-AND-MOTIVATION：" class="headerlink" title="BACKGROUND AND MOTIVATION："></a><strong>BACKGROUND AND MOTIVATION：</strong></h3><p>本节包含了关于DBMS的基本知识，如SQL语法和元数据，以及对无语法的DBMS模糊化的挑战和我们的基本思想。</p>
<p><font color="red">DBMS</font></p>
<p>DBMS是一种软件，用于根据特定的数据库模型存储和访问数据。其中，最流行的数据库模型之一是关系模型，基于此模型的DBMS通常被称为关系数据库管理系统（RDBMS）。市面上有大约391种流行的DBMS产品，它们在支持的功能方面存在显著差异，比如操作系统支持、数据类型、触发器、存储引擎等。</p>
<p><font color="red"><strong>SQL grammar.</strong> </font></p>
<p>SQL是一种专用语言，用于管理DBMS中保存的数据。SQL语法描述了该语言的语法和语义特征。SQL语句是SQL语法的载体，它们是输入DBMS的最小执行单元。不同的DBMS通常具有不同的语法。例如，尽管有156个DBMS支持关系模型，但它们在相同功能上仍然存在语法差异。表1中展示了一个例子，SQLite、MariaDB和PostgreSQL都支持“创建触发器”语句，但它们的语法非常不同。在某些条件下创建触发器时，SQLite使用“when”子句和“update”语句，MariaDB使用“if-else”作为条件语句，而PostgreSQL声明了一个额外的函数。</p>
<p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816101526041.png" alt="image-20230816101526041"></p>
<p><font color="red"><strong>Metadata.</strong></font></p>
<p>元数据是描述实际数据的数据，简单地说，可以将其定义为关于数据的数据。具体来说，它包含有关实际数据的模式（例如表名和数据类型）或其他相关信息，如存储（例如表大小）和数据元素（例如列、属性）的信息。例如，图1展示了名为“students”的表的元数据。它描述了关于表的信息（即名称和注释）、列（即名称、数据类型、对应的表名）和统计数据（例如birth_year的索引）。元数据在DBMS中起着至关重要的作用。它可以被视为访问实际数据的索引。因此，DBMS总是利用元数据来检查SQL语句的语义正确性。</p>
<p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816101734516.png" alt="image-20230816101734516"></p>
<p><font color="red"><strong>DBMS fuzzing.</strong></font></p>
<p>DBMS模糊测试工具生成大量的SQL语句，并将它们提交给目标DBMS执行。与普通程序不同，DBMS总是对SQL语句进行严格的语法和语义检查。错误的语句将被直接丢弃。为了生成语法和语义上正确的SQL语句，DBMS模糊测试工具通常会在语句生成中模拟SQL的语法（例如，将其模型化为抽象语法树（AST））。</p>
<p>DBMS模糊测试工具可以分为基于生成的和基于变异的两类。它们都依赖于语法进行语句生成。基于生成的模糊测试工具根据从语法中派生的指定模型生成SQL语句。他们需要为每个DBMS构建一个特定的语法生成模型。基于变异的模糊测试工具修改当前的测试用例以生成新的用例。它们通常为每个DBMS构建一个特定的SQL解析器和AST突变器，以支持语法正确的查询突变。</p>
<p><strong>Dependency on grammar limits the adaptability of DBMS fuzzers.</strong></p>
<p>数据库管理系统（DBMS）模糊测试工具对语法的依赖性是如何限制其适应性的。具体而言，无论是生成模型、SQL解析器还是AST突变器，它们都强烈依赖于DBMS的语法。适应新的DBMS需要大量的额外代码，这既耗时又消耗劳动力。表2显示了SQLsmith、SQLancer和Sqirrel适应SQLite、PostgreSQL、MariaDB和DuckDB所需的额外代码行数。这表明由于对语法的依赖，这三个模糊测试工具都需要大量的额外代码来适应不同的DBMS。例如，SQLancer使用了超过8000行代码来构建PostgreSQL的SQL生成模型。尽管SQLsmith只需要大约300行代码来适应新的DBMS，但它只部分支持语法，因为SQLsmith只能为PostgreSQL生成SELECT语句。更重要的是，市场上有391种不同的DBMS，其中大多数使用不同的语法。目前最先进的DBMS模糊测试工具只支持最流行的DBMS，如PostgreSQL和SQLite。如果我们想将这些高级模糊测试工具适应这些不同的DBMS，这将需要太长时间和太多的人力资源才能在经济上可行。因此，为了降低适应成本并将模糊测试应用于更多的DBMS，我们迫切需要不依赖于语法的DBMS模糊测试工具。</p>
<p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816102249698.png" alt="image-20230816102249698"></p>
<p><strong>Challenges in grammar-free DBMS fuzzing.</strong></p>
<p>数据库管理系统(DBMS)模糊测试中面临的主要挑战。该挑战在于在保持语法和语义正确性的同时生成SQL语句。不使用语法，对于基于生成的模糊测试工具来说，构建生成模型非常困难，因此我们主要关注基于突变的模糊测试。没有语法解析器，模糊测试工具无法区分语句中的标记。因此，随机突变容易破坏SQL语句的精细结构，从而可能产生语法错误。即使偶然选择了可以突变的语句中的标记，例如“SELECT”中的表名，不当的突变也可能导致语义错误。例如，在突变语句“Select Name From Student”时，变量“Student”可能会被突变。但是，当它被突变为DBMS中不存在的任意表名时，将导致语义错误。</p>
<p><strong>The basic idea of Griffin: make the best use of metadata in DBMSs.</strong> </p>
<p>Griffin的基本思路，即在DBMS中充分利用元数据。为了应对维护语法和语义正确性的挑战，Griffin的基本思路是将DBMS的状态总结为元数据图，这是一种轻量级的数据结构，可以提高模糊测试的突变效果。首先，Griffin重新调整现有有效SQL测试用例中的SQL语句，以保持新生成的SQL测试用例的语法正确性。然后，Griffin根据DBMS的元数据信息突变每个SQL语句的变量，以确保语义正确性。如前所述，元数据描述了DBMS的状态，即关于数据库对象（如表、视图、触发器和索引）的信息。因此，根据DBMS中的元数据信息，我们可以识别SQL语句中的变量（如表名或列名），并替代不正确的变量以确保语义正确性。得益于有效的SQL语句生成，Griffin能够有效触发DBMS的各种行为。更重要的是，Griffin不依赖于DBMS的特定语法，因此可以轻松适应各种DBMS。</p>
<h3 id="DESIGN："><a href="#DESIGN：" class="headerlink" title="DESIGN："></a><strong>DESIGN：</strong></h3><p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816102753492.png" alt="image-20230816102753492"></p>
<p>图2展示了Griffin的设计。Griffin试图以无语法方式生成SQL测试用例，它包含以下步骤：</p>
<ol>
<li>元数据分析。Griffin跟踪执行过程中语句的元数据。基于元数据，Griffin构造元数据图来描述元数据和语句之间的依赖关系。</li>
<li>基于元数据的突变。Griffin首先从现有测试用例中重新排列语句，然后通过替换元数据节点来重构元数据图，以纠正语义错误。利用元数据引导的突变，Griffin不断生成语义正确的SQL测试用例以寻找DBMS中的错误。</li>
</ol>
<h4 id="3-1-Metadata-Analysis"><a href="#3-1-Metadata-Analysis" class="headerlink" title="3.1 Metadata Analysis"></a><strong>3.1 Metadata Analysis</strong></h4><p>3.1节介绍了Griffin在获取新测试用例时对元数据的分析过程。Griffin分析每个语句使用的元数据和整个DBMS的元数据。具体来说，Griffin首先在执行过程中跟踪每个语句的元数据。基于元数据，Griffin构造元数据图来描述元数据与语句之间的依赖关系。</p>
<p><font color="cornflowerblue"><em>3.1.1 Metadata tracking.</em> </font></p>
<p>元数据图是一个有向图（Vm, Vs,  E），其中Vm和Vs表示两种类型的节点，E表示边。Vm表示所有元数据节点的集合，这些节点代表可以通过元数据查询找到的数据库对象，如表、列或触发器。Vs表示所有语句节点的集合，语句节点代表一个SQL语句。图中有三种类型的边。第一种边从元数据节点m到语句节点s，表示当数据库对象m存在于当前数据库时，s中的语句在语义上是正确的。第二种边从语句节点s到元数据节点m，表示如果成功执行s，将在当前数据库中创建数据库对象m。第三种边从元数据节点m1到元数据节点m2，表示数据库对象m2包含在m1中，例如一个表包含在一个模式中，或一个列包含在一个表中。每个元数据节点都有m.name和m.type属性，分别表示对象名称（如表名）和对象类型（如“TABLE”）。</p>
<p>通过执行特定查询，我们可以跟踪元数据并获取当前元数据节点（包括其名称和类型）以及数据库对象之间的包含关系。</p>
<p><font color="cornflowerblue"><em>3.1.2 Metadata graph constructing.</em> </font></p>
<p>根据语句Si和DBMS元数据之间的依赖关系，我们应确定要添加到图中的语句节点、元数据节点和它们之间的边。对于每个元数据节点，如果它是语句文本的子串，则将从元数据节点到语句节点的边添加到图中。对于每个由s创建的元数据节点（例如，语句“CREATE table t  (aint)”将创建数据库对象“t”和列“a”的节点），将元数据节点m添加到图中，并从语句节点s到元数据节点m添加一条边。如果元数据节点m有一个父对象，则还将从表示父对象的节点到m添加一条边。</p>
<p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816104613168.png" alt="image-20230816104613168"></p>
<p>根据给定的两个SQL语句，我们可以逐步构建元数据图。</p>
<p>首先，我们有以下两个SQL语句：</p>
<ol>
<li><code>CREATE TABLE b(u INT PRIMARY KEY);</code></li>
<li><code>CREATE TABLE a(x INT PRIMARY KEY, y INT REFERENCES b(u));</code></li>
</ol>
<p>以下是按照这两个语句创建元数据图的过程：</p>
<p><strong>1. 执行第一个语句</strong></p>
<p>这个语句创建了一个名为“b”的表，该表有一个名为“u”的整数列，该列被设置为主键。因此，我们在元数据图中添加以下节点和边：</p>
<ul>
<li>节点：<ul>
<li>b（表节点）</li>
<li>u（列节点）</li>
</ul>
</li>
<li>边：<ul>
<li>(b, u)：表“b”包含列“u”。</li>
</ul>
</li>
</ul>
<p>此外，我们将第一个语句表示为一个语句节点s1，并在元数据图中添加以下边：</p>
<ul>
<li>从s1到b和u（因为s1创建了表b和列u）</li>
</ul>
<p><strong>2. 执行第二个语句</strong></p>
<p>这个语句创建了一个名为“a”的表，该表有两个整数列“x”和“y”。列“x”被设置为主键，列“y”引用表“b”的列“u”。因此，我们在元数据图中添加以下节点和边：</p>
<ul>
<li>节点：<ul>
<li>a（表节点）</li>
<li>x（列节点）</li>
<li>y（列节点）</li>
</ul>
</li>
<li>边：<ul>
<li>(a, x)：表“a”包含列“x”。</li>
<li>(a, y)：表“a”包含列“y”。</li>
<li>(y, u)：列“y”引用了表“b”的列“u”。</li>
</ul>
</li>
</ul>
<p>此外，我们将第二个语句表示为一个语句节点s2，并在元数据图中添加以下边：</p>
<ul>
<li>从s2到a、x和y（因为s2创建了表a和列x、y）</li>
</ul>
<p>最后，根据上述步骤，我们的元数据图将包含以下节点和边：</p>
<ul>
<li>节点：b, u, a, x, y, s1, s2</li>
<li>边：(b, u), (a, x), (a, y), (y, u), (s1, b), (s1, u), (s2, a), (s2, x), (s2, y)</li>
</ul>
<p>此元数据图准确地表示了数据库对象（如表和列）之间的关系，以及SQL语句与这些对象之间的关系。</p>
<h4 id="3-2-Metadata-Based-Mutation"><a href="#3-2-Metadata-Based-Mutation" class="headerlink" title="3.2 Metadata-Based Mutation"></a><strong>3.2 Metadata-Based Mutation</strong></h4><p>这段文字描述了一种名为”Metadata-Based Mutation”（基于元数据的变异）的方法，该方法用于生成语义正确的新测试用例。该方法包括两个步骤：首先，重新整理原始SQL测试用例中的SQL语句；然后，使用元数据引导的替代来纠正语义错误。</p>
<ol>
<li><strong>SQL语句重新整理</strong>：此操作旨在从现有的测试用例中创建新的测试用例。首先，它随机选择几个现有的测试用例作为变异的来源。然后，它反复执行以下操作：（1）随机选择一个SQL测试用例。（2）将测试用例的当前语句添加到候选用例中。（3）删除测试用例的当前语句并转到下一条语句。这些操作一直执行，直到所有原始测试用例中都不存在语句。最后，重新整理操作将从新的测试用例中删除一些语句，以减小新测试用例的大小，因为不断生成的测试用例会变得越来越大，对模糊测试的性能不利。</li>
<li><strong>元数据引导的替代</strong>：元数据引导的替代旨在通过重建测试用例的元数据图来纠正重新整理中的语义错误。Griffin首先定位旧元数据图G0中的不正确的元数据节点，并按照以下两个谓词<strong>替换</strong>元数据节点：（1）元数据的<font color="cornflowerblue">类型应该匹配</font>。（2）元数据的<font color="cornflowerblue">关系应该匹配</font>。具体而言，对于第一个谓词，每个元数据节点的类型在替换之前和之后应该保持不变。对于第二个谓词，元数据节点之间的关系在替换之前和之后应该保持不变。然后，Griffin计算满足这两个谓词的所有可能替代。</li>
</ol>
<p><img src="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/image-20230816105345461.png" alt="image-20230816105345461"></p>
<p>图5给出了一个基于元数据的变化过程的示例。Griffin首先重组了原始SQL测试用例的SQL语句，并生成了一个名为中间用例的新测试用例，如中间部分所示。中间部分的中间情况包含一些语义错误和一个不正确的元数据图。然后，Griffin通过使用元数据引导的替换重构其元数据图来纠正语义错误，生成最终的测试用例。</p>
<hr>
<p>我们将使用这两个测试用例（Test case 1和Test case 2）作为突变（mutation）的来源，以生成新的测试用例。我们可以通过以下步骤来生成新的测试用例：</p>
<p><strong>SQL语句重新整理</strong>：我们从现有的测试用例中选择语句，并组合成新的测试用例。在这个例子中，我们将从测试用例1中选择语句t1和t2，并从测试用例2中选择语句s2，组合成新的测试用例：</p>
<p><strong>中间用例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA foreign_keys<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(x <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, y <span class="type">INT</span> <span class="keyword">REFERENCES</span> a(x));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b(u) <span class="keyword">VALUES</span> (<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>请注意，这个中间用例的最后一个语句有一个语义错误，因为它试图向不存在的表“b”中插入数据。</p>
<p><strong>元数据引导的替代</strong>：为了纠正这个错误，我们需要对元数据图进行替代。在这个例子中，元数据图的不正确节点是“b”。</p>
<p>我们查找所有可能的替代，并发现我们可以将“b”替换为“a”，因为它们都是表。所以我们进行替代：</p>
<p><strong>最终用例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA foreign_keys<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(x <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, y <span class="type">INT</span> <span class="keyword">REFERENCES</span> a(x));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a(x) <span class="keyword">VALUES</span> (<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>现在，新的测试用例（最终用例）中的所有语句都是语义正确的，因为第三条语句现在插入数据到一个存在的表“a”中。这就是一个简单的基于元数据的突变过程的例子，它从现有的测试用例中生成新的测试用例，并确保新生成的测试用例是语义正确的。</p>
<h3 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION:"></a><strong>EVALUATION:</strong></h3><p>评估部分回答了以下问题：</p>
<ol>
<li>Griffin在真实世界DBMS中的错误检测性能如何？</li>
<li>与其他DBMS模糊测试器相比，Griffin的覆盖范围和错误发现情况如何？</li>
<li>元数据基础的突变对模糊测试覆盖率的贡献是什么？</li>
</ol>
<p><strong>Benchmark</strong>：</p>
<ul>
<li>针对Griffin的错误检测能力，选择了三个经过广泛测试的DBMS：MariaDB、SQLite和PostgreSQL，以及一个新开发的DBMS DuckDB。</li>
<li>选择的DBMS版本分别为：SQLite 3.37.0、DuckDB 0.3.2、MariaDB 10.7.1和PostgreSQL 14.1。</li>
</ul>
<p><strong>Baselines</strong>：</p>
<ul>
<li>为评估Griffin的有效性，选择了SQLsmith、SQLancer和Sqirrel作为基线，这些都是工业界和学术界广泛使用的DBMS模糊测试器。</li>
<li>SQLancer和SQLsmith是基于生成的DBMS模糊测试器，可以连续生成SQL查询进行模糊测试，无需初始种子。</li>
<li>Griffin和Sqirrel是基于突变的DBMS模糊测试器，需要一些SQL查询作为模糊测试的初始种子。</li>
<li>收集了来自每个DBMS官方回归测试套件的开源测试用例，并从中提取SQL语句作为Sqirrel和Griffin的初始种子。</li>
<li>请注意，由于Sqirrel不支持DuckDB的语法，SQLsmith不支持MariaDB的语法，所以我们跳过了在DuckDB上对Sqirrel的评估和在MariaDB上对SQLsmith的评估。</li>
</ul>
<p><strong>Metrics:</strong></p>
<p>Bug检测能力、代码覆盖率</p>
<h4 id="5-1-DBMS-Bug-Detection"><a href="#5-1-DBMS-Bug-Detection" class="headerlink" title="5.1 DBMS Bug Detection"></a><strong>5.1 DBMS Bug Detection</strong></h4><p>这段话描述了Griffin在一周内对四个经过广泛测试的数据库管理系统（DBMS）的错误检测结果。以下是详细的总结：</p>
<ol>
<li>Griffin成功检测了四个经过广泛测试的DBMS中的55个以前未知的错误。</li>
<li>在四个DBMS中，Griffin检测到的错误统计如下：SQLite有16个，DuckDB有12个，MariaDB有24个，PostgreSQL有3个。</li>
<li>使用AddressSanitizer部署的Griffin可以检测到各种错误，包括4个未定义的行为，15个断言失败，3个NULL指针解引用，21个段违规，1个缓冲区溢出，5个用后毒和6个堆使用后释放。</li>
<li>所有这些错误都已报告给相应的DBMS供应商，所有这些错误都已得到确认，其中50个已得到修复。特别是，NVD中有13个错误被分配了唯一的CVE ID。</li>
<li>对触发这些错误的概念验证（PoC）进行了分析。结果表明，其中33个无法直接由其他DBMS模糊测试器生成。对于SQLancer和SQLsmith，由于缺乏语法规则支持，它们无法生成这些SQL测试用例。对于Sqirrel，尽管初始种子包含一些特定的SQL语法，但由于无法被Sqirrel内部解析器识别（不支持特定的语法），所以它跳过了这些种子的突变。相反，Griffin被设计成独立于语法的，并且可以利用这些SQL测试用例的初始种子进行元数据突变来发现这些错误。</li>
<li>在识别和修复这些错误之后，这些DBMS的供应商还将触发这些错误的SQL测试用例添加到这些DBMS的回归测试用例集中。</li>
</ol>
<h4 id="5-2-Comparison-with-Existing-Fuzzers"><a href="#5-2-Comparison-with-Existing-Fuzzers" class="headerlink" title="5.2 Comparison with Existing Fuzzers"></a><strong>5.2 Comparison with Existing Fuzzers</strong></h4><p>这段文字描述了与现有模糊测试工具的比较。以下是对这段文字的总结：</p>
<ol>
<li>为了评估性能，我们对每个测试DBMS进行了12小时的模糊测试，使用了Griffin、SQLsmith、SQLancer和Sqirrel。实验的基本指标是分支数和唯一崩溃数。为了公平比较，在完成模糊测试实验后，我们收集了每个模糊测试器生成的SQL查询并进行了干运行，以统一分支覆盖率。</li>
<li>覆盖率方面，Griffin在分支覆盖率方面表现优于其他模糊测试工具。具体来说，Griffin在12小时的模糊测试后，分别比SQLancer、SQLsmith和Sqirrel覆盖了更多的分支。</li>
<li>改进的主要原因在于Griffin的无语法突变。基于生成的两个模糊测试器，SQLancer和SQLsmith，只能基于它们预定义的模型生成SQL语句，这只覆盖了DBMS的整个SQL语法的一部分。例如，由于预定义的AST模型有限，SQLsmith只能为PostgreSQL生成SELECT语句。与此相反，Griffin可以突变输入中的任何语句，只要它能够被目标DBMS以语法和语义正确的方式执行，因为Griffin被设计为无语法的。换句话说，Griffin可以通过突变现有输入生成具有各种语法的大量新输入。因此，Griffin可以实现比其他DBMS模糊测试工具更高的分支覆盖率。</li>
<li>唯一崩溃方面，Griffin发现的唯一崩溃数量比其他最先进的DBMS模糊测试工具多。具体来说，Griffin在12小时内分别比SQLsmith、SQLancer和Sqirrel多发现了27、27和22个唯一崩溃。</li>
<li>基于改进的覆盖率和突变的丰富种类的SQL语句，Griffin可以触发DBMS的更多不同行为。案例研究显示，Griffin可以生成其他DBMS模糊测试器无法基于有限的SQL语法生成的SQL查询。此外，基于元数据突变，Griffin可以重组新的SQL语句，并通过元数据引导的替换生成新的语义正确的测试用例。因此，Griffin触发了其他DBMS模糊测试工具无法触发的行为，并发现了比其他DBMS模糊测试工具更多的新崩溃。</li>
</ol>
<h4 id="5-3-Effectiveness-of-Metadata-Based-Mutation"><a href="#5-3-Effectiveness-of-Metadata-Based-Mutation" class="headerlink" title="5.3 Effectiveness of Metadata-Based Mutation"></a><strong>5.3 Effectiveness of Metadata-Based Mutation</strong></h4><p>这一部分介绍了元数据突变在Griffin中的有效性。以下是对这段文字的总结：</p>
<ol>
<li>为了了解元数据突变在Griffin中的贡献，我们实现了一个没有元数据突变的Griffin版本，称为Griffin-。我们使用语义正确率（即在模糊测试期间收集的语义正确SQL查询与所有生成的SQL查询的比例）来衡量元数据突变在提高语义正确性方面的有效性。请注意，元数据突变用于突变语句中的变量，并通过类型检查和关系检查确保语义正确性。</li>
<li>表5显示了Griffin和Griffin-在对四个DBMS进行12小时模糊测试时的语义正确率。从表中可以看出，Griffin生成了更多的语义正确SQL查询并覆盖了更多的分支比Griffin-。具体来说，与Griffin-相比，Griffin在PostgreSQL、MariaDB、SQLite和DuckDB上分别生成了更多的语义正确的SQL查询，并覆盖了更多的分支。这个结果是合理的，因为我们设计了元数据突变来提高语义正确性。没有元数据突变，Griffin-只能通过重新组合初始种子中的SQL语句来突变新的SQL查询。因此，Griffin-生成的大多数输入包含语义错误，无法通过DBMS的语义检查，并且无法探索更多的DBMS状态空间。</li>
<li>从表中，我们还可以注意到Griffin在SQLite上只实现了33.42%的语义正确SQL查询的提升。这可以通过SQLite的灵活类型特性来解释。SQLite是一个具有灵活类型检查功能的库功能DBMS。对于SQL语句，它存储和执行而不检查数据类型的真正语义正确性。因此，许多包含数据类型不匹配的SQL查询仍然被SQLite视为语义正确。相反，PostgreSQL、MariaDB和DuckDB在执行前检查语义信息来制定查询计划。因此，在执行之前认为包含语义错误的任何SQL语句都是无效的。因此，Griffin在PostgreSQL、MariaDB和DuckDB上的改进比SQLite上更多。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/">http://example.com/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/27/LearnedSQLGen-Constraint-aware-SQL-Generation-using-Reinforcement-Learning/" title="LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/24/sql%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/" title="sql的编译与执行"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">sql的编译与执行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Griffin-Grammar-Free-DBMS-Fuzzing"><span class="toc-number">1.</span> <span class="toc-text">Griffin: Grammar-Free DBMS Fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">背景信息:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">结果:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E8%A6%81%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">摘要：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.7.</span> <span class="toc-text">INTRODUCTION:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BACKGROUND-AND-MOTIVATION%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">BACKGROUND AND MOTIVATION：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DESIGN%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">DESIGN：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Metadata-Analysis"><span class="toc-number">1.9.1.</span> <span class="toc-text">3.1 Metadata Analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Metadata-Based-Mutation"><span class="toc-number">1.9.2.</span> <span class="toc-text">3.2 Metadata-Based Mutation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EVALUATION"><span class="toc-number">1.10.</span> <span class="toc-text">EVALUATION:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-DBMS-Bug-Detection"><span class="toc-number">1.10.1.</span> <span class="toc-text">5.1 DBMS Bug Detection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Comparison-with-Existing-Fuzzers"><span class="toc-number">1.10.2.</span> <span class="toc-text">5.2 Comparison with Existing Fuzzers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-Effectiveness-of-Metadata-Based-Mutation"><span class="toc-number">1.10.3.</span> <span class="toc-text">5.3 Effectiveness of Metadata-Based Mutation</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/21/Detecting-Logical-Bugs-of-DBMS-with-Coverage-based-Guidance/" title="Detecting Logical Bugs of DBMS with Coverage-based Guidance">Detecting Logical Bugs of DBMS with Coverage-based Guidance</a><time datetime="2023-10-21T11:38:31.000Z" title="发表于 2023-10-21 19:38:31">2023-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/21/Squirrel-Testing-Database-Management-Systems-withLanguage-Validity-and-Coverage-Feedback-%E5%AF%B9%E4%BA%8EDBMS%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/" title="Squirrel Testing Database Management Systems withLanguage Validity and Coverage Feedback--对于DBMS的模糊测试技术介绍">Squirrel Testing Database Management Systems withLanguage Validity and Coverage Feedback--对于DBMS的模糊测试技术介绍</a><time datetime="2023-10-21T11:00:32.000Z" title="发表于 2023-10-21 19:00:32">2023-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/27/LearnedSQLGen-Constraint-aware-SQL-Generation-using-Reinforcement-Learning/" title="LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning">LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning</a><time datetime="2023-09-27T07:05:56.000Z" title="发表于 2023-09-27 15:05:56">2023-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/" title="Griffin Grammar-Free DBMS Fuzzing">Griffin Grammar-Free DBMS Fuzzing</a><time datetime="2023-08-18T07:28:26.000Z" title="发表于 2023-08-18 15:28:26">2023-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/24/sql%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/" title="sql的编译与执行">sql的编译与执行</a><time datetime="2023-07-24T03:19:59.000Z" title="发表于 2023-07-24 11:19:59">2023-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>