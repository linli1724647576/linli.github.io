<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。 https:&#x2F;&#x2F;www.secrss.com&#x2F;articles&#x2F;43424 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;594160921 https:&#x2F;&#x2F;sites.g">
<meta property="og:type" content="article">
<meta property="og:title" content="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱">
<meta property="og:url" content="http://example.com/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。 https:&#x2F;&#x2F;www.secrss.com&#x2F;articles&#x2F;43424 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;594160921 https:&#x2F;&#x2F;sites.g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-08T02:13:40.000Z">
<meta property="article:modified_time" content="2023-03-08T02:21:09.947Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-08 10:21:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-08T02:13:40.000Z" title="发表于 2023-03-08 10:13:40">2023-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-08T02:21:09.947Z" title="更新于 2023-03-08 10:21:09">2023-03-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"><a href="#通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱" class="headerlink" title="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"></a>通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><p><code>本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。</code></p>
<p><a target="_blank" rel="noopener" href="https://www.secrss.com/articles/43424">https://www.secrss.com/articles/43424</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/594160921">https://zhuanlan.zhihu.com/p/594160921</a></p>
<p><a target="_blank" rel="noopener" href="https://sites.google.com/view/npm-vulnerability-study/">https://sites.google.com/view/npm-vulnerability-study/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CErMF3CgSc8">https://www.youtube.com/watch?v=CErMF3CgSc8</a></p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>NPM上发布了170多万个Node.js库，以促进软件开发。正如对比安全所揭示的，第三方库出现在当今软件的大多数（79%）中。然而，任何事物都有两面性。虽然使用库可以减少开发成本和时间，但这些集成库在实践中对软件生态系统构成了新的安全威胁，这些库中的漏洞可能会使依赖它们的软件不断面临安全风险。之前的工作已经调查了整个NPM生态系统的脆弱性影响，而他们的方法要么只是静态地考虑直接依赖性，或者基于依赖关系进行间接依赖的可达性分析，这可能会引入不准确的传递依赖关系，从而导致误报漏洞警告。现存的研究方法还没有提供一个精确的依赖关系。尤其是软件依赖关系之间的内部复杂关系，在很大程度上削弱了其分析的影响，并限制了进一步的解决方案（即精确修复）的提出。尽管一些现有的SCA工具（如Snyk和Blackduck）支持对用户项目进行NPM依赖性分析，但大多数工具都是从实际安装中检索依赖树，而不是从静态推理中检索依赖树。此外，由于语义版本控制的灵活性，依赖关系以及依赖关系中的漏洞实际上会随着时间的推移而发生动态变化。因此，尽管现有工作也调查了漏洞的影响，在没有静态和精确的依赖关系解决方案的情况下，大规模分析依赖关系中存在的漏洞传播的演变仍然是一个挑战，更不用说在防止漏洞动态引入依赖项方面获得实用的解决方案。</p>
<h2 id="2-论文主要成果"><a href="#2-论文主要成果" class="headerlink" title="2. 论文主要成果"></a>2. 论文主要成果</h2><ul>
<li>实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包（超过114万个库和1094万个版本）之间的依赖关系，以及来自NVD的800多个已知CVE（常见漏洞和暴露），进一步的支持对漏洞传播的分析</li>
<li>提出了一种基于DVGraph的新算法（DTResolver），可以静态、精确地解析任意安装时间的依赖树，精度高达90%以上，并通过大约100k个代表性软件包进行了验证</li>
<li>进一步对依赖树中的脆弱性传播进行了实证研究。首先，我们研究了NPM依赖解析带来的依赖树的特征，在此基础上，我们分析了依赖树中漏洞传播的影响和特征，特别是传递依赖的漏洞。此外，我们还将研究扩展到时间维度，以研究依赖树中漏洞传播随时间的演变，揭示依赖树中引入漏洞的原因，以及可能的解决方案</li>
</ul>
<h2 id="3-实验架构"><a href="#3-实验架构" class="headerlink" title="3. 实验架构"></a>3. 实验架构</h2><p>包括依赖漏洞知识图构建、依赖树解析、漏洞路径识别及其验证、大规模实证研究以及对经验教训和解决方案的讨论，以及可能的研究方向</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1ed5572cf3d56e315f7e865590c7f9ac.png" alt="img"></p>
<h2 id="4-DVGraph的构建"><a href="#4-DVGraph的构建" class="headerlink" title="4. DVGraph的构建"></a>4. DVGraph的构建</h2><p>为了支持高精度和高效率的大规模依赖漏洞分析，我们设计并实现了一套数据处理平台，以构建和维护完整而精确的依赖漏洞图DVGraph（基于neo4j）。</p>
<p>下图为改数据处理平台的框架：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/5d6447824371e7607b366407f7aad9fa.png" alt="img"></p>
<p><strong>Metadata Pipeline：</strong>将数据保存在元数据库中</p>
<p><strong>CVE Pipeline：</strong>从NVD数据集收集CVE数据</p>
<p><strong>CVE Triage Pipeline：</strong>手工标记CVE数据的对应的受影响的库和版本</p>
<p><strong>Graph Pipeline：</strong>解析新来的元数据和映射的CVE数据，计算要在DVGraph上执行的操作（即添加、更改和删除节点和边），并最终执行这些操作</p>
<h2 id="5-依赖树解析和脆弱路径识别"><a href="#5-依赖树解析和脆弱路径识别" class="headerlink" title="5. 依赖树解析和脆弱路径识别"></a>5. 依赖树解析和脆弱路径识别</h2><h3 id="5-1-依赖树解析"><a href="#5-1-依赖树解析" class="headerlink" title="5.1 依赖树解析"></a>5.1 依赖树解析</h3><p>目前还没有一个考虑到特定于平台的依赖关系解决规则，可能导致不准确的依赖关系解析。本文目标是实现静态解析与NPM在实际安装过程中动态解析和安装的依赖树一致的依赖树，以便我们能够准确有效地识别依赖树中的漏洞和脆弱路径，而无需实际安装。</p>
<p>为了提高精度，同时保持效率，我们提出了一种基于DVGraph的依赖解析算法（DTResolver），可以在不安装的情况下，对任意数据软件包依赖解析的过程中，识别并找出所有依赖中含有安全漏洞的组件及相应的依赖引入路径</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/0fffc83b26b8297bd142c0061a005fb8.png" alt="img"></p>
<p>Dependency Tree Resolution</p>
<p>此外由于NPM中广泛使用依赖约束条件（版本范围）而不是固定版本进行依赖定义，导致依赖安装结果随着时间可能发生变化</p>
<p>如下图中，在<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#46;&#49;">&#66;&#64;&#49;&#46;&#x30;&#46;&#49;</a>发布后，<a href="mailto:&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>的安装过程中，对B的依赖将解析成新发布的版本而不是原有的<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>, 图中<a href="mailto:&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;">&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;</a>的发布亦是如此。因此我们在DTResolver的基础上进一步增加了时间约束，使其能够支持在给定项目从其发布前到DVGraph更新时间内任意时刻的依赖树模拟解析。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/cb04b86c4aafea8676a467c495666079.jpg" alt="img"></p>
<h3 id="5-2-脆弱路径识别"><a href="#5-2-脆弱路径识别" class="headerlink" title="5.2 脆弱路径识别"></a>5.2 脆弱路径识别</h3><p>给出了脆弱点和路径的示例 通过反向深度优先搜索（DFS）实现了一个脆弱路径提取器，以彻底查找依赖树中从脆弱点到根节点的依赖关系</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/aed9b3b573cfcee4c57b966475f78199.png" alt="img"></p>
<h3 id="5-3-评估验证"><a href="#5-3-评估验证" class="headerlink" title="5.3 评估验证"></a>5.3 评估验证</h3><p>通过比较DTResolver解析的依赖树与实际安装的依赖树来验DTResolver。此外，我们将npm-remote-ls作为比较时的方法，这是一种广泛使用的公共API，在实践中无需实际安装即可获得依赖树，并且它完全遵循依赖范围来派生依赖树。</p>
<p>数据选择我们的验证基于两个标准收集的数据：（1）流行度，对于每个流行度指标（即过去、过去3年和去年下载量最多的明星、分叉、下载量多），我们分别选择了前2000个库。（2）中心性，对于每个中心性度量（即最大出入度），我们还选择了前2000个库和前20K个版本。分别地对于库，我们采用每个次要版本的最高补丁版本。最后，整理了15673个库中的103609个版本。</p>
<p><strong>DTResolver解析器的评估。</strong>根据结果，90.58%的图树在忽略无法计算的情况（例如，具有捆绑的依赖项并且包含没有时间的依赖项）后与安装树完全匹配。而只有53.33%的远程树与安装树完全匹配，这是因为npm远程ls错过了一些官方的解决规则（例如，未弃用版本的优先级选择）。此外，我们进一步确定了不匹配依赖树的两个主要原因：1）在npm ls的输出中消除了依赖，这省略了一些包和依赖关系以简化树视图。2） 由于环境问题，依赖项可能无法完全安装（例如，当缺少所需的操作系统支持时，某些程序包可能无法安装）。此外，缺少库版本（即不在NPM注册表中或爬网失败）也会导致依赖关系树中缺少一些包。</p>
<p><strong>漏洞检测和漏洞路径识别评估。</strong>除了DTResolver的评估，我们还扩展到比较检测到的漏洞和易受攻击的路径。由于从实际安装中检索到的安装树可能不完整（例如，依赖关系中的某些包由于环境问题而未安装），我们通过调用Graph Tree和Remote Tree中已识别的漏洞和漏洞路径来评估漏洞检测的准确性。我们发现DTResolver（98.1%）和npm远程ls（97.7%）在检测易受攻击组件方面具有相似的高覆盖率，但在识别易受攻击路径方面存在差异（92.60%对78.31%）。这可能是因为大多数依赖性约束都被解析为最满意的版本，并且依赖性范围也遵循这一规则，因此，仍然可以识别最脆弱的包。然而，通过依赖关系到达解决依赖关系忽略了NPM特定的解决规则，这会影响识别依赖关系路径的准确性。</p>
<h2 id="6-大规模实证研究"><a href="#6-大规模实证研究" class="headerlink" title="6. 大规模实证研究"></a>6. 大规模实证研究</h2><p>以下两个方面分析NPM中安全漏洞的影响：</p>
<ul>
<li>漏洞如何影响NPM生态系统？漏洞如何通过依赖关系树传播影响根包(root packages)？</li>
<li>漏洞传播如何在依赖树中发展？依赖关系树的变化如何影响漏洞传播的演变？</li>
</ul>
<h3 id="6-1-通过依赖树传播漏洞"><a href="#6-1-通过依赖树传播漏洞" class="headerlink" title="6.1 通过依赖树传播漏洞"></a>6.1 通过依赖树传播漏洞</h3><ul>
<li>据统计证明，漏洞广泛存在于NPM包的依赖关系中（整个生态系统中有19.96%的库的四分之一版本）</li>
<li>第三方库的最新版本（16.17%）仍然存在通过依赖关系受到漏洞影响的潜在风险。</li>
<li>其他用户使用的易受攻击的库中，有相当一部分（超过100个）仍然有易受攻击的最新版本</li>
<li>一些有影响力的已知CVE广泛存在于大部分包的依赖树中</li>
<li>包通常受到多个漏洞的影响，每个漏洞通过多个漏洞路径影响根包（平均一个漏洞引入8个漏洞路径）</li>
<li>漏洞仍然广泛存在于受影响库版本的直接依赖关系中（超过30%），即使是最新版本</li>
<li>在易受攻击的路径上也存在中心性，即大多数易受攻击的路径都会通过有限的直接依赖关系，这可以用来切断易受攻击的路径</li>
</ul>
<h3 id="6-2-依赖树中的漏洞传播演化"><a href="#6-2-依赖树中的漏洞传播演化" class="headerlink" title="6.2 依赖树中的漏洞传播演化"></a>6.2 依赖树中的漏洞传播演化</h3><ul>
<li>随着时间的推移，已知的漏洞正在对NPM生态系统造成更大的影响。它们不仅影响到更多的库版本，而且还影响到依赖树中更脆弱的点</li>
<li>大多数CVE（93%）在被发现之前已经被引入依赖树，这些CVE的固定版本（87%）也大多在CVE发布之前发布</li>
<li>依赖树中只有60%的CVE被DTC自动删除，即使如此，每个CVE删除仍需要一年以上的时间</li>
<li>过时的维护（提供者）和不合适的依赖约束（使用者）是阻碍依赖树中漏洞自动移除的主要原因。应该采取更多的对策和解决方案来避免、监控甚至纠正这些不良做法</li>
</ul>
<p>DTReme</p>
<p>添加了1)<strong>前向漏洞检查</strong>，在解析新的依赖关系的版本时（算法1中的第13行和第17行），只解析每个依赖关系的干净版本；2)<strong>向后安装的包跟踪</strong>，一旦没有干净版本可以解决，回滚到父节点的解析，并找到替代版本，以避免没有干净版本的情况。因此，我们可以彻底遍历所有可能的解决方案，找到可能的干净依赖树，并且可以为整个依赖树生成一个新的package-lock.json文件作为修复解决方案。</p>
<h2 id="7、有限性"><a href="#7、有限性" class="headerlink" title="7、有限性"></a>7、有限性</h2><p>首先，依赖关系中的漏洞可能永远不会影响根包，因为可能永远无法访问这些易受攻击的功能。这只能通过基于依赖树和调用图分析易受攻击的函数调用路径来进一步解决。我们将此作为我们未来的工作。其次，CVE和库版本的映射是手动标记的，这可能会导致数据错误标记，合作的作者已将数据与现有CVE交叉验证，以缓解此类威胁。第三，我们无法区分包含缺失依赖项的安装，这可能会使基本事实不准确，我们只接受依赖项中成功安装的包作为验证中的基本事实。第四，由于计算成本过高，在分析漏洞传播时，我们忽略了具有超过1k条漏洞路径的版本。总的来说，这样的版本只占2.01%，这只能对我们的结果造成有限的偏差。</p>
<h2 id="附录1-Npm依赖解析规则"><a href="#附录1-Npm依赖解析规则" class="headerlink" title="附录1 Npm依赖解析规则"></a>附录1 Npm依赖解析规则</h2><p><a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v9/commands/npm-install">https://docs.npmjs.com/cli/v9/commands/npm-install</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/penghuwan/p/6970543.html">【npm】详解npm的模块安装机制 - 外婆的 - 博客园 (cnblogs.com)</a></p>
<p><font color="red"><strong>依赖树表面的逻辑结构与依赖树真实的物理结构</strong> </font></p>
<p>这里要先提到两个命令：tree -d（linux）和npm ls（npm）</p>
<p>在一个npm项目下：</p>
<p><strong>tree -d命令</strong>以树状图的方式列出一个项目下所有依赖的物理结构</p>
<p><strong>npm ls命令</strong>以树状图的方式列出一个项目下所有依赖的逻辑结构</p>
<p>以官方文档为例子：</p>
<p>项目example1有两个依赖模块：mod-a模块和mod-c模块；</p>
<p>mod-a模块有一个依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;">&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;</a>模块</p>
<p>mod-c模块有一个依赖模块<a href="mailto:&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;</a>模块</p>
<p>tree -d 和npm ls运行结果如下：（注意npm版本为npm3而非npm2）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092200262-641835535.png" alt="img"></p>
<p>先看看下面那个红框的结果，这应该是“最符合我们理解”的依赖树，首先项目下形成了一级依赖——mod-a模块和mod-b模块，然后以这两个模块为父模块再追加二级依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a>和<a href="mailto:mod-b@2.0.0">mod-b@2.0.0</a></p>
<p>但是！这却并不是物理上真实形成的依赖树的模样，物理上真实形成的依赖树是上面的那个红色框。<strong>mod-a,mod-c和mod-b竟然同为同一级</strong>的依赖。</p>
<p>你可能会问，为什么会形成这样的依赖树呢？下面我就来解释一番</p>
<p>【注意】：下面的图示全部为依赖树的物理结构，而不是逻辑结构</p>
<p><font color="red"><strong>关于npm模块安装机制的一点猜想</strong></font></p>
<p>安装模块时，可能的方式有两种：<strong>平级式</strong>的安装或<strong>嵌套式</strong>的安装（此处仅仅是猜想和假设）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092352262-1548398831.png" alt="img"></p>
<p>能不能完全采取平级的安装方式呢？——不能</p>
<p>我们取和上面相似的一个例子：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块Cv2.0。显然，它们并不能同时存在于同一个node_modules下，当安装的时候，由于npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092426950-802407609.png" alt="img"></p>
<p>但如果我们仅仅只安装一个版本的C依赖模块，将可能会导致A模块和B模块不兼容</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092458231-782438150.png" alt="img"></p>
<p><strong>基于以上原因，npm2选择了嵌套的安装方式——</strong></p>
<p><font color="red"><strong>npm2下的模块安装机制</strong></font></p>
<p>npm2安装多级的依赖模块采用嵌套的安装方式：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092546575-1188239142.png" alt="img"></p>
<p><strong>优点和弊端</strong></p>
<p><strong>优点：</strong>解决了版本单一时存在的存在的不兼容问题，实现多版本兼容</p>
<p><strong>弊端：</strong>可能造成相同模块大量冗余的问题，如下：</p>
<p>以上面例子为例，下面这种情况也是合理存在的：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092618981-1003798029.png" alt="img"></p>
<p>凭感觉也知道，这绝不是什么好现象，那我们如何能在实现依赖间多版本兼容的前提下，减少这种模块冗余呢？于是npm3做了一下改进</p>
<p><font color="red"><strong>npm3下的模块安装机制：</strong></font></p>
<p>npm3和npm2的不同主要体现在二级模块的安装上：</p>
<p>npm3会**”尽量”<strong>把逻辑上某个层级的模块在物理结构上</strong>“全部”**放在项目的第一层级里，具体我概括为以下三种情况：</p>
<p>1.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>还没有相同名称的模块</strong>，便<strong>把这第二层级的模块放在第一层级</strong></p>
<p>2.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，相同版本的模块</strong>，便<strong>直接复用那个模块</strong></p>
<p>3.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，但版本不同的模块</strong>，便<strong>只能嵌套在自身的父模块下方</strong></p>
<p>这一开始可能有些难理解，所以让我们看图说话吧！</p>
<p><strong>先说1：在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</strong></p>
<p>我们先简化一下上面的例子：现在项目APP下只有一个一级依赖模块A，它下面有一个二级依赖模块C，但npm install的时候，项目下安装依赖的</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092737903-1235721353.png" alt="img"></p>
<p>npm3中的二级模块（C v1.0),在项目的一级目录（node_modules）下没有相同名称的模块时，会被安装到一级目录下，从而跟它的父模块A同级。<strong>这就是本文一开始中依赖树的逻辑结构和物理结构不同的起因</strong>。</p>
<p>也就是说：</p>
<p><strong>在npm2中，依赖树的逻辑结构和它的物理结构相同</strong></p>
<p><strong>在npm3中，依赖树的逻辑结构和它的物理结构可能不同</strong></p>
<p><strong>再说2:在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</strong></p>
<p>在1的基础上，我们把1的例子还原回之前的复杂一些的场景：：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块C v1.0（两个C模块版本相同）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092859168-1795479456.png" alt="img"></p>
<p>对npm2,两个C包是相同的，造成模块冗余</p>
<p>在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块</p>
<p><strong>npm3就是用这种方式，部分地解决了npm2的痛点（部分）</strong></p>
<p>【从1，2到3的过渡】我在这一小节的开始说：“npm3会”尽量”把逻辑上某个层级的模块”全部”放在项目的第一层级里”，我想你看完1，2后应该多少有些理解了**<em>“尽量”*<strong>的含义了，但我说了</strong></em>“尽量”***，同时也就意味着npm3存在着不能把二级依赖放在第一层级的情况。对此，请看3:</p>
<p><strong>最后说3:在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方</strong></p>
<p>在2中，A，B所依赖的两个C模块是相同的，<strong>但如果两个C模块的版本不同呢？</strong>，项目npm install情况如下：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093023575-1842293712.png" alt="img"></p>
<p>在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块</p>
<p><strong>（看到这里我想应该能解答你对文章开头那个例子的疑惑了吧，这个例子和那个例子是几乎完全一样的哦）</strong></p>
<p>看到这里，你对npm2和npm3下的模块工作机制，以及npm3针对npm2的优化有个大体的了解了吧，但请思考一个问题：n<strong>pm3是否已经把npm2的模块冗余的缺陷优化到极致了呢？</strong> ———答案是<strong>没有</strong>，请往下看：</p>
<p>实际上：<strong>npm3中仍然可能出现模块冗余的情况</strong>，因为一级目录下已经有v1.0的C模块了，<strong>所以所有的v2.0只能作为二级依赖模块被安装</strong>，这样你就会看到如下的情况</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093147262-345050329.png" alt="img"></p>
<p>并且在上图所示的这种特殊情况里，npm3和npm2表现得似乎并没什么区别</p>
<p>【过渡】那么这有没有什么解决的方式呢？当然是有的，当A模块下的C v1.0模块被更新至C v2.0的前提下，我们可以<strong>通过npm dedupe把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0</strong></p>
<p><font color="red"><strong>利用npm dedupe去除冗余模块</strong></font></p>
<p><strong>npm dedupe做了什么？****它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块</strong></p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093125700-1173491575.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/">http://example.com/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">01-编译Cpython</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PLUMBER</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div><div><a href="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/" title="TYPET5 SEQ2SEQ TYPE INFERENCEUSING STATIC ANALYSIS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">TYPET5 SEQ2SEQ TYPE INFERENCEUSING STATIC ANALYSIS</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="toc-number">1.</span> <span class="toc-text">通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1. 背景介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BA%E6%96%87%E4%B8%BB%E8%A6%81%E6%88%90%E6%9E%9C"><span class="toc-number">1.2.</span> <span class="toc-text">2. 论文主要成果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9E%E9%AA%8C%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">3. 实验架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-DVGraph%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.4.</span> <span class="toc-text">4. DVGraph的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BE%9D%E8%B5%96%E6%A0%91%E8%A7%A3%E6%9E%90%E5%92%8C%E8%84%86%E5%BC%B1%E8%B7%AF%E5%BE%84%E8%AF%86%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5. 依赖树解析和脆弱路径识别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BE%9D%E8%B5%96%E6%A0%91%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 依赖树解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%84%86%E5%BC%B1%E8%B7%AF%E5%BE%84%E8%AF%86%E5%88%AB"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 脆弱路径识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%AF%84%E4%BC%B0%E9%AA%8C%E8%AF%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 评估验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6"><span class="toc-number">1.6.</span> <span class="toc-text">6. 大规模实证研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%80%9A%E8%BF%87%E4%BE%9D%E8%B5%96%E6%A0%91%E4%BC%A0%E6%92%AD%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 通过依赖树传播漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BE%9D%E8%B5%96%E6%A0%91%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%BC%A0%E6%92%AD%E6%BC%94%E5%8C%96"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 依赖树中的漏洞传播演化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%9C%89%E9%99%90%E6%80%A7"><span class="toc-number">1.7.</span> <span class="toc-text">7、有限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%951-Npm%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99"><span class="toc-number">1.8.</span> <span class="toc-text">附录1 Npm依赖解析规则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/09/Static-Type-Recommendation-for-Python/" title="Static Type Recommendation for Python">Static Type Recommendation for Python</a><time datetime="2023-05-09T11:20:55.000Z" title="发表于 2023-05-09 19:20:55">2023-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/29/%E5%A6%82%E4%BD%95%E7%94%A8ChatGpt%E6%90%9E%E5%AD%A6%E6%9C%AF%EF%BC%9F%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D/" title="如何用ChatGpt搞学术？事半功倍">如何用ChatGpt搞学术？事半功倍</a><time datetime="2023-04-29T11:06:10.000Z" title="发表于 2023-04-29 19:06:10">2023-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/26/35-Numba%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Python%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%9A%84/" title="35-Numba是如何解决Python的三大性能瓶颈的">35-Numba是如何解决Python的三大性能瓶颈的</a><time datetime="2023-04-26T13:27:46.000Z" title="发表于 2023-04-26 21:27:46">2023-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/" title="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时">34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</a><time datetime="2023-04-26T13:27:13.000Z" title="发表于 2023-04-26 21:27:13">2023-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/" title="33-为什么 obj == obj 为 False、[obj] == [obj] 为 True">33-为什么 obj == obj 为 False、[obj] == [obj] 为 True</a><time datetime="2023-04-26T13:26:41.000Z" title="发表于 2023-04-26 21:26:41">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>