<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>AexPy Detecting API Breaking Changes in Python Packages | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AexPy: Detecting API Breaking Changes in Python PackagesBasic Information: Title: AexPy: Detecting API Breaking Changes in Python Packages (AexPy: 检测Python包中的API破坏性变更) Authors: Xingliang Du, Jun Ma Af">
<meta property="og:type" content="article">
<meta property="og:title" content="AexPy Detecting API Breaking Changes in Python Packages">
<meta property="og:url" content="http://example.com/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="AexPy: Detecting API Breaking Changes in Python PackagesBasic Information: Title: AexPy: Detecting API Breaking Changes in Python Packages (AexPy: 检测Python包中的API破坏性变更) Authors: Xingliang Du, Jun Ma Af">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-06-28T12:42:06.000Z">
<meta property="article:modified_time" content="2023-06-28T12:43:06.700Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AexPy Detecting API Breaking Changes in Python Packages',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-28 20:43:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AexPy Detecting API Breaking Changes in Python Packages</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-28T12:42:06.000Z" title="发表于 2023-06-28 20:42:06">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T12:43:06.700Z" title="更新于 2023-06-28 20:43:06">2023-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AexPy Detecting API Breaking Changes in Python Packages"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="AexPy-Detecting-API-Breaking-Changes-in-Python-Packages"><a href="#AexPy-Detecting-API-Breaking-Changes-in-Python-Packages" class="headerlink" title="AexPy: Detecting API Breaking Changes in Python Packages"></a>AexPy: Detecting API Breaking Changes in Python Packages</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: AexPy: Detecting API Breaking Changes in Python Packages (AexPy: 检测Python包中的API破坏性变更)</li>
<li>Authors: Xingliang Du, Jun Ma</li>
<li>Affiliation: State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China (南京大学，新软件技术国家重点实验室，南京，中国)</li>
<li>Keywords: Python, application programming interface, backward compatibility, breaking change (Python, 应用程序编程接口, 向后兼容性, 破坏性变更)</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9514462">Paper</a>, <a target="_blank" rel="noopener" href="https://github.com/duxingliang/AexPy">GitHub</a></li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>本研究提出了一种基于API模型的系统方法，名为AexPy，用于检测Python包中的API破坏性变更。通过设计Python特定的API模型，并采用强大的混合分析方法，AexPy在已知的61个破坏性变更数据集上实现了86.9%的召回率。此外，AexPy在45个包的最新版本中检测到405个高和中等破坏性变更，准确率达到93.5%。其中，除了291个已记录的破坏性变更外，AexPy还检测到了114个未记录的变更。我们向活跃的包开发者报告了63个未记录的破坏性变更，其中31个已得到确认。</li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h3><p><font color="red">背景：</font></p>
<p>Python提供了方便的标准库和庞大的第三方包生态系统，适用于许多任务（如深度学习、自动脚本、数据处理），帮助开发人员高效实现他们的想法。然而，在包的演变过程中，包的开发人员可能会重新设计数据结构、更改操作或调整规范，以修复错误或提供新功能。其中一些变化可能会破坏客户端代码，即所谓的“破坏性变化”。API变化是常见的变化情况之一。API描述了一个包的公共接口，这些接口是客户端依赖的约定，因此API的变化可能会影响客户端。在常用的Python框架包的演变过程中，超过40%的API变化是破坏性的，这比静态语言的比例更高。这些破坏性变化破坏了向后兼容性，降低了演化的稳定性，并可能在客户端引发潜在的错误。</p>
<p><font color="red">相关工作：</font></p>
<p>检测Python包中的破坏性变化是具有挑战性的，因为Python具有动态特性和灵活的设计，例如动态模块导入、动态类型、多个API引用和灵活的参数传递，这些特性增加了API的复杂性，并引入了各种API变化。现有的方法，如pidiff［９］和PyCompat［４］，对这些挑战缺乏足够的考虑，导致结果不准确和不完整。</p>
<p><font color="red">方法：</font></p>
<p>本文提出了一种自动和系统的方法来检测Python包中的API破坏性变化，帮助Python开发人员可靠地演化包。该方法分为三个主要步骤：1）从不同版本的Python包中提取API；2）比较API以检测不同模式的变化；3）评估变化的向后兼容性并进行分级。为此，提出了一个Python包API模型，考虑了Python的主要特性（如继承、参数传递、别名、类型）。特别地，对函数的签名类型进行建模以应对动态类型的挑战。基于该模型，结合动态反射和静态分析进行API发现和信息丰富，得到包括类型、参数、别名和继承在内的详细API描述。然后，将API变化系统地分类为42种模式。设计了一种适应Python命名解析的入口配对算法和一种基于约束的检查算法来自动检测变化。最后，为了实用性，将变化分为四个破坏级别，根据API的范围、变化模式和变化内容，表示不同程度的变化严重性。特别地，使用类型之间的子集关系来建模类型变化的兼容性。</p>
<p>作者在一个名为AexPy的原型中实现了所提出的方法。通过将其应用于不同包的已知&#x2F;未知破坏性变化的检测，评估了该工具的有效性和效率。具体来说，将AexPy与现有的两个Python  API破坏性变化检测工具（pidiff和PyCompat）进行了比较。AexPy受益于详细的模型和混合分析，其在可比较的时间性能下提高了近50%的召回率。同时，在最新版本的45个包中，AexPy检测到了43个包中的高&#x2F;中等破坏性变化，手动验证的准确率达到了93.5%。到目前为止，已经收到了63个报告的未记录的破坏性变化中的50个反馈，其中31个得到了确认，表明我们的方法在实际环境中是实用的。</p>
<p><font color="red">贡献：</font></p>
<p>这篇论文的主要贡献包括：</p>
<ol>
<li>系统设计了Python包API模型和API变化分类：作者对Python包API进行了系统设计，提出了一种API变化的分类方法。为了适应Python API的灵活性，他们将变化分为四个破坏级别，并改善了模型的实用性。</li>
<li>提出了一种自动和系统的方法来检测Python包中的API破坏性变化：为了解决Python动态特性和灵活设计带来的挑战，作者的方法通过动态反射和静态分析提取API，并通过基于约束的检查算法检测破坏性变化。据作者所知，他们首次提出了一种检测Python包中类型破坏性变化的方法，通过静态构造类型之间的子集关系检查变化的兼容性。</li>
<li>实现了名为AexPy的原型工具，用于检测现实世界中包的破坏性变化：作者在实际包上评估了AexPy，包括61个已知的破坏性变化和45个最新版本的包。他们的方法实现了86.9%的召回率，超过了现有工具，并且在最新版本中以93.5%的精确度检测到高和中等破坏性变化。在报告的63个变化中，已有31个被包开发人员确认。</li>
</ol>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><ul>
<li>论文背景: 随着Python语言的流行，社区开发人员创建和维护了许多第三方包。在包的演化过程中，API经常发生变化。包开发人员需要保持API的向后兼容性，以避免破坏客户端代码。然而，由于Python的动态特性和灵活的设计，如动态类型、API别名、混乱的公共边界和灵活的参数传递，检测Python包中的破坏性变更具有挑战性。尽管Python语言很受欢迎，但目前很少有针对检测破坏性变更的工具，现有方法对上述挑战考虑不足，导致检测结果不准确和不完整。</li>
<li>过去方案: 过去的方法缺乏对Python动态特性和灵活设计的充分考虑，导致检测破坏性变更的不准确和不完整。</li>
<li>论文的Motivation: 鉴于现有方法的不足，本研究旨在提出一种基于API模型的系统方法，以更准确和更全面地检测Python包中的破坏性变更。通过设计Python特定的API模型和采用混合分析方法，本研究的目标是提高检测的召回率和准确率，并发现未记录的破坏性变更。</li>
</ul>
<h4 id="API-Backward-Compatibility"><a href="#API-Backward-Compatibility" class="headerlink" title="API Backward Compatibility"></a><em>API Backward Compatibility</em></h4><p>API向后兼容性是指软件包在更新版本时，保持与旧版本的兼容性，即新版本的API能够以相同的方式使用，并产生与旧版本相同的行为。这意味着客户端可以无需修改代码，将新版本的软件包替换旧版本，继续正常运行而不会引发编译或运行时错误。</p>
<p>在软件包中，API描述和规定了预期行为，包括数据结构的描述以及对这些数据的操作。向后兼容性是指系统能够与旧的遗留系统进行互操作，例如处理来自旧系统的输入。如果修改系统的方式违反了这个特性，就称为”破坏”向后兼容性，即破坏性变化。软件包的向后兼容性意味着客户端可以以相同的语法和语义使用新版本的软件包，并获得与旧版本相同的行为。API的破坏性变化可能会在客户端代码中引发编译或运行时问题。例如，在Java API中进行签名变更可能导致编译错误，而在C&#x2F;C++的共享对象（动态链接库）中删除函数可能导致运行时链接错误。</p>
<h4 id="B-Breaking-Changes-in-Python-Packages"><a href="#B-Breaking-Changes-in-Python-Packages" class="headerlink" title="B. Breaking Changes in Python Packages"></a><em>B. Breaking Changes in Python Packages</em></h4><p>本段主要介绍了在Python包中检测破坏性变化所面临的四个挑战。</p>
<ol>
<li>动态语言特性：由于Python的动态语言特性，静态收集API元数据变得困难。Python提供了装饰器、元类、类钩子等语言级机制来动态修改类，这增加了静态分析的难度。此外，Python的动态类型系统对类型兼容性检查带来挑战。CPython只在运行时检查类型兼容性，因此类型相关的错误只会在执行时出现，难以在编程阶段轻松检测，尤其是在两个版本之间。Python具有复杂的类型系统和无强制类型声明的特点，引入了复杂和多样的类型变化。</li>
<li>复杂的API引用：Python允许使用不同的名称引用相同的API，这导致了定位和区分API变得困难。Python是一种支持多继承和灵活对象定义的面向对象编程语言。大多数编程元素（如模块、类、函数）都是对象，可以存储在变量或另一个对象的成员中。一个API对象可以被不同的名称访问，一个成员名称可以指向来自另一个模块甚至另一个包的API（即外部API）。这个特性在一些流行的包中被广泛使用，例如NumPy、Tensorflow，以方便创建简短的名称，但也导致了复杂的跨API结构。</li>
<li>伪私有成员：Python中公共API的边界模糊。Python没有访问修饰符，使得大多数对象都是可访问的，这导致了在区分API的范围时容易产生困惑。Python将以双下划线开头的类成员视为私有，并对其名称进行编码以防止访问这些成员。但对于模块成员，没有类似的机制。Python开发者通常使用自己的私有命名约定，例如如果成员名称以下划线开头或属于特定模块，则被视为私有。由于Python对这些约定没有强制限制，客户端仍然可以像访问普通成员一样访问这些成员，这使得覆盖这些变化变得复杂。</li>
<li>灵活的参数传递：Python具有灵活的参数传递设计。首先，可以指定默认值使参数可选。其次，在调用函数时，参数可以作为位置参数或关键字参数传递。第三，函数可以接受未绑定的参数。Python将未绑定的位置参数收集为列表，类似于C++或Java中的可变参数函数。特别地，Python将未绑定的关键字参数收集为字典。</li>
</ol>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628144514708.png" alt="image-20230628144514708"></p>
<p>总的来说，Python作为一种动态语言，在进行API向后兼容性检测时面临了动态语言特性、复杂的API引用、伪私有成员和灵活的参数传递等挑战。这些挑战增加了静态分析和破坏性变化检测的复杂性。</p>
<h4 id="C-Limitations-of-Existing-Approaches"><a href="#C-Limitations-of-Existing-Approaches" class="headerlink" title="C. Limitations of Existing Approaches"></a><em>C. Limitations of Existing Approaches</em></h4><p>现有工具包括pidiff和PyCompat，用于检测Python中的破坏性变化。然而，这些工具存在一些局限性。</p>
<p>Pidiff是一个用于强制使用语义化版本控制（semver）的工具，它通过比较两个版本的Python包提供的API来检测变化，并根据semver规则生成报告并提醒开发者。Pidiff主要通过反射提取API，并从源代码中获取实例属性。它分类和检测三类变化模式，包括模块、对象和签名的变化。</p>
<p>[9] R. McGovern. (2022, May) rohanpm&#x2F;pidiff: The python interface diff　tool. [Online]. Available: <a target="_blank" rel="noopener" href="https://github.com/rohanpm/pidiff">https://github.com/rohanpm/pidiff</a></p>
<p>PyCompat是一个半自动的API兼容性问题检测工具，针对六个流行的Python包的客户端设计，基于自己的API变化检测器。PyCompat完全通过动态反射提取API，然后分类和检测包括类、方法和属性变化在内的14种变化模式。</p>
<p>[4] Z. Zhang, H. Zhu, M. Wen, Y. Tao, Y. Liu, and Y. Xiong, “Howdo python framework apis evolve? an exploratory study,” in <em>27th**IEEE International Conference on Software Analysis, Evolution and</em>Reengineering, SANER 2020, London, ON, Canada, February 18-21,<em>2020</em>, K. Kontogiannis, F. Khomh, A. Chatzigeorgiou, M. Fokaefs,and M. Zhou, Eds. IEEE, 2020, pp. 81–92. [Online]. Available:<a target="_blank" rel="noopener" href="https://doi.org/10.1109/SANER48275.2020.9054800">https://doi.org/10.1109/SANER48275.2020.9054800</a></p>
<p>然而，根据第二节提到的挑战，现有方法缺乏对类型变化、类继承、API别名和伪私有成员的考虑。此外，pidiff忽略了参数默认值的变化，而PyCompat忽略了参数类型的变化。PyCompat还忽略了嵌套模块，导致缺乏深层API及其变化的检测。此外，PyCompat无法直接用于除了这六个包之外的其他包。这些限制导致检测结果不准确或不完整，并且可用性较低。</p>
<p>为了解决这个问题，需要更全面、系统的破坏性变化分类和更自动化、健壮的检测工具。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文针对Python软件包中的破坏性变更检测问题进行研究。提出了一种基于API模型的系统化方法，包括Python特定的API模型，并将API变更分类为不同的破坏级别。该方法使用混合分析来获取API及其类型，并通过检查API对之间的约束来检测分级变更。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>本文的技术路线包括以下步骤：<ol>
<li>构建Python特定的API模型。</li>
<li>使用混合分析获取API及其类型。</li>
<li>通过检查API对之间的约束来检测分级变更。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="BACKWARD-COMPATIBILITY-MODELING"><a href="#BACKWARD-COMPATIBILITY-MODELING" class="headerlink" title=" BACKWARD COMPATIBILITY MODELING"></a><font color="red"> BACKWARD COMPATIBILITY MODELING</font></h3><h4 id="A-Python-API-Model"><a href="#A-Python-API-Model" class="headerlink" title="A. Python API Model"></a>A. Python API Model</h4><p>根据Python模块化结构，我们考虑api的集合E，即四个集合M、C、F、A的并集，分别表示模块、类、函数和属性。</p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628151335120.png" alt="image-20230628151335120"></p>
<p>根据Python的模块化结构，我们考虑API的集合E，即模块（M）、类（C）、函数（F）和属性（A）的并集。例如，与图1中的代码对应的API集合是E &#x3D; {D, f, A, x, t, init, g, B, h, i}。</p>
<p>1）模块（Module）：模块m ∈ M作为代码的组织单元，具有包含任意对象（如类、函数、属性或子模块）的命名空间[8]，例如模块D。我们通过members(m)来描述其成员关系，其中包含m的所有成员及其对应的成员名称，如类和函数的定义，对外部对象的引用。形式上，members(m)是一个映射器，形式为字符串 → (E ∪ {⊥})，从成员名称到目标API（对于外部API为⊥）。例如，示例中的模块D包含一个函数、两个类和对typing中外部类的引用，即members(D) &#x3D; {“opt” → ⊥, “f” → f, “A” → A, “B” → B}。</p>
<p>2）类（Class）：类c ∈ C是创建用户定义对象的模板，包含操作类实例的方法定义[8]，例如A、B。我们通过members(c)来描述其成员关系，忽略基类的成员，例如members(B) &#x3D; {“h” → h, “i” → i}。我们以三个属性来建模继承关系：</p>
<ul>
<li>基类（Base Class）：c显式继承的类集合，例如bases(B) &#x3D; {list, A}。</li>
<li>抽象基类（Abstract Base Class）：c可被识别为的广泛使用的内置ABC（Abstract Base Classes）集合，例如abcs(B) &#x3D; {Iterable, Sequence}，因为list支持这些ABC。</li>
<li>方法解析顺序（Method Resolution Order）：用于查找方法的有序类元组[8]，间接影响API，例如mro(B) &#x3D; (B, list, A, object)。</li>
</ul>
<p>3）函数（Function）：函数f ∈ F是包接口的主要部分，例如f、g、h、i。我们关注函数的签名，包括参数和返回类型，例如paramaters(f) &#x3D; {a, b}，return(i) &#x3D; str。我们考虑三个作用域，即函数绑定的位置，例如scope(f) &#x3D; scope(i) &#x3D; Static，scope(g) &#x3D; Class，scope(h) &#x3D; Instance。特别地，我们将在类内部定义的函数（即方法）的第一个参数self视为实例作用域，例如h。这遵循广泛采用的约定[8]。</p>
<p>参数是函数定义中指定的函数可以接受的参数的命名实体[8]，例如参数a、b、self、c、ar、kw。对于参数p，我们关注其名称、位置、可选性、文字默认值、类型以及尤其是传递方式，例如name(a) &#x3D; “a”，position(b) &#x3D; 2，optional(c) &#x3D; True，default(c) &#x3D; None，kind(a) &#x3D; Positional，kind(kw) &#x3D; VarKeyword。参数c的类型有些复杂，所以我们在第III-A5节中对其进行解释。我们发现许多开发者在函数体内使用指定的关键字访问VarKeyword参数，例如函数i的参数v，因此我们引入了一个新的参数类型VarKeywordCandidate，表示从VarKeyword访问的关键字。</p>
<p>4）属性（Attribute）：属性a ∈ A是与对象关联的值，并通过使用点表达式引用其名称[8]，例如x、y。我们关注属性的类型和作用域，例如type(x) &#x3D; int，scope(x) &#x3D; Class，scope(y) &#x3D; Instance，因为y是在类A的构造函数中定义的，所以只能由A的实例访问，而不是A本身。</p>
<p>5）类型（Type）：在上述模型中，我们考虑参数和属性的类型。类型注解[8]有助于处理动态类型，但它们依赖于上下文，不能在版本之间使用，例如h的注解是一个包含从上下文中引用opt的字符串，尽管字符串不同，但它们具有相同的含义，即Union[A, None]。因此，我们设计了一个简单的、可移植的类型模型，涵盖主要的Python类型，并用于检查描述在第IV-C3节中的类型变化兼容性。在我们的类型模型中，类型T是该类型对象的集合。有以下三种基本类型：</p>
<ul>
<li>字面量（Literal）：特定的字符串、布尔值、数值字面量，例如“abc”。</li>
<li>类型（Class）：非具体值的类类型，例如int、A。</li>
<li>特殊类型（Special）：none、any和unknown（未覆盖的类型）。</li>
</ul>
<p>还有四种复合类型，它们以特定的语义结构组合其他类型。例如，参数c的注解是opt[‘abc’]，其中opt引用Optional。它表示c接受字符串字面值“abc”或None，因此我们用一个和类型（sum type）来建模，type(c) &#x3D; “abc” + none。然后我们可以判断它在结构上与Union[None, ‘abc’]相同。</p>
<ul>
<li>和类型（Sum）：T1+T2+···+Tn，表示至少属于T1、…、Tn之一的对象。</li>
<li>乘积类型（Product）：T1 × T2 ×···× Tn，表示由n个有序对象组成的复合对象，第i个对象类型为Ti。</li>
<li>可调用类型（Callable）：Targs → Tret，表示接受Targs并返回Tret的可调用对象，例如strlen()的类型为str → int。</li>
<li>泛型类型（Generic）：Tbase(T1, T2,…,Tn)，表示泛型类型实例，具有基本类型Tbase和类型参数T1、…、Tn，用于数组和集合类型，例如list(float)、dict(str, int)。</li>
</ul>
<p>6）别名（Alias）：为了建模Python中复杂的API引用，我们使用e的定义的限定名称作为e的标识符，例如id(f) &#x3D; “D.f”和id(g) &#x3D; “D.A.g”，并将除了定义之外指向e的所有引用视为e的别名，记为aliases(e)。例如，类A中名为“t”的成员引用了模块D中的函数f，因此“D.A.t”是f的别名。</p>
<h4 id="B-Change-Classifification"><a href="#B-Change-Classifification" class="headerlink" title="B. Change Classifification"></a><em>B. Change Classifification</em></h4><p>根据我们提出的API模型，我们将变化分为17个粗粒度的模式，基于直接发生在六个API类别上的三种形式的变化（添加、删除和修改）。然后，我们将这些变化模式细分为42个细粒度的模式，以进行更详细的分类。对于类，我们通过其原因（基类、ABC和MRO变化）对继承关系变化进行划分。对于函数和属性，我们通过作用域对它们的添加和删除进行划分，以区分实例成员。对于参数，我们根据其类型和可选性对其添加和删除进行划分，并通过其原因对修改进行划分。对于别名变化，我们通过API位置区分外部引用。需要注意的是，这些API变化与代码变化是不同的，因为一次代码变化可能导致多个API变化，例如，第一个位置的参数添加导致Add&amp;MoveParameter变化。</p>
<p>总结一下，上述文本描述了根据API模型对变化进行的分类。通过将变化模式细分为粗粒度和细粒度模式，我们能够更详细地描述API的变化，并考虑各种不同的变化原因和上下文。</p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628164816406.png" alt="image-20230628164816406"></p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628164825172.png" alt="image-20230628164825172"></p>
<h4 id="C-Breaking-Grading"><a href="#C-Breaking-Grading" class="headerlink" title="C. Breaking Grading"></a><em>C. Breaking Grading</em></h4><p>根据对代码库和问题的观察，我们为每个变化设置了一种启发式的破坏级别（包括兼容、低、中和高），用于指示变化的严重程度，即受影响情况的范围。由于Python API的约束较弱且缺乏编译类型检查，开发人员在限制客户端使用方面存在困难。多个破坏级别帮助开发人员在获得全面结果的同时专注于重要变化，以提高实用性并保持全面性。</p>
<p>1）兼容：对旧程序没有破坏性影响的变化被视为兼容，例如添加类和添加别名。</p>
<p>2）低级：我们将对虚假私有API或外部API的别名的所有破坏性变化评为低级，以减少干扰。尽管客户端可以直接使用这些API，但通常情况下并不会这样做，并且软件包开发人员可能不提供对这些API的兼容性保证。关于确定私有API的详细信息我们在第IV-C1节中进行了说明。</p>
<p>3）中级：我们将间接破坏公共API的变化评为中级，因为破坏情况是有条件的且罕见的。例如，在类&#x2F;实例方法上的参数变化可能会导致覆盖时的不一致性。由于Python的覆盖设计，在子类覆盖该方法时，新方法会复制原始方法的签名并替换原始方法。当原始方法发生签名变化时，子类中的签名与基类不同，这就破坏了覆盖的约定。</p>
<p>类型不兼容性变化是中级破坏性变化的另一个重要模式。由于鸭子类型（duck-typing）的特性，这些变化引发的错误仅在参数或属性在函数逻辑中被访问或显式类型检查时发生，而不是在函数调用时发生。关于类型兼容性的详细信息我们在第IV-C3节中进行了说明。</p>
<p>4）高级：我们将直接破坏公共API可用性的变化评为高级。例如，删除模块和添加必需参数是高级破坏性变化，因为访问模块或调用函数的程序将崩溃，无法找到模块或缺少必需参数。</p>
<p>以上是对文本的概括，描述了根据变化的严重程度将其分类为兼容、低、中和高级别。这有助于开发人员专注于重要变化，同时考虑到实际情况并保持全面性。</p>
<h3 id="BREAKING-CHANGE-DETECTION"><a href="#BREAKING-CHANGE-DETECTION" class="headerlink" title=" BREAKING CHANGE DETECTION"></a><font color="red"> BREAKING CHANGE DETECTION</font></h3><p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628165816242.png" alt="image-20230628165816242"></p>
<h4 id="A-API-Extracting"><a href="#A-API-Extracting" class="headerlink" title="A. API Extracting"></a><em>A. API Extracting</em></h4><p>1）动态反射分析：Python的标准库提供了反射工具来访问运行时对象的元数据。Python默认通过对应的目录结构来查找模块[26]。模块<code>importlib</code>和<code>pkgutil</code>支持标准的导入机制，而<code>inspect</code>模块提供了几个有用的函数来检查实时对象[29]。AexPy会发现包中的所有模块，并尝试导入它们以收集API。首先，AexPy使用Python官方的包管理器pip[23]将包安装到与匹配的Python解释器版本相对应的可用环境中。然后，通过从包的顶层模块开始进行自上而下、广度优先的搜索，AexPy发现所有可访问的API，处理异常以提高鲁棒性，并通过API对象的内置位置属性[26]生成标识符。最后，AexPy通过inspect模块收集每个检测到的API对象的元数据，然后以我们模型的形式生成API的集合。</p>
<p>动态提取方法可以准确地发现API的定义和引用。动态导入和运行时反射可以处理来自装饰器的对象赋值和API修改。AexPy遵循Python的标准方法来访问包，模拟客户端的使用方式，因此AexPy可以发现客户端实际可以访问的内容。对于API的引用，由于在运行时，不同名称引用的同一个API是相同的对象，AexPy通过反射获取每个别名的实际目标对象，通过它们的唯一定义位置进行标识，从而建立准确的API引用关系。</p>
<p>2）静态程序分析：反射提供了关于可访问API的基本信息，但对于函数逻辑（例如实例属性和在函数体中定义的候选关键字参数）了解甚少。反射可以读取类型注解，但无法识别不同注解中相同的类型。因此，我们通过它们的定义位置将动态提取的API映射到源代码，并引入静态分析来丰富属性、参数和类型。</p>
<p>获取类型的方法有多种，AexPy依赖于一种常用的Python静态类型检查器Mypy[16]，因为Mypy具有包括泛型、可调用类型等在内的类型系统，并支持双向类型推断，部分处理了缺乏类型注解的情况。</p>
<h4 id="B-API-Difference"><a href="#B-API-Difference" class="headerlink" title="B. API Difference"></a><em>B. API Difference</em></h4><p>我们设计了一个差异算法来检测42种API变化模式。AexPy首先将两个版本之间对应的API进行配对，然后根据每个变化模式所定义的约束条件检查API配对。</p>
<ol>
<li>API配对：API配对包括API入口配对和函数参数配对两个部分。对于旧版本的API e，API入口配对找到新版本中的API e，使得e可以通过id(e)或者aliases(e)之一访问到。具体而言，AexPy首先找到具有相同标识符和类别（例如模块、类）的e。如果找不到这样的e，则AexPy通过在新版本中进行一系列成员访问来解析id(e)来定位别名API。特别对于在类c中定义的方法，AexPy通过mro(c)查找具有相同名称的第一个现有方法，以处理继承关系。这种配对算法模拟了运行时的实际名称解析，以处理多个别名。如果仍然找不到这样的API（e &#x3D; ⊥），则AexPy认为e在新版本中被删除。AexPy将⊥配对到新版本中未配对的API上。对于已配对的函数，参数配对进一步找到在两个版本中接受相同参数的参数，以处理灵活的参数传递。具体而言，AexPy区分传递的种类，并单独对位置参数、关键字参数和可变参数进行配对。</li>
<li>基于约束的检测：为了实现自动检测，我们将每个变化模式与一个逻辑表达式关联起来作为其约束条件，以检查API对(e, e)或参数对(p, p)是否满足变化模式的条件。包括检查配对是否包含⊥以检测添加和删除，并比较非⊥配对的属性以检测修改。表III显示了一些典型的检查约束。以下以一些变化模式为例说明我们如何设计约束条件。</li>
</ol>
<p>RemoveFunction 前两个子句（e ∈ F ∧ e &#x3D; ⊥）表示函数e被删除，因为新版本中没有配对的入口，最后一个子句（scope(e) &#x3D; Static）强制函数没有绑定到任何对象，从而区分该模式与RemoveMethod。</p>
<p>RemoveBaseClass 第一个子句（e, e ∈ C）强制该类在两个版本中都存在，第二个子句（bases(e) ⊆ bases(e)）表示新版本中有一些基类被删除。</p>
<p>MoveParameter 前两个子句（p &#x3D; ⊥ ∧ p &#x3D; ⊥）强制参数p在两个版本中存在，最后一个子句（position(p) &#x3D; position(p)）表示p在两个版本中</p>
<h4 id="C-Backward-Compatibility-Evaluation"><a href="#C-Backward-Compatibility-Evaluation" class="headerlink" title="C. Backward Compatibility Evaluation"></a><em>C. Backward Compatibility Evaluation</em></h4><p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628185803520.png" alt="image-20230628185803520"></p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我们基于以下研究问题评估了AexPy的效果： </p>
<ul>
<li>RQ1（召回率）AexPy是否比现有方法检测到更多已知的破坏性变化？ </li>
<li>RQ2（实用性）AexPy能否发现潜在的未知破坏性变化？ </li>
<li>RQ3（效率）AexPy的时间性能如何？</li>
</ul>
<p>我们将AexPy与pidiff [9]和PyCompat [4]在召回率和效率方面进行了比较。我们对pidiff进行包装，并解析其输出以进行手动检查。我们重新实现了PyCompat，并根据其开源存储库[31]调整了其API提取方法，以分析除了它设计用于的六个框架包之外的其他包。pidiff和PyCompat都需要包元数据，因此我们使用AexPy的预处理结果作为它们的输入。我们在Ubuntu 18.04主机上的限制为50GB和一小时的容器中运行这三个工具，主机配备了12个3.8GHz的CPU和64GB的RAM。</p>
<h4 id="A-Detecting-Known-Breaking-Changes"><a href="#A-Detecting-Known-Breaking-Changes" class="headerlink" title="A. Detecting Known Breaking Changes"></a><em>A. Detecting Known Breaking Changes</em></h4><p>在检测已知的破坏性变化方面，我们收集了在2021年1月至2022年5月期间从GitHub上通过关键词搜索解决的API向后兼容性问题报告和拉取请求。所选的关键词包括：1）一般关键词，如“breaking change”（破坏性变化）、“backward compatibility”（向后兼容性），以及2）与破坏性变化导致的错误&#x2F;异常有关的关键词，例如“TypeError”（类型错误）、“ModuleNotFoundError”（模块未找到错误）、“AttributeError”（属性错误），这些关键词指示异常类型，以及异常消息中的“missing parameter”（缺少参数）、“unexpected keyword parameter”（意外的关键字参数）。从搜索结果中，我们阅读破坏性版本的源代码，以确保它是实际的API破坏性变化，并确定具体的变化是什么。我们还在最新的两个主要版本的变更日志中搜索记录的API破坏性变化。最后，我们收集了来自45个开源包（涵盖不同领域，如网络、实用工具、人工智能等）中的61个不同类别的API破坏性变化。</p>
<p>对于每个已知的破坏性变化，我们在相应的版本对上执行了三个工具。AexPy在5个变化上崩溃，而pidiff在31个变化上崩溃，PyCompat在13个变化上崩溃，主要是由于安装和导入过程中的异常。我们手动阅读结果，检查这些工具是否检测到了这些变化。表格IV显示了每个工具在每个类别中检测到的破坏性变化数量。</p>
<p>AexPy在所有类别中检测到了最多的已知破坏性变化，并且涵盖了其他工具检测到的所有已知变化。AexPy检测到了86.9%（53&#x2F;61）的变化（包括2个低级别的变化），相较于pidiff和PyCompat增加了近50%。特别是，AexPy检测到了66.7%（4&#x2F;6）的类型变化，而其他现有工具没有检测到。对于没有任何工具崩溃的已知变化，AexPy比pidiff多发现了6个变化，比PyCompat多发现了23个变化。高召回率表明我们的方法可以检测到更多的破坏性变化。</p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628202837076.png" alt="image-20230628202837076"></p>
<h4 id="B-Finding-Unknown-Breaking-Changes"><a href="#B-Finding-Unknown-Breaking-Changes" class="headerlink" title="B. Finding Unknown Breaking Changes"></a><em>B. Finding Unknown Breaking Changes</em></h4><p>我们对前面评估中使用的相同的45个选定的开源包的最新版本（与它们的先前版本）上的AexPy进行了评估。</p>
<p>除了兼容性和低级别的变化之外，AexPy在这些版本对上检测到了433个变化（312个高级别，121个中级别）。其中，经过手动检查，405个变化（294个高级别，111个中级别）被确认为真实，准确率为93.5%。我们阅读了这些版本的变更日志（如果存在），标记了291个已记录的变化。其余的114个破坏性变化未被记录，我们向相关包的开发者报告了其中的63个变化。AexPy在bentoml 0.13.1和clyngor 0.4.2上崩溃。表格V展示了其他43个包的结果，包括检测到的高级别&#x2F;中级别变化的数量和对报告的问题的确认情况。</p>
<p>AexPy在大多数包上找到了有意义的结果。在14个包中，AexPy没有发现破坏性变化，其中13个版本是补丁更新，另一个版本[36]也保持了其API语法。在其他包中，大多数检测到的破坏性变化在变更日志中有记录，尽管大多数变更日志都是高层次的，只简要说明了API的变化，而AexPy提供了详细的信息。</p>
<p>AexPy检测到了开发者确认的未记录的破坏性变化，这表明我们的方法在实际情况下检查向后兼容性是有用的。我们根据它们的包将这63个高级别&#x2F;中级别的破坏性变化分为10个问题，并向开发者报告了这些问题。到目前为止，我们收到了8个涉及50个变化的开发者回复，其中31个变化得到了确认。包的开发者们同意其余的19个变化是真实的，但是他们忽略了它们，因为相关的API（虽然没有被识别为“私有”）实际上是没有兼容性保证的实现细节，这是根据开发者的设计。例如，来自tornado [37]的开发者回复道：“对于这些变化给您带来的困扰，我感到抱歉，但是这些都是未记录的实现细节，没有兼容性的保证。”</p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628203150855.png" alt="image-20230628203150855"></p>
<h4 id="C-Time-Performance"><a href="#C-Time-Performance" class="headerlink" title="C. Time Performance"></a><em>C. Time Performance</em></h4><p>为了评估效率，我们在相同的环境下对选定的45个软件包中的每一对相邻版本运行这三个工具。</p>
<p>pycompat是半自动的，如何评估其他45个包呢？</p>
<p><img src="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/image-20230628203122644.png" alt="image-20230628203122644"></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:<ul>
<li>本文使用了一个已知破坏性变更数据集进行实验评估，共包含45个软件包的最新版本。</li>
<li>实验中使用了原型实现AexPy进行破坏性变更检测。</li>
</ul>
</li>
<li>b. 详细的实验结果:<ul>
<li>AexPy在已知破坏性变更数据集上的召回率达到了86.9%。</li>
<li>在45个软件包的最新版本中，AexPy检测到了405个高和中等破坏性变更，准确率为93.5%。</li>
<li>AexPy还发现了114个未记录的破坏性变更，其中63个已报告给活跃的软件包开发者，31个已得到确认。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/">http://example.com/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/07/Automated-Deprecated-API-Usage-Update-for-Android-Apps-How-Far-Are-We/" title="Automated Deprecated-API Usage Update for Android Apps How Far Are We"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Automated Deprecated-API Usage Update for Android Apps How Far Are We</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/20/Characterization-and-Automatic-Update-ofDeprecated-Machine-Learning-API-Usages/" title="Characterization and Automatic Update ofDeprecated Machine-Learning API Usages"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Characterization and Automatic Update ofDeprecated Machine-Learning API Usages</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#AexPy-Detecting-API-Breaking-Changes-in-Python-Packages"><span class="toc-number">1.</span> <span class="toc-text">AexPy: Detecting API Breaking Changes in Python Packages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-number">1.3.</span> <span class="toc-text">Introduction:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.4.</span> <span class="toc-text">背景:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-Backward-Compatibility"><span class="toc-number">1.4.1.</span> <span class="toc-text">API Backward Compatibility</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Breaking-Changes-in-Python-Packages"><span class="toc-number">1.4.2.</span> <span class="toc-text">B. Breaking Changes in Python Packages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Limitations-of-Existing-Approaches"><span class="toc-number">1.4.3.</span> <span class="toc-text">C. Limitations of Existing Approaches</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BACKWARD-COMPATIBILITY-MODELING"><span class="toc-number">1.6.</span> <span class="toc-text"> BACKWARD COMPATIBILITY MODELING</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Python-API-Model"><span class="toc-number">1.6.1.</span> <span class="toc-text">A. Python API Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Change-Classifification"><span class="toc-number">1.6.2.</span> <span class="toc-text">B. Change Classifification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Breaking-Grading"><span class="toc-number">1.6.3.</span> <span class="toc-text">C. Breaking Grading</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BREAKING-CHANGE-DETECTION"><span class="toc-number">1.7.</span> <span class="toc-text"> BREAKING CHANGE DETECTION</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-API-Extracting"><span class="toc-number">1.7.1.</span> <span class="toc-text">A. API Extracting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-API-Difference"><span class="toc-number">1.7.2.</span> <span class="toc-text">B. API Difference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Backward-Compatibility-Evaluation"><span class="toc-number">1.7.3.</span> <span class="toc-text">C. Backward Compatibility Evaluation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0"><span class="toc-number">1.8.</span> <span class="toc-text">评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Detecting-Known-Breaking-Changes"><span class="toc-number">1.8.1.</span> <span class="toc-text">A. Detecting Known Breaking Changes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Finding-Unknown-Breaking-Changes"><span class="toc-number">1.8.2.</span> <span class="toc-text">B. Finding Unknown Breaking Changes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Time-Performance"><span class="toc-number">1.8.3.</span> <span class="toc-text">C. Time Performance</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.9.</span> <span class="toc-text">结果:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/27/LearnedSQLGen-Constraint-aware-SQL-Generation-using-Reinforcement-Learning/" title="LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning">LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning</a><time datetime="2023-09-27T07:05:56.000Z" title="发表于 2023-09-27 15:05:56">2023-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/18/Griffin-Grammar-Free-DBMS-Fuzzing/" title="Griffin Grammar-Free DBMS Fuzzing">Griffin Grammar-Free DBMS Fuzzing</a><time datetime="2023-08-18T07:28:26.000Z" title="发表于 2023-08-18 15:28:26">2023-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/24/sql%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/" title="sql的编译与执行">sql的编译与执行</a><time datetime="2023-07-24T03:19:59.000Z" title="发表于 2023-07-24 11:19:59">2023-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/23/Finding-Bugs-in-Database-Systems-via-Query-Partitioning/" title="Finding Bugs in Database Systems via Query Partitioning">Finding Bugs in Database Systems via Query Partitioning</a><time datetime="2023-07-23T03:07:25.000Z" title="发表于 2023-07-23 11:07:25">2023-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/22/go-randgen%E4%BD%BF%E7%94%A8/" title="go-randgen使用">go-randgen使用</a><time datetime="2023-07-22T03:08:23.000Z" title="发表于 2023-07-22 11:08:23">2023-07-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>