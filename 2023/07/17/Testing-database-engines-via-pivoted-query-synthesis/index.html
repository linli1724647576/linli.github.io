<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Testing database engines via pivoted query synthesis | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Testing Database Engines via Pivoted Query SynthesisBasic Information: Title: Testing Database Engines via Pivoted Query Synthesis (通过旋转查询合成测试数据库引擎) Authors: Manuel Rigger and Zhendong Su (Manuel Rigg">
<meta property="og:type" content="article">
<meta property="og:title" content="Testing database engines via pivoted query synthesis">
<meta property="og:url" content="http://example.com/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Testing Database Engines via Pivoted Query SynthesisBasic Information: Title: Testing Database Engines via Pivoted Query Synthesis (通过旋转查询合成测试数据库引擎) Authors: Manuel Rigger and Zhendong Su (Manuel Rigg">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-17T02:42:50.000Z">
<meta property="article:modified_time" content="2023-07-18T02:24:35.245Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Testing database engines via pivoted query synthesis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-18 10:24:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Testing database engines via pivoted query synthesis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-17T02:42:50.000Z" title="发表于 2023-07-17 10:42:50">2023-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-18T02:24:35.245Z" title="更新于 2023-07-18 10:24:35">2023-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Testing database engines via pivoted query synthesis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Testing-Database-Engines-via-Pivoted-Query-Synthesis"><a href="#Testing-Database-Engines-via-Pivoted-Query-Synthesis" class="headerlink" title="Testing Database Engines via Pivoted Query Synthesis"></a>Testing Database Engines via Pivoted Query Synthesis</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Testing Database Engines via Pivoted Query Synthesis (通过旋转查询合成测试数据库引擎)</li>
<li>Authors: Manuel Rigger and Zhendong Su (Manuel Rigger和Zhendong Su)</li>
<li>Affiliation: Department of Computer Science, ETH Zurich (苏黎世联邦理工学院计算机科学系)</li>
<li>Keywords: Database Management Systems, Logic Bugs, Pivoted Query Synthesis (数据库管理系统，逻辑错误，旋转查询合成)</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://www.usenix.org/conference/osdi20/presentation/rigger">Paper</a>, <a target="_blank" rel="noopener" href="https://github.com/sqlancer/">GitHub Code</a> (GitHub: None)</li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>通过旋转查询合成的方法，作者提出了一种新颖且通用的方法来测试数据库管理系统（DBMS），并成功地发现了121个独特的错误，其中96个已经被修复或验证，证明了该方法的高效性和通用性。</li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息:"></a>背景信息:</h3><ul>
<li>论文背景: 数据库管理系统（DBMS）是广泛使用的，已经通过模糊测试工具进行了广泛测试，但是对于逻辑错误的检测方法仍然有待解决。</li>
<li>过去方案: 过去的方法主要是使用差异测试来检测逻辑错误，但是由于不同DBMS之间的差异性，这种方法存在一定的限制。</li>
<li>论文的Motivation: 为了有效地检测DBMS中的逻辑错误，作者提出了一种名为Pivoted Query Synthesis的方法，通过合成查询来解决测试神谕问题，并在三个常用的DBMS上进行了测试，发现了大量的逻辑错误。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文介绍了数据库管理系统（DBMS）中逻辑错误的问题以及现有测试方法在检测这些错误方面的局限性。</li>
<li>作者提出了一种名为Pivoted Query Synthesis（PQS）的新方法，用于检测DBMS中的逻辑错误。</li>
<li>PQS的核心思想是自动生成查询，以获取一个特定的、随机选择的行，称为枢轴行。如果DBMS无法获取枢轴行，则表示系统存在错误。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>PQS的技术路线如下：<ol>
<li>从数据库中的一组表和视图中随机选择一行作为枢轴行。</li>
<li>随机生成布尔谓词，并修改为对枢轴行的值求值为TRUE。</li>
<li>将这些表达式用于随机生成的查询的WHERE和JOIN子句中，以确保枢轴行包含在结果集中。</li>
<li>如果枢轴行不在结果集中，则检测到错误。</li>
</ol>
</li>
<li>PQS基于一个抽象语法树（AST）解释器，提供了一个准确的oracle。</li>
<li>解释器的实现对于复杂的操作符需要适度的努力，但可以忽略DBMS面临的其他挑战，如查询计划和并发访问。</li>
<li>AST解释器在单个记录上操作，因此性能良好。</li>
</ul>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:<ul>
<li>作者在三个广泛使用的DBMS（SQLite、MySQL和PostgreSQL）上测试了他们的方法。</li>
<li>作者发现了121个独特的错误，其中96个已经修复或验证。</li>
</ul>
</li>
<li>b. 详细的实验结果:<ul>
<li>作者相信他们的方法的简单性和广泛适用性可以提高许多DBMS的鲁棒性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>这篇论文的主题是针对数据库管理系统（DBMS）的测试，特别是在找出逻辑错误方面的研究。虽然fuzzing（模糊测试）已经广泛用于找出引起崩溃的bug，但在找出逻辑错误方面，比如DBMS计算错误的结果集时，解决方法仍然很少。为了解决这个问题，作者提出了一个新的，通用的方法，叫做Pivoted Query Synthesis（基于主轴的查询合成）。</p>
<p>这个方法的核心思想是自动生成查询，确保这些查询能够获取特定的、随机选择的行，称为主轴行。如果DBMS未能获取主轴行，那么可能的原因就是DBMS中的bug。</p>
<p>作者在三个广泛使用且成熟的DBMS（SQLite，MySQL和PostgreSQL）上测试了这种方法。总共，他们发现了在这些DBMS中的121个独特的bug，其中96个已经被修复或验证。这证明了这种方法的高效性和通用性。作者期望这种方法的广泛应用性和简单性将有助于提高许多DBMS的稳健性。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h3><p><strong>背景：</strong></p>
<p>数据库管理系统（DBMS）是许多应用程序中的核心组件，因为它们可以有效地存储和检索数据。现有的测试工具（例如SQLsmith）和模糊测试工具（如AFL）可以找到导致DBMS崩溃的查询，但无法检测逻辑错误，也就是导致查询返回错误结果的错误。</p>
<p><strong>相关工作：</strong></p>
<p>在自动检测DBMS的逻辑错误方面存在一个关键挑战，那就是构建一个有效的测试oracle，可以检测给定输入的系统是否表现正确。1998年，Slutz提出使用差异测试来检测DBMS中的逻辑错误，通过比较在多个DBMS上查询的结果。然而，这种方法的主要局限性是，被测试的系统需要为给定的输入实现相同的语义。</p>
<p>虽然所有的DBMS都支持通用和标准化的语言SQL来创建、访问和修改数据，但实际上，每个DBMS都提供了许多对这个标准的扩展，并在其他部分（例如如何处理NULL值）偏离了这个标准。这大大限制了差异测试的应用，甚至在所有的DBMS获取相同的行时，也不能确保它们工作正确，因为它们可能受到相同的底层bug的影响。</p>
<p><strong>解决方式及贡献：</strong></p>
<p>为了有效地检测DBMS中的逻辑错误，作者提出了一种称为Pivoted Query Synthesis（PQS）的通用和原则性的方法，并在一个名为SQLancer的工具中实现了这种方法。这个方法的核心思想是通过合成一个查询，其结果集必须包含一个单一的、随机选择的行（称为主轴行）来解决oracle问题。如果DBMS处理的查询没有获取到主轴行，就检测到了DBMS中的bug。</p>
<p>作者在三个广泛使用的<strong>DBMS（SQLite，MySQL，PostgreSQL）</strong>上实现并测试了这种方法，总共发现了96个独特的bug，其中61个是通过容纳oracle找到的逻辑错误。此外，他们还通过引起DBMS内部错误找到了32个bug，通过引起DBMS崩溃找到了3个bug。</p>
<p>因此，该研究的主要贡献是：</p>
<ol>
<li>提出了一种称为Pivoted Query Synthesis（PQS）的通用且高效的方法，用于发现DBMS中的bug。</li>
<li>在一个名为SQLancer的工具中实现了PQS，用于测试SQLite，MySQL，和PostgreSQL。</li>
<li>对PQS进行了评估，发现了96个bug。</li>
</ol>
<h3 id="Motivation-Example"><a href="#Motivation-Example" class="headerlink" title="Motivation Example:"></a>Motivation Example:</h3><p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230714090255269.png" alt="image-20230714090255269"></p>
<p>首先，创建一个新表t0，并有一个列c0。</p>
<p>接下来，创建一个索引并插入三行值为0，1，和 NULL 的行。</p>
<p>选定 pivot row 为 c0&#x3D;NULL，然后构建一个随机的 WHERE 子句 “c0 IS NOT 1”。查询的结果应该是{0，NULL}，结果查出来的结果是{0}，导致pivot row并没有被获取。</p>
<h3 id="Background："><a href="#Background：" class="headerlink" title="Background："></a><strong>Background：</strong></h3><ul>
<li><strong>数据库管理系统</strong>：本研究主要目标是测试基于 Codd 提出的关系数据模型的关系数据库管理系统。最常用的DBMS，如 Oracle，Microsoft SQL，PostgreSQL，MySQL 和 SQLite 都是基于这种模型。在这个模型中，一个关系 R 是一个数学关系 R ⊆ S1 ×S2 ×…×Sn，其中 S1，S2，…，Sn 被称为域。在实际中，关系通常被称为表，域被称为数据类型。此关系中的每个元组被称为行。SQL，一个基于关系代数的领域特定语言，是与 DBMS 交互的最常用语言。</li>
<li><strong>测试 Oracle</strong>：有效的测试 oracle 对于自动测试方法至关重要。<ul>
<li>测试样例[21]：测试 oracle 评估给定的测试用例是否通过。手动编写的测试用例编码了程序员的知识，因此程序员作为测试 oracle。缺点：手写test cases。</li>
<li>差异测试[46]：针对 DBMS 的最成功的自动测试 oracle 是基于差异测试的。（基本思路是在数据库管理系统（DBMS）的上下文中，输入可以是数据库以及查询，而系统可以是多个 DBMS。如果他们获取的结果集不匹配，就可能检测到其中一个 DBMS 的 bug。） 然而，由于 SQL 方言的显著差异，使得差异测试难以有效使用。此外，差异测试并不是一个精确的 oracle，因为它无法检测影响所有系统的 bug。</li>
</ul>
</li>
<li><strong>测试的 DBMS</strong>：我们主要关注三个流行且广泛使用的开源 DBMS：SQLite，MySQL，和 PostgreSQL。这些 DBMS 是最受欢迎且广泛使用的系统。</li>
</ul>
<h3 id="Pivoted-Query-Synthesis"><a href="#Pivoted-Query-Synthesis" class="headerlink" title="Pivoted Query Synthesis"></a><strong>Pivoted Query Synthesis</strong></h3><p>Pivoted Query Synthesis（PQS）是一种自动化测试技术，用于检测数据库管理系统（DBMS）中的逻辑错误。其核心理念是，通过一次只考虑单行数据，可以创建一个概念上简单但能有效检测逻辑错误的测试oracle。</p>
<p>具体来说，PQS的步骤如下：</p>
<ol>
<li>从数据库中的一组表和视图中随机选择一行数据，这被称为“支点行”(pivot row)。</li>
<li>然后，随机生成一组布尔谓词，然后修改这些谓词，使它们对支点行的值进行评估结果为TRUE。这一过程基于抽象语法树（AST）解释器进行。</li>
<li>通过在其他随机生成的查询的WHERE和JOIN子句中使用这些表达式，我们可以确保结果集必须包含支点行。如果结果集中未包含支点行，那么就发现了一个错误。</li>
</ol>
<p>虽然为复杂操作符（如正则表达式操作符）实现这种解释器需要一定的实现工作，但是DBMS需要解决的其他挑战，如查询计划、并发访问、完整性和持久性，可以被该解释器忽略。此外，AST解释器可以被朴素地实现而不影响工具的性能，因为它只操作单个记录，而DBMS在处理查询时可能需要扫描数据库的所有行。</p>
<h4 id="3-1-Approach-Overview"><a href="#3-1-Approach-Overview" class="headerlink" title="3.1 Approach Overview"></a><strong>3.1 Approach Overview</strong></h4><p>Pivoted Query Synthesis (PQS) 的详细步骤在图1中进行了说明。下面是一个对其过程的概括：</p>
<ol>
<li>首先，创建一个包含一个或多个随机表的数据库，并用随机数据填充（步骤1）。确保每个表和随机生成的视图至少有一行数据，以便在步骤2中选择一个随机的支点行。支点行在概念上只是一行，它可以由引用多个表和&#x2F;或视图的行的列组成。它图1中显示的支点行由表t0和t1的列组成。</li>
<li>在接下来的步骤中，我们根据支点行构造一个测试oracle（步骤3到步骤7）。为此，我们根据DBMS的SQL语法和有效的表列名随机创建表达式（步骤3）。然后，评估这些表达式，用支点行的对应值替代列引用。接着，我们修改表达式使得它们的值为TRUE（步骤4）。这些表达式会被用在我们构造的查询的WHERE和&#x2F;或JOIN子句中（步骤5）。将此查询传递给DBMS后，DBMS返回一个结果集（步骤6），我们期望这个结果集包含支点行，可能还包含其他行。最后，我们检查结果集是否确实包含支点行（步骤7）。如果它没有包含，那么我们可能已经检测到DBMS中的一个错误。</li>
<li>在下一次迭代中，我们要么继续步骤2并为新选择的支点行生成新的查询，要么继续步骤1以生成新的数据库。</li>
</ol>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230715151529199.png" alt="image-20230715151529199"></p>
<h4 id="3-2-Query-Generation-amp-Checking"><a href="#3-2-Query-Generation-amp-Checking" class="headerlink" title="3.2 Query Generation &amp; Checking"></a><strong>3.2 Query Generation &amp; Checking</strong></h4><p><strong>Random predicate generation</strong></p>
<p>谓词是一种函数，其结果只有两种可能：真（true）或假（false）。谓词通常用于表示对象的某些特性或属性，或者是表达两个或多个对象之间的关系。</p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230716142414205.png" alt="image-20230716142414205"></p>
<ol>
<li>首先，基于数据库的模式（即列名和类型）构造随机表达式树，这些表达式的深度最大到达指定的深度。</li>
<li>对于SQLite和MySQL，SQLancer生成任意类型的表达式，因为这两种数据库管理系统都支持隐式的布尔值转换。</li>
<li>对于PostgreSQL，由于它的隐式转换很少，所以生成的根节点必须产生布尔值，这可以通过选择适当的操作符（例如比较操作符）来实现。</li>
<li>输入参数深度用来确保在达到指定的最大深度时生成叶节点。叶节点可以是随机生成的常量，也可以是对表或视图中的列的引用。</li>
<li>如果还没有达到最大深度，也会考虑其他操作符（例如一元操作符NOT）。</li>
<li>生成这些表达式依赖于各自的数据库管理系统支持哪些操作符。</li>
</ol>
<blockquote>
<p>假设我们有一个数据库，它包含一个表<code>t1</code>，<code>t1</code>有两列，名为<code>column1</code>（数值型）和<code>column2</code>（字符型）。假设我们要生成一个最大深度为3的表达式。</p>
<p>在深度为1时，SQLancer可以选择生成一个叶节点，比如一个引用列或者一个常量。但是，由于我们的最大深度为3，所以它也可以选择生成一个非叶节点。假设它选择生成了一个二元操作符<code>&gt;</code>。那么，<code>&gt;</code>操作符的两边都需要是数值表达式，因此我们不能再使用<code>column2</code>了。</p>
<p>在深度为2时，对于<code>&gt;</code>操作符的每一边，SQLancer再次有选择生成叶节点或非叶节点的权利。假设它在左边选择了一个叶节点<code>column1</code>，在右边选择了一个非叶节点<code>-</code>（减法）。</p>
<p>在深度为3时，对于减法操作符<code>-</code>，SQLancer必须为每一边生成叶节点，因为我们已经达到了最大深度。假设它选择了常量<code>5</code>和<code>3</code>。</p>
<p>因此，生成的随机谓词表达式为<code>column1 &gt; 5 - 3</code>。这个谓词会被用于<code>WHERE</code>语句中，例如<code>SELECT * FROM t1 WHERE column1 &gt; 5 - 3</code>。</p>
</blockquote>
<p><strong>Expression evaluation.</strong></p>
<p>在这个过程中，我们根据生成的随机表达式树对数据行（在这里是“pivot row”）进行计算，以确定其条件是否对应为 TRUE。</p>
<p>在这个过程中，每一个节点（Node）必须提供一个 execute() 方法来计算节点的结果。这个方法需要手动实现。</p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230716144529507.png" alt="image-20230716144529507"></p>
<p>对于叶节点（Leaf Nodes），它们直接返回分配给它们的常量值。对于列节点（Column Nodes），它们被赋予与在 pivot row 中对应的列相对应的值。例如，在图1的第三步中，叶节点 t0.c1 返回 TRUE，常量节点3返回整数3。</p>
<p>对于复合节点（Composite Nodes），它们根据子节点返回的字面值计算结果。例如，NOT节点返回 FALSE，因为它的子节点计算为 TRUE。节点首先执行它的子表达式，然后将结果转换为布尔值；如果结果是布尔值，那么这个值就会被取反；否则返回 NULL。</p>
<p>这种实现方式比为编程语言设计的AST解释器简单，因为所有节点都在字面值（literal values）上操作，不需要考虑可变存储。这也比基于查询引擎的模型简单，如众所周知的Volcano-style迭代模型以及基于它的广泛使用的模型，比如向量化模型或数据中心的代码生成模型，它们都需要考虑多行数据。</p>
<p>由于我们方法的瓶颈在于DBMS执行查询而不是SQLancer，所有的操作都以一种原始的方式实现，并没有进行任何优化。尽管如此，一些操作仍然需要适度的实现努力；例如，实现LIKE正则表达式操作符在SQLancer中有超过50行的代码。</p>
<blockquote>
<p>在这个例子中，我们将以一个简单的 SQL 表达式 <code>NOT (t0.c1 = 3)</code> 对一个假设的 pivot row 进行评估。</p>
<p>假设 pivot row 是一行数据，其中 <code>t0.c1</code> 的值为 <code>3</code>。在这个例子中，表达式树可以视为三个节点：</p>
<ol>
<li>一个复合节点 <code>NOT</code></li>
<li>一个叶节点 <code>t0.c1</code>，其值为 <code>3</code></li>
<li>一个常量叶节点 <code>3</code></li>
</ol>
<p>首先，我们从最底层的叶节点开始评估。<code>t0.c1</code> 代表的是 pivot row 中的一个列值，这个值是 <code>3</code>。常量节点 <code>3</code> 直接返回其值 <code>3</code>。</p>
<p>接下来，我们看到 <code>=</code> 这个复合节点。它比较了两个子节点的值，都为 <code>3</code>，所以结果为 <code>TRUE</code>。</p>
<p>最后，<code>NOT</code> 这个复合节点对子节点进行求反，所以结果从 <code>TRUE</code> 变为 <code>FALSE</code>。</p>
</blockquote>
<p><strong>Expression rectifification.</strong></p>
<p>是确保生成的随机表达式能够评估为 TRUE 的过程。在 SQL 中，一个表达式在布尔上下文中的结果可以是 TRUE，FALSE，或者 NULL。这三种结果基于三值逻辑。</p>
<p>为了整改一个表达式使其结果为 TRUE，可以利用一些算法。例如，如上文中的 Figure 1 步骤 4 所示，通过在表达式前增加一个 NOT 运算，可以改变原有表达式的结果使其为 TRUE。</p>
<p>值得注意的是，这种方法同样适用于其他的逻辑系统，例如四值逻辑。</p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230716144856719.png" alt="image-20230716144856719"></p>
<p>具体的调整依赖于具体的逻辑系统。另外，如果确保表达式评估为 FALSE，也可以通过检查 pivot row 是否符合预期的不包含在结果集中来验证。</p>
<p><strong>Query generation.</strong></p>
<p>查询生成是生成针对 pivot row 的目标查询的过程。这一步中，最重要的是将评估结果为 TRUE 的表达式用于 WHERE 和 JOIN 子句。WHERE 子句限制了查询获取的行，而 JOIN 子句则用于连接表。由于这些表达式的评估结果为 TRUE，因此 pivot row 一定会包含在结果集中。</p>
<p>对于 pivot row 来说，内连接、全连接、左连接和右连接的行为都与 WHERE 子句一样，因为我们创建了使 pivot row 为 TRUE 的连接谓词。SELECT 语句通常提供多种关键字来控制查询的行为，我们会从中随机选择一些适用的选项。具体来说，我们考虑了以下几个元素：</p>
<ul>
<li>DISTINCT 子句：过滤掉重复的行，同时保证 pivot row 包含在结果集中；</li>
<li>GROUP BY 子句：包含所有 pivot row 的列，以保证 pivot row 包含在结果集中；</li>
<li>ORDER BY 子句：仅影响结果集的顺序，而 PQS 不对此进行验证；</li>
<li>聚合函数：当一个表中只有一行时，计算多行的值，这允许部分测试这些函数；</li>
<li>针对特定 DBMS 的查询选项，例如 MySQL 的 FOR UPDATE 子句，这些选项不能影响结果集。</li>
</ul>
<p>这些额外的元素是我们核心方法的可选扩展，通过压力测试 DBMS 的查询优化器，PQS 能够找到更多的错误。然而，这些元素并不能全面测试这些功能。</p>
<blockquote>
<p>聚合函数  count 、 sum 、 avg 、….</p>
</blockquote>
<p><strong>Checking containment.</strong> </p>
<p>“Checking containment” 这一步是 Pivoted Query Synthesis 方法的最后一步，其目的是确认预定的“枢轴行”(pivot row)是否包含在查询结果中。</p>
<p>在步骤6中，我们使用数据库管理系统（DBMS）来评估查询。然后，我们需要检查枢轴行是否确实出现在这个结果集中。虽然这个检查过程可以在 SQLancer 中实现，但是实际上，开发者构建了查询以便进行这种包含性检查，有效地合并了步骤6和7。</p>
<p>数据库管理系统提供了各种各样的操作符来检查包含关系，例如 <code>IN</code> 和 <code>INTERSECT</code> 操作符。举例来说，为了在步骤7中检查枢轴行（3, TRUE, -5）是否包含在结果集中，我们可以使用 Listing 2 中显示的查询，如果枢轴行被包含在内，这个查询将返回一行结果。</p>
<p><strong>“Checking arbitrary expressions.</strong></p>
<p>“Checking arbitrary expressions” 是 Pivoted Query Synthesis (PQS) 初始概念的一个扩展，它的目标是在步骤5的查询中使用任意表达式来指定要获取的数据，而不仅仅是引用列。</p>
<p>举个例子，而不是仅仅引用 t0.c0，我们可能想检查 t0.c0 + 1 是否能够正确地被评估。为了做到这一点，我们可以将枢轴行的定义扩展到引用任意计算的值。例如，对于 t0.c0 + 1，其枢轴行的值必须是4，这可以基于我们在步骤2中已经解释过的表达式评估机制得到。</p>
<p>在实现层面，这就需要首先生成在步骤5中使用的表达式，这样在步骤2中就可以通过评估这些表达式得到枢轴行的值。</p>
<h4 id="3-3-Random-State-Generation"><a href="#3-3-Random-State-Generation" class="headerlink" title="3.3 Random State Generation"></a><strong>3.3 Random State Generation</strong></h4><p>“随机状态生成”是PQS方法中的第一步。在这一步骤中，系统会生成一个随机的数据库状态。这个过程类似于查询生成，通过启发式和迭代地选择适用的选项进行。</p>
<p>首先，系统使用 CREATE TABLE 语句创建一定数量的表，这是固定的第一步。然后，系统会启发式地选择后续的声明。可选的声明包括 INSERT 语句，它可以插入数据行。通过生成数据定义语言（DDL）和数据操作语言（DML）声明，我们可以探索更大的数据库空间，一些特定的数据库可能会暴露出DBMS的错误。例如，我们为所有数据库实现了 UPDATE、DELETE、ALTER TABLE 和 CREATE INDEX 命令，以及DBMS特定的运行时选项。</p>
<p>我们实现的一些命令是特定于各个DBMS的。MySQL独有的声明包括REPAIR TABLE和CHECK TABLE。PostgreSQL独有的声明有DISCARD和CREATE STATISTICS。因为声明是启发式选择的，所以数据库状态生成步骤可能会生成一个空数据库（例如，因为 DELETE 语句可能删除了所有行，或者表约束可能使得无法插入任何行）；在这种情况下，当前数据库被丢弃，然后创建一个新的数据库。</p>
<p>需要注意的是，随机数据库生成并不是这篇论文的贡献；实际上，已经有很多数据库生成方法被提出，任何一种方法都可以和PQS结合使用。</p>
<h4 id="3-4-Important-Implementation-Details"><a href="#3-4-Important-Implementation-Details" class="headerlink" title="3.4 Important Implementation Details"></a><strong>3.4 Important Implementation Details</strong></h4><p>以下是一些本研究认为对结果产生重大影响的实施决策：</p>
<ol>
<li><p><strong>错误处理</strong>：尽管我们试图生成在语法和语义上都正确的语句，但有时生成语义上正确的语句是不切实际的。我们定义了一些在执行相应语句时可能会遇到的错误信息列表，如果DBMS返回预期的错误，那么就忽略它。非预期的错误表明DBMS存在错误。</p>
</li>
<li><p><strong>性能</strong>：我们优化了SQLancer以利用底层硬件的优势。我们通过在不同的数据库上运行每个线程来并行化系统。为了充分利用每个CPU，我们降低了生成导致CPU利用率低的SQL语句的概率。</p>
</li>
<li><p><strong>行数</strong>：我们通过限制插入行数到较低值（10-30行）找到了大多数错误。过高的行数可能会导致没有限制性连接子句的表连接时查询超时。</p>
</li>
<li><p><strong>数据库状态</strong>：对于许多SQL语句的生成，需要知道数据库模式或其他数据库状态；例如，要插入数据，SQLancer必须确定表的名称及其列。我们从DBMS动态查询这样的状态，而不是自己跟踪或计算，这会需要额外的实现工作。例如，为了查询表的名称，MySQL和PostgreSQL都提供了一个信息表information_schema.tables和SQLite是一个表sqlite_master。</p>
</li>
<li><p>**退出(Bailouts)**：对于一些运算符或函数，边角情况的行为可能难以实现，也可能最初并不重要去测试。在我们的方法中，表达式评估步骤并不需要为每个可能的输入计算结果。例如，考虑一个整数除法操作，如果除数是0，那么结果是未定义的。在这种情况下，如果测试程序遇到除数为零的情况，它可以选择”退出”，也就是放弃这个操作，然后生成一个新的表达式。</p>
</li>
<li><p><strong>值缓存</strong>：当SQLancer随机生成值时，它会将值存储在缓存中，随后以给定的概率重新使用这些值。</p>
<blockquote>
<p>“值缓存”是一种在测试过程中保存并重用生成的值的策略。这种方法有两个主要优势：</p>
<ol>
<li>触发特殊的角落情况：通过重用同样的值，可以增加触发某些特殊情况的可能性。例如，比较相同的两个值（比如3 &gt; 3）可能会暴露出一些错误或者未考虑到的行为。</li>
<li>增加插入成功的可能性：特别是在有外键约束的情况下，使用缓存中的值可以提高成功插入新行的可能性。因为外键约束要求插入的行中的某个值必须是另一个表中已存在的值，从缓存中选择值可以保证这一点。</li>
</ol>
<p>使用值缓存可以增加测试覆盖率，并且更可能找出数据库管理系统的一些潜在错误。</p>
</blockquote>
</li>
<li><p><strong>实施范围</strong>：我们实现的每一个测试实施都是广泛的，但不完全。对于每个DBMS，我们至少实现了整数和字符串数据类型；对于SQLite实施，我们还支持浮点数和二进制数据。我们实现了许多常见的语句、运算符和函数的生成。</p>
</li>
</ol>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><p>Benchmark：对于所有的dbms，我们开始测试最新的发布版本，它是SQLite 3.28、MySQL 8.0.16和PostgreSQL 11.4。</p>
<p>Baselines：没有合适的baseline。</p>
<p>Metrics：测试过程中发现的错误数量、错误的类型（如重复错误）、以及修复错误所花费的时间</p>
<p> <strong>Bug Reports Overview</strong></p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230717100035104.png" alt="image-20230717100035104"></p>
<p>这段话总结了作者们报告的错误数量和分类。</p>
<ul>
<li>作者们总共报告了121个错误，其中96个被认定为真正的错误，因为这些错误导致了代码修复（78个报告）、文档修复（8个报告），或者得到了开发者的确认（10个报告）。这些错误都是以前未知的，并且每一个错误都有与之关联的独特的修复方式，或者已经被开发者确认为独特的错误。</li>
<li>作者们提出了25个错误报告，这些被归类为错误的报告，因为报告中展示的行为被认为是符合预期的（13个报告），或者因为报告的错误被认为是重复的（12个报告）。</li>
<li>只有对于SQLite，数据库管理系统（DBMS）开发者给错误分配了严重性等级。14个错误被分类为临界级，8个错误为严重级，16个为重要级。对于13个错误，作者们在邮件列表中报告了，但在错误跟踪器中没有创建条目。其它的错误报告被分配了低严重性等级，如次要等级。尽管严重性等级并没有一致地设置，但这仍然证明了作者们发现了许多严重的错误。</li>
<li>表3显示了真正错误的分类。大部分错误都是由”containment oracle”找到的，这是预期的，因为作者们的方法主要依赖于这个oracle。也许令人惊讶的是，遇到意外的错误也使得作者们能够检测到大量的错误。对于PostgreSQL，作者们甚至发现了7个意外错误，而只找到了1个逻辑错误。作者们认为，当使用模糊测试（fuzzers）来测试DBMS时，这个观察可以被利用，例如，通过检查特定的错误信息，来指示数据库的损坏。</li>
<li>作者们的方法也检测到了一些崩溃错误，其中一个被认为是MySQL中的一个安全漏洞（CVE-2019-2879）。这些错误不太有趣，因为它们也可以通过传统的模糊测试找到。实际上，针对PostgreSQL的一个重复错误报告，基于SQLsmith的发现，就在作者们发现并报告它后不久就被报告出来了。</li>
</ul>
<p><strong>SQL Statements Overview</strong></p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230717101311180.png" alt="image-20230717101311180"></p>
<ol>
<li>测试用例长度：自动和手动减少的测试用例（包括生成状态的语句和引发错误的查询）通常只包含几条SQL语句（平均为3.71行）。在13个测试用例中，一行就足够了。这些测试用例要么是对常数进行操作的SELECT语句，要么是设置DBMS特定选项的操作。要复现一个错误所需的最大语句数量为8。一个在报告时已经被修复的PostgreSQL崩溃错误需要27个语句才能复现。总体来说，复现错误所需的语句数量较少，这表明可以系统地生成语句和查询，以有效地而非随机地探索空间。</li>
<li>语句分布：对于所有的DBMS，CREATE TABLE和INSERT语句是大部分错误报告的一部分，这是预期之内的，因为只有少数的错误可以在不操作表或从表中提取数据的情况下复现。91.0%的错误报告只包含一个表。SELECT语句排名也很高，因为 container oracle依赖于它。</li>
<li>列约束：列约束常常是测试用例的一部分，它可以用来限制存储在列中的值。最常见的约束是UNIQUE（出现在21.9%的测试用例中）。PRIMARY KEY列也很常见（16.7%）。DBMS通常通过创建索引来强制执行UNIQUE和PRIMARY KEY；然而，通过CREATE INDEX创建的显式索引更常见（27.1%）。其他的约束不常见，例如，FOREIGN KEYs只在1.0%的错误报告中出现。</li>
</ol>
<h3 id="Interesting-Bugs"><a href="#Interesting-Bugs" class="headerlink" title="Interesting Bugs"></a><strong>Interesting Bugs</strong></h3><p> <strong>Containment Bugs</strong></p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230717102529773.png" alt="image-20230717102529773"></p>
<p>在这个测试用例中，”COLLATE NOCASE”子句告诉数据库管理系统在比较字符串时忽略大小写；但在这个情况下，它意外地导致结果集中省略了大写的”A”。</p>
<p>。。。</p>
<p><strong>Error Bugs</strong></p>
<p><img src="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/image-20230717103220958.png" alt="image-20230717103220958"></p>
<p>操纵在REAL PRIMARY KEY列中的值会导致数据库损坏。作者们发现了4种这样的情况，都表现为数据库模式错误。这个具体的错误在2015年被引入，直到2019年作者们报告才被发现；这个错误被指定为严重级别。</p>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a><strong>Related Work</strong></h3><ol>
<li>软件系统的测试：作者介绍了几种重要的软件系统测试方法，包括差异测试（Differential testing）[33]，这种技术比较多个实现了共同语言的系统的结果；如果结果偏离，那么一个或多个系统可能存在错误。另一个方法是蜕变测试（Metamorphic testing）[9]，该方法将程序转化为预期与原程序相同结果的形式，已经应用于各种系统上，如C&#x2F;C++编译器[51,52]、符号执行引擎[24]和PDF阅读器[30]等。<font color="green">Metamorphic testing 蜕变测试它应对的是一种特殊情况：对于某些程序或系统，可能没有现成的“oracle”（验证程序正确性的参考），也就是说，我们可能无法直接验证程序的输出是否正确。例如（举例说明混排关系），对于一个排序程序，如果我们改变输入列表的顺序，那么排序的输出应该不变。因此，一个蜕变关系可能是“无论输入的顺序如何，排序的结果都应该相同”。</font></li>
<li>DBMS的蜕变测试：PQS启发了两种后续的测试方法，即非优化参考引擎构建（NoREC）[42]和三值逻辑划分（TLP）[43]，这两种方法都在SQLancer中实现。然而，NoREC和TLP都不能建立基准真值，这一点PQS可以做到。NoREC只能找到PQS检测到错误的52.7%，这是由其较窄的范围所导致的[42]。</li>
<li>DBMS的差异测试：Slutz提出了一种基于差异测试的方法来查找DBMS中的错误，该方法在RAGS中实现[46]。但是，该方法只适用于一小部分常见的SQL语句。</li>
<li>数据库模糊测试：SQLsmith是一个流行的工具，它随机生成SQL查询以测试各种DBMS[45]。然而，它无法找到我们方法能找到的逻辑错误。</li>
<li>一致性检查：Kingsbury开发了Jepsen，一个用于测试分布式系统的安全属性（例如，一致性模型的违反）的框架，它在分布式DBMS中找到了许多关键错误[28]。</li>
<li>满足约束的查询：一些方法通过生成满足某些约束的查询来改进随机查询生成，如基数或覆盖特性。</li>
<li>基于约束求解的DBMS测试：Khalek等人研究了使用约束求解来自动化测试DBMS的方法[3, 27]。</li>
<li>测试其他方面：除了试图改进DBMS的正确性，也提出了一些方法来测试DBMS的其他方面。例如，Poess等人提出了一种基于模板的方法来生成适合基准测试DBMS的查询，他们在一个工具QGEN中实现了这个方法[39]。</li>
</ol>
<p>这些方法各有优点，但是都不能像作者所提出的方法那样发现逻辑错误。作者认为他们的方法因为其简单性可能具有更广泛的适用性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/">http://example.com/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/18/%E4%BB%80%E4%B9%88%E6%98%AF%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95/" title="什么是蜕变测试?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">什么是蜕变测试?</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">History-Driven Build Failure Fixing: How Far Are We?</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-Database-Engines-via-Pivoted-Query-Synthesis"><span class="toc-number">1.</span> <span class="toc-text">Testing Database Engines via Pivoted Query Synthesis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">背景信息:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">结果:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E8%A6%81%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">摘要：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-number">1.7.</span> <span class="toc-text">Introduction:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation-Example"><span class="toc-number">1.8.</span> <span class="toc-text">Motivation Example:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">Background：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pivoted-Query-Synthesis"><span class="toc-number">1.10.</span> <span class="toc-text">Pivoted Query Synthesis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Approach-Overview"><span class="toc-number">1.10.1.</span> <span class="toc-text">3.1 Approach Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Query-Generation-amp-Checking"><span class="toc-number">1.10.2.</span> <span class="toc-text">3.2 Query Generation &amp; Checking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Random-State-Generation"><span class="toc-number">1.10.3.</span> <span class="toc-text">3.3 Random State Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Important-Implementation-Details"><span class="toc-number">1.10.4.</span> <span class="toc-text">3.4 Important Implementation Details</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.11.</span> <span class="toc-text">Evaluation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interesting-Bugs"><span class="toc-number">1.12.</span> <span class="toc-text">Interesting Bugs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Related-Work"><span class="toc-number">1.13.</span> <span class="toc-text">Related Work</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/" title="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction">Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction</a><time datetime="2023-07-20T02:40:56.000Z" title="发表于 2023-07-20 10:40:56">2023-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/%E4%BB%80%E4%B9%88%E6%98%AF%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95/" title="什么是蜕变测试?">什么是蜕变测试?</a><time datetime="2023-07-18T02:19:20.000Z" title="发表于 2023-07-18 10:19:20">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/" title="Testing database engines via pivoted query synthesis">Testing database engines via pivoted query synthesis</a><time datetime="2023-07-17T02:42:50.000Z" title="发表于 2023-07-17 10:42:50">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?">History-Driven Build Failure Fixing: How Far Are We?</a><time datetime="2023-07-09T07:58:11.000Z" title="发表于 2023-07-09 15:58:11">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/" title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts</a><time datetime="2023-07-09T07:57:05.000Z" title="发表于 2023-07-09 15:57:05">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>