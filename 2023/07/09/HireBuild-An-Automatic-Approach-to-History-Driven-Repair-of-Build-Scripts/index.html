<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts(2018)Basic Information: Title: HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts (HireBuild: 一种基于历史驱">
<meta property="og:type" content="article">
<meta property="og:title" content="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts">
<meta property="og:url" content="http://example.com/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts(2018)Basic Information: Title: HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts (HireBuild: 一种基于历史驱">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-09T07:57:05.000Z">
<meta property="article:modified_time" content="2023-07-09T07:57:58.467Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-09 15:57:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T07:57:05.000Z" title="发表于 2023-07-09 15:57:05">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-09T07:57:58.467Z" title="更新于 2023-07-09 15:57:58">2023-07-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts-2018"><a href="#HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts-2018" class="headerlink" title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts(2018)"></a>HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts(2018)</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts (HireBuild: 一种基于历史驱动的自动构建脚本修复方法)</li>
<li>Authors: Foyzul Hassan, Xiaoyin Wang</li>
<li>Affiliation: The University of Texas at San Antonio (美国圣安东尼奥德克萨斯大学)</li>
<li>Keywords: Patch Generation, Software Build Scripts, Build Logs</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3180155.3180181">Paper</a>, [GitHub: None]</li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>本文提出了HireBuild，一种自动生成构建脚本修复补丁的方法，通过使用从现有构建脚本修复中自动生成的修复模式，并基于构建日志相似性推荐修复模式，能够在可比较的时间内修复45%的可重现构建失败。</li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息:"></a>背景信息:</h3><ul>
<li>论文背景: 软件构建工具的发展减少了构建管理的工作量，但开发人员仍需要专业知识和长时间来维护构建脚本和解决构建失败问题。</li>
<li>过去方案: 自动程序修复技术在减少软件故障解决成本方面具有巨大潜力，但现有技术主要集中在修复源代码，无法直接帮助解决软件构建失败问题。</li>
<li>论文的Motivation: 为了解决这个问题，本文提出了HireBuild方法，通过使用从现有构建脚本修复中自动生成的修复模式，并基于构建日志相似性推荐修复模式，实现了自动构建脚本修复。通过实验证明，HireBuild能够在可比较的时间内修复45%的可重现构建失败问题。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文介绍了构建脚本在软件项目中的重要性以及开发人员在维护和解决构建失败方面面临的挑战。还讨论了自动修复构建脚本的潜在好处和现有自动修复技术的局限性。作者提出了他们的方法HireBuild，该方法旨在基于历史修复和构建日志相似性生成构建脚本的补丁。该方法包括三个阶段：获取具有相似构建日志的历史修复的构建失败，从种子修复中提取修复模式，根据模式和构建脚本信息生成排序的补丁。作者还提到了修复构建脚本中的独特挑战和机会，并概述了他们的方法的特点。HireBuild的评估被简要提及，以及该工作的贡献。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>HireBuild方法从每个种子修复中推断出构建修复模式的层次结构，通过概括种子修复的差异输出中的每个元素来生成层次结构。层次结构是通过概括差异输出中的元素生成的，除了通常表示不同修复的操作和节点类型。任务和块信息不包含在模式中，因为它们通常不是修复的一部分。层次结构用于在不同的抽象级别生成补丁。</li>
</ul>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:<ul>
<li>评估使用TravisTorrent数据集构建，其中包含来自54个不同项目的175个构建修复。训练集包含135个构建修复，评估集包含40个构建修复。在评估集的40个构建修复中，成功重现了24个构建失败。评估旨在回答与成功修复构建失败的数量、修复构建失败所花费的时间、可以修复的构建修复的大小以及无法成功修复构建脚本的原因相关的研究问题。</li>
</ul>
</li>
<li>b. 详细的实验结果:<ul>
<li>研究发现，修复构建失败所花费的时间受到补丁列表大小的影响。研究比较了成功修复和未修复的构建失败的补丁列表大小。结果显示，成功修复的构建失败的补丁列表大小范围从68到2,245，中位数为486。另一方面，未修复的构建失败的补丁列表大小范围从8到1,266，中位数为223。这表明，补丁列表较小的构建失败更有可能成功修复。此外，研究还分析了方法生成的构建修复补丁的大小。结果发现，修复的构建失败的补丁至少有一个语句更改，最多有两个语句更改，中位数为一个。相反，未修复的构建失败的补丁至少有一个语句更改，最多有11个语句更改，中位数为一个。这表明，该方法主要适用于具有少量语句更改的构建失败。对于评估的构建失败中的54.16％，该方法无法生成构建修复。进行了手动分析以确定这些失败的原因。原因分为四类：项目特定更改适应性、不匹配的模式、依赖解析失败和多位置修复。这些类别代表了该方法在适应项目特定更改、生成适当模式、解决依赖关系和处理多位置修复方面面临的挑战。评估的内部有效性存在三个主要威胁。为了减轻这些威胁，研究采取了措施，如对代码和数据进行双重检查，使用严格的正确修复标准，考虑实际修复时间而不是等待时间。外部有效性的主要威胁是评估集中可重现错误修复的数量有限，这可能限制了研究结果的普遍适用性。讨论部分主要关注两个方面：补丁验证和构建正确性，以及构建环境对构建自动化和修复的影响。研究发现，该方法使用的补丁验证策略是有效的，因为评估中的所有修复构建都通过了验证。研究还强调了在避免构建中断方面，同步构建脚本版本依赖和构建环境的重要性，特别是在Android项目的情况下。相关工作部分简要提到了自动程序修复的研究兴趣以及程序分析、合成和机器学习的进展。相关工作部分讨论了各种现有的自动补丁生成技术和构建配置文件分析技术。提到的一些技术包括GenProg、RSRepair、AE、PAR、SemFix、Prophet、Relifix、SPR、Angelix、DirectFix和Nopol。该部分还提到了分析构建配置文件在软件工程研究中的重要性，如依赖分析、构建配置文件的迁移和经验研究。在这个领域的一些相关工作包括Gunter基于Petri网的模型、Adams提取依赖图的框架、Al-Kofahi的故障定位方法、Wolf用于预测构建错误的方法以及McIntosh关于开发人员在构建配置中的努力的经验研究。该部分还简要讨论了Tamrawi等人开发的用于在Makefiles中生成字符串依赖图的SYMake工具。最后，该部分简要讨论了AutoConf，这是一种根据检测到的计算机系统特征自动生成配置脚本的工具。</li>
</ul>
</li>
</ul>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><strong>背景：</strong> 此研究的背景是软件构建和测试过程的自动化，特别是处理与构建脚本相关的问题。随着软件的规模和功能的增长，构建脚本变得越来越复杂，需要频繁的维护。开发人员需要对代码、测试用例、系统配置和依赖项进行更改，这可能导致构建脚本需要进行必要的更改。然而，许多开发人员并没有修复构建脚本所需的专门知识，因此，构建脚本的自动修复可能是软件项目经理和开发人员所期望的。</p>
<p><strong>相关工作：</strong> 尽管自动生成软件补丁是一个新兴的技术，且已经得到了多个研究工作的关注，比如 GenProg 和 PAR 都实现了自动修复bug的有希望的结果。但是，这些工作都是设计用于修复用不同编程语言编写的源代码的。</p>
<p><strong>局限性：</strong> 修复构建脚本具有其独特的挑战性。首先，尽管代码相似性假设仍然适用于构建脚本，但构建脚本修复通常涉及到在当前项目中不存在的开放知识，如新版本的依赖项或构建工具插件。其次，与源代码错误不同，构建失败没有测试套件来帮助定位错误和作为适应度函数。第三，虽然不同的编程语言具有相似的语义，但构建脚本的语义与普通程序非常不同，因此我们需要为构建脚本重新开发抽象修复模板。</p>
<p><strong>解决方法：</strong> 为了解决这些问题，作者提出了一种新的方法，HireBuild，用于为构建脚本生成补丁。他们的insight是，由于许多软件项目使用相同的构建工具（如 Gradle），类似的构建失败将导致类似的构建日志。因此，可以使用构建失败日志从历史构建修复数据集中定位类似的构建失败，并为这些新的失败适应历史修复。</p>
<p><strong>贡献：</strong></p>
<ol>
<li>提出了一种新的方法和工具，用于自动为构建脚本生成补丁以解决软件构建失败。</li>
<li>提供了一个包含175个构建修复的数据集，这可以为未来的研究提供基础和基准。</li>
<li>对我们的方法进行了实际的构建修复的实证评估。</li>
<li>提出了一个用于Gradle构建脚本的抽象语法</li>
</ol>
<h3 id="MOTIVATING-EXAMPLE"><a href="#MOTIVATING-EXAMPLE" class="headerlink" title="MOTIVATING EXAMPLE"></a><strong>MOTIVATING EXAMPLE</strong></h3><p>在本节中，我们将介绍一个来自数据集的真实示例，来说明构建脚本的补丁生成与源代码的补丁生成有何不同。示例2显示了一个构建失败及其相应的补丁，其中上面部分显示了构建失败日志中最相关的代码片段，下面部分显示了解决构建失败的代码更改。项目名称和提交id显示在示例标题后面。</p>
<p>在这个构建失败中，构建失败日志抱怨有两个冲突的模块slf4j版本，错误修复方法是在Galaxy组件的编译中添加一个对模块的排除。虽然这个构建修复只是一个一行简单的修复，但它在以下方面说明了源代码修复和构建脚本修复之间的区别。</p>
<p>首先，可以找到从现有的脚本或过去的修复我们需要执行一个排除操作，然而，由于org.slf4j从未出现在脚本(它是过渡引用，将从Gradle中央依赖库下载)，字符串“org.slf4j”很难生成，并枚举所有可能的字符串不是一个可行的解决方案。实际上，该字符串可以通过比较构建失败日志和Gradle中央依赖存储库中的可用模块来生成，但这是非常不同的从源代码补丁中，所有要引用的变量名都已经在代码中定义（如果生成的修复包含一个新声明的变量，该变量可以有任何名称，只要它不与作用域中的现有名称冲突）。</p>
<p>其次，在构建脚本修复中，我们能够并且需要考虑特定于构建的操作。例如，我们不应该简单地将排除视为一个任意的方法名，而是需要将其语义涉及到修复模式模板中，这样我们就知道一个模块名将遵循排除命令。</p>
<p>第三，构建日志信息非常重要，因为它不仅提供了冲突依赖关系的名称，而且还提供了在构建失败发生时执行的编译任务，这在很大程度上可以帮助补丁生成工具定位构建失败并确定应用补丁的位置。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>HireBuild是一个自动构建修复工具，其总体目标是生成可以用于解决构建失败的构建脚本补丁。HireBuild通过以下三个步骤实现这些目标：</p>
<ol>
<li><strong>日志相似性计算</strong>：通过计算日志相似性，找到与当前构建失败相似的历史构建修复作为种子修复。</li>
<li><strong>从种子修复中提取构建修复模式</strong>：根据找到的种子修复，提取出构建修复模式，这些模式代表了过去解决类似构建失败的常见方法。</li>
<li><strong>生成并验证具体的构建脚本补丁</strong>：根据提取的构建修复模式，生成具体的构建脚本补丁，并进行验证，以确定这些补丁是否可以成功解决当前的构建失败。</li>
</ol>
<p>在具体的子节中，作者首先介绍了Gradle的初步知识，然后详细描述了HireBuild的这三个步骤。</p>
<h4 id="3-1-Gradle-Build-Tool"><a href="#3-1-Gradle-Build-Tool" class="headerlink" title="3.1 Gradle Build Tool"></a><strong>3.1 Gradle Build Tool</strong></h4><p>这段文字主要介绍了Gradle构建工具的一些基本特性和工作原理。</p>
<p>Gradle是一种基于Groovy和Kotlin的通用构建管理系统，支持自动下载和配置依赖项或其他库。它支持从Maven和Ivy仓库中检索这些依赖项，允许重用现有构建系统的构建成果。</p>
<p>一个Gradle构建可能包含一个或多个构建项目。每个构建项目对应于构建整个软件项目或一个子模块。每个构建项目由多个任务组成，每个任务代表了构建过程中的一项工作，例如编译源代码或生成Javadoc。</p>
<p>Gradle用户在build.gradle文件中描述其构建过程。这个文件通常位于项目的根文件夹中。在此文件中，开发人员可以使用Groovy或Kotlin代码的声明式和命令式语句的组合。这个构建文件定义了一个项目及其任务，任务还可以在运行时动态地创建和扩展。由于Gradle是一个通用的构建系统，因此这个构建文件可以执行任何任务。</p>
<h4 id="3-2-Log-Similarity-Calculation-to-Find-Similar-Fixes"><a href="#3-2-Log-Similarity-Calculation-to-Find-Similar-Fixes" class="headerlink" title="3.2 Log Similarity Calculation to Find Similar Fixes"></a><strong>3.2 Log Similarity Calculation to Find Similar Fixes</strong></h4><p>HireBuild的日志相似度计算过程可以分为以下三个主要部分：</p>
<ol>
<li><strong>构建日志解析</strong>：Gradle构建日志通常包含数千行文本，其中只有一小部分是关于错误和异常的信息，这正是HireBuild感兴趣的部分。为了减少计算中的噪声，HireBuild仅使用构建日志的错误和异常部分来计算构建日志之间的相似性。它通过提取Gradle错误指示头（例如“* What went wrong”）后的构建日志部分来提取错误和异常部分。HireBuild只提取最后一个错误，因为早期的错误可能是被容忍的，并且不太可能是构建失败的原因。此外，如果错误和异常部分中存在异常堆栈跟踪，HireBuild会移除堆栈跟踪。</li>
<li><strong>文本处理</strong>：从构建失败日志中提取出错误和异常部分后，HireBuild进行一系列处理来将日志文本转换为标准词向量。这包括文本规范化（将纯文本分解为单独的标记，并将驼峰命名法的单词拆分为多个单词）、停用词移除（移除常见的停用词、标点符号等），以及词干提取（将变形词还原为其词根）。</li>
<li><strong>相似度计算</strong>：在从构建失败日志的错误和异常部分生成词向量后，HireBuild使用标准的词频-逆文档频率（TF-IDF）公式对所有词进行加权。最后，它计算待解决的构建失败日志与训练集中历史构建修复的所有构建失败日志之间的余弦相似性，并获取最相似的历史修复。HireBuild使用五个最相似的历史修复作为生成构建修复模式的种子修复。</li>
</ol>
<h4 id="3-3-Generation-of-Build-Fix-Patterns"><a href="#3-3-Generation-of-Build-Fix-Patterns" class="headerlink" title="3.3 Generation of Build-Fix Patterns"></a><strong>3.3 Generation of Build-Fix Patterns</strong></h4><p><font color="red">可以举几个例子说明一下具体的修复模式吗？</font></p>
<p>HireBuild 生成构建修复模式的过程包括以下步骤：</p>
<p><strong>构建脚本差异化（Build-Script Differencing）</strong>：对于每个种子修复（seed fix，即在历史数据集中与新构建失败日志最为相似的修复案例），HireBuild 首先计算修复前后的代码差异，这些差异包含一系列基本的修改，如插入、删除和更新。HireBuild 通过 Gradle 的 Groovy 解析器将脚本代码转换为抽象语法树（AST）表示，并运用差异算法（例如 GumTree 或 ChangeDistiller）提取 AST 更改。</p>
<p><strong>生成层次化构建修复模式（Hierarchical Build-Fix Patterns）</strong>：有些情况下，可以直接使用具体的构建修复模式生成修复补丁。但在更常见的场景中，生成的代码差异太特定，无法直接用作补丁。因此，HireBuild 通过对每个种子修复的差异化输出中的每个元素进行概括，推断出构建修复模式的层次结构。通过选择是否以及如何概括叶节点，可以在不同的抽象级别生成补丁</p>
<p><img src="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/image-20230705193716150.png" alt="image-20230705193716150"></p>
<p><strong>合并构建修复模式（Merging Build-Fix Patterns）</strong>：生成模式层次结构后，HireBuild 尝试合并相似的层次结构。只有具有相同操作和节点类型的两个层次结构才可以合并。在合并过程中，HireBuild 从它们的根节点递归合并层次结构，并合并具有完全相同值的节点。如果两个要合并的节点有不同的常量值，HireBuild 不会合并它们和它们的子节点。如果两个要合并的节点有不同的表达式值，HireBuild 提取它们对应的 AST 树，并合并 AST 树，以便提取出表达式的公共部分。</p>
<p><img src="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/image-20230705193543414.png" alt="image-20230705193543414"></p>
<p><strong>构建修复模式的排名（Ranking of Build-Fix Patterns）</strong>：层次结构合并后，HireBuild 计算种子修复中构建修复模式的频率。在合并的层次结构中，所有模式的频率始终是被合并的原始层次结构的数量。然后，HireBuild 根据频率对构建修复模式进行排名。当 A 和 B 之间存在关系时，如果 A 是 B 的概括（A 是通过概括 B 的一个或多个叶节点生成的），则 B 的排名高于 A。如果两种模式之间没有概括关系，HireBuild 会优先考虑来自排名更高的种子修复的构建修复模式。</p>
<p><img src="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/image-20230705194220617.png" alt="image-20230705194220617"></p>
<blockquote>
<p>假设我们有两个项目，每个项目都进行了一个不同的版本更新操作。</p>
<p>示例5：Gradle 构建修复 (BuildCraft&#x2F;BuildCraft: 98f7196)</p>
<ul>
<li><p>版本 &#x3D; “1.7.2-10.12.1.1079”</p>
</li>
<li><p>版本 &#x3D; “1.7.2-10.12.2.1121”</p>
</li>
</ul>
<p>示例6：Gradle 构建修复 (ForgeEssentials&#x2F;ForgeEssentialsMain:fcbb468)</p>
<ul>
<li><p>版本 &#x3D; “1.4.0-beta7”</p>
</li>
<li><p>版本 &#x3D; “1.4.0-beta8”</p>
</li>
</ul>
<p>首先，HireBuild 将提取每个种子修复的构建脚本，并将其转化为抽象语法树 (AST) 形式。这两个例子都是更新操作，具有同样的节点类型 (即ConstantExpression)，且父表达式 (ParentExp) 都为 “version &#x3D; “。</p>
<p>然后，HireBuild 会从每个种子修复中推断出构建修复模式的层次结构。在这个例子中，我们可以将 “version &#x3D; 1.7.2-10.12.1.1079” 和 “version &#x3D; 1.4.0-beta7” 看作是相似的模式，因为它们都进行了版本号的更新。</p>
<p>接下来，HireBuild 会尝试合并这两个相似的层次结构。由于这两个层次结构的操作和节点类型都是一样的（都是更新操作和ConstantExpression节点类型），所以它们可以被合并。在合并过程中，HireBuild 会将相同的值合并到一起。在这个例子中，”version &#x3D; *” 被添加为一个新节点，因为 “version &#x3D; 1.7.2…” 和 “version &#x3D; 1.4.0…” 的子节点都有 “version” 和 “&#x3D;”。</p>
<p>最后，HireBuild 会计算并排列种子修复中的构建修复模式的频率。在这个例子中，所有的构建修复模式都有相同的频率，但最具体的模式，即 “update constant expression with parent expression version&#x3D; *”，会被排在最前。这意味着，在为修复构建错误生成具体补丁时，HireBuild 会优先使用这个模式。</p>
</blockquote>
<h4 id="3-4-Generation-and-Validation-of-Concrete-Patches"><a href="#3-4-Generation-and-Validation-of-Concrete-Patches" class="headerlink" title="3.4 Generation and Validation of Concrete Patches"></a><strong>3.4 Generation and Validation of Concrete Patches</strong></h4><p>生成和验证具体补丁的过程包括以下步骤：（补丁&#x3D;&#x3D;规则）</p>
<ol>
<li><strong>确定应用补丁的文件</strong>：HireBuild 首先需要确定在哪个 .gradle 文件上应用修复。HireBuild 使用一个简单的启发式方法，它始终选择构建失败日志中错误部分提及的第一个 .gradle 文件。如果没有提及任何 .gradle 文件，HireBuild 则使用根目录下的 build.gradle 文件。</li>
<li><strong>生成具体补丁</strong>：在给定了构建修复模式和存在错误的 Gradle 构建脚本之后，HireBuild 会首先将错误的 Gradle 构建脚本解析为抽象语法树 (AST)，然后尝试找出应该在哪里应用补丁。对于更新和删除操作，HireBuild 将构建修复模式匹配到 AST 中的节点。当构建修复模式可以映射到多个 AST 节点时（对于通用的构建修复模式很常见），HireBuild 会为所有映射的 AST 节点生成补丁。</li>
<li><strong>确定值的类型</strong>：在确定了应用哪个构建修复模式和在哪里应用之后，我们最后需要关注构建修复模式的抽象部分，并确定抽象节点的值（例如，模式 “update constant expression with parent expression version&#x3D; <em>“ 中的 “</em>“ 的值）。HireBuild 首先根据导致要应用的构建修复模式的具体值和种子修复中的 AST 节点，确定要添加的值属于哪种类型。一旦确定了值的类型，HireBuild 会针对不同的类型生成不同的值。</li>
<li><strong>生成具体补丁</strong>：在确定了构建修复模式、位置和具体值之后，会生成一个具体的补丁并将其添加到补丁列表中。</li>
<li><strong>补丁的排序</strong>：生成的补丁数量可能会很多，因此需要进行排序，以便尽快找到实际的修复。HireBuild 使用以下几个启发式规则对生成的补丁进行排序：高级构建修复模式生成的补丁比低级模式生成的补丁排名高；如果补丁应用于某个位置，且该补丁由合并自若干种子修复的构建修复模式生成，如果该位置处于与任何种子修复中的任务&#x2F;块名称相同的任务&#x2F;块中，则 HireBuild 将补丁的优先级增加 1.0；如果补丁涉及到构建失败日志中出现的值，HireBuild 也将补丁的优先级增加 1.0。</li>
<li><strong>补丁应用</strong>：生成补丁的排序列表后，HireBuild 会一个接一个地应用补丁，直到超出超时阈值或修复失败。如果构建过程返回 0 并且构建日志显示构建成功，HireBuild 就会认为失败已经修复。一旦找到了第一个通过验证的补丁，HireBuild 就会停止应用补丁。</li>
</ol>
<blockquote>
<p>在这种情况下，HireBuild 工具生成的补丁是一些特定的规则，它们描述了如何修改 Gradle 构建脚本以解决构建失败的问题。这些补丁是基于特定的修复模式生成的，修复模式是通过分析大量的修复实例（也就是种子修复）得到的。</p>
</blockquote>
<h3 id="EMPIRICAL-EVALUATION"><a href="#EMPIRICAL-EVALUATION" class="headerlink" title="EMPIRICAL EVALUATION"></a><strong>EMPIRICAL EVALUATION</strong></h3><p>作者使用的是<strong>TravisTorrent数据集</strong>，它收集了很多TravisCI的构建数据。作者对这个数据集的使用侧重于分析构建状态从错误&#x2F;失败转变为通过状态时，对应的Gradle构建脚本的更改。通过分析版本历史，作者找出了那些满足以下条件的代码提交被视为构建修复：(1)它们之前版本的构建状态是失败&#x2F;错误；(2)提交后的构建状态是成功；(3)它们只包含Gradle构建脚本的更改。从所有项目的提交历史中，他们提取了175个构建修复，并根据代码提交时间戳将其排序，其中<strong>75%的早期构建修复用作训练集，其余的25%用作评估集</strong>。评估集中的所有构建修复都是训练集的构建修复之后发生的。</p>
<p>作者的<strong>评价指标</strong>主要包括HireBuild修复多少可重现的构建失败，修复构建失败所需的时间，成功和失败的构建修复的大小，以及未能成功进行构建脚本修复的原因。</p>
<p>作者回答了以下研究问题：</p>
<p>• RQ1 HireBuild可以修复多少在评估集中可重现的构建失败？ </p>
<p>• RQ2 HireBuild修复构建失败所花费的时间是多少？</p>
<p> • RQ3 修复成功和无法修复的构建修复的大小是多少？ <font color="red">统计这个有什么意义呢？</font></p>
<p>• RQ4 未能成功进行构建脚本修复的原因是什么？</p>
<p>研究结果：</p>
<p>在24个可重现的构建失败中，HireBuild可以为其中的11个生成正确的修复。对于修复成功的构建失败，修复列表的大小最小为68，最大为2,245，中位数为486。对于未能修复的构建失败，修复列表的最小值、中位数和最大值分别为8、223和1,266，这些都比可修复的构建失败的修复列表要小。对于那些HireBuild修复成功的11个构建失败，与手动修复时间相比，HireBuild在自动修复构建失败方面花费的时间非常接近。HireBuild修复的最小时间为2分钟，最大时间为305分钟，中位数为44分钟，而人工修复的最小时间少于一分钟，最大时间为5281分钟，中位数为42分钟。对于可修复的构建失败，HireBuild在时间上与手动修复相当。</p>
<p>至于未能成功进行构建脚本修复的13个构建失败，作者进行了手动分析，找出了四个主要原因：(1)项目特定的更改适应问题，(2)不匹配的模式，(3)依赖项解析失败，(4)多位置修复。</p>
<blockquote>
<p>“Fixed patch list size” 可能是指生成的修复列表的大小，也就是生成并尝试应用的所有可能修复的数量。这是一个度量自动修复工具如何应对问题，尝试多少种可能的修复策略，直到找到一个成功修复问题的衡量指标。如果修复列表的大小较大，那么自动修复工具需要更多的时间来尝试所有可能的修复策略。（可能的修复策略）</p>
<p>“Fix line size” 则可能是指实际应用到代码中的修复的大小，也就是修改了多少行代码来解决问题。这个指标可以衡量修复的复杂度。例如，如果只修改了一行代码，那么我们可以认为这是一个比较简单的修复；而如果修改了很多行代码，那么这可能是一个比较复杂的修复。（实际修改的行数）</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/">http://example.com/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">History-Driven Build Failure Fixing: How Far Are We?</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/07/Automated-API-Usage-Update-for-Android-Apps/" title="Automated API-Usage Update for Android Apps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Automated API-Usage Update for Android Apps</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts-2018"><span class="toc-number">1.</span> <span class="toc-text">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts(2018)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">背景信息:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">结果:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.6.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOTIVATING-EXAMPLE"><span class="toc-number">1.7.</span> <span class="toc-text">MOTIVATING EXAMPLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-number">1.8.</span> <span class="toc-text">Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Gradle-Build-Tool"><span class="toc-number">1.8.1.</span> <span class="toc-text">3.1 Gradle Build Tool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Log-Similarity-Calculation-to-Find-Similar-Fixes"><span class="toc-number">1.8.2.</span> <span class="toc-text">3.2 Log Similarity Calculation to Find Similar Fixes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Generation-of-Build-Fix-Patterns"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.3 Generation of Build-Fix Patterns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Generation-and-Validation-of-Concrete-Patches"><span class="toc-number">1.8.4.</span> <span class="toc-text">3.4 Generation and Validation of Concrete Patches</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EMPIRICAL-EVALUATION"><span class="toc-number">1.9.</span> <span class="toc-text">EMPIRICAL EVALUATION</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/" title="Testing database engines via pivoted query synthesis">Testing database engines via pivoted query synthesis</a><time datetime="2023-07-17T02:42:50.000Z" title="发表于 2023-07-17 10:42:50">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?">History-Driven Build Failure Fixing: How Far Are We?</a><time datetime="2023-07-09T07:58:11.000Z" title="发表于 2023-07-09 15:58:11">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/" title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts</a><time datetime="2023-07-09T07:57:05.000Z" title="发表于 2023-07-09 15:57:05">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-API-Usage-Update-for-Android-Apps/" title="Automated API-Usage Update for Android Apps">Automated API-Usage Update for Android Apps</a><time datetime="2023-07-07T08:20:20.000Z" title="发表于 2023-07-07 16:20:20">2023-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-Deprecated-API-Usage-Update-for-Android-Apps-How-Far-Are-We/" title="Automated Deprecated-API Usage Update for Android Apps How Far Are We">Automated Deprecated-API Usage Update for Android Apps How Far Are We</a><time datetime="2023-07-07T08:19:22.000Z" title="发表于 2023-07-07 16:19:22">2023-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>