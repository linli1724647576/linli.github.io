<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine ConstructionBasic Information: Title: Detecting Optimization Bugs in Database Engines via Non-optimizing Reference E">
<meta property="og:type" content="article">
<meta property="og:title" content="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction">
<meta property="og:url" content="http://example.com/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine ConstructionBasic Information: Title: Detecting Optimization Bugs in Database Engines via Non-optimizing Reference E">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-20T02:40:56.000Z">
<meta property="article:modified_time" content="2023-07-20T02:42:00.125Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-20 10:42:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-20T02:40:56.000Z" title="发表于 2023-07-20 10:40:56">2023-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-20T02:42:00.125Z" title="更新于 2023-07-20 10:42:00">2023-07-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction"><a href="#Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction" class="headerlink" title="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction"></a>Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction (通过非优化参考引擎构建检测数据库引擎中的优化错误)</li>
<li>Authors: Manuel Rigger, Zhendong Su</li>
<li>Affiliation: Department of Computer Science, ETH Zurich (苏黎世联邦理工学院计算机科学系)</li>
<li>Keywords: database testing, DBMS testing, query optimizer bugs, test oracle</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://doi.org/10.1145/3368089.3409710">Paper</a>, <a target="_blank" rel="noopener" href="https://github.com/sqlancer">GitHub</a></li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>通过构建非优化参考引擎，该论文提出了一种全自动的方法来检测数据库管理系统（DBMS）中的优化错误。通过比较优化版本和非优化版本的DBMS返回的结果集，可以检测出DBMS中的错误。在四个广泛使用的DBMS上进行了广泛的测试，发现了159个以前未知的错误，其中141个已经被修复。这项技术被证明是有效的，通用的，并且需要很少的实现工作。</li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息:"></a>背景信息:</h3><ul>
<li>论文背景: 数据库管理系统（DBMS）在许多系统中起着重要的作用。为了满足不断增长的性能需求，DBMS应用了越来越复杂的查询优化技术。然而，错误的优化可能导致逻辑错误，使得查询返回错误的结果集。本文旨在解决DBMS中的优化错误问题。</li>
<li>过去方案: 过去的方法包括Pivoted Query Synthesis (PQS)和RAGS。然而，PQS需要高度的实现工作，并且只能检测到部分错误；而RAGS只适用于SQL的共同核心，无法覆盖所有DBMS。</li>
<li>论文的Motivation: 鉴于过去方法的局限性，本文提出了一种新的、通用的、低实现成本的技术，即通过构建非优化参考引擎来检测DBMS中的优化错误。通过比较优化版本和非优化版本的DBMS返回的结果集，可以检测出DBMS中的错误。本文的动机是提供一种简单、有效、低实现成本的测试技术，以帮助发现DBMS中的优化错误。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文提出了一种名为非优化参考引擎构建（NoREC）的技术，用于检测数据库管理系统（DBMS）中的优化错误。该方法涉及将优化版本的DBMS的结果与不执行任何优化的版本进行比较。作者在四个广泛使用的DBMS上评估了NoREC，并发现了159个以前未知的错误，其中141个已由开发人员修复。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>本文提出了一种名为NoREC的新颖、通用且具有成本效益的技术，用于在DBMS中发现优化错误。该方法涉及重写查询以使其无法优化，并比较优化和未优化版本的结果。</li>
</ul>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:<ul>
<li>作者在一个名为SQLancer的工具中实现了NoREC，并在四个广泛使用的DBMS（SQLite，MariaDB，PostgreSQL和CockroachDB）上进行了评估。</li>
<li>在为期5个月的测试活动中，他们发现了159个以前未知的错误，其中141个已由开发人员修复。</li>
</ul>
</li>
<li>b. 详细的实验结果:<ul>
<li>这些错误包括优化错误、崩溃错误、断言失败和错误错误。</li>
<li>尽管PQS对SQLite进行了广泛测试，但NoREC在发现SQLite中的错误方面特别有效。</li>
</ul>
</li>
</ul>
<h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>由于DBMS被广泛使用，且为了有效地访问数据，它们需要进行复杂的优化操作。然而，错误的优化可能会导致逻辑错误，从而使查询计算出错误的结果集。</p>
<p>作者提出了一种名为NoREC（非优化引用引擎构建）的全自动方法来检测DBMS中的优化错误。这种方法的理念是用一个优化版和一个非优化版的DBMS来评估查询，然后检测它们返回的结果集中的差异，以此来找出DBMS中的错误。获取DBMS的非优化版本是具有挑战性的，因为DBMS通常对优化的控制有限。<strong>论文的insight是，可以将优化的查询重写为DBMS无法优化的查询。</strong>对这个未优化的查询的评估实际上相当于一个非优化的参考引擎执行原始查询。在对四种广泛使用的DBMS（包括PostgreSQL，MariaDB，SQLite，和CockroachDB）进行大量测试后，研究者发现在这些系统的最新版本中有159个之前未知的错误，其中141个已经被开发者修复。其中，51个是优化错误，其余的是错误和崩溃错误。结果表明，NoREC方法是有效的，通用的，且需要很少的实现工作，这使得这种技术在实践中具有广泛的应用性。</p>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION:"></a>INTRODUCTION:</h3><p><strong>背景</strong>：</p>
<p>数据库管理系统（DBMS）是许多系统的重要组件，为了满足不断增长的性能需求，需要对查询评估进行越来越复杂的优化。然而，优化器的实现错误可能导致逻辑错误，这些错误会使得DBMS对给定查询返回错误的结果集。</p>
<p><strong>相关工作</strong>：</p>
<ul>
<li>Pivoted Query Synthesis (PQS)是一种解决DBMS逻辑错误的方法，它基于一个单一的关键行来验证DBMS，然后生成一个预期获取此行的查询。尽管PQS在检测许多广泛使用的DBMS中的错误方面效果显著，但实现这种技术需要<font color="red">高昂的实现成本</font>, <font color="red">还有就是不能处理多行的错误检测（如重复行的错误检测）</font>。</li>
<li>RAGS系统则使用了另一种检测DBMS中逻辑错误的技术，基于差异性测试。生成的查询会发送到多个DBMS，如果DBMS对输出结果存在分歧，那么至少有一个DBMS可能受到错误影响。然而，该方法的一个主要缺点是<font color="red">只适用于SQL的通用核心</font>，因为DBMS在支持的运算符和类型方面存在差异，甚至是常见运算符在不同的DBMS中也有微妙的语义差异。</li>
</ul>
<p><strong>解决方式</strong>：本文提出了一种名为NoREC（非优化引用引擎构建）的新方法，它对比一个优化版本的DBMS和一个不进行任何优化的同一DBMS版本的结果。挑战是 虽然许多DBMS提供了一些选项来控制优化，但这些选项是有限的，并且特定于DBMS。虽然添加这些选项是可能的，但由于需要大量的实现工作和领域知识，回顾性地这样做是容易出错和不切实际的。</p>
<p>作者提出了一个观点，即可以通过重写查询来达到DBMS不进行优化的目的。具体来说，作者提出了一种转换方法，将一个带有WHERE子句的查询（DBMS对其进行大量优化）转换为一个在表的每一条记录上都评估WHERE子句谓词的查询，后者无法进行有意义的优化。</p>
<p><strong>贡献</strong>：</p>
<ul>
<li>提出了一种新的、有效的用于检测DBMS优化错误的测试技术NoREC；</li>
<li>实现了一个名为SQLancer的NoREC工具；</li>
<li>对NoREC进行了广泛的评估，发现了许多广泛使用的DBMS中的150多个新错误。</li>
</ul>
<h3 id="Motivation-Example"><a href="#Motivation-Example" class="headerlink" title="Motivation Example:"></a>Motivation Example:</h3><p><img src="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/image-20230718111101398.png" alt="image-20230718111101398"></p>
<p>这个例子中，作者使用了SQLite数据库来说明他们的方法。在一个只包含一个记录的初始数据库中，他们生成了带有随机WHERE条件t0.c0 GLOB ‘-<em>‘的查询1。其中，GLOB是一个正则表达式运算符，’-</em>‘是一个应该匹配’-‘及其后面的任意数量字符的正则表达式。</p>
<p>由于WHERE（和JOIN）子句在性能上至关重要，因此会受到DBMS的优化。在这个例子中，SQLite应用了LIKE优化，通过使用一个基于UNIQUE约束隐式创建的索引进行范围搜索，这允许执行引擎跳过无关的记录。然而，出乎意料的是，这种优化导致DBMS省略了获取单个记录，尽管该记录符合指定的正则表达式。</p>
<p>接下来，作者将第一个查询翻译为查询2，这样DBMS就不太可能对其进行优化。具体来说，他们将WHERE子句的谓词直接移到SELECT关键字旁边，这导致查询在表的每个记录上评估谓词。他们期望表达式评估为TRUE的次数与第一个查询获取的记录数实际上是一致的。然而，在这个例子中，对数据库中的单个记录进行表达式评估结果为TRUE。DBMS只能对第一个查询有意义地应用错误的优化，而不能对第二个查询这样做。作者向SQLite的开发者报告了这个错误，开发者迅速修复了它。</p>
<h3 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a><strong>APPROACH</strong></h3><p>该文提出了一种名为NoREC的方法来查找数据库管理系统（DBMS）中的优化错误。这个方法的核心思想是，可以将DBMS优化的给定查询转化为另一个不能有效优化的查询。文章将可能被DBMS优化的查询称为优化查询，而没有或较少优化的查询称为未优化查询。虽然这种转化步骤不能保证优化的完全消除，但实践中发现这种技术广泛适用于禁用它们。</p>
<h4 id="3-1-Approach-Overview"><a href="#3-1-Approach-Overview" class="headerlink" title="3.1 Approach Overview"></a>3.1 <strong>Approach Overview</strong></h4><p><img src="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/image-20230719080036379.png" alt="image-20230719080036379"></p>
<p>NoREC方法概述如下：</p>
<p>步骤1：随机生成一个形如”SELECT * FROM t0 WHERE ϕ”的优化查询。由于大多数优化都应用于数据过滤，如查询的WHERE子句所表达的，所以期望随机生成的查询可能会被DBMS优化。然而，由于错误的优化，可能会发生遗漏记录或错误获取记录。</p>
<p>步骤2：将优化查询转化为一个形如”SELECT (ϕ IS TRUE) FROM t0”的未优化查询。这个查询没有WHERE条件，因此，DBMS必须获取选定表中的每个记录，这实际上禁用了DBMS可能应用的大部分优化。此外，此查询会在表中的每个记录上评估ϕ作为一个布尔谓词。这个谓词应该对优化查询的结果集中的每个记录（即，对于WHERE子句评估为TRUE的记录）评估为TRUE，因为无论谓词在哪里使用，它都必须始终产生相同的值。</p>
<p>步骤3：将这两个查询传递给DBMS，并比较两个结果集。对于优化查询，计算记录的数量。对于未优化的查询，计算结果集中TRUE值的数量，这应该对应于优化查询获取的记录数量。如果两者不一致，则NoREC检测到查询优化器中的一个错误。</p>
<p>该方法的经验证据显示，这种比较足以找到所有的优化错误。为了完整性，作者也描述了如何扩展NoREC以验证记录内容。</p>
<h4 id="3-2-Translating-the-Query"><a href="#3-2-Translating-the-Query" class="headerlink" title="3.2 Translating the Query"></a><strong>3.2 Translating the Query</strong></h4><p>将优化查询转换为未优化查询的过程非常直接且自动化。如图1步骤2所示，只需将WHERE子句中的条件移动到SELECT语句后，以便在表中的每一行上执行。接下来的部分详细说明了如何扩展基础方法以覆盖DBMS的其他特性。</p>
<ol>
<li>多表：在FROM子句中，可以指定从多个表中获取记录，这些表通常由WHERE子句中的谓词联接。虽然之前的示例只引用了一个表，但是该方法可以直接应用到多个表上，无需任何修改。</li>
<li>连接子句：除WHERE子句外，JOIN子句也可以用于连接两个表。在转换期间，可以保持这些JOIN子句不变。如果将其ON子句一起移动，可能需要将其翻译为多个未优化查询。<img src="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/image-20230719080916097.png" alt="image-20230719080916097"></li>
<li>ORDER BY子句：ORDER BY子句不影响结果集的基数。因此，未优化的查询可以在转换过程中省略或替换它，以便测试与此功能相关的错误。</li>
<li>GROUP BY子句：GROUP BY子句按相同的值分组记录，通常与聚合和窗口函数一起使用。如果优化查询中存在这些子句，可以将它们复制到未优化的查询中。如果这样做，需要额外的查询来求和各个组的中间计数，假设使用了聚合函数来求和表达式评估为TRUE的记录。</li>
</ol>
<blockquote>
<p>假设我们有以下优化查询：</p>
<p><font color="red">SELECT t0.c1, AVG(t0.c2) FROM t0 WHERE t0.c3 &gt; 5 GROUP BY t0.c1;</font></p>
</blockquote>
<blockquote>
<p>此查询会找出 <code>t0.c3 &gt; 5</code> 的所有记录，然后按 <code>t0.c1</code> 的值进行分组，并计算每组中 <code>t0.c2</code> 的平均值。</p>
<p>为了找出潜在的优化错误，我们需要将这个查询转换为一个未优化查询，如下：</p>
<p><font color="red">SELECT t0.c1, (t0.c3 &gt; 5) FROM t0  GROUP BY t0.c1;</font></p>
<p>在这个未优化的查询中，所有的记录都被获取，然后按 <code>t0.c1</code> 进行分组。对于每一行，我们都计算条件 <code>(t0.c3 &gt; 5)</code>，并返回一个布尔值。</p>
<p>这样，我们就可以比较优化查询和未优化查询的结果，如果它们不一致，那就可能是数据库管理系统的优化过程中存在错误。</p>
<p>为了正确比较结果，我们可能还需要一个额外的查询来汇总每个组的TRUE计数。</p>
<p>SELECT COUNT(*)<br>FROM (<br> SELECT t0.c1, (t0.c3 &gt; 5)<br> FROM t0<br> GROUP BY t0.c1<br>) as t<br>WHERE t.c3 &gt; 5;</p>
</blockquote>
<h4 id="3-3-Determining-the-Row-Count"><a href="#3-3-Determining-the-Row-Count" class="headerlink" title="3.3 Determining the Row Count"></a><strong>3.3 Determining the Row Count</strong></h4><p>对于<strong>优化查询</strong>，</p>
<p>有两种方式计算结果集中的记录数。</p>
<ol>
<li><strong>朴素方法</strong>：在这种方法中，通过DBMS返回的结果集进行迭代以确定计数。这是适用于两种查询的通用方法。</li>
<li><strong>使用COUNT(*)函数</strong>：这种方法利用了DBMS的聚合函数来计算记录数。相较于第一种方法，这种方法更高效，因为DBMS可能会对查询进行优化，并且可以避免DBMS和SQLancer之间的边界交叉带来的开销。SQLancer只需要从DBMS返回的单个记录的结果集中获取计数。</li>
</ol>
<p><img src="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/image-20230719083527208.png" alt="image-20230719083527208"></p>
<p>对于<strong>未优化查询</strong>，</p>
<p>我们假设DBMS无法对查询进行优化，因此也无法对其应用的聚合函数进行优化。由于使用聚合函数更高效，我们只使用这种策略。在这种情况下，使用SUM()函数，将布尔值解释为整数进行加和，其中TRUE为1，FALSE和NULL为0。对于某些DBMS，例如PostgreSQL和CockroachDB，它们不提供从布尔到整数的隐式转换，需要额外的转换操作。</p>
<p><img src="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/image-20230719083641413.png" alt="image-20230719083641413"></p>
<p><strong>记录检查</strong></p>
<p>此外，NoREC方法的基本思想可以扩展到检查记录的内容。如果单纯比较记录的条数，可能优化查询和未优化查询的记录条数相同，但是TRUE和优化查询的记录可能不同，因此可以使用朴素方法检查TRUE的记录和优化查询对应的记录。检查记录内容还是让我们能够在SQLite扩展中找到一个额外的错误。</p>
<h4 id="3-4-Corner-Cases-and-Limitations"><a href="#3-4-Corner-Cases-and-Limitations" class="headerlink" title="3.4 Corner Cases and Limitations"></a><strong>3.4 Corner Cases and Limitations</strong></h4><hr>
<p>在对数据库管理系统（DBMS）的一大子集进行测试的过程中，研究者们发现了一些限制和特殊情况，尽管这些限制并未妨碍他们找到错误。其中包括：</p>
<ol>
<li><strong>模糊查询</strong>：SQL查询可能模糊，因此DBMS可能会为优化查询和未优化查询返回不同的结果。实践中发现，子查询可能会带来问题，特别是当子查询可能返回多条记录与一个值进行比较时。因此，研究者们决定禁用子查询的生成，并将生成无歧义子查询作为未来工作的一部分。</li>
<li><strong>非确定性函数</strong>：查询可能是明确的，但由于非确定性函数，优化查询和未优化查询可能会产生不同的结果。这些函数包括随机数生成器和返回当前时间的函数。为了防止误报，研究者们禁用了它们的生成。</li>
<li><strong>短路评估</strong>：NoREC方法不适用于检测某种优化导致异常或错误被“优化掉”的错误。这是由于SQL并未指定AND和OR操作符是否必须短路。他们发现DBMS在优化查询和未优化查询之间可能会对此进行不一致的处理。</li>
<li><strong>其他特性</strong>：NoREC方法并不直接适用于DISTINCT子句，也不适用于计算多条记录的结果，如聚合和窗口函数。这也是影响PQS的一个限制。</li>
</ol>
<p>此外，他们还发现了SQLite的三个特殊情况：</p>
<ol>
<li><strong>SQLite中的数字比较</strong>：SQLite3将代表相同值的浮点数和整数视为相等，即使使用DISTINCT关键字，也会导致不一致的结果。他们手动过滤掉这些假阳性，然后引入一个选项，避免在视图中生成DISTINCT关键字。</li>
<li><strong>SQLite中的输入列</strong>：第二个SQLite特例涉及SQLite的dbstat扩展。WHERE子句stat.aggregate &#x3D; 1将配置选项设为TRUE，改变了查询的行为并获取了一条记录。然而，当直接在SELECT子句后使用这个谓词时，该列并未被用作输入，因此没有获取到任何记录。他们通过避免生成为这个特定列和扩展设定配置选项的子句来解决这个问题。</li>
<li><strong>SQLite中的模糊GROUP BY</strong>：第三个SQLite特例是视图中的模糊GROUP BY，与其他特性（如优化器提示）结合使用时会引发问题。他们测试的所有其他DBMS都禁止了这样的模糊GROUP BY，并且在视图创建时返回了错误。在整个测试期间，他们很少遇到这样的情况，因此在SQLancer中没有解决这个问题。</li>
</ol>
<h4 id="3-5-Query-and-Database-Generation"><a href="#3-5-Query-and-Database-Generation" class="headerlink" title="3.5 Query and Database Generation"></a><strong>3.5 Query and Database Generation</strong></h4><p>SQLancer是一个工具，用于随机生成数据库和查询，从而尝试发现数据库管理系统（DBMS）中的错误。作者扩展了SQLancer，使其能够支持更多的数据库管理系统（如CockroachDB和MariaDB），以及更多的SQL功能（例如额外的数据类型、操作符和函数）。</p>
<p>SQLancer通过随机创建表格、索引、插入数据，以及更新和删除数据，来生成数据库，以此尝试压力测试数据库管理系统，增加找到错误的可能性。SQLancer的随机查询生成的核心部分是随机表达式的生成，这些表达式在WHERE和JOIN子句中使用。</p>
<p>SQLancer通过选择适用的选项来启发式地生成这些表达式。适用的选项依赖于特定的DBMS，因为不同的DBMS支持的操作符和进行的隐式转换各不相同。表达式的生成基于相应DBMS的语法和当前数据库的架构（以生成对列和表的有效引用）。</p>
<h3 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a><strong>EVALUATION</strong></h3><p>评估的目标是展示作者提出的方法的有效性和通用性。为了实现这个目标，他们在四个广泛使用的数据库管理系统（DBMS）上测试了NoREC，这四个系统分别是SQLite，MariaDB，PostgreSQL和CockroachDB。作为这一过程的一部分，他们扩展了SQLancer，为MariaDB和CockroachDB增加了数据库和查询生成器，并且为SQLite和PostgreSQL增强了这些组件。</p>
<p>为了最大限度地提高他们的实际影响力，他们在五个月的时间内投入了大量的时间和精力，这使他们能够找到159个真实的、以前未知的错误。此外，他们分析了错误报告，以便更好地理解NoREC能够发现哪些类型的错误。由于PQS是最相关的工作，所以他们将PQS和NoREC进行了比较。</p>
<p> <strong>Selected Bugs</strong></p>
<p>这一部分概述了使用NoREC测试方法所发现的一些错误，这些错误是在SQLite、CockroachDB和MariaDB中找到的。</p>
<p>SQLite中的错误：</p>
<ol>
<li>IN运算优化不正确：SQLite错误地实现了一个将IN表达式转换为等式的优化，导致了意外的类型转换。</li>
<li>运算符交换忽略了COLLATE：SQLite交换了一个运算符，忽略了COLLATE子句，这导致了对部分索引的错误匹配。</li>
</ol>
<p>CockroachDB中的错误：</p>
<ol>
<li>向量化引擎错误：在CockroachDB的向量化引擎中发现了11个错误。其中一个错误在将两个表进行连接时，导致只提取了一个记录，而不是两个。</li>
<li>过滤器处理不正确：在一些罕见的情况下，CockroachDB被发现错误地处理CHECK约束，导致了错误的记录检索。</li>
</ol>
<p>MariaDB中的错误：</p>
<ol>
<li>字符串范围扫描不正确：MariaDB在对字符串比较进行索引范围扫描时应用错误，导致提取的行数不正确。</li>
<li>数字比较不正确：一个将浮点数与整数列进行比较的情况产生了错误结果，导致意外地提取了一条记录。</li>
</ol>
<p><strong>Bug overview</strong></p>
<ul>
<li>总共报告了168个错误，其中159个是以前未知的真正错误。开发者已经对其中141个错误进行了修复，14个错误经过验证但尚未修复，3个错误报告通过修改文档解决，9个错误被证实为错误的报告。</li>
<li>测试使用了多种方法发现错误，包括NoREC预知方法（发现了51个错误）、监控数据库创建和查询时的意外内部错误（发现了58个错误）、找出调试断言错误（发现了27个错误）和在发布构建中找出崩溃错误（发现了23个错误）。</li>
<li>扩展了一些额外的SQL子句，例如ORDER BY和GROUP BY，但它们对NoREC的错误发现能力贡献并不大。</li>
<li>在SQLite中发现的错误最多，共110个，其中71个影响到了SQLite核心。其他错误影响到了一些扩展。在SQLite的开发者添加了计算列功能后，我们在这个功能中发现了22个错误。</li>
<li>在PostgreSQL中只找到了8个错误，其中没有优化错误。这和先前的发现一致，说明PostgreSQL相对其他数据库更严格的输入检查和复杂的代码审查过程可能是错误较少的原因。</li>
<li>在CockroachDB中发现了35个错误，其中15个错误报告依赖于实验性的特性。CockroachDB的开发者基于我们的错误报告积极地添加测试设施和代码审查，以检测类似的错误。</li>
<li>在MariaDB中发现了6个错误，但只有一个在三个月内被修复，因此我们停止了对MariaDB的测试。由于我们投入的时间较少，我们相信我们的方法可能会在MariaDB中找到更多的错误。</li>
</ul>
<p><strong>Comparison to PQS</strong></p>
<p>这两者都是用来发现数据库管理系统（DBMS）中逻辑错误的工具。</p>
<p>由于几个原因，进行公平的比较相当困难：PQS的实现工作量较大；每个系统测试的DBMS集不同；无法自动进行比较。</p>
<p>作者提出了一种方法来进行公平的比较，这涉及将一个系统的测试案例转换为另一个系统的，然后在发现bug的DBMS上进行评估。</p>
<p>结果发现，PQS可以检测到NoREC找到的56.9%的错误。特定类型的错误，如涉及重复记录或聚合函数的错误，PQS无法检测到，但NoREC找到了。考虑到可能对PQS进行的改进，它可以检测到NoREC找到的82.4%的错误。另一方面，NoREC本可以找到PQS找到的52.7%的错误。然而，NoREC未能检测到大部分涉及运算符、函数和其他特性实现不正确的错误。</p>
<p>比较得出的结论是，虽然这两个系统各有优点，但PQS的实现开销更大。NoREC，其翻译过程更简单，适用于任何数据库和查询生成器。作者设想将两种方法结合起来，对DBMS进行全面测试。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/">http://example.com/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/22/go-randgen%E4%BD%BF%E7%94%A8/" title="go-randgen使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go-randgen使用</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/18/%E4%BB%80%E4%B9%88%E6%98%AF%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95/" title="什么是蜕变测试?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">什么是蜕变测试?</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction"><span class="toc-number">1.</span> <span class="toc-text">Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">背景信息:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">结果:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E8%A6%81%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">摘要：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.7.</span> <span class="toc-text">INTRODUCTION:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation-Example"><span class="toc-number">1.8.</span> <span class="toc-text">Motivation Example:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.9.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Approach-Overview"><span class="toc-number">1.9.1.</span> <span class="toc-text">3.1 Approach Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Translating-the-Query"><span class="toc-number">1.9.2.</span> <span class="toc-text">3.2 Translating the Query</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Determining-the-Row-Count"><span class="toc-number">1.9.3.</span> <span class="toc-text">3.3 Determining the Row Count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Corner-Cases-and-Limitations"><span class="toc-number">1.9.4.</span> <span class="toc-text">3.4 Corner Cases and Limitations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-Query-and-Database-Generation"><span class="toc-number">1.9.5.</span> <span class="toc-text">3.5 Query and Database Generation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EVALUATION"><span class="toc-number">1.10.</span> <span class="toc-text">EVALUATION</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/22/go-randgen%E4%BD%BF%E7%94%A8/" title="go-randgen使用">go-randgen使用</a><time datetime="2023-07-22T03:08:23.000Z" title="发表于 2023-07-22 11:08:23">2023-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/Detecting-Optimization-Bugs-in-Database-Engines-via-Non-optimizing-Reference-Engine-Construction/" title="Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction">Detecting Optimization Bugs in Database Engines via Non-optimizing Reference Engine Construction</a><time datetime="2023-07-20T02:40:56.000Z" title="发表于 2023-07-20 10:40:56">2023-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/%E4%BB%80%E4%B9%88%E6%98%AF%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95/" title="什么是蜕变测试?">什么是蜕变测试?</a><time datetime="2023-07-18T02:19:20.000Z" title="发表于 2023-07-18 10:19:20">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/" title="Testing database engines via pivoted query synthesis">Testing database engines via pivoted query synthesis</a><time datetime="2023-07-17T02:42:50.000Z" title="发表于 2023-07-17 10:42:50">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?">History-Driven Build Failure Fixing: How Far Are We?</a><time datetime="2023-07-09T07:58:11.000Z" title="发表于 2023-07-09 15:58:11">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>