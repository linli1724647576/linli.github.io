<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级刷题指南</title>
    <url>/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="PAT甲级刷题指南"><a href="#PAT甲级刷题指南" class="headerlink" title="PAT甲级刷题指南"></a>PAT甲级刷题指南</h1><h2 id="《算法笔记》C-标准模板库-STL-介绍"><a href="#《算法笔记》C-标准模板库-STL-介绍" class="headerlink" title="《算法笔记》C++标准模板库(STL)介绍"></a>《算法笔记》C++标准模板库(STL)介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>变长数组</p>
<h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、vector&lt;int&gt; v(size,0);  //初始化为0</span><br><span class="line">2、vector&lt;int&gt; v;  v.resize(n,0);  //resize一个大小为n，初值为0的可变数组</span><br><span class="line">3、vector&lt;type&gt; v;   //不初始化,type可以是一个结构体</span><br><span class="line">4、vector&lt;int&gt; ilist2(v);  vector&lt;int&gt; ilist2  = v;   //两种方式等价，都是深拷贝</span><br><span class="line">5、vector&lt;int&gt; ilist = &#123;1,2,3.0,4,5,6,7&#125;;   //和数组初始化方法一样</span><br><span class="line">6、vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1);   //迭代器初始化</span><br></pre></td></tr></table></figure>

<h5 id="访问："><a href="#访问：" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、随机访问数组下标访问 v[i]</span><br><span class="line">2、迭代器访问数组</span><br><span class="line">    vector&lt;int&gt;::iterator iter;</span><br><span class="line">    for(iter = vi.begin();iter != vi.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a><strong>常用函数</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、插入push_back  v.push_back(i);</span><br><span class="line">2、删除pop_back   v.pop_back();  //删除最后一个元素，回溯的时候常用</span><br><span class="line">3、大小size    v.size();  //获取数组大小</span><br><span class="line">4、清空clear   v.clear(); //清空数组</span><br><span class="line">5、插入insert  //尽量不要频繁使用这个函数，会引起大量数据移动，降低程序效率</span><br><span class="line">    v.insert(v.begin(),8);//在最前面插入新元素</span><br><span class="line">    v.insert(v.begin()+3,1);//在迭代器中下标为3的元素前插入新元素</span><br><span class="line">    v.insert(v.end(),3);//在向量末尾追加新元素</span><br><span class="line">    v.insert(v.end(),3,0);//在尾部插入3个0</span><br><span class="line">6、删除erase  //erase函数有两种函数原型，一种是给定要删除的位置，另一种是给定删除的区域。</span><br><span class="line">	有两种函数原型，c.erase (p),c.erase(b,e);第一个删除迭代器p所指向的元素，第二个删除迭代器b,e所标记的范围内的元素，c为容器对象，返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点）</span><br><span class="line">	应用一：删除连续数字</span><br><span class="line">	//但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); iter++)  </span><br><span class="line">	&#123;</span><br><span class="line">      if(*iter == 3)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">	&#125;</span><br><span class="line">	//可以删除连续的数字3</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">     if( *iter == 3)</span><br><span class="line">          iter = veci.erase(iter);//当删除时erase函数自动指向下一个位置，就不需要进行++</span><br><span class="line">      else</span><br><span class="line">            iter ++ ;    //当没有进行删除的时候，迭代器++</span><br><span class="line">	&#125;</span><br><span class="line">	//另一种解决无法删除连续的数字的方法</span><br><span class="line">	我们先介绍一下remove函数:</span><br><span class="line">    remove是个stl的通用算法std::remove(first,last,val)移除[first, last)范围内等于val的元素在vector里面用就类似于 iter=std::remove(vec.begin(), vec.end(), val)但这个函数只是把val移到vec的末尾，并不真正删除,真正删除还是要调用一次erase函数</span><br><span class="line">    veci.erase(remove(vec.begin(),vec.end(),3),vec.end());</span><br><span class="line">    </span><br><span class="line">    应用二：删除重复数字，顺序不发生变化</span><br><span class="line">    如果不要求顺序的话，我们可以直接调用unique函数进行操作，这里介绍一下unique函数：从头到尾，判断当前元素是否等于上一个元素，将不重复的元素移到前面来(赋值操作)，而不是将重复的元素移动到后面去。</span><br><span class="line">    vec.erase(unique(vec.begin(),vec.end()),vec.end())  //将重复的区域删除，顺序会改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a><strong>常见错误</strong>：</h5><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814163126705.png" alt="image-20210814163126705"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>是一个内部自动有序且不含重复元素的容器</p>
<p>unordered_set 无序 其余和set的用法一样，效率更高</p>
<h5 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s(b, e);</span><br><span class="line">比如：</span><br><span class="line">int arr[]=&#123;1,2,3,4,3,2,1&#125;;</span><br><span class="line">set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-1"><a href="#访问：-1" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、迭代器访问</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt;::iterator it</span><br><span class="line">for(it = st.begin();it != st.end();it++)&#123;</span><br><span class="line">	printf(&quot;%d &quot;,*it);</span><br><span class="line">&#125; </span><br><span class="line">2、随机访问   在set中查找2，返回其迭代器</span><br><span class="line">set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">printf(&quot;%d &quot;,*it);</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	set&lt;int&gt; st;</span><br><span class="line">1、插入 insert()</span><br><span class="line">	st.insert(3);</span><br><span class="line">2、查找 find()</span><br><span class="line">	set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">	if(st.find(2)==st.end()) printf(&quot;没找到&quot;);</span><br><span class="line">3、删除  erase()</span><br><span class="line">st.erase(it) it为需要删除元素的迭代器，复杂度O(1)</span><br><span class="line">st.erase(value) value为要删除元素的值，复杂度O(logN)</span><br><span class="line">	st.erase(st.find(2));</span><br><span class="line">	st.erase(2)，效果一致，两种用法</span><br><span class="line">4、获取元素个数 size()</span><br><span class="line">	cout&lt;&lt;&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">5、清空 clear()</span><br><span class="line">	st.clear(); </span><br><span class="line">6、判空 empty()</span><br><span class="line">	st.empty()</span><br></pre></td></tr></table></figure>





<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>字符串</p>
<h5 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string s1;  s1为空字符串</span><br><span class="line">2、string s2(&quot;ABC&quot;);  用字符串字面值初始化s2</span><br><span class="line">3、string s3(s2);  用s3初始化为s2的一个副本</span><br><span class="line">4、string s4(n,&#x27;c&#x27;);  将s4初始化为字符&#x27;c&#x27;的n个副本</span><br></pre></td></tr></table></figure>

<h5 id="访问：-2"><a href="#访问：-2" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过下标访问</span><br><span class="line">    string str = &quot;abcd&quot;;</span><br><span class="line">    for(int i=0;i &lt; str.length();i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,str[i]);</span><br><span class="line">    &#125; </span><br><span class="line">2、通过迭代器访问</span><br><span class="line">    cout&lt;&lt;&quot;通过迭代器访问如下：&quot;&lt;&lt;endl;</span><br><span class="line"> for(string::iterator;it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,*it);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-2"><a href="#常用函数：-2" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、判空 s.empty()</span><br><span class="line">2、统计字符个数  s.size()  /   s.length()</span><br><span class="line">3、拼接字符串 += </span><br><span class="line">	str3 = str1+str2;  //拼接后再赋值</span><br><span class="line">	str1 += str2;  //直接接在后面，效率更高</span><br><span class="line">4、字符串比较大小 == != &gt;=等等</span><br><span class="line">5、插入 insert()</span><br><span class="line"> insert(pos,string) 在pos位置插入string</span><br><span class="line"> insert(it,it2,it3) 在it位置插入 [it2,it3)的串，it2,it3为待插字符串的首尾迭代器</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line"> 	str2 = &quot;opq&quot;;     //insert(pos,string)</span><br><span class="line">	str1.insert(3,str2);</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.insert(str1.begin()+3,str2.begin(),str2.end());     //insert(it,it2,it3)</span><br><span class="line">	cout&lt;&lt;&quot;abcopqxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">6、删除单个元素、区间元素 erase()</span><br><span class="line"> 删除单个元素 str.erase(it)  it为删除元素的迭代器</span><br><span class="line"> 删除一个区间内的所有元素 str.erase(first,last) [first,last)</span><br><span class="line"> str.erase(pos,length) pos为开始位置，length为长度</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcopqopqxyz&quot;;</span><br><span class="line"> 	str1.erase(str1.begin()+3);//str.erase(it)删除4号位o </span><br><span class="line">	cout&lt;&lt;&quot;abcopqopqxyz字符串删除第四个位置o字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(str1.begin()+3,str1.end()-3);//str.erase(first,last)</span><br><span class="line">	cout&lt;&lt;&quot;abcpqopqxyz字符串删除第4~8位置字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(3,3);//str.erase(ipos,length)</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串删除从第4位置开始的3个字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">7、清空 clear()</span><br><span class="line">	str1.clear();</span><br><span class="line">8、子串 substr()</span><br><span class="line"> substr(pos,len) 返回从pos号开始，长度为len子串</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串从下标2开始长度为3的子串为：&quot;&lt;&lt;str1.substr(2,3)&lt;&lt;endl;</span><br><span class="line">9、查找 find()</span><br><span class="line"> str.find(str2) 当str2是str的子串时，返回其在str中第一次出现的位置，如果str2不是str的子串，返回string::npos（常数）</span><br><span class="line"> str.find(str2,pos) 从str的pos号位置开始匹配str2，返回指相同</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;,str2=&quot;xyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;xyz子串在abcxyz中第一次出现的位置为：&quot;&lt;&lt;str1.find(str2)&lt;&lt;endl;  </span><br><span class="line">	</span><br><span class="line">	position = s.find(&quot;jk&quot;);</span><br><span class="line">	if (position != s.npos) printf(&quot;position is : %d\n&quot; ,position);  //查找成功</span><br><span class="line">	else printf(&quot;Not found the flag\n&quot;);  //查找失败</span><br><span class="line"> 10、替换 replace()</span><br><span class="line">  str.replace(pos,len,str2) 把str从pos号开始，长度为len的子串替换为str2</span><br><span class="line">  str.replace(it1,it2,str) 把str的迭代器[it1,it2)返回的子串替换为str2</span><br><span class="line">  	str1 = &quot;Maybe you will turn around.&quot;;</span><br><span class="line">	str2 = &quot;will not&quot;;str3 = &quot;surely&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will turn around.字符串从第10位开始的4位替换为str2后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(10,4,str2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will not turn around.字符串从起始位开始的5位替换为str3后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(str1.begin(),str1.begin()+5,str3)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h5 id="string和char-的转换"><a href="#string和char-的转换" class="headerlink" title="string和char[]的转换"></a>string和char[]的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string转char*</span><br><span class="line">printf(&quot;%s&quot;,str.c_str());</span><br><span class="line">2、char* 转string</span><br><span class="line">	char* p = &quot;abc&quot;;</span><br><span class="line">    string s = p;</span><br></pre></td></tr></table></figure>

<h5 id="string和int等类型的转换"><a href="#string和int等类型的转换" class="headerlink" title="string和int等类型的转换"></a>string和int等类型的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转string:</span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br><span class="line">转Int</span><br><span class="line">stoi(str1);  //int</span><br><span class="line">stof(str1);  //float</span><br><span class="line">stoll(str1);  //long long </span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string strA = &quot;yasaken@126.com&quot;;</span><br><span class="line">    string strB = &quot;LURY@LENOVO.com&quot;;</span><br><span class="line">    printf(&quot;Before transform:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::toupper);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::toupper);</span><br><span class="line">    printf(&quot;After transform to toupper:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::tolower);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::tolower);</span><br><span class="line">    printf(&quot;After transform to lower:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>map即映射，是常用的STL容器，它可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<p>uordered_map无序容器，效率更高</p>
<h5 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、直接赋值</span><br><span class="line">map&lt;string, int&gt; m1;</span><br><span class="line">m1[string(&quot;abc&quot;)] ++;</span><br><span class="line">//如果“abc&quot;已经存在，会在原来的基础上++，如果不存在，则会创建一个hash_key</span><br><span class="line"></span><br><span class="line">2、用insert添加</span><br><span class="line">map&lt;string, int&gt; m2;</span><br><span class="line">m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-3"><a href="#访问：-3" class="headerlink" title="访问："></a>访问：</h5><p>map会以键从小到大的顺序自动排序，unordered_map则不会排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过key访问value</span><br><span class="line">	map&lt;char,int&gt; mp;</span><br><span class="line">	//通过下标访问 </span><br><span class="line">	mp[&#x27;c&#x27;] = 20;</span><br><span class="line">	mp[&#x27;c&#x27;] = 30;//20被覆盖</span><br><span class="line">	printf(&quot;%d\n&quot;,mp[&#x27;c&#x27;]);//输出30</span><br><span class="line">2、通过迭代器访问</span><br><span class="line">	for(map&lt;char,int&gt;::iterator it = mp.begin();it != mp.end();it++)&#123;</span><br><span class="line">		//it-&gt;first是当前映射的键；it-&gt;second是当前映射的值 </span><br><span class="line">		printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-3"><a href="#常用函数：-3" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查找  find()</span><br><span class="line">     if(M.find(exponent)!=M.end())&#123;</span><br><span class="line">     	printf(&quot;%d&quot;,M[exponent]);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	printf(&quot;没找到&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	map&lt;char,int&gt;::iterator it = mp.find(&#x27;b&#x27;);</span><br><span class="line">	printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">2、删除 erase</span><br><span class="line"> mp.erase(key);  key为想要删除的键</span><br><span class="line"> mp.erase(first,last); 删除一个区间内的元素，first,last为迭代器</span><br><span class="line"> 	it = mp.find(&#x27;m&#x27;);</span><br><span class="line">	mp.erase(it);//删除b 2</span><br><span class="line">	mp.erase(&#x27;r&#x27;);//删除b 2</span><br><span class="line">3、获取大小 size()</span><br><span class="line">	cout&lt;&lt;&quot;此时map的长度为：&quot;&lt;&lt;mp.size();</span><br><span class="line">4、清空 clear()</span><br><span class="line">	mp.clear();</span><br></pre></td></tr></table></figure>

<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap:"></a>multimap:</h5><p>multimap 和 map 很相似，但是 multimap 允许重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multimap&lt;int, string&gt; multi_map;		// 可实现多重映射</span><br><span class="line"></span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng1&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng2&quot; &#125;);</span><br><span class="line">for (auto&amp; i: multi_map)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; &quot;  &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">520  huameng</span><br><span class="line">520  huameng1</span><br><span class="line">520  huameng2</span><br></pre></td></tr></table></figure>



<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>Queue翻译为队列，理解为一个先进先出的容器</p>
<h5 id="queue初始化："><a href="#queue初始化：" class="headerlink" title="queue初始化："></a>queue初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; first;                 // empty queue</span><br></pre></td></tr></table></figure>

<h5 id="访问：-4"><a href="#访问：-4" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问队首元素：如q.front()</span><br><span class="line">访问队尾元素，如q.back();</span><br><span class="line">printf(&quot;%d %d\n&quot;,q.front(),q.back());</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-4"><a href="#常用函数：-4" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size()-容器大小</span><br><span class="line">empty()-容器判空</span><br><span class="line">push()尾部增加元素</span><br><span class="line">pop()删除尾部元素</span><br></pre></td></tr></table></figure>

<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue:"></a>priority_queue:</h5><p>在&lt; queue&gt;头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</p>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义priority_queue对象</span><br><span class="line">priority_queue&lt;int &gt;q1;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q2;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;//定义小的先出队</span><br><span class="line">//其中第二个参数( vector )，是来承载底层数据结构堆的容器，第三个参数( less )，则是一个比较类，</span><br><span class="line">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span><br></pre></td></tr></table></figure>

<p>priority_queue的基本操作均与queue相同，<strong>优先队列没有back（）操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>

<p>操作示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//---1---push()</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---2---top()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;优先队列341的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());  <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//---3---pop()</span></span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;弹出队首元素后优先队列的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());   <span class="comment">//3</span></span><br><span class="line">	<span class="comment">//---4---empty()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列为空吗？&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;Not Empty\n&quot;</span>);</span><br><span class="line">	<span class="comment">//---5---size()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列大小为：&quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级操作示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级队列优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//---1---基本数据类型：设置优先级队列总是把最小的元素放在队首 </span></span><br><span class="line">	<span class="comment">// priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //小顶堆</span></span><br><span class="line">    <span class="comment">//注意&lt;int&gt; &gt;之间的空格 </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//大顶堆</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体优先级的设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;  <span class="comment">//价格大的优先</span></span><br><span class="line">        <span class="comment">//return f1.price &gt; f2.price; //价格小的优先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"><span class="comment">//需要重载小于号，只能重载小于号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;fruit&gt; q;  <span class="comment">//价格大的优先</span></span><br><span class="line">    <span class="comment">//这边就不能再加greater或less了</span></span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似Cmp写在外面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//重载优先级结构体进行排序 </span></span><br><span class="line">	priority_queue&lt;fruit&gt; q;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//梨子 4</span></span><br><span class="line">    <span class="comment">//用cmp函数优先级排序 </span></span><br><span class="line">	priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; qq;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	qq.<span class="built_in">push</span>(f1);</span><br><span class="line">	qq.<span class="built_in">push</span>(f2);</span><br><span class="line">	qq.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;qq.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;qq.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//苹果 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>stack即栈，是一种先进后出的容器，区别于queue；</p>
<h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stk;</span><br></pre></td></tr></table></figure>

<h5 id="访问：-5"><a href="#访问：-5" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问栈顶元素 stk.top()</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-5"><a href="#常用函数：-5" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push() 压栈</span><br><span class="line">top() 取栈顶元素</span><br><span class="line">pop() 出栈</span><br><span class="line">empty() 判空</span><br><span class="line">size() 获取大小</span><br><span class="line">//---1、2、3---push()、top()、pop() </span><br><span class="line">for(int i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line">	st.push(i);//将i压入栈 </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;入栈12345的栈顶为：&quot;;</span><br><span class="line">cout&lt;&lt;st.top()&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i &lt;= 3;i++)&#123;</span><br><span class="line">	st.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;出栈3个元素后栈顶为：&quot;;</span><br><span class="line">printf(&quot;%d\n&quot;,st.top());</span><br><span class="line">//---4---empty()</span><br><span class="line">cout&lt;&lt;&quot;此时栈为空吗？&quot;&lt;&lt;endl;</span><br><span class="line">if(st.empty() == true)  printf(&quot;Empty\n&quot;);</span><br><span class="line">else printf(&quot;Not Empty\n&quot;);</span><br><span class="line">//---5---size()</span><br><span class="line">cout&lt;&lt;&quot;此时队列大小为：&quot;&lt;&lt;st.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>Pair可以看作一个内部有两个元素的结构体，且这两个元素的类型可以指定</p>
<h5 id="初始化：-5"><a href="#初始化：-5" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">pair&lt;int, double&gt; p2(1, 2.4);  //用给定值初始化</span><br><span class="line">pair&lt;int, double&gt; p3(p2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<h5 id="访问：-6"><a href="#访问：-6" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &#x27; &#x27; &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-6"><a href="#常用函数：-6" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、比较操作数 &lt;.&gt;,&lt;=,==</span><br><span class="line">//比较规则是先比较first，再比较second</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; p1(5,10);</span><br><span class="line">	pair&lt;int,int&gt; p2(5,15);</span><br><span class="line">	pair&lt;int,int&gt; p3(10,5);</span><br><span class="line">	if(p1 &lt; p3)	printf(&quot;p1 &lt; p3\n&quot;);</span><br><span class="line">	if(p1 &lt;= p3)	printf(&quot;p1 &lt;= p3\n&quot;);</span><br><span class="line">	if(p1 &lt; p2)	printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2、make_pair 赋值</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line"> </span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line"> </span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br></pre></td></tr></table></figure>

<h5 id="常用于作为map的键值对进行插入："><a href="#常用于作为map的键值对进行插入：" class="headerlink" title="常用于作为map的键值对进行插入："></a>常用于作为map的键值对进行插入：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">//pair作为map键值对进行插入 </span><br><span class="line">mp.insert(make_pair(&quot;heihei&quot;,5));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,10));</span><br></pre></td></tr></table></figure>



<h3 id="algorithm常用函数"><a href="#algorithm常用函数" class="headerlink" title="algorithm常用函数"></a>algorithm常用函数</h3><h5 id="max-、min-、abs"><a href="#max-、min-、abs" class="headerlink" title="max()、min()、abs()"></a>max()、min()、abs()</h5><p>最大值、最小值、绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=-2;</span><br><span class="line">printf(&quot;%d %d\n&quot;,max(x,y),min(x,y));</span><br><span class="line">printf(&quot;%d %d\n&quot;,abs(x),abs(y));</span><br></pre></td></tr></table></figure>

<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换两个元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=2;</span><br><span class="line">swap(x,y);</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>1.会将区间内的元素全部逆序。常用于数组，字符串，容器等，其本身的函数参数也不复杂。<br>2.容器类型的要用begin()和end()来指定反转的区域，数组类型的直接用int类型即可。<br>3.reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;</span><br><span class="line">reverse(v.begin(),v.end());//v的值为1,2,3,4,5</span><br><span class="line">string str=&quot;www.mathor.top&quot;;</span><br><span class="line">reverse(str.begin(),str.end());//str结果为pot.rohtam.wwww</span><br></pre></td></tr></table></figure>

<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>1.按照单元赋值，将一个区间的元素都赋同一个值<br> 2.fill(arr, arr + n, 要填入的内容);<br> fill(vector.begin(), vector.end(), val);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">fill(arr, arr + 10, 2);</span><br><span class="line">vector&lt;int&gt;  v&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">fill(v.begin(), v.end(), -1);</span><br><span class="line">vector&lt;int&gt; myvector (8);// myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">fill (myvector.begin(),myvector.begin()+4,5);</span><br><span class="line">// myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">fill (myvector.begin()+3,myvector.end()-2,8);</span><br><span class="line">// myvector: 5 5 5 8 8 8 0 0</span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>1.Sort函数有三个参数：<br>（1）第一个是要排序的数组的起始地址。<br>（2）第二个是结束的地址（最后一位要排序的地址的下一地址）<br>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。<br>2.Sort函数使用模板:Sort(start,end,排序方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组排序</span><br><span class="line">int IntValue[5] = &#123;1,4,3,8,5&#125;;</span><br><span class="line">sort(IntValue,IntValue+5);</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">	cout&lt;&lt;IntValue[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">2、vector排序</span><br><span class="line">vector&lt;int&gt; v = &#123;2,6,4,9,6,0,3&#125;;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">vector&lt;int&gt;::iterator  start;</span><br><span class="line">for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">	cout&lt;&lt;(*start)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">3、自定义排序</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">linli1 20</span><br><span class="line">linli2 24</span><br><span class="line">linli6 8</span><br><span class="line">linli3 8</span><br><span class="line"> * */</span><br><span class="line">typedef struct stu&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;stu;</span><br><span class="line">bool cmp(stu u,stu g)&#123;  //&lt;表示升序排序</span><br><span class="line">    if(u.age==g.age)&#123;</span><br><span class="line">        return u.name&lt;g.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.age&lt;g.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;stu&gt; v;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        stu c ;</span><br><span class="line">        cin&gt;&gt;c.name&gt;&gt;c.age;</span><br><span class="line">        v.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end(),cmp);</span><br><span class="line">    vector&lt;stu&gt;::iterator  start;</span><br><span class="line">    for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">        cout&lt;&lt;(*start).name&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h5><p><strong>lower_bound：</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于或等于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;lower_bound(a+l,a+r,key)-a；(a是数组)。</p>
<p><strong>upper_bound:</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（同样这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;upper_bound(a+l,a+r,key)-a；(a是数组)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int board[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int t1 = lower_bound(board,board+5,3)-board; //2</span><br><span class="line">int t2 = upper_bound(board,board+5,3)-board; //3</span><br></pre></td></tr></table></figure>



<h2 id="PAT真题模拟"><a href="#PAT真题模拟" class="headerlink" title="PAT真题模拟"></a>PAT真题模拟</h2><h3 id="PAT-1001"><a href="#PAT-1001" class="headerlink" title="PAT 1001"></a>PAT 1001</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330182108486.png" alt="image-20210330182108486"></p>
<p>我的做法，难点在于如何3位3位加一个逗号，我用栈来存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="type">int</span> cishu;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(c);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">3</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;s[i];</span></span><br><span class="line">    <span class="comment">// 	if(s[i]!=&#x27;-&#x27;&amp;&amp;(i!=s.length()-1)&amp;&amp;(s.length()-i-1)%3==0) cout&lt;&lt;&quot;,&quot;;//后面剩下3n个数时 要加&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大神的做法见注释，好像比较难想到。</p>
<h3 id="PAT-1002"><a href="#PAT-1002" class="headerlink" title="PAT 1002"></a>PAT 1002</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330183857126.png" alt="image-20210330183857126"></p>
<p>多项式加法，通过第一个测试点不是很难。</p>
<p>注意点： <strong>系数为0时不进行输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line">    <span class="type">int</span> n,m;   cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a; <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">find</span>(a)!=M.<span class="built_in">end</span>()) M[a] += b;</span><br><span class="line">        <span class="keyword">else</span> M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330190215218.png" alt="image-20210330190215218"></p>
<p>具体还有两个未通过也不知道是怎么回事</p>
<p>map的倒叙遍历需要掌握</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1003-dijstra"><a href="#PAT-1003-dijstra" class="headerlink" title="PAT 1003 (dijstra)"></a>PAT 1003 (dijstra)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155146524.png" alt="image-20210401155146524"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155200043.png" alt="image-20210401155200043"></p>
<p> 题目翻译：</p>
<p>你是一个救援队长，你要救援有危险的城市，你需要尽可能快的到达有危险的城市，并且带尽可能多的人。</p>
<p>输入：</p>
<p>第1行：4个正整数： 城市数量N、 路数量M、你在的城市、你要救援的城市。</p>
<p>第2行：N个整数，第i个数表示第i个城市的救援队数量。</p>
<p>然后M行：每一行表示一条路，三个数字分别是起点、终点、距离。</p>
<p>保证至少有一条路让你去你要救援的城市。</p>
<p>输出：</p>
<p>最短路径条数  可带的最多人数  (我输出理解成了最短路径长度…)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *dist;   <span class="comment">//保存最短路径</span></span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//s集合，表示已经访问过</span></span><br><span class="line"><span class="type">int</span> *rescue;    <span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> **e;      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> *pre;     <span class="comment">//pre记录路径</span></span><br><span class="line"><span class="type">int</span> *rm;      <span class="comment">//能够到达i点的最多人数</span></span><br><span class="line"><span class="type">int</span> *num_of_shortest;  <span class="comment">//能够到达i点的最短路径条数</span></span><br><span class="line"><span class="type">int</span> N,M,C1,C2;</span><br><span class="line"><span class="type">int</span> maxrescue = <span class="number">0</span>;  <span class="comment">//最大救援队数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    rescue = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    pre = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    rm = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(rm,<span class="number">0</span>,<span class="built_in">sizeof</span>(rm));</span><br><span class="line">    num_of_shortest = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  <span class="comment">//初始化城市救援队数量</span></span><br><span class="line">        cin&gt;&gt;rescue[i];</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">new</span> <span class="type">int</span>*[N];     <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> e[i][j]=<span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c1,c2,length;  </span><br><span class="line">        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length;</span><br><span class="line">        e[c1][c2] = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;N;j++)</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;&quot;e[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]&quot;&lt;&lt;e[i][j]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[C1] = <span class="number">1</span>;</span><br><span class="line">    num_of_shortest[C1] = <span class="number">1</span>;</span><br><span class="line">    rm[C1] = rescue[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dist[i] = e[C1][i];</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&lt;<span class="number">9999</span>)&#123;   <span class="comment">//能够到达</span></span><br><span class="line">            pre[i]=C1;</span><br><span class="line">            rm[i] = rescue[C1]+rescue[i];</span><br><span class="line">            num_of_shortest[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;e[C1][4]&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; :&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">99999</span>,u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//选出下一次要加入s集合的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[i]&lt;min)&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//更新dist数组</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]&lt;dist[i])&#123;</span><br><span class="line">                dist[i] = dist[u] + e[u][i];</span><br><span class="line">                pre[i]=u;</span><br><span class="line">                rm[i] = rm[u]+rescue[i];</span><br><span class="line">                num_of_shortest[i] = num_of_shortest[u];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]==dist[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(rm[u]+rescue[i]&gt;rm[i])&#123;</span><br><span class="line">                    pre[i]=u;</span><br><span class="line">                    rm[i] = rm[u]+rescue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num_of_shortest[i] += num_of_shortest[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dijstra</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num_of_shortest[C2]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rm[C2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401160800655.png" alt="image-20210401160800655"></p>
<p>dijstra的套路算法，关键是需要增加几个判别的数组，一个是有多少条最短路径num_of_shortest，另一个是当前可以到达的最多救援队数量rm。</p>
<h3 id="PAT-1004（按层统计树的叶子节点）"><a href="#PAT-1004（按层统计树的叶子节点）" class="headerlink" title="PAT 1004（按层统计树的叶子节点）"></a>PAT 1004（按层统计树的叶子节点）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405155805312.png" alt="image-20210405155805312"></p>
<p>题意：按照每一层统计树的叶子节点个数</p>
<p>第一行输入 N&#x3D;2 树的节点       M&#x3D;1 非叶子节点个数</p>
<p>下面M行表示非叶子节点所跟的孩子  01 1 02    01表示 01号节点 ，1表示有一个孩子，02表示01的孩子的ID。</p>
<p><strong>题解</strong>：</p>
<p>第一步当然是想数据结构，用什么数据结构来存储这棵树呢？由于树的度不确定，我们很难使用二叉树的链式结构来存储，最初想到的是使用孩子兄弟链表进行存储，但最后发现构造这一棵树并不是太容易，而且我们只是需要统计每一层的非叶子节点数而已。我们不如直接使用结构体数组来存储这棵树，结构体包括ID，节点的孩子vector<int> child ，layer层数，这样我们统计每个节点是否是叶子节点的时候就可以使用child.size()来判断。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br></pre></td></tr></table></figure>

<p>其次就是有几个注意点：在分配内存空间的时候需要注意 如果是new，在堆上分配，内存的数据可以是任意的，意味着我们需要额外的初始化。如果使用Tseq[N+1]这种在栈上分配内存的状况，就可以不用初始化，这也导致我几个测试点过不了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">Tree_Node Tseq[N+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>还有一个坑点是，我们统计每一个节点的层数是，利用双亲节点的层数+1，这样有一个问题，要是先输入孩子节点，再输入双亲节点统计就有问题。<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20210405160649369.png" alt="image-20210405160649369" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以需要对输入的结点ID的大小进行排序，确保上层的节点先被统计进来。这样做法虽然有点蠢，但最后得了27分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">next_input</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numvec;</span><br><span class="line">&#125;next_input;</span><br><span class="line">vector&lt;next_input&gt; input_vector;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(next_input a,next_input b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;   cin&gt;&gt;N&gt;&gt;M;    <span class="comment">//N节点数  M非叶子节点数  </span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// Tree_Node* Tseq; </span></span><br><span class="line">    <span class="type">int</span> maxlayer;  <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">    Tree_Node Tseq[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        Tseq[i].ID = i;  <span class="comment">//分配序号</span></span><br><span class="line">    Tseq[<span class="number">1</span>].layer = <span class="number">1</span>;  <span class="comment">//01节点为根节点，层数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//把输入变成一个vector，然后再排序，以免计算层数时出错</span></span><br><span class="line">        next_input input;</span><br><span class="line">        <span class="type">int</span> id,num,child;  </span><br><span class="line">        cin&gt;&gt;id&gt;&gt;num;</span><br><span class="line">        input.id = id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;child;  input.numvec.<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        input_vector.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(input_vector.<span class="built_in">begin</span>(),input_vector.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//统计节点的层数和孩子</span></span><br><span class="line">        <span class="type">int</span> id,num,childnum;</span><br><span class="line">        id = input_vector[i].id;</span><br><span class="line">        num = input_vector[i].numvec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            childnum = input_vector[i].numvec[j];</span><br><span class="line">            Tseq[id].child.<span class="built_in">push_back</span>(childnum);</span><br><span class="line">            Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        maxlayer = <span class="built_in">max</span>(maxlayer,Tseq[i].layer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;  <span class="comment">//第i层有几个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxlayer;i++)&#123;</span><br><span class="line">        Map[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Tseq[i].child.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;   <span class="comment">//是叶子节点</span></span><br><span class="line">            Map[Tseq[i].layer]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ::iterator iter;</span><br><span class="line">    cout&lt;&lt;Map.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    iter = Map.<span class="built_in">begin</span>(); iter++;</span><br><span class="line">    <span class="keyword">for</span>(;iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405160805791.png" alt="image-20210405160805791"></p>
<p>最后一个测试点有点懵</p>
<p>如果考虑到只有一个节点的情况，if(N&#x3D;&#x3D;1){ cout&lt;&lt;”1”&lt;&lt;endl;return 0;} 这句话会根据出现在不同的位置而产生不同的结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405161716830.png" alt="image-20210405161716830"></p>
<h3 id="PAT-1005"><a href="#PAT-1005" class="headerlink" title="PAT 1005"></a>PAT 1005</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404205053583.png" alt="image-20210404205053583"></p>
<p>计算一个数的个位数字之和，英文输出。比较简单，十分钟搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string Map[] = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        count += (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ss = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ss;</span></span><br><span class="line">    cout&lt;&lt;Map[ss[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ss.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Map[ss[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1006"><a href="#PAT-1006" class="headerlink" title="PAT 1006"></a>PAT 1006</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404211724478.png" alt="image-20210404211724478"></p>
<p>水题，比较来上班最早的和来上班最晚的，直接写一个结构体比较就好了，二十分钟能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    string early;</span><br><span class="line">    string later;</span><br><span class="line">&#125;person;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpearly</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.early);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.early);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&lt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmplater</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.later);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.later);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&gt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt;  vec_person;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        person p;</span><br><span class="line">        cin&gt;&gt;p.id&gt;&gt;p.early&gt;&gt;p.later;</span><br><span class="line">        vec_person.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmpearly);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmplater);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1007（动态规划）"><a href="#PAT-1007（动态规划）" class="headerlink" title="PAT 1007（动态规划）"></a>PAT 1007（动态规划）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404222558427.png" alt="image-20210404222558427"></p>
<p>leetcode经典题，最大连续子序列和，一想就知道使用动态规划。</p>
<p>坑点1： output the one with the smallest indices i and j (as shown by the sample case). 这句话的意思是输出开始的数，而不是下标，整了一小时。</p>
<p>坑点2： If all the K numbers are negative, then its maximum sum is defined to be 0, and you  are supposed to output the first and the last numbers of the whole  sequence.  这句话记得看就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; seq.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[seq.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="type">int</span> pre[seq.<span class="built_in">size</span>()];</span><br><span class="line">    dp[<span class="number">0</span>] = seq[<span class="number">0</span>];  pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>,maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;seq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+seq[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = seq[i];</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsub)&#123;</span><br><span class="line">            maxsub = dp[i];  maxi = pre[i]; maxj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxsub&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxsub&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxi]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxj];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这儿的dp定义的略有不同，不过无伤大雅，dp[i]是指以i结尾的最大连续子序列和。</p>
<h3 id="PAT-1008"><a href="#PAT-1008" class="headerlink" title="PAT 1008"></a>PAT 1008</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404223852830.png" alt="image-20210404223852830"></p>
<p>水题。电梯上升一层6s，下降一层4s，每层有需要停留5s，求电梯所需要时间。十分钟解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; v.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//代表现在电梯到哪一层了</span></span><br><span class="line">    <span class="type">int</span> total_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((v[i]-temp)&gt;=<span class="number">0</span>)&#123;  <span class="comment">//上升</span></span><br><span class="line">            total_time += (v[i]-temp)*<span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//下降</span></span><br><span class="line">            total_time += (temp-v[i])*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = v[i];</span><br><span class="line">        total_time += <span class="number">5</span>; <span class="comment">//停留</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total_time;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1009"><a href="#PAT-1009" class="headerlink" title="PAT 1009"></a>PAT 1009</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210409154552498.png" alt="image-20210409154552498"></p>
<p>和pat1002类似，这里做的是乘法A * B,可以采用暴力法二重循环。</p>
<p>注意的是如果系数等于0则不输出。</p>
<p>不能使用cout&lt;&lt;M.size();  来统计输出的个数，因为会把系数为0的统计进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n]; <span class="type">double</span> b[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k; cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> ai; <span class="type">double</span> bi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> exponent = ai+a[j];</span><br><span class="line">            <span class="type">double</span> coefficient = bi*b[j];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(exponent)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                M[exponent] += coefficient;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                M[exponent] = coefficient;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;M.size();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1010（数学题）"><a href="#PAT-1010（数学题）" class="headerlink" title="PAT 1010（数学题）"></a>PAT 1010（数学题）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202035024.png" alt="image-20210410202035024"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202048687.png" alt="image-20210410202048687"></p>
<p>题目大意：N1 N2 tag radix</p>
<p>N1 N2 为两个数，基数未定，范围从[0-9] [a-z]，radix表示一个数的基数（tag&#x3D;1，则表示N1 的基数，tag&#x3D;2则表示N2的基数）我们要求另一个数的基数，使得N1&#x3D;N2。若不存在则输出”Impossible”。</p>
<p>最初的想法是把一个数的十进制算出来，另一个数从2 一直往上遍历，遍历到什么时候是个头呢，无从知晓。看了答案之后方才明白。</p>
<p><strong>进制范围的确定</strong>   （关键步骤+二分查找）</p>
<p>进制的最小取值为：各个位数最大值+1 如123的最小进制一定大于3， abc的最小进制一定大于12  （这个比较好理解）</p>
<p>现在来讨论进制的上限（max_radix）  (这个不好理解)<br>　　那么现在在题目中，给出了两个数，一个数记为a是已知进制的，另一个记为b未知，假设a&#x3D;675,为10进制，b&#x3D;1，未知进制<br>　　很显然，b的最低进制min_radix是2<br>　　那么b的最高进制max_radix 是多少呢<br>　　我们的目的是让a&#x3D;b，b不可过小也不可过大<br>　　<br>　　假设 max_radix&#x3D;1000<br>　　很显然b &#x3D; 1(1000) &#x3D; 1000 &gt; a &#x3D; 675<br>　　所以，发现了吗<br>　　想让a&#x3D;b，b的最大进制就是a的值,即675<br>　　因为我举的例子比较特殊，如果b不为1，那么就很难直接得到b的精确的最高进制max_radix<br>　　但是 ，可以肯定的是，当b为1 的时候，max_radix是最大的（因为此时b最小）<br>　　因此，我们虽然不知道b&#x3D;10,20,80,13671…时，对应的max_radix是多少，但是，他们一定比b&#x3D;1对应的max_radix小<br>　　那么我们就可以用最大的max_radix作为进制的上限，在min_radix 到max_radix中二分查找<br>　　同时需要注意，max_radix&gt;&#x3D;min_radix<br>　　故有 max_radix &#x3D; max(a,min_radix);</p>
<p><strong>坑点</strong>：</p>
<p>计算过程中会出现数据溢出。<br> 举个极端例子：<br> 一亿进制的zzzzzzzzzz转化为十进制。 即使用long long也无法保存。<br> 那么应该怎么判断呢？ 可以判断计算结束后的值是否小于0，因为溢出后的值一定小于0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202935463.png" alt="image-20210410202935463"></p>
<p>这一句显得至关重要，有6个测试点来自这。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">transfer_to_ten</span><span class="params">(string a,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll total=<span class="number">0</span>;</span><br><span class="line">    ll basement = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) total += (a[i]-<span class="string">&#x27;0&#x27;</span>)*basement;</span><br><span class="line">        <span class="keyword">else</span> total += (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>)*basement;</span><br><span class="line">        basement *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_base</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// if(a[i]&lt;=&#x27;9&#x27;) min_base = max(min_base,a[i]-&#x27;0&#x27;+1);</span></span><br><span class="line">        <span class="comment">// else min_base = max(min_base,a[i]-&#x27;a&#x27;+11);</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) min_base = min_base&gt;(a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>) ? min_base : (a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> min_base = min_base&gt;(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>) ? min_base : (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search_base</span><span class="params">(string a,<span class="type">int</span> min_base,<span class="type">int</span> max_base,<span class="type">long</span> <span class="type">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_base&lt;<span class="number">2</span>) min_base = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_base&gt;max_base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll mid_base = min_base + (max_base-min_base)/<span class="number">2</span>;</span><br><span class="line">    ll temp = <span class="built_in">transfer_to_ten</span>(a,mid_base);</span><br><span class="line">    <span class="keyword">if</span>(temp==target) <span class="keyword">return</span> mid_base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target || temp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">search_base</span>(a,min_base,mid_base<span class="number">-1</span>,target);  <span class="comment">//关键 temp可能会溢出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search_base</span>(a,mid_base+<span class="number">1</span>,max_base,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    string cc;</span><br><span class="line">    ll tag,radix;</span><br><span class="line">    ll target;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(a,radix);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;radix;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;target: &quot;&lt;&lt;target&lt;&lt;endl;</span></span><br><span class="line">        cc = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(b,radix);</span><br><span class="line">        cc = a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll min_base = <span class="built_in">find_min_base</span>(cc);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;min_base: &quot;&lt;&lt;min_base&lt;&lt;endl;</span></span><br><span class="line">    ll max_base = target&gt;min_base ? target : min_base;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;max_base: &quot;&lt;&lt;max_base&lt;&lt;endl;</span></span><br><span class="line">    ll mid_base = <span class="built_in">search_base</span>(cc,min_base,max_base,target);</span><br><span class="line">    <span class="keyword">if</span>(mid_base) cout&lt;&lt;mid_base;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410203111819.png" alt="image-20210410203111819"></p>
<p>第10个测试点据说是：10测试点是输入为0<br> 当其中一个输入为0时，base若等于最大数字加1则为1，但我们知道进制的最小值为2，故在搜索前需要进行检查。（不太清楚）</p>
<h3 id="PAT-1011"><a href="#PAT-1011" class="headerlink" title="PAT 1011"></a>PAT 1011</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153118330.png" alt="image-20210422153118330"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153134396.png" alt="image-20210422153134396"></p>
<p>给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大。每一场都选最大的。无脑题，关键在于读懂题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ca</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> pro;</span><br><span class="line">&#125;ca;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ca a,ca b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pro&gt;b.pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>]=&#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"><span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ca&gt;&gt; <span class="built_in">v</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            ca d; </span><br><span class="line">            cin&gt;&gt;d.pro;</span><br><span class="line">            d.a = a[j];</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        res *= v[i][<span class="number">0</span>].pro;</span><br><span class="line">        cout&lt;&lt;v[i][<span class="number">0</span>].a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1012"><a href="#PAT-1012" class="headerlink" title="PAT 1012"></a>PAT 1012</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163238958.png" alt="image-20210422163238958"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163249988.png" alt="image-20210422163249988"></p>
<p>这一题竟然解决了一个小时。</p>
<p>题目大意：输入学生 以及三门课的成绩，然后每输入一个学生的id就打印最高的排名和对应排名的分类。排名分成三门课的单独排名和平均分的排名。排名也有优先级，A&gt;C&gt;M&gt;E。还算模拟题吧。</p>
<p>我的思路是建立一个学生表Map[string , stu]；stu包含学生的信息，包括成绩，排名等等。在第一波输入的时候，我们可以将成绩信息，填入学生表，同时将每科的成绩分门别列进行排序，第二轮遍历学生表Map时我们按照成绩查找对应的排名，本来想用二分查找，（但也必须是改进的二分查找，查找目标&#x3D;&#x3D;target的最小边界）。然后printinfo函数输出每个学生的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    string ID;</span><br><span class="line">    <span class="type">int</span> C,M,E,A;  <span class="comment">//成绩</span></span><br><span class="line">    <span class="type">int</span> rC,rM,rE,rA;  <span class="comment">//排名</span></span><br><span class="line">&#125;stu;</span><br><span class="line">map&lt;string,stu&gt; Map;  <span class="comment">//学生表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; CC;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; MM;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; EE;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AA;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int binary_search(vector&lt;int&gt; A,int target,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">//     if(l&gt;r) return -2;</span></span><br><span class="line"><span class="comment">//     int mid = (l+r)/2;</span></span><br><span class="line"><span class="comment">//     if(A[mid]==target) return mid+1;</span></span><br><span class="line"><span class="comment">//     if(A[mid]&gt;target) return binary_search(A,target,mid+1,r);</span></span><br><span class="line"><span class="comment">//     else return binary_search(A,target,l,mid-1);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]==target) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstu</span><span class="params">(stu S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.rA&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rA&lt;&lt;<span class="string">&quot; A&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rC&lt;=<span class="built_in">min</span>(S.rA,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rC&lt;&lt;<span class="string">&quot; C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rM&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rA)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rM&lt;&lt;<span class="string">&quot; M&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rE&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rA,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rE&lt;&lt;<span class="string">&quot; E&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string a; <span class="type">int</span> b,c,d;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        CC.<span class="built_in">push_back</span>(b);   MM.<span class="built_in">push_back</span>(c);  </span><br><span class="line">        EE.<span class="built_in">push_back</span>(d); </span><br><span class="line">        <span class="type">int</span> aver = (<span class="type">int</span>)((<span class="type">double</span>)(b+c+d)/<span class="number">3.0</span>+<span class="number">0.5</span>);</span><br><span class="line">        AA.<span class="built_in">push_back</span>(aver);</span><br><span class="line">        stu temp; </span><br><span class="line">        temp.ID = a; temp.C=b; temp.M=c; temp.E=d; temp.A=aver;</span><br><span class="line">        Map[a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(CC.<span class="built_in">begin</span>(),CC.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(EE.<span class="built_in">begin</span>(),EE.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(MM.<span class="built_in">begin</span>(),MM.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(AA.<span class="built_in">begin</span>(),AA.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    map&lt;string,stu&gt; :: iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="comment">// int a = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rA = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rC = binary_search(CC,iter-&gt;second.C,0,CC.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rE = binary_search(EE,iter-&gt;second.E,0,EE.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rM = binary_search(MM,iter-&gt;second.M,0,MM.size()-1);</span></span><br><span class="line">        iter-&gt;second.rA = <span class="built_in">search</span>(AA,iter-&gt;second.A);</span><br><span class="line">        iter-&gt;second.rC = <span class="built_in">search</span>(CC,iter-&gt;second.C);</span><br><span class="line">        iter-&gt;second.rE = <span class="built_in">search</span>(EE,iter-&gt;second.E);</span><br><span class="line">        iter-&gt;second.rM = <span class="built_in">search</span>(MM,iter-&gt;second.M);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string s;  cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(s)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printstu</span>(Map[s]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163816564.png" alt="image-20210422163816564"></p>
<h3 id="PAT-1013（连通分量）"><a href="#PAT-1013（连通分量）" class="headerlink" title="PAT 1013（连通分量）"></a>PAT 1013（连通分量）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172221670.png" alt="image-20210422172221670"></p>
<p>题意：给出城市个数为N，连接城市间的道路的条数为M，以及询问次数为K</p>
<p>然后输入这M条道路连接的两个端点城市的编号Ａ和Ｂ</p>
<p>然后是K次询问，每次询问的方法是：给出一个编号为Q城市，然后将这个城市和与其相连的道路从网络中删除，要求让你求出添加多少条道路，才能使得被删除了编号为Q的城市的网络仍然联通</p>
<p>转化成求连通分量个数。即图的遍历，我这里使用广度优先搜索遍历图，求连通分量k。</p>
<p>bfs(int node)；除去node结点的连通分量，从1..N遍历结点，设置一个visited数组表示该结点是否访问过。如果访问过则记作1.k++，然后是用一个栈广度优先搜索该连通分量中可以到达的结点。</p>
<p>最后需要增加的路径&#x3D;连通分量个数-1</p>
<p>注意：每一次考虑新的结点的时候visited必须复位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//1..N 0不用</span></span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">int</span> k;  <span class="comment">//连通分量个数</span></span><br><span class="line"><span class="type">int</span> **Graph;   <span class="comment">//Graph  1..N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;   <span class="comment">//不考虑node结点,求连通分量个数k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==node) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==node) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Graph[top][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                    visited[j]=<span class="number">1</span>;</span><br><span class="line">                    S.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="comment">//visited数组初始化，表示没有访问过</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph初始化</span></span><br><span class="line">    Graph = <span class="keyword">new</span> <span class="type">int</span>*[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Graph[i] = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(Graph[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(Graph[i]));  <span class="comment">//Graph[i][u] = 0代表i,u之间没有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">        Graph[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// memset(visited,0,sizeof(visited));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) visited[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(a);</span><br><span class="line">        cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=K<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 5 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">2 1 3 4 5 6 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172806405.png" alt="image-20210422172806405"></p>
<h3 id="PAT-1014-队列模拟"><a href="#PAT-1014-队列模拟" class="headerlink" title="PAT 1014 (队列模拟)"></a>PAT 1014 (队列模拟)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174327230.png" alt="image-20210422174327230"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174337754.png" alt="image-20210422174337754"></p>
<p><strong>题目大意</strong>：银行有N个窗口，每个窗口划分成两部分，黄线内的和黄线外的</p>
<p>顾客排队有以下几个要求：</p>
<p>1、每个窗口黄线内可以站M个人，第（MN+1)个人得排在黄线外</p>
<p>2、每个顾客选择最短的队伍，（队伍长度相同选择序号小的）</p>
<p>3、顾客i将花费 Ti 的时间处理问题</p>
<p>3、每个窗口的第一位顾客将于8:00被服务</p>
<p>给定每个顾客的处理问题的时间，求每位顾客解决问题的时间点。</p>
<p>输入：第一行 N(窗口）、M（黄线内的人数）、K（顾客人数）、Q（要求的顾客完成时间）  五点之前下班</p>
<p><strong>思路</strong>：用一个vector表示一个窗口，窗口里是一个queue<int>表示窗口队列，首先初始化窗口，之后模拟每一次完成（查找所有窗口剩余时间最少的出队，如果还有人在黄线外等候则加入该窗口的队列，然后更新每个窗口front元素的剩余时间）。持续下去直到所有窗口都为空。 用一个变量nowtime记录当前时间，也即每个顾客的完成时间。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M,K,Q;  <span class="comment">//N 窗口  M 黄线内人数  K 顾客人数  Q 询问时间</span></span><br><span class="line"><span class="type">int</span> Time[<span class="number">1001</span>];   <span class="comment">//表示第i位顾客还剩多少时间完成</span></span><br><span class="line"><span class="type">int</span> process[<span class="number">1001</span>];   <span class="comment">//最多有1001个顾客，time表示第i个顾客的完成时间，单位分钟</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Custom;  <span class="comment">//顾客队列,按照编号进行</span></span><br><span class="line">vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; Window; <span class="comment">//窗口vector，每个窗口维护一个队列，队列长度不超过M</span></span><br><span class="line"><span class="type">int</span> nowtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断所有窗口是否还有人在排队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isemptyWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最早出队的窗口号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mintime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_time = <span class="number">9999</span>; </span><br><span class="line">    <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>() &amp;&amp; Time[Window[i].<span class="built_in">front</span>()]&lt;min_time)&#123;</span><br><span class="line">            min_time = Time[Window[i].<span class="built_in">front</span>()];</span><br><span class="line">            min_i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新每个窗口的出队时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> subtime,<span class="type">int</span> t)</span></span>&#123;  <span class="comment">//subtime减去的时间，t除外</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=t &amp;&amp; !Window[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Time[Window[i].<span class="built_in">front</span>()] -= subtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_to_clock</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour = time/<span class="number">60</span>+<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> minn = time%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;<span class="number">17</span> || (hour==<span class="number">17</span>&amp;&amp;minn&gt;<span class="number">0</span>)) cout&lt;&lt;<span class="string">&quot;Sorry&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>,hour,minn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> pCustom = <span class="number">1</span>;  <span class="comment">//顾客指针，在pCustom之前的都已经安排到Windows黄线内去了</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Time[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//初始化窗口</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;  Window.<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口队列</span></span><br><span class="line">    <span class="keyword">while</span>(pCustom&lt;=N*M &amp;&amp; pCustom&lt;=K)&#123;</span><br><span class="line">        Window[(pCustom+<span class="number">1</span>)%M].<span class="built_in">push</span>(pCustom);  <span class="comment">//按照顺序每个窗口依次安排人</span></span><br><span class="line">        pCustom++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isemptyWindow</span>())&#123;</span><br><span class="line">        <span class="type">int</span> min_i = <span class="built_in">mintime</span>();  <span class="comment">//最早出队的窗口号</span></span><br><span class="line">        <span class="type">int</span> subtime = Time[Window[min_i].<span class="built_in">front</span>()];  <span class="comment">//需要更新的时间</span></span><br><span class="line">        nowtime += subtime;   <span class="comment">//更新当前时间</span></span><br><span class="line">        process[Window[min_i].<span class="built_in">front</span>()] = nowtime;   <span class="comment">//记录该顾客已经完成</span></span><br><span class="line">        Window[min_i].<span class="built_in">pop</span>();  <span class="comment">//当前窗口出队</span></span><br><span class="line">        <span class="keyword">if</span>(pCustom&lt;=K)&#123;</span><br><span class="line">            Window[min_i].<span class="built_in">push</span>(pCustom);   <span class="comment">//加入新元素</span></span><br><span class="line">            pCustom++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(subtime,min_i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">time_to_clock</span>(process[a]);</span><br><span class="line">        <span class="keyword">if</span>(i!=Q<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193023153.png" alt="image-20210422193023153"></p>
<p>看答案发现五点前还没处理完的不可能赶人家走吧，所以修改了一下代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193841669.png" alt="image-20210422193841669"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193858472.png" alt="image-20210422193858472"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193918612.png" alt="image-20210422193918612"></p>
<p>参考了网上的AC代码，还是没看出来自己为什么错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> win_num, win_len, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;win_num, &amp;win_len, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">times</span>(win_num); <span class="comment">//times按顺序记录每个窗口中排队的人的结束时间，用以标示下一个进入的人的开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n)</span>, <span class="title">start_time</span><span class="params">(n)</span></span>; <span class="comment">//data记录每个用户的耗时，start_time记录每个用户的开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i&lt;win_num*win_len; i++)&#123;  <span class="comment">//先把黄线内的人排队排好</span></span><br><span class="line">        <span class="type">int</span> t = i%win_num; <span class="comment">//第t个窗口</span></span><br><span class="line">        start_time[i] = i&lt;win_num?<span class="number">0</span>:times[t][i/win_num<span class="number">-1</span>]; <span class="comment">//第一排的开始时间是0，之后的开始时间是前一排的结束时间，从times中获取</span></span><br><span class="line">        times[t].<span class="built_in">push_back</span>(start_time[i]+data[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=win_num*win_len; i&lt;n; i++)&#123;  <span class="comment">//黄线外的人进入队伍</span></span><br><span class="line">        <span class="type">int</span> mint=<span class="number">540</span>, w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;win_num; j++)&#123;  <span class="comment">//选择队伍，按队伍中size()-win_len个人的最早开始时间选择</span></span><br><span class="line">            <span class="type">int</span> st = times[j][times[j].<span class="built_in">size</span>()-win_len];</span><br><span class="line">            <span class="keyword">if</span>(st&lt;mint)&#123;</span><br><span class="line">                mint = st;</span><br><span class="line">                w = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">-1</span>) start_time[i] = <span class="number">540</span>; <span class="comment">//没窗口选，全都已经超时，按540计</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start_time[i] = times[w][times[w].<span class="built_in">size</span>()<span class="number">-1</span>]; <span class="comment">//计算开始时间</span></span><br><span class="line">            times[w].<span class="built_in">push_back</span>(start_time[i]+data[i]); <span class="comment">//排队进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(start_time[x]&gt;=<span class="number">540</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (start_time[x]+data[x])/<span class="number">60</span>+<span class="number">8</span>, (start_time[x]+data[x])%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PAT-1015"><a href="#PAT-1015" class="headerlink" title="PAT 1015"></a>PAT 1015</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210426090709927.png" alt="image-20210426090709927"></p>
<p>最初这题题目没看懂</p>
<p>题目大意：给出一个素数，判断在d进制下反转后在十进制下是否是素数，如果是，则输出”Yes”，否，则输出”No”。</p>
<p>Sample input:</p>
<p>73 在十进制下反转 37</p>
<p>23(10111) 在2进制下反转(11101) 29 是质数</p>
<p>23在10进制下反转32不是质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//判断n是否是素数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>) <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> zNum = <span class="number">0</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//转换为p进制</span></span><br><span class="line">        z[zNum++] = n % d;</span><br><span class="line">        n /=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zNum; ++i) &#123;<span class="comment">//逆序转为10进制</span></span><br><span class="line">        n = n * d + z[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">true</span>)&#123;<span class="comment">//是素数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;<span class="comment">//是负数，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Check</span>(n, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1016"><a href="#PAT-1016" class="headerlink" title="PAT 1016"></a>PAT 1016</h3><p>题目大意： 打长途电话每分钟要花一定的费用，这取决于一天中打电话的时间。当客户开始连接长途电话时，时间会被记录下来，客户挂断电话的时间也会被记录下来。每个日历月，每一分钟都会向客户发送一张账单（按一天中的时间确定的费率）。你的工作是准备每个月的账单，给你一套电话记录。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210429204459301.png" alt="image-20210429204459301"></p>
<h3 id="PAT-1039"><a href="#PAT-1039" class="headerlink" title="PAT 1039"></a>PAT 1039</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182936179.png" alt="image-20210420182936179"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182949322.png" alt="image-20210420182949322"></p>
<p>题目大意：有一个表保存了学生的选课信息，根据学生姓名来查询信息，输出该名学生选课情况。</p>
<p>样例解释，有11个学生，共5门课，接下来10行表示每门课的选课情况，例如2,3行，第4门课（4是课程号），7个人选，选课名单BOB5…</p>
<p>最后一行按顺序输出学生的名单。结果输出每个学生的名字，选课门数和课程号。</p>
<p>思路比较清楚，我定义的数据结构还算比较复杂</p>
<p>Query_List 代表学生的选课列表（索引就代表学号），Course_List代表课程的学生列表。</p>
<p>我们先把数据读入课程列表中，再用一个Map将学生的名字和学号一一对应。然后遍历Course_List，查到Course_List的学生选的哪门课就往Query_List中添加。最后将Query_List中的list排序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br></pre></td></tr></table></figure>

<p>坑点：最后一个测试数据比较大，据说要用scanf和printf，或者用char</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;Course_List&gt; CList;</span><br><span class="line">    vector&lt;Query_List&gt; QList;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> i1,i2;  </span><br><span class="line">        string i3;  </span><br><span class="line">        cin&gt;&gt;i1&gt;&gt;i2;</span><br><span class="line">        Course_List C; </span><br><span class="line">        C.cno = i1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;i2;i++)&#123;</span><br><span class="line">            cin&gt;&gt;i3;  </span><br><span class="line">            C.name.<span class="built_in">push_back</span>(i3);</span><br><span class="line">        &#125;</span><br><span class="line">        CList.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name;  cin&gt;&gt;name;</span><br><span class="line">        M[name] = i;</span><br><span class="line">        Query_List Q;  Q.name = name;</span><br><span class="line">        QList.<span class="built_in">push_back</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;CList[i].name.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//M[CList[i].name[j]].list.push_back(CList[i].cno);</span></span><br><span class="line">            QList[M[CList[i].name[j]]].list.<span class="built_in">push_back</span>(CList[i].cno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;QList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(QList[i].list.<span class="built_in">begin</span>(),QList[i].list.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;QList[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;QList[i].list.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=QList.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420183645306.png" alt="image-20210420183645306"></p>
<h3 id="PAT-1040（dp"><a href="#PAT-1040（dp" class="headerlink" title="PAT 1040（dp)"></a>PAT 1040（dp)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420235614633.png" alt="image-20210420235614633"></p>
<p>题目大意：查询长度最长的对称串</p>
<p>动态规划，dp[i] [j] 表示从 i 开始到 j 结束的对称串。（ i&lt;&#x3D;j ） </p>
<p>dp[i] [i] &#x3D; 1;</p>
<p>dp [i] [i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</p>
<p>dp[i] [i+k] &#x3D; (s[i] &#x3D;&#x3D; s[i+k] &amp;&amp; dp[i+1] [i+k-1] )</p>
<p>i，j的状态取决于 i+1,j-1是不是对称串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> dp[length][length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="built_in">memset</span>(dp[i],<span class="literal">false</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    <span class="type">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//Initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) &#123;dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>; maxlength=<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;length;k++)&#123;  <span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length &amp;&amp; i+k&lt;length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+k] &amp;&amp; dp[i+<span class="number">1</span>][i+k<span class="number">-1</span>]==<span class="literal">true</span>)&#123; </span><br><span class="line">                dp[i][i+k]=<span class="literal">true</span>;</span><br><span class="line">                maxlength=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="PAT-1041"><a href="#PAT-1041" class="headerlink" title="PAT 1041"></a>PAT 1041</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233542571.png" alt="image-20210420233542571"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233553640.png" alt="image-20210420233553640"></p>
<p>题目大意，找到最近的一个不重复的数，如果找不到输出none。</p>
<p>直接一个map存放出现的次数，之后再从前往后遍历。无脑题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> unicode;</span><br><span class="line">    <span class="type">int</span> Map[<span class="number">50000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">0</span>,<span class="built_in">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a ;cin&gt;&gt;a;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a);</span><br><span class="line">        Map[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(!unique &amp;&amp; j&lt;A.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[A[j]]==<span class="number">1</span>)&#123;</span><br><span class="line">            unique = <span class="literal">true</span>;</span><br><span class="line">            unicode = A[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unique) cout&lt;&lt;unicode;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1081"><a href="#PAT-1081" class="headerlink" title="PAT 1081"></a>PAT 1081</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210423091333960.png" alt="image-20210423091333960"></p>
<p>简单题，模拟分数乘法操作。</p>
<p>注意点：题目准确说明数的范围是Long ing型，第四个测试点出现浮点错误，需要判断一下分母为0的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fenzi[N]; <span class="type">long</span> <span class="type">long</span> fenmu[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,&amp;fenzi[i],&amp;fenmu[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> denominator = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) denominator *= fenmu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) numerator += denominator/fenmu[i]*fenzi[i];</span><br><span class="line">    <span class="keyword">if</span>(denominator==<span class="number">0</span>)&#123;  <span class="comment">//这里一定要判断一下，第四个测试点可能会出现浮点错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> interger = numerator/denominator;</span><br><span class="line">    <span class="keyword">if</span>(interger) cout&lt;&lt;interger;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re_numerator = numerator - interger*denominator;</span><br><span class="line">    <span class="keyword">if</span>(re_numerator)&#123;</span><br><span class="line">        <span class="keyword">if</span>(interger) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(re_numerator,denominator);</span><br><span class="line">        re_numerator /= g;    denominator/= g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,re_numerator,denominator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2021-7-10"><a href="#2021-7-10" class="headerlink" title="2021.7.10"></a>2021.7.10</h2><h3 id="PAT-1152"><a href="#PAT-1152" class="headerlink" title="PAT 1152"></a>PAT 1152</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153004327.png" alt="image-20210710153004327"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153023441.png" alt="image-20210710153023441"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153032898.png" alt="image-20210710153032898"></p>
<p>题目大意：给定一个N位的数，寻找第一次出现的m位素数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(LL t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL s = <span class="number">2</span>; s&lt;<span class="built_in">sqrt</span>(t) ;s++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i++)&#123;</span><br><span class="line">        res = s.<span class="built_in">substr</span>(i,n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issushu</span>(<span class="built_in">stoi</span>(res)))&#123;</span><br><span class="line">            cout&lt;&lt;res;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153216499.png" alt="image-20210710153216499"></p>
<h3 id="PAT-1153"><a href="#PAT-1153" class="headerlink" title="PAT 1153"></a>PAT 1153</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210514325.png" alt="image-20210710210514325"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210537819.png" alt="image-20210710210537819"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210558121.png" alt="image-20210710210558121"></p>
<p>题目大意：给出一组学生的准考证号和成绩，准考证号包含了等级(乙甲顶)，考场号，日期，和个人编号信息，并有三种查询方式<br>查询一：给出考试等级，找出该等级的考生，按照成绩降序，准考证升序排序<br>查询二：给出考场号，统计该考场的考生数量和总得分<br>查询三：给出考试日期，查询改日期下所有考场的考试人数，按照人数降序，考场号升序排序<br><strong>修改前的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;p1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    <span class="keyword">if</span>(M.<span class="built_in">find</span>(cc)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        M[cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        M[cc] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">dic1</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;dic1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;N<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710211717494.png" alt="image-20210710211717494"></p>
<p>改后发现格式不需要那么复杂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1.second==o2.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.first&lt;o2.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; </span><br><span class="line">                    total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    M[cc] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; dic1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : M) dic1.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it.first, it.second));</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一格多一个换行也没关系</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710220609566.png" alt="image-20210710220609566"></p>
<p><strong>修改后的AC代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testees</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;testees;</span><br><span class="line">vector&lt;testees&gt; t;</span><br><span class="line"><span class="type">int</span> N,M,type;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(testees a,testees b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,t[i].id.<span class="built_in">c_str</span>(),t[i].score);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>))&#123;</span><br><span class="line">                sum += t[i].score;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>))&#123;</span><br><span class="line">                mp[t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">vec_mp</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec_mp.<span class="built_in">begin</span>(),vec_mp.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec_mp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,vec_mp[i].first.<span class="built_in">c_str</span>(),vec_mp[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        testees ta;</span><br><span class="line">        cin&gt;&gt;ta.id&gt;&gt;ta.score;</span><br><span class="line">        t.<span class="built_in">push_back</span>(ta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>,i,type,s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">deal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710215520857.png" alt="image-20210710215520857"></p>
<h3 id="PAT-1154"><a href="#PAT-1154" class="headerlink" title="PAT 1154"></a>PAT 1154</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222438518.png" alt="image-20210710222438518"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222450152.png" alt="image-20210710222450152"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222458698.png" alt="image-20210710222458698"></p>
<p>题目大意：</p>
<p>相邻的两边不能同色，不用邻接矩阵，直接用边进行判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Graph</span><span class="params">(V,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> query; cin&gt;&gt;query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;query;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">            Graph[i] = a;</span><br><span class="line">            M[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[Edge[i].first] == Graph[Edge[i].second])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;-coloring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222553175.png" alt="image-20210710222553175"></p>
<h3 id="PAT-1155（回溯）"><a href="#PAT-1155（回溯）" class="headerlink" title="PAT 1155（回溯）"></a>PAT 1155（回溯）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230530365.png" alt="image-20210710230530365"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230546043.png" alt="image-20210710230546043"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230612772.png" alt="image-20210710230612772"></p>
<p>题目大意：给定一个二叉树，判断是不是大顶堆或小顶堆，并且输出路径，从右到左输出，可以利用回溯法解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> MAX_OR_MIN;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&gt;N)&#123;   <span class="comment">//到头了，输出路径</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    V.<span class="built_in">resize</span>(N+<span class="number">1</span>);  <span class="comment">//下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;  <span class="comment">//确定大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&gt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&lt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(V[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">backtrace</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==res[i].<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230634645.png" alt="image-20210710230634645"></p>
<h2 id="2021-7-17"><a href="#2021-7-17" class="headerlink" title="2021.7.17"></a>2021.7.17</h2><h3 id="PAT-1148"><a href="#PAT-1148" class="headerlink" title="PAT 1148"></a>PAT 1148</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174748111.png" alt="image-20210717174748111"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174800947.png" alt="image-20210717174800947"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174812459.png" alt="image-20210717174812459"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174821796.png" alt="image-20210717174821796"></p>
<p>题目大意：狼人杀，给出N个人，其中只有两个是狼人，找出狼人，其中所有人中有两个人说谎，说谎的人里包含一个狼人。</p>
<p>本来是想通过假设说谎的人数 i,j  来找到狼人，后来发现通过假定狼人i,j来验证是否成立来得更加方便。整了一个半小时了都。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Data</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> istrue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;   <span class="comment">//i,j是werewolf,其他是human</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i || k==j) output[k] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> output[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始验证</span></span><br><span class="line">            <span class="type">int</span> fa = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> wefa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[k] * output[<span class="built_in">abs</span>(Data[k])]&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">                     fa++;</span><br><span class="line">                     <span class="keyword">if</span>(k==i || k==j) wefa++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa==<span class="number">2</span> &amp;&amp; wefa==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717175023186.png" alt="image-20210717175023186"></p>
<h3 id="PAT-1149"><a href="#PAT-1149" class="headerlink" title="PAT 1149"></a>PAT 1149</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193857126.png" alt="image-20210717193857126"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193908755.png" alt="image-20210717193908755"></p>
<p>题目大意：集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No～</p>
<p>分析：用map存储每一个货物的所有不兼容货物～在判断给出的一堆货物是否是相容的时候，判断任一货物的不兼容货物是否在这堆货物中～如果存在不兼容的货物，则这堆货物不能相容～如果遍历完所有的货物，都找不到不兼容的两个货物，则这堆货物就是兼容的～</p>
<p>用map存储每一个货物的所有不相容货物，然后逐一进行比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(a)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(b);</span><br><span class="line">            Map[a] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(b)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(a);</span><br><span class="line">            Map[b] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(Q)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;Q;k++)&#123;</span><br><span class="line">            cin&gt;&gt;res[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;res.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jj=<span class="number">0</span>;jj&lt;res.<span class="built_in">size</span>();jj++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ii==jj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Map.<span class="built_in">find</span>(res[ii])== Map.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vector&lt;string&gt; temp = Map[res[ii]];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> zz=<span class="number">0</span>;zz&lt;temp.<span class="built_in">size</span>();zz++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp[zz]==res[jj])&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193955512.png" alt="image-20210717193955512"></p>
<p>修改后，在查找是否兼容这一部分，需要通过map定位到该值所在的结点，然后往节点后的链表顺序查找，这样可能比较浪费时间。</p>
<p>牺牲空间的方法，首先开辟一个大空间res，存放所有可能的物品，每遍历一个物品，就往res中添入不可兼容的物品，之后再查找时，如果在res中，则不可兼容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(res[x]==<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            res[x] = <span class="number">1</span>;   <span class="comment">//表示不兼容  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Map[x].<span class="built_in">size</span>();j++)</span><br><span class="line">                res[Map[x][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717202436733.png" alt="image-20210717202436733"></p>
<h3 id="PAT-1150"><a href="#PAT-1150" class="headerlink" title="PAT 1150"></a>PAT 1150</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210722721.png" alt="image-20210717210722721"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210738857.png" alt="image-20210717210738857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210750029.png" alt="image-20210717210750029"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210800815.png" alt="image-20210717210800815"></p>
<p>题目大意：旅行商问题，给定一个图，并给定路径，判断该路径是否满足一下条件：</p>
<p>Ts a simple cycle 每个城市只访问一次，并且回到远点</p>
<p>Not a TS cycle 没有访问到每个城市，或者没有回到原点</p>
<p>NA not a TS cycle  路径不可达</p>
<p>TS cycle  多次访问每个城市</p>
<p>然后求距离最短的路径。</p>
<p>思路：构建邻接矩阵，一个visited数组判断是否访问过，按照路径一次模拟一遍即可，水题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> shortest = INT_MAX;  <span class="comment">//存放最短路径</span></span><br><span class="line">    <span class="type">int</span> shortestindex = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d1,d2,dist; cin&gt;&gt;d1&gt;&gt;d2&gt;&gt;dist;</span><br><span class="line">        Graph[d1][d2] = dist;</span><br><span class="line">        Graph[d2][d1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T; cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=T;kk++)&#123;</span><br><span class="line">        <span class="type">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//0 可达性  1 是否都访问过  2  是否多次访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> C;  cin&gt;&gt;C;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(C+<span class="number">1</span>)</span></span>;   <span class="comment">//路径也从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visited[path[1]] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[path[i]][path[i+<span class="number">1</span>]]==<span class="number">0</span>) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total_cost += Graph[path[i]][path[i+<span class="number">1</span>]];</span><br><span class="line">                visited[path[i]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;visited.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) flag[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//没有访问过,flag=1 Not a TS cycle</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]&gt;<span class="number">1</span>) flag[<span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//多次访问  TS cycle;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="keyword">if</span>(!flag[<span class="number">0</span>] &amp;&amp; !flag[<span class="number">1</span>] &amp;&amp; !flag[<span class="number">2</span>] &amp;&amp; path[<span class="number">1</span>]==path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>,kk);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">1</span>] || path[<span class="number">1</span>]!=path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest Dist(%d) = %d&quot;</span>,shortestindex,shortest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210659132.png" alt="image-20210717210659132"></p>
<h3 id="PAT-1151"><a href="#PAT-1151" class="headerlink" title="PAT 1151"></a>PAT 1151</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190008683.png" alt="image-20210718190008683"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190019702.png" alt="image-20210718190019702"></p>
<p>题目大意：给出中序序列和先序序列，再给出两个点，求这两个点的最近公共祖先～</p>
<p>柳神题解：不用建树～已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。中序加先序可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点，在此时并入lca算法可以确定两个结点的公共祖先～</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,<span class="type">int</span> node1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> pre_right,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,pre_left+<span class="number">1</span>,mid_position,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,mid_position+<span class="number">1</span>,pre_right,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190202986.png" alt="image-20210718190202986"></p>
<p>问题出在递归过程中变量设置太多，导致递归栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(vector&lt;int&gt; preorder,vector&lt;int&gt; inorder,int node1,</span><br><span class="line">    int node2,int pre_left,int pre_right,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>改成，将preorder,inorder设置成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(int node1,int node2,int pre_left,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,pre_left+<span class="number">1</span>,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,mid_position+<span class="number">1</span>,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(node1,node2,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190952587.png" alt="image-20210718190952587"></p>
<h2 id="2021-7-24"><a href="#2021-7-24" class="headerlink" title="2021.7.24"></a>2021.7.24</h2><h3 id="PAT-1144"><a href="#PAT-1144" class="headerlink" title="PAT 1144"></a>PAT 1144</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103108325.png" alt="image-20210724103108325"></p>
<p>题目大意：给一个数串，找到数串中没有出现的最小正整数</p>
<p>思路：用一个长度为N的哈希表就可以了，因为最小整数不可能超过N，符合条件就放入，不符合条件就跳过，最后从1开始遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(N+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;=<span class="number">1</span> &amp;&amp; L[i]&lt;=N)</span><br><span class="line">            M[L[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103224067.png" alt="image-20210724103224067"></p>
<h3 id="PAT-1145"><a href="#PAT-1145" class="headerlink" title="PAT 1145"></a>PAT 1145</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724143956305.png" alt="image-20210724143956305"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144007126.png" alt="image-20210724144007126"></p>
<p>题目大意：</p>
<p>（quadratic：平方的）</p>
<p><strong>给定一个序列，用平方探测法（只用正数）解决哈希冲突，然后给出m个数字（皆为正数），如果这个数字不能够被插入就输出”X cannot be inserted.”，然后输出这m个数字的平均查找次数</strong></p>
<p>思路：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144235052.png" alt="image-20210724144235052"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//0  1  2  3  4</span></span><br><span class="line"><span class="comment">//10 6  11    4</span></span><br><span class="line"><span class="comment">//11 2次  4 1次  15 6次  2 2次</span></span><br><span class="line"><span class="comment">//11/4 = 2.8</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Msize,N,M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;Msize&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isprime</span>(Msize)) Msize++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Hash</span><span class="params">(Msize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构建哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断插入不成功？</span></span><br><span class="line">            <span class="keyword">if</span>(Hash[(a+j*j)%Msize]==<span class="number">0</span>)&#123;</span><br><span class="line">                Hash[(a+j*j)%Msize] = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==Msize) <span class="built_in">printf</span>(<span class="string">&quot;%d cannot be inserted.\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均查找次数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断找不到?</span></span><br><span class="line">            <span class="type">int</span> t = (b+j*j)%Msize;</span><br><span class="line">            <span class="keyword">if</span>(Hash[t]==b || Hash[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">        sum += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum/M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144253395.png" alt="image-20210724144253395"></p>
<h3 id="PAT-1146"><a href="#PAT-1146" class="headerlink" title="PAT 1146"></a>PAT 1146</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150143550.png" alt="image-20210724150143550"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150158871.png" alt="image-20210724150158871"></p>
<p>题目大意：判断一个序列是不是拓扑序列。</p>
<p>思路：构建邻接矩阵，计算入度，根据给出序列判断入度是否为0，然后将以该顶点为起点的边的终点的入度—1,依次判断下一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  <span class="comment">//N:定点数 M：边数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个顶点的入度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[j][i]==<span class="number">1</span>) in++;</span><br><span class="line">        &#125;</span><br><span class="line">        indegree[i] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为拓扑序列</span></span><br><span class="line">    <span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree1</span><span class="params">(indegree)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree1[seq[j]]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Graph[seq[j]][k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        indegree1[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150354679.png" alt="image-20210724150354679"></p>
<h3 id="PAT-1147"><a href="#PAT-1147" class="headerlink" title="PAT 1147"></a>PAT 1147</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153528563.png" alt="image-20210724153528563"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153541846.png" alt="image-20210724153541846"></p>
<p>题目大意：给定一个完全二叉树，要求判断是否是大顶堆或小顶堆，并给出该二叉树的后序遍历。</p>
<p>判断大顶堆或小顶堆只需要遍历整个序列，判断seq[i] 和 seq[2<em>i] 和 seq[2</em>i+1]的关系即可。</p>
<p>后序遍历采用栈进行模拟，</p>
<p>如果有左节点且左节点没被访问过，左节点入栈，</p>
<p>如果左节点被访问过且右节点没被访问过，右节点入栈</p>
<p>如果是叶子节点，且左右节点都被访问过，则出栈，visited设1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHEAP -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; seq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = seq.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">//第0个结点不用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(size+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node = S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node*<span class="number">2</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>+<span class="number">1</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>&gt;size || (node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>+<span class="number">1</span>])  <span class="comment">//访问该结点的条件 1、没有孩子结点 </span></span><br><span class="line">         || (node*<span class="number">2</span>+<span class="number">1</span>&gt;size &amp;&amp; node*<span class="number">2</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>]))&#123;   <span class="comment">//2、如果有右节点，且被访问过 3、如果没有右结点且左节点被访问过</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            visited[node] = <span class="number">1</span>;  <span class="comment">//标志该结点以访问过</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(seq[node]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)  cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_or_min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(seq[<span class="number">1</span>]&gt;seq[M]) max_or_min = MAX;</span><br><span class="line">        <span class="keyword">else</span> max_or_min = MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_or_min==MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&gt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&gt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&lt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&lt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_or_min==MAX) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN) cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==NOTHEAP) cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="built_in">postorder</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724154312977.png" alt="image-20210724154312977"></p>
<h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021.7.31"></a>2021.7.31</h2><h3 id="PAT-1140"><a href="#PAT-1140" class="headerlink" title="PAT 1140"></a>PAT 1140</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731211941856.png" alt="image-20210731211941856"></p>
<p>题目大意：</p>
<p>题意：后面一个数是前面一个数的描述，一般第一个数是d，代表0-9的任意一个数，第二 数是第一个数的描述，就是将d+d的个数。同样，第三个数是第二个数的描述，依次，例如:1   11(前一个1是第一个数，后一个1是第一个中1的个数)    12（代表前一个数中有2个1）  1121（前面一个数中有1个1，1个2，数放前，个数放后）  122111   112213  12221131  1123123111 。</p>
<p>思路：采用模拟的方法，c表示当前字符，如果遍历到的字符不是c，则输出到temp中，如果是c，则c的个数size++.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731212418772.png" alt="image-20210731212418772"></p>
<p>原因在于<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225304119.png" alt="image-20210731225304119"></p>
<p>使用&#x3D;是深拷贝，需将temp重新拷贝一份再赋值给temp</p>
<p>使用+&#x3D; 是直接在后面append。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225217330.png" alt="image-20210731225217330"></p>
<h3 id="PAT-1141"><a href="#PAT-1141" class="headerlink" title="PAT 1141"></a>PAT 1141</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225429215.png" alt="image-20210731225429215"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225444048.png" alt="image-20210731225444048"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225453525.png" alt="image-20210731225453525"></p>
<p>问题描述：给定每个考生的成绩和学校，统计该学校的总成绩并排序。</p>
<p>思路：用一个Map用于查找学校信息，便于统计学校总成绩，然后扔到vector进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total==b.total &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.total==b.total)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.total&gt;b.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].total),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231308137.png" alt="image-20210731231308137"></p>
<p>sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231840300.png" alt="image-20210731231840300"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231858291.png" alt="image-20210731231858291"></p>
<p>正确代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231804410.png" alt="image-20210731231804410"></p>
<h3 id="PAT-1142"><a href="#PAT-1142" class="headerlink" title="PAT 1142"></a>PAT 1142</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231938095-1677591493747.png" alt="image-20210731231938095"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231950482-1677591493747.png" alt="image-20210731231950482"></p>
<p>题目大意：问题描述：给定一个无向图，和一些顶点，判断这些顶点是否组成了集合（每两个顶点都相连）</p>
<p>Yes 是一个团，每两个顶点都相邻</p>
<p>Not Maximal  是一个团，但是可以再加入一个顶点，使得每两个顶点相连</p>
<p>Not a Clique  不是每两个顶点都相连。</p>
<p>思路：构造邻接矩阵，对给定序列依次判断是否是一个团，然后再尝试加入其他顶点，判断是否是最大团。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232208835-1677591493747.png" alt="image-20210731232208835"></p>
<h3 id="PAT-1143"><a href="#PAT-1143" class="headerlink" title="PAT 1143"></a>PAT 1143</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232235278.png" alt="image-20210731232235278"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232247776.png" alt="image-20210731232247776"></p>
<p>题目大意：用先序遍历的方式给出一棵排序二叉树。让你回答n个询问。<br> 找出每个询问的最近公共祖先。</p>
<p>用TreeMap存树的每个结点，第一步判断是否存在  否则not found</p>
<p>第二部查找最近的公共祖孙，这里利用二叉排序树的特点，如果n1 和 n2 一个大于根节点 一个小于根节点，则根节点必定是公共祖先，否则递归进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLCA</span><span class="params">(vector&lt;<span class="type">int</span>&gt; Tree,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = Tree[left];</span><br><span class="line">    <span class="keyword">if</span>((n1&lt;t &amp;&amp; n2&gt;t) || (n1&gt;t &amp;&amp; n2&lt;t) || (n1==t||n2==t)) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left+<span class="number">1</span>;  <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(Tree[i]&lt;t) i++;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;t &amp;&amp; n2&lt;t) <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,left+<span class="number">1</span>,i<span class="number">-1</span>,n1,n2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,i,right,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Tree</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; TreeMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;Tree[i];</span><br><span class="line">        TreeMap[Tree[i]]++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>() &amp;&amp; TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.&quot;</span>,n1,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> lca = <span class="built_in">searchLCA</span>(Tree,<span class="number">0</span>,N<span class="number">-1</span>,n1,n2);</span><br><span class="line">            <span class="keyword">if</span>(lca==n1)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n1,n2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lca==n2)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n2,n1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.&quot;</span>,n1,n2,lca);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232946850.png" alt="image-20210731232946850"></p>
<p>佬们的代码：他是直接利用先序遍历的特点，按顺序判断是否是祖先</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232910793.png" alt="image-20210731232910793"></p>
<h2 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021.8.7"></a>2021.8.7</h2><h3 id="PAT-1136"><a href="#PAT-1136" class="headerlink" title="PAT 1136"></a>PAT 1136</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112248715.png" alt="image-20210807112248715"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112302487.png" alt="image-20210807112302487"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112313001.png" alt="image-20210807112313001"></p>
<p>题目大意：一个数加它的翻转能否在10次内得到一个回文数</p>
<p>思路：模拟大数加法，并且模拟反转过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> benwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c = a[i]-<span class="string">&#x27;0&#x27;</span> + b[i]-<span class="string">&#x27;0&#x27;</span> + jinwei;</span><br><span class="line">        benwei = c%<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(benwei) + res;</span><br><span class="line">        jinwei = c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jinwei!=<span class="number">0</span>) res = <span class="built_in">to_string</span>(jinwei) + res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispalindromic</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ispalindromic</span>(a) &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s + &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        string c = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        a = <span class="built_in">add</span>(a,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Not found in 10 iterations.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s is a palindromic number.&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112447331.png" alt="image-20210807112447331"></p>
<h3 id="PAT-1137"><a href="#PAT-1137" class="headerlink" title="PAT 1137"></a>PAT 1137</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162201003.png" alt="image-20210807162201003"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162215605.png" alt="image-20210807162215605"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162226330.png" alt="image-20210807162226330"></p>
<p>题目大意：</p>
<p>判断一个学生是否有资格获得整数的条件有2个：1.学生是否能编程&gt;&#x3D;200题 2.学生的总评成绩是否&gt;&#x3D;60</p>
<p>由于题目是分开给出各项成绩，而且Id唯一，所以我们可以使用Map方便查找。最后进行判断，判断完后排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162636845.png" alt="image-20210807162636845"></p>
<p><strong>大坑</strong>：</p>
<p>题目中的-1的意思表示的是没有学生的某一项没有分数（而非分数为0！没有分数代表没来考试，而分数为0代表考试考了0分！）</p>
<p>所以mid的初值应该设为-1 而不应该设为0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162728149.png" alt="image-20210807162728149"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">-1</span>;  <span class="comment">//-1代表没有成绩，不代表0分</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;=<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162753507.png" alt="image-20210807162753507"></p>
<h3 id="PAT-1138"><a href="#PAT-1138" class="headerlink" title="PAT 1138"></a>PAT 1138</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162840383.png" alt="image-20210807162840383"></p>
<p>题目大意：给出数的前序、中序，求后序输出的第一个值</p>
<p>思路：按照前序、中序序列构造树的方法，采用递归，中间需要用到Map来查找中序序列的位置。</p>
<p>如果有左子树，后序遍历的第一个序列在左子树中寻找，否则在右子树中寻找。只有一个节点，则Return；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(preorder,inorder,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807163415544.png" alt="image-20210807163415544"></p>
<p>改进方法：函数传值的时候尽量不要把整个vector都传进去，否则会出现爆内存的情况。需要把vector设置成全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192348410.png" alt="image-20210807192348410"></p>
<h3 id="PAT-1139"><a href="#PAT-1139" class="headerlink" title="PAT 1139"></a>PAT 1139</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192751253.png" alt="image-20210807192751253"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192805065.png" alt="image-20210807192805065"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192815264.png" alt="image-20210807192815264"></p>
<p><strong>题意</strong>：如果一个男孩子A对一个女孩子B有好感，那么他需要跟他的好哥们C说，然后C再去找B的闺蜜，让闺蜜给B带话。</p>
<p>思路就是从A的同性朋友中找出C，再从B的同性朋友中找出D，然后C，D是好朋友的话，这个话就带到了。</p>
<p>但是输出那里规定A，B可以是同性，</p>
<p>If they are of the same gender, then both friends must be in the same gender as theirs.</p>
<p>emmmmmmm，这道题gay里gay气的。</p>
<p><strong>思路</strong>：Person结构体存储自己的Id,还有男朋友，女朋友（其实也可以一起存储），然后用一个Map&lt;id,Person&gt;方便使用Id找到相对应的朋友。</p>
<p>然后给定两个朋友A，朋友B，根据Map找到对应的A的男朋友或女朋友，and 找到B的男朋友或女朋友，最后写一个函数判断这两人之间是否存在关系，然后将存在关系的朋友排好序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; boyfriend;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; girlfriend;</span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfriend</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    Person p = Map[id];</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.boyfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.girlfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(id2&gt;<span class="number">0</span>) Map[id1].boyfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">else</span> Map[id1].girlfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span>) Map[id2].boyfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        <span class="keyword">else</span> Map[id2].girlfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807193412853.png" alt="image-20210807193412853"></p>
<p>参考了以下柳神的代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807200903777.png" alt="image-20210807200903777"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a != y.a ? x.a &lt; y.a : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> asa = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(a)),asb = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(b));</span><br><span class="line">        <span class="comment">// A/B ID 作为下标记录同性边数据，arr记录关系</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v[asa].<span class="built_in">push_back</span>(asb);</span><br><span class="line">            v[asb].<span class="built_in">push_back</span>(asa);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[asa * <span class="number">10000</span> + asb] = arr[asb * <span class="number">10000</span> + asa] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[<span class="built_in">abs</span>(c)].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v[<span class="built_in">abs</span>(d)].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// A在寻找同性朋友时，需要避免找到他想要的伴侣B，所以当前朋友就是B或B的同性朋友就是A时舍弃该结果</span></span><br><span class="line">                <span class="keyword">if</span> (v[<span class="built_in">abs</span>(c)][j] == <span class="built_in">abs</span>(d) || <span class="built_in">abs</span>(c) == v[<span class="built_in">abs</span>(d)][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// A/B，先找A的所有同性朋友C，再找B的所有同性朋友D，当C和D两人是朋友的时候则可以输出C和D</span></span><br><span class="line">                <span class="keyword">if</span> (arr[v[<span class="built_in">abs</span>(c)][j] * <span class="number">10000</span> + v[<span class="built_in">abs</span>(d)][k]] == <span class="literal">true</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node&#123;v[<span class="built_in">abs</span>(c)][j], v[<span class="built_in">abs</span>(d)][k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(ans.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进后</strong>，重新捋一下<strong>思路</strong>：</p>
<p><font color="red">重点!!!</font></p>
<ul>
<li><p>题目简化后为A寻找同性伴侣B，D寻找同性伴侣A，然后A和B是朋友，则添加到结果中。</p>
</li>
<li><p>由于数据错综复杂，所以不适合采用邻接矩阵，我们只需要记录他们之间的关系即可，数据结构可以直接采用 map&lt;pair&lt;int,int&gt;,bool&gt;来存储两者间的关系，其中make_pair&lt;int,int&gt;可以使用哈希映射，比如make_pair&lt;a,b&gt;可以等价为 a*10000+b,同时不会导致哈希冲突。</p>
</li>
<li><p>如何寻找同性朋友呢，可以使用结构体Person, Person下有一个vector用于存储同性朋友，为了快速找到 id 对应的结构体Person，我们可以用map将id直接映射到Person中。</p>
</li>
<li><p>如果用Int接收朋友，会出现+0000和-0000的情况，不能判断是否为同性朋友，题目说we use a negative sign to represent girls. 用一个符号代表女性朋友，我们可以先用string接收，然后stoi(s)转成Int形，用s.length是否相同来判断是否为同性朋友。  (对应2、3个测试点)</p>
</li>
<li><p>输出的数据必须从小到大排序</p>
</li>
<li><p>A在寻找同性朋友时应该避免找到他的同性伴侣D，坑点（对应4、5、6测试点）</p>
</li>
<li><p>输出要保留4位小数  %04d  对应（2、3测试点）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gayfriend;  <span class="comment">//同性朋友</span></span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;pair&lt;int,int&gt;,bool&gt; isfriend;  key不能是pair类型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; isfriend;   <span class="comment">//可以建立Int,Int的哈希映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string sd1,sd2;  cin&gt;&gt;sd1&gt;&gt;sd2;</span><br><span class="line">        <span class="type">int</span> id1 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd1)),id2 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建朋友关系</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id1,id2)]=true;</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id2,id1)]=true;</span></span><br><span class="line">        isfriend[id1*<span class="number">10000</span>+id2]=<span class="literal">true</span>;</span><br><span class="line">        isfriend[id2*<span class="number">10000</span>+id1]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是同性朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(sd1.<span class="built_in">length</span>()==sd2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            Map[id1].gayfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">            Map[id2].gayfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        id1 = <span class="built_in">abs</span>(id1); id2 = <span class="built_in">abs</span>(id2);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        Person p1 = Map[id1];</span><br><span class="line">        Person p2 = Map[id2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p1.gayfriend.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p2.gayfriend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> fri1 = p1.gayfriend[i];</span><br><span class="line">                <span class="type">int</span> fri2 = p2.gayfriend[j];</span><br><span class="line">                <span class="keyword">if</span>(fri1==id2 || fri2==id1) <span class="keyword">continue</span>;  <span class="comment">// A在寻找同性朋友时，需要避免直接找到他想要的伴侣B</span></span><br><span class="line">                <span class="keyword">if</span>(isfriend[fri1*<span class="number">10000</span>+fri2] &amp;&amp; fri1!=fri2)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(fri1,fri2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807205353302.png" alt="image-20210807205353302"></p>
<h2 id="2021-8-14"><a href="#2021-8-14" class="headerlink" title="2021.8.14"></a>2021.8.14</h2><h3 id="PAT-1132"><a href="#PAT-1132" class="headerlink" title="PAT 1132"></a>PAT 1132</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125130500.png" alt="image-20210814125130500"></p>
<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20210814125141745.png" alt="image-20210814125141745" style="zoom:150%;">

<p>题目大意：<strong>一个偶数个位的正整数num，把它从中间分成左右两个整数a、b，问num能不能被a和b的乘积整除，能的话输出yes，不能的话输出no</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125236517.png" alt="image-20210814125236517"></p>
<p>因为没有判断c1*c2能不能是0，正确的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>((c1*c2) &amp;&amp;c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125323306.png" alt="image-20210814125323306"></p>
<h3 id="PAT-1133"><a href="#PAT-1133" class="headerlink" title="PAT 1133"></a>PAT 1133</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125357711.png" alt="image-20210814125357711"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125410450.png" alt="image-20210814125410450"></p>
<p>题目大意：给出一个链表，将链表分为三部分，第一部分小于0的数，第二部分小于&#x3D;K的数，第三部分，大于K的数。</p>
<p>思路：数据结构，一个结构体，存放地址address,数number，下一跳nextaddress，再采用map使得可以方便地根据address查找结点所在的位置，然后获取下一跳，以此类推。最后通过三次查找把合适的部分取出来放到vector中，这样就排好序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string address;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string nextaddress;</span><br><span class="line">    <span class="type">bool</span> isvisited = <span class="literal">false</span>;</span><br><span class="line">&#125;node;</span><br><span class="line">unordered_map&lt;string,node&gt; M;</span><br><span class="line">vector&lt;node&gt; res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string fadd;  cin&gt;&gt;fadd;</span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        node n; </span><br><span class="line">        cin&gt;&gt;n.address&gt;&gt;n.number&gt;&gt;n.nextaddress;</span><br><span class="line">        M[n.address] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    string nextaddress = fadd;</span><br><span class="line">    <span class="comment">//第一遍寻找负数</span></span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一遍寻找小于K的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;=K) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三遍加入剩余的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=res.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number,res[i+<span class="number">1</span>].address.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d -1&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125702974.png" alt="image-20210814125702974"></p>
<h3 id="PAT-1134"><a href="#PAT-1134" class="headerlink" title="PAT 1134"></a>PAT 1134</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125742396.png" alt="image-20210814125742396"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125753908.png" alt="image-20210814125753908"></p>
<p>题目大意：n个顶点和m条边的图，分别给出m条边的两端顶点，然后对其进行k次查询，每次查询输入一个顶点集合，要求判断这个顶点集合是否能完成顶点覆盖，即图中的每一条边都至少有一个顶点在这个集合中。</p>
<p>思路：很简单，将顶点集合用map存，然后遍历边，判断是否有一个顶点在map中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edgeset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        edgeset.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e1,e2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> c;  cin&gt;&gt;c; Map[c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;edgeset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> e1 = edgeset[j].first, e2 = edgeset[j].second;</span><br><span class="line">            <span class="keyword">if</span>(Map.<span class="built_in">find</span>(e1)==Map.<span class="built_in">end</span>() &amp;&amp; Map.<span class="built_in">find</span>(e2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125924885.png" alt="image-20210814125924885"></p>
<h3 id="PAT-1135"><a href="#PAT-1135" class="headerlink" title="PAT 1135"></a>PAT 1135</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145832177.png" alt="image-20210814145832177"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145853993.png" alt="image-20210814145853993"></p>
<p><strong>题目大意</strong>：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</p>
<p>1、非红即黑</p>
<p>2、根结点是否为黑色       </p>
<p>3、将NULL看成1个叶子节点，为黑<code>black</code>色</p>
<p>4、如果1个结点是红色，它的孩子节点是否都为黑色       </p>
<p>5、从任意结点到叶子结点的路径中，黑色结点的个数是否相同       </p>
<p><strong>考场错误思路一</strong>：由于是二叉排序树加上先序序列，可以递归构造二叉树。然后dfs的过程中判断第4个条件，并统计第5个条件（黑色结点个数是否相同）</p>
<p>一开始理解错了，从根节点到叶子结点的路径中，黑色结点个数相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; black_num;   <span class="comment">//统计路径上的黑色结点的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,<span class="type">int</span> black)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&gt;<span class="number">0</span>) black++;   <span class="comment">//黑色结点+1</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        black_num.<span class="built_in">push_back</span>(black);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    black_num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="type">bool</span> dfs = <span class="built_in">DFS</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfs==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;black_num.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(black_num[i]!=black_num[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814150547067.png" alt="image-20210814150547067"></p>
<p>第3个结点段错误，建树过程中存在一些问题。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814154047150.png" alt="image-20210814154047150"></p>
<p><strong>考场错误思路二</strong>：为了使得每一层到叶子结点的黑色结点数相同，我私自认为</p>
<p>&#x2F;&#x2F;判断是否为红黑树</p>
<p>&#x2F;&#x2F;1、红黑树一定是一棵平衡二叉树</p>
<p>&#x2F;&#x2F;2、红黑树一定层次分明,一层黑一层白</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lefthigh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> righhigh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lefthigh,righhigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh-rh&gt;<span class="number">1</span> || rh-lh&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">levelsearch</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> black = <span class="number">1</span>;  <span class="comment">//第一层是black</span></span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> lsize = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsize;i++)&#123;</span><br><span class="line">            TreeNode* p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val*black&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        black*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">levelsearch</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然是错误的，所以红黑树不是平衡二叉树</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155039169.png" alt="image-20210814155039169"></p>
<p><strong>正确思路</strong>：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155458247.png" alt="image-20210814155458247"></p>
<p>这里是判断平衡二叉树的变体，算高度时只统计黑色结点的个数</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155547670.png" alt="image-20210814155547670"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? <span class="built_in">max</span>(l, r) + <span class="number">1</span> : <span class="built_in">max</span>(l, r);</span><br><span class="line">    <span class="comment">// return 1+max(l,r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh!=rh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">DFS</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155614848.png" alt="image-20210814155614848"></p>
<h2 id="2021-8-20"><a href="#2021-8-20" class="headerlink" title="2021.8.20"></a>2021.8.20</h2><h3 id="PAT-1128"><a href="#PAT-1128" class="headerlink" title="PAT 1128"></a>PAT 1128</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184132575.png" alt="image-20210820184132575"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184145438.png" alt="image-20210820184145438"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184157300.png" alt="image-20210820184157300"></p>
<p>判断同一行同一列对角线上有无N皇后，同一列题目已经保证了，同一行用map保证，对角线判断j-i&#x3D;&#x3D;abs(row[j]-row[i] ） O(n*n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> K;   cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//第一个元素不用，下标表示col，数值表示row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;row[i];</span><br><span class="line">            <span class="keyword">if</span>(map[row[i]]==<span class="number">1</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> map[row[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;row.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;row.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="built_in">abs</span>(row[j]-row[i])) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184442560.png" alt="image-20210820184442560"></p>
<h3 id="PAT-1129"><a href="#PAT-1129" class="headerlink" title="PAT 1129"></a>PAT 1129</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184523153.png" alt="image-20210820184523153"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184533785.png" alt="image-20210820184533785"></p>
<p><strong>题目大意</strong>：给定一个序列，求目前出现次数最多的k个数字。如果数字出现次数相同，升序排列。</p>
<p><strong>解题思路</strong>：类似LRU，寻找出现次数最多的三个。</p>
<p>数据结构的设计，一个vector&lt;pair&lt;int,int&gt;&gt; KWindow;   存放出现次数最多的K个数字,pair-&gt;first代表数字，pair-&gt;second代表出现的次数，每加入一个数字，我们就要判断是否要更新KWindow.采用unordered_map存放这个数字在目前出现了几次。</p>
<p>判断是否需要更新KWindow? </p>
<p>情况一：新加入的数字在KWindow中，直接在KWindow中更新就好了，然后排序。</p>
<p>情况二：新加入的数字不在KWindow中，而且KWindow还没满，直接加入，然后排序。</p>
<p>情况三：新加入的数字不在KWindow中，而且KWindow满了，判断是否需要替换，由于之前已经排好序了，只要和最后一个比较，如果次数&lt;最后一个，或者次数相同，数字小于最后一个，则替换掉最后一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;    <span class="comment">//统计在j之前出现的次数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; KWindow;  <span class="comment">//存放出现次数最多的K个数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">finda</span><span class="params">(<span class="type">int</span> target,<span class="type">int</span> fre)</span></span>&#123;  <span class="comment">//查找当前数字是不是在KWindow中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(KWindow[i].first==target)&#123;</span><br><span class="line">            KWindow[i].second = fre;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Min = <span class="number">0</span>;  <span class="comment">//当前最小的次数</span></span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp; cin&gt;&gt;temp;</span><br><span class="line">        input.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Map[input[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">finda</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]))&#123;  <span class="comment">//本来就在窗口里面，不用处理</span></span><br><span class="line">            <span class="keyword">if</span>(KWindow.<span class="built_in">size</span>()&lt;K)&#123;  <span class="comment">//窗口还有容量</span></span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]&gt;Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]==Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].first&gt;input[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                    KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(KWindow.<span class="built_in">begin</span>(),KWindow.<span class="built_in">end</span>(),cmp);  <span class="comment">//将窗口排好序</span></span><br><span class="line">        Min = KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;KWindow[i].first;</span><br><span class="line">            <span class="keyword">if</span>(i!=KWindow.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185242648.png" alt="image-20210820185242648"></p>
<h3 id="PAT-1130"><a href="#PAT-1130" class="headerlink" title="PAT 1130"></a>PAT 1130</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185308171.png" alt="image-20210820185308171"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185322504.png" alt="image-20210820185322504"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185334088.png" alt="image-20210820185334088"></p>
<p><strong>题目大意</strong>：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级</p>
<p><strong>解题思路</strong>：给定的输入建树的过程我感觉比较复杂。在输入的第一遍建立TreeNode，然后将string映射到TreeNode中，但这样会有一个问题，就是string的值可能相同，所以我给每个输入结点设置了一个id，第二遍结点全部都创建好了，我们就可以根据左子树所在的行数，和右子树所在的行数 所 映射到的结点建立连接。  最后就是寻找根节点的过程，用set就可以了，把有父节点的加入set，最后不在set的那个就是根节点。</p>
<p>后面就是中序遍历，很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; Set;  <span class="comment">//用来寻找没有前驱的结点,寻找根节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; MM;  <span class="comment">//建立id到TreeNode的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">input</span></span><br><span class="line">&#123;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">&#125;input;</span><br><span class="line">vector&lt;input&gt; I;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        TreeNode* r = MM[I[i].id];</span><br><span class="line">        <span class="keyword">if</span>(I[i].left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* left = MM[I[I[i].left].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].left].id);</span><br><span class="line">            r-&gt;left = left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(I[i].right!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* right = MM[I[I[i].right].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].right].id);</span><br><span class="line">            r-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(I[i].id)==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> MM[I[i].id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)  <span class="comment">//如果不是叶子结点则加括号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    I.<span class="built_in">push_back</span>(input&#123;&#125;);  <span class="comment">//第一个数不用</span></span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        input ii;  cin&gt;&gt;ii.val&gt;&gt;ii.left&gt;&gt;ii.right;</span><br><span class="line">        ii.id=i;</span><br><span class="line">        I.<span class="built_in">push_back</span>(ii);</span><br><span class="line">        TreeNode* r = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ii.val);</span><br><span class="line">        MM[ii.id] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185818116.png" alt="image-20210820185818116"></p>
<h3 id="PAT-1131"><a href="#PAT-1131" class="headerlink" title="PAT 1131"></a>PAT 1131</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181205412.png" alt="image-20210820181205412"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181223417.png" alt="image-20210820181223417"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181241538.png" alt="image-20210820181241538"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181255465.png" alt="image-20210820181255465"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181307918.png" alt="image-20210820181307918"></p>
<p><strong>题目大意</strong>：</p>
<p>给出各地铁线所经过的站点，构成一张地铁交通图。再给出起点和终点，让你找出最快的一条路径，<strong>如果路径不唯一就选择中转次数最少的那一条</strong>。 </p>
<p><strong>解题思路</strong>：</p>
<p>我没有考虑到这一点，所以2，4测试点没有过。</p>
<p>1、本来想用Floyd算法，但是发线每条边权值都为1，所以用BFS搜索即可。</p>
<p>2、构造邻接矩阵有一个问题，就是要解决0000四位整数映射问题，不然开辟10000*10000个空间未免太大了，我的做法是读入是写到set中，然后遍历set建立string-int的映射，还有int-string的映射。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181854943.png" alt="image-20210820181854943"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181916383.png" alt="image-20210820181916383"></p>
<p>3、建图，采用邻接矩阵，这里存储的是无向图，因此根据线路构造的时候要存储两次，邻接矩阵存储的边值代表线路（几号线）而不是代价。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182051111.png" alt="image-20210820182051111"></p>
<p>4、BFS寻找最短路径，用path来存储路径，path[i] &#x3D; j表示，从j-&gt;i，方便往回寻找</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182130533.png" alt="image-20210820182130533"></p>
<p>5、找到后需要输出路径，顺着path往回寻找，将结果放到path_中。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182243168.png" alt="image-20210820182243168"></p>
<p>6、最后在把path带入到Graph中构造出所要的线路结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182317542.png" alt="image-20210820182317542"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; input;   <span class="comment">//input[i]表示i+1号线的站点</span></span><br><span class="line">unordered_set&lt;string&gt; Set;  <span class="comment">//实现站点映射</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; MapStoI; <span class="comment">//相互映射</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,string&gt; MapItoS; <span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;   <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> kkk=<span class="number">0</span>;  <span class="comment">//结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(string start,string destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> begin = MapStoI[start];</span><br><span class="line">    <span class="type">int</span> end = MapStoI[destination];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(kkk,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(kkk,<span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(begin);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   <span class="comment">//BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kkk;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span> &amp;&amp; Graph[t][i])&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">//访问过</span></span><br><span class="line">                path[i] = t;  <span class="comment">//记录从t-i的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="type">int</span> p = end;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path_;  path_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(p!=begin)&#123;</span><br><span class="line">        <span class="type">int</span> temp = path[p];</span><br><span class="line">        path_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;path_.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(path_.<span class="built_in">begin</span>(),path_.<span class="built_in">end</span>());  <span class="comment">//反转</span></span><br><span class="line">    <span class="type">int</span> bbbb = path_[<span class="number">0</span>];  <span class="type">int</span> eeee = path_[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> xianlu = Graph[path_[<span class="number">0</span>]][path_[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[path_[i]][path_[i<span class="number">-1</span>]]==xianlu) eeee = path_[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[eeee].<span class="built_in">c_str</span>());</span><br><span class="line">            xianlu = Graph[path_[i]][path_[i<span class="number">-1</span>]];</span><br><span class="line">            bbbb = eeee;</span><br><span class="line">            eeee = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[end].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph.<span class="built_in">resize</span>(kkk,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(kkk,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;input[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            Graph[MapStoI[input[i][j<span class="number">-1</span>]]][MapStoI[input[i][j]]] = i+<span class="number">1</span>;  <span class="comment">//后面的数字代表几号线 ,0 表示不连通</span></span><br><span class="line">            Graph[MapStoI[input[i][j]]][MapStoI[input[i][j<span class="number">-1</span>]]] = i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="comment">//1  处理输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">C</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;C[j];</span><br><span class="line">            Set.<span class="built_in">insert</span>(C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        input.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 站点映射</span></span><br><span class="line">    unordered_set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Set.<span class="built_in">begin</span>();iter!=Set.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        MapItoS[kkk] = *iter;</span><br><span class="line">        MapStoI[*iter]=kkk++;</span><br><span class="line">    &#125;<span class="comment">//映射完后共有Kkk个结点，从0..kkk-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 建图</span></span><br><span class="line">    <span class="built_in">BuildGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 广度优先搜索寻找最短路径</span></span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        string start,end; cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182348064.png" alt="image-20210820182348064"></p>
<p><strong>答案正解</strong>：</p>
<p>1、使用邻接表存储     2、使用line的键为a*10000+b,建立边到线路的映射      3、dfs暴力深搜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[<span class="number">10000</span>],minCnt,minTransfer;  <span class="comment">//是否访问过 最小代价  最小中转次数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10000</span>);  <span class="comment">//采用邻接表存储</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path,tempPath;<span class="comment">//路径vector</span></span><br><span class="line"><span class="type">int</span> start,end1;<span class="comment">//起点 终点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; line;  <span class="comment">//结点到路线的映射</span></span><br><span class="line"><span class="comment">/*unordered_map&lt;int,int&gt;line存储两个结点的边所属的路线</span></span><br><span class="line"><span class="comment">假设边两端为a到b，line的键为a*10000+b,值为这条边所属的路线*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transferCnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//传入临时路径，传出中转站个数</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">-1</span>,preLine=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]] != preLine) </span><br><span class="line">			cnt++;<span class="comment">//换乘数cnt+1</span></span><br><span class="line">		preLine=line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;<span class="comment">//输出换乘数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> cnt)</span></span>&#123; <span class="comment">//cnt为换乘数</span></span><br><span class="line">    <span class="comment">//搜索到路径，需要更新</span></span><br><span class="line">	<span class="keyword">if</span>(node==end1 &amp;&amp; (cnt&lt;minCnt || (cnt ==minCnt&amp;&amp;<span class="built_in">transferCnt</span>(tempPath) &lt;minTransfer))) &#123;</span><br><span class="line">		minCnt=cnt;<span class="comment">//更新cnt</span></span><br><span class="line">		minTransfer=<span class="built_in">transferCnt</span>(tempPath);<span class="comment">//更新最小换乘次数</span></span><br><span class="line">		path=tempPath;<span class="comment">//更新路径vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node == end1) <span class="keyword">return</span>;<span class="comment">//搜索到，但不需要更新</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[node].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//dfs寻找路径</span></span><br><span class="line">		<span class="keyword">if</span>(visit[v[node][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">			visit[v[node][i]]=<span class="number">1</span>;<span class="comment">//加锁</span></span><br><span class="line">			tempPath.<span class="built_in">push_back</span>(v[node][i]);</span><br><span class="line">			<span class="built_in">dfs</span>( v[node][i] ,cnt+<span class="number">1</span>); <span class="comment">//cnt+1，进入下一层dfs</span></span><br><span class="line">			visit[v[node][i] ]=<span class="number">0</span>;<span class="comment">//解锁  类似回溯，只对这一层dfs有效</span></span><br><span class="line">			tempPath.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	<span class="type">int</span> n,m,k,pre,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//地铁路线数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;pre);<span class="comment">//pre为m线路的首站</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;<span class="comment">//for循环剩下的m-1个站</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">			v[pre].<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="comment">//首站为pre的线路(vector里)加上temp站</span></span><br><span class="line">			v[temp].<span class="built_in">push_back</span>(pre);</span><br><span class="line">			<span class="comment">//temp站的vector里加入首站(pre)</span></span><br><span class="line">			line[pre*<span class="number">10000</span>+temp]=line[temp*<span class="number">10000</span>+pre]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//pre到temp的线路=temp到pre的线路+1</span></span><br><span class="line">			pre=temp;<span class="comment">//首站为temp</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);<span class="comment">//k次查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;end1);</span><br><span class="line">		<span class="comment">//查询start站到end1站</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//minCnt为最小换乘数，minTransfer为换乘站</span></span><br><span class="line">		minCnt=<span class="number">99999</span>,minTransfer=<span class="number">99999</span>;<span class="comment">//初始化</span></span><br><span class="line">		tempPath.<span class="built_in">clear</span>();</span><br><span class="line">		tempPath.<span class="built_in">push_back</span>(start);<span class="comment">//把start压入临时路径vector</span></span><br><span class="line">		visit[start]=<span class="number">1</span>; <span class="comment">//加锁</span></span><br><span class="line">		<span class="built_in">dfs</span>(start,<span class="number">0</span>); <span class="comment">//递归DFS！！！！！！！！！</span></span><br><span class="line">		visit[start]=<span class="number">0</span>; <span class="comment">//解锁</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//以下为output</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minCnt);<span class="comment">//起点&amp;终点之间的min站数</span></span><br><span class="line">		<span class="type">int</span> preLine=<span class="number">0</span>,preTransfer=start;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;path.<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]] != preLine)&#123;</span><br><span class="line">				<span class="keyword">if</span>(preLine != <span class="number">0</span>) <span class="comment">//每当line和preline不等则输出这句话</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>,</span><br><span class="line">					preLine,preTransfer,path[j<span class="number">-1</span>] );</span><br><span class="line">				preLine=line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]];<span class="comment">//更新上一条线路号</span></span><br><span class="line">				preTransfer = path[j<span class="number">-1</span>];<span class="comment">//更新上一个换乘站</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, </span><br><span class="line">				preLine,preTransfer,end1);<span class="comment">//输出最后一小截线路</span></span><br><span class="line">				<span class="comment">//preLine路线 从preTransfer站到end1站</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820183834493.png" alt="image-20210820183834493"></p>
<h2 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h2><p>1h40min搞定  98分</p>
<h3 id="PAT-1124"><a href="#PAT-1124" class="headerlink" title="PAT 1124"></a>PAT 1124</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105622634.png" alt="image-20210829105622634"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105636286.png" alt="image-20210829105636286"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105648351.png" alt="image-20210829105648351"></p>
<p><strong>题目大意</strong>：明PAT考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔N个人就发出一个红包。请你编写程序帮助他确定中奖名单。注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出“Keep going…”</p>
<p><strong>思路</strong>：只要读懂题目，没有任何头脑的题，一个while循环，加一个set判断重复轻松搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> M,N,S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;S;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">L</span><span class="params">(M+<span class="number">1</span>,<span class="string">&quot;&quot;</span>)</span></span>; </span><br><span class="line">    set&lt;string&gt; Set;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = S;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(L[cur])==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(L[cur]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(L[cur]);</span><br><span class="line">            cur += N;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Keep going...&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105856839.png" alt="image-20210829105856839"></p>
<h3 id="PAT-1125"><a href="#PAT-1125" class="headerlink" title="PAT 1125"></a>PAT 1125</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105926511.png" alt="image-20210829105926511"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105937843.png" alt="image-20210829105937843"></p>
<p>题目大意：　绳子每次打结长度都会减小到原来的一半，那么打结的顺序会影响到最终的长度。求最终长度不超过的数。</p>
<p>刚开始都没太懂题目的意思…最后想想应该是排序+模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = <span class="built_in">double</span>(possible)/<span class="number">2</span> + <span class="built_in">double</span>(Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">    <span class="comment">// printf(&quot;%.0f&quot;,possible);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110128163.png" alt="image-20210829110128163"></p>
<p>注意：只需排序一次，觉得要每次有新绳子就要排序一下，比你小的两个数的平均数肯定也是最小的呀！</p>
<p>测试点1是只有一段绳子，开始的两段绳子要特殊处理，总长度初值应该是最小绳子长度，而不是0</p>
<p>稍加修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = Input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = (possible+Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110627305.png" alt="image-20210829110627305"></p>
<h3 id="PAT-1126"><a href="#PAT-1126" class="headerlink" title="PAT 1126"></a>PAT 1126</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110921087.png" alt="image-20210829110921087"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110935002.png" alt="image-20210829110935002"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110945243.png" alt="image-20210829110945243"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110956289.png" alt="image-20210829110956289"></p>
<p>题目大意：</p>
<p>对于无向图来说：</p>
<ol>
<li>是欧拉图，连通且所有节点的度为偶数</li>
<li>是半欧拉图，连通且只有两个节点的度为奇数</li>
</ol>
<p>转化为统计图的度，然后判断几个节点的度是奇数，如果仅仅只是这样简单处理测试点3过不去，后向仔细看题看到了<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111134310.png" alt="image-20210829111134310"></p>
<p>需要是连通图才可以。</p>
<p>由于懒得构造邻接矩阵再进行遍历，这里使用并查集来判断是不是完全连通图、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *parents;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> total)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;total = total;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="type">int</span>[total+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">find</span>(node1);</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">find</span>(node2);</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;</span><br><span class="line">            parents[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents[node]!=node)&#123;</span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(node1)==<span class="built_in">find</span>(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEurn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isConnected</span>(i,i+<span class="number">1</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    UnionFind* uf = <span class="keyword">new</span> <span class="built_in">UnionFind</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        degree[n1]++; degree[n2]++;</span><br><span class="line">        uf-&gt;<span class="built_in">Union</span>(n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==N) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">if</span>(degree[i]%<span class="number">2</span>) oddnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uf-&gt;<span class="built_in">isEurn</span>()==<span class="literal">false</span>) &#123;cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(oddnum==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oddnum==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Semi-Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111235971.png" alt="image-20210829111235971"></p>
<h3 id="PAT-1127"><a href="#PAT-1127" class="headerlink" title="PAT 1127"></a>PAT 1127</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111310015.png" alt="image-20210829111310015"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111320873.png" alt="image-20210829111320873"></p>
<p><strong>题目大意</strong>：给定中序和后序序列，建立一棵树，然后对这棵树进行Z型层序遍历。</p>
<p><strong>思路</strong>：就是在层序遍历的时候需要把层数分出来，然后设置一个flag，需要的时候把序列翻转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorder;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> inleft,<span class="type">int</span> inright,<span class="type">int</span> postleft,<span class="type">int</span> postright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inleft&gt;inright) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;postright&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> curnode = postorder[postright];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(curnode);</span><br><span class="line">    <span class="type">int</span> mid = M[curnode];</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(inleft,mid<span class="number">-1</span>,postleft,postleft+mid<span class="number">-1</span>-inleft);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(mid+<span class="number">1</span>,inright,postleft+mid<span class="number">-1</span>-inleft+<span class="number">1</span>,postright<span class="number">-1</span>);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> yinzi = <span class="number">-1</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(yinzi==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        yinzi *= <span class="number">-1</span>;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; inorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">        M[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; postorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ZigZag</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111516703.png" alt="image-20210829111516703"></p>
<h2 id="2021-9-5"><a href="#2021-9-5" class="headerlink" title="2021.9.5"></a>2021.9.5</h2><h3 id="PAT-1120"><a href="#PAT-1120" class="headerlink" title="PAT 1120"></a>PAT 1120</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154114163.png" alt="image-20210905154114163"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154125395.png" alt="image-20210905154125395"></p>
<p>题意：统计数的各位数字之和，并升序输出</p>
<p>用set啥的就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:15-8:25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            count += s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[count]++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154408271.png" alt="image-20210905154408271"></p>
<h3 id="PAT-1121"><a href="#PAT-1121" class="headerlink" title="PAT 1121"></a>PAT 1121</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154431389.png" alt="image-20210905154431389"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154440477.png" alt="image-20210905154440477"></p>
<p>题目大意：给N对夫妻编号，再给M个派对里的参与人的编号，输出单身的人的编号（包括夫妻没全部到场的也算单身）</p>
<p>用map统计夫妻配对的情况，再用一个map[10000]统计到场情况，最后一一排除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154613535.png" alt="image-20210905154613535"></p>
<p>改用set存储M个人的信息，就可以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">insert</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=res.<span class="built_in">begin</span>();it!=res.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it!=res.<span class="built_in">begin</span>())<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155315203.png" alt="image-20210905155315203"></p>
<h3 id="PAT-1122"><a href="#PAT-1122" class="headerlink" title="PAT 1122"></a>PAT 1122</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155357857.png" alt="image-20210905155357857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155408391.png" alt="image-20210905155408391"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155419998.png" alt="image-20210905155419998"></p>
<p>判断是否是哈密顿回路，随便写写就AC了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:40-9:00</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E; cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        graph[e1][e2]=<span class="number">1</span>; graph[e2][e1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Input[i];</span><br><span class="line">        <span class="keyword">if</span>(Input.<span class="built_in">size</span>()!=V+<span class="number">1</span> || Input[<span class="number">0</span>]!=Input[V])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[Input[j]][Input[j+<span class="number">1</span>]]==<span class="number">1</span>)&#123;</span><br><span class="line">                Set.<span class="built_in">insert</span>(Input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==V) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155456226.png" alt="image-20210905155456226"></p>
<h3 id="PAT-1123"><a href="#PAT-1123" class="headerlink" title="PAT 1123"></a>PAT 1123</h3>]]></content>
      <tags>
        <tag>算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubAction+Hexo搭建个人博客</title>
    <url>/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="GithubAction-Hexo搭建个人博客"><a href="#GithubAction-Hexo搭建个人博客" class="headerlink" title="GithubAction+Hexo搭建个人博客"></a>GithubAction+Hexo搭建个人博客</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信很多小伙伴们都在使用 Hexo + Github Page 的方式，先在本地生成自己博客的静态页面，然后再推送到 Github Page 来实现页面的更新。Github 近些年推出了 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a>，这是一个非常强大的 Workflow 自动化工作流，它可以帮助我们完成很多自动化部署任务。今天就来利用 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a> 自动化部署 Hexo 到 Github Page。</p>
<p>本来想使用 Travis CI 自动部署 Hexo 博客，一个私人仓库用于备份博客源码，另一个公开仓库用于托管静态页面，但是最近将修改的文章推送到私人仓库时没有触发 Travis CI 的工作流， Travis CI持续集成部署麻烦，而且还需付费，所以考虑了GIthub Action这种简单免费的部署方式。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>Node.JS</li>
<li>Git</li>
</ul>
<h3 id="Hexo本地博客搭建"><a href="#Hexo本地博客搭建" class="headerlink" title="Hexo本地博客搭建"></a>Hexo本地博客搭建</h3><h4 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h4><p>首先全局安装Hexo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Hexo</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，创建一个project文件夹，然后在该文件夹下初始化，（下面所有命令都是在该文件夹里执行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化 Hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>创建文章命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo new &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会发现在source&#x2F;_post文件夹里出现了”文章名字”.md的文件，Hexo采用markdown编辑。</p>
<p>在本地启动文章，就可以在<a href="http://localhost:4000/">http://localhost:4000/</a> 访问该博客了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo s   # 本地服务启动server</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228215744193.png" alt="image-20230228215744193"></p>
<p>Hexo常用的配置以及目录结构</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228220622909.png" alt="image-20230228220622909"></p>
<p>source&#x2F;_post用于存放用户文章 , _config.yml用于存放配置文件</p>
<h4 id="一些配置修改"><a href="#一些配置修改" class="headerlink" title="一些配置修改"></a>一些配置修改</h4><p>主题配置，在Hexo的官方网站上有许多可以选择的样式 <a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p>
<p>选择一个主题，按照主题里面提示的方法进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在Hexo目录下Clone这个主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"># 修改 Hexo 根目錄下的 _config.yml，把主題改為butterfly</span><br><span class="line">theme: butterfly</span><br><span class="line"></span><br><span class="line"># 安裝插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>





<p>在博客搭建完成之后会发现图片无法显示，</p>
<p>安装一个图片显示的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml的配置文件，然后把 _config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。将图片存放在这个文件夹里引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder = true</span><br></pre></td></tr></table></figure>





<h3 id="Hexo博客发布"><a href="#Hexo博客发布" class="headerlink" title="Hexo博客发布"></a>Hexo博客发布</h3><p>在github下创建一个 linli1724647576.github.io 的仓库，目前github采用的令牌代替密码，所以需要在 devoloper setting的设置里new 一个 Tokens，勾上所有的权限。</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228221853162.png" alt="image-20230228221853162"></p>
<p>然后，在_config.yml 的配置文件里做以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: &quot;https://github.com/linli1724647576/linli1724647576.github.io.git&quot;</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>执行上传命令，会提示输入github的用户名和密码，密码用令牌代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo d  #上传博客 deploy</span><br></pre></td></tr></table></figure>

<p>上传成功后就可以在github Pages里访问了。</p>
<h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;  等价于 hexo new &quot;我的第一篇文章&quot;  还等价于</span><br><span class="line">hexo p 等价于 hexo publish</span><br><span class="line">hexo g 等价于 hexo generate  </span><br><span class="line">hexo s等价于 hexo server     </span><br><span class="line">hexo d 等价于 hexo deploy</span><br></pre></td></tr></table></figure>

<p>下次发布时先运行hexo g生成静态网页，然后再hexo d </p>
<p>也可以采用admin模式自动发布,需要安装插件</p>
<p>npm install –save hexo-admin</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/BV1mU4y1j72n/">https://www.bilibili.com/video/BV1mU4y1j72n/</a></p>
<p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/2023/03/01/tags/</url>
    <content><![CDATA[<p>硕士在读，计算机技术专业，分享一些论文和一些技术，强迫自己以更加系统和严谨的态度梳理问题，也希望对他人有所帮助。</p>
]]></content>
  </entry>
  <entry>
    <title>PLUMBER</title>
    <url>/2023/03/04/PLUMBER/</url>
    <content><![CDATA[<h1 id="PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem"><a href="#PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem" class="headerlink" title="PLUMBER: Boosting the Propagation of Vulnerability Fixes in the npm Ecosystem"></a>PLUMBER: Boosting the Propagation of Vulnerability Fixes in the <em>npm</em> Ecosystem</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><ul>
<li>npm是JavaScript编程语言中最大的生态系统，截至2022年1月，它拥有超过180万个第三方软件包。</li>
<li>2017年11月2日的npm快照进行的调查显示，在610,097个包中，其中21.9%直接依赖于易受攻击的包。如果考虑到传递性依赖关系，这种脆弱性对npm生态系统的脆弱性影响可能会显著增加。</li>
<li>我们对npm包的3948个漏洞报告的初步研究发现，在发现漏洞后，60.6%涉及的包及时发布了修复版本。</li>
<li>漏洞修复工具例如 <em>npm</em> audit [6] and Dependabot [7] 来提醒那些直接地或过渡性地依赖于脆弱的软件包版本的项目。</li>
<li>我们对传播漏洞修复的滞后的原因进行了两个观察：大多数包只修复了其最高主要版本中的漏洞，而没有将修复移植到早期的流行版本中。由于缺乏生态系统级依赖图的完整概图，包开发人员几乎没有意识到它们是阻止修复程序传播到其许多下游包的关键因素。</li>
</ul>
<h2 id="2-Motivation-Example"><a href="#2-Motivation-Example" class="headerlink" title="2.Motivation Example"></a>2.Motivation Example</h2><p><img src="/2023/03/04/PLUMBER/image-20230226104613081.png" alt="image-20230226104613081"></p>
<ul>
<li>我们将阻止修复在依赖路径上传播的包称为阻塞包。上图中browser-sync和graphql为阻塞包。</li>
<li>从阻塞包到脆弱包的依赖路径被称为阻塞链。 上图中 browser-sync-&gt;socket.io -&gt;engine.io为一条阻塞链</li>
</ul>
<h2 id="3-Introduction"><a href="#3-Introduction" class="headerlink" title="3.Introduction"></a>3.Introduction</h2><h3 id="3-1-相关工作"><a href="#3-1-相关工作" class="headerlink" title="3.1 相关工作"></a>3.1 相关工作</h3><p>(1)脆弱性对生态系统的影响[2、10、10-16]；</p>
<p>(2)减少报告易受攻击的依赖项[17–22]的误报；</p>
<p>(3)易受攻击的程序包更新中的滞后[1,23-28]</p>
<p>[1] 他们进行了一项实证调查，以确定在脆弱的包发布和固定发布之间可能出现的滞后。为了确保快速采用和传播包含修复程序的版本，他们为开发人员和研究人员提供了可操作的建议：开发者要有更好的意识，以便更快地规划依赖项更新。</p>
<p>然而，现有的工作都没有探索生态系统中阻塞包和阻塞链的特征。如何设计一种技术来加速漏洞的修复仍然是一项主要问题。</p>
<h3 id="3-2-目标和挑战"><a href="#3-2-目标和挑战" class="headerlink" title="3.2 目标和挑战"></a>3.2 目标和挑战</h3><p>为关键软件包提供可行的补救策略，促进脆弱性修复的传播。</p>
<ul>
<li>获取最新的漏洞元数据和npm依赖元数据。</li>
<li>了解阻塞链的演化特征及其对脆弱性修复传播的影响。</li>
</ul>
<h3 id="3-3-方法和结果"><a href="#3-3-方法和结果" class="headerlink" title="3.3 方法和结果"></a>3.3 方法和结果</h3><p><strong>Empirical Study:</strong></p>
<p>（RQ1）含有漏洞的包的规模及其对其他项目的影响；</p>
<p>（RQ2）在连续npm快照上的阻塞链的演化特征；</p>
<p>（RQ3）对传播漏洞修复有更好效果的补救策略。</p>
<p><strong>Technique:</strong></p>
<p>(1)对漏洞和npm依赖元数据进行建模，并逐步更新其演化过程；</p>
<p>(2)识别阻碍漏洞修复通过依赖路径传播的关键阻塞链；</p>
<p>(3)分析阻塞链上的软件包的特性，定制修复方案。</p>
<p><strong>Evaluation:</strong></p>
<p>我们应用PLUMBER为最具影响力的阻塞链生成了268份修复报告。47.4%的补救报告得到了积极的反馈。PLUMBER生成的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个活跃的npm项目中。</p>
<p><strong>Contributions:</strong></p>
<ul>
<li>我们进行了第一个实证研究，以描述软件包在生态系统中阻碍脆弱性修复的传播的情况。</li>
<li>我们开发了PLUMBER工具，通过纠正关键的阻塞链，来促进npm生态系统中脆弱性修复的传播。</li>
<li>一个大规模的漏洞修复传播实验。我们的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个根包中。</li>
</ul>
<h2 id="4-Empirical-Study"><a href="#4-Empirical-Study" class="headerlink" title="4.Empirical Study"></a>4.Empirical Study</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2023/03/04/PLUMBER/image-20230227101417121.png" alt="image-20230227101417121"></p>
<p>搜集漏洞元数据：<em>GitHub Advisory DB</em>, <em>Snyk Vul</em> <em>nerability DB</em> and <em>NPM Security Advisories</em>. </p>
<p>收集npm依赖项元数据：（V，E，C） V版本集合， E依赖边 （最新版本）<em>E</em> &#x3D; <em>{<strong>p</strong>i*@<em>va</em> <em>→</em> <em>pj</em>@<em>v*<em>b</em></em>|<strong>p</strong>i*@<em>v*<em>a</em></em>, pj</em>@<em>vb</em> <em>∈</em></p>
<p><em>V</em> <em>}</em>.   C  依赖关系 <em>c</em>(<em>pi</em>@<em>v*<em>a</em></em>, pj* ) <em>∈</em> <em>C</em></p>
<p>识别易受攻击的路径：通过将漏洞元数据映射到npm依赖元数据G &#x3D;（V，E，C），在集合V中，我们定位了所有带有详细漏洞信息的脆弱包版本。通过可达性分析来识别所有的脆弱路径。</p>
<p>VP模型统计： Table 2</p>
<p><img src="/2023/03/04/PLUMBER/image-20230227102441166.png" alt="image-20230227102441166"></p>
<h3 id="RQ1（阻塞包的规模）："><a href="#RQ1（阻塞包的规模）：" class="headerlink" title="RQ1（阻塞包的规模）："></a>RQ1（阻塞包的规模）：</h3><p>在npm生态系统中阻止漏洞修复传播的包的规模是多少？它们在多大程度上影响了其他项目？</p>
<p>在npm生态系统的356283个活跃根系项目中，有20.0%)中有320个仍然通过1065723个脆弱路径直接或过渡地依赖于这些脆弱包。平均而言，每个根项目都会受到4.4个±7.5漏洞的影响。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228090108772.png" alt="image-20230228090108772"></p>
<p>在npm生态系统的快照中，有45,148个阻塞包和358,422个阻塞链导致983,336个依赖路径的漏洞修复传播滞后。在有影响力的阻塞软件包和阻塞链上都有明显的中心地位。20%的阻塞软件包和阻塞链影响了绝大多数脆弱的路径。</p>
<h3 id="RQ2（阻塞链的进化）："><a href="#RQ2（阻塞链的进化）：" class="headerlink" title="RQ2（阻塞链的进化）："></a>RQ2（阻塞链的进化）：</h3><p>阻断链在npm生态系统中是如何进化的？它们在npm的生态系统中存在了多久了？</p>
<p>方法：每隔两个月爬取一次npm快照，(a)通过比较快照si（1 &lt; i≤7）与s1的统计数据，我们研究了s1中阻塞链、脆弱路径和受影响的根项目的规模，这些项目在一年的进化过程中进行了修复。(b)通过比较两个连续快照si−1和si的统计数据，我们统计了每两个月间隔内修复的阻塞链、脆弱路径和受影响的根项目的数量。此外，我们还关注了与si−1相比，si是否引入了新的案例。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228091129135.png" alt="image-20230228091129135"></p>
<p>在2020年8月1日的npm快照中，经过一年的进化，77.0%的阻断链仍然存在。在此期间，受这些阻塞链影响的脆弱路径和根项目的数量分别下降了37.1%和17.3%。9,904个活动根项目通过17,612条脆弱路径仍然引用了9,808个与更高级漏洞捆绑的阻塞链。</p>
<h3 id="RQ3（补救模式）："><a href="#RQ3（补救模式）：" class="headerlink" title="RQ3（补救模式）："></a>RQ3（补救模式）：</h3><p>阻塞链如何从脆弱路径中去除？是否可以提炼出常见的补救模式，以促进漏洞修复的传播？</p>
<p>我们实证研究了在快照s1-s7（在RQ2中收集）和提炼的常见修复模式中，包更新是如何通过包更新进行修复的。我们关注两种类型的阻塞链，它们通过包更新进行了修复，具有传播漏洞修复的显著效果：</p>
<p><strong>Type A</strong>。阻断链存在于快照s1-si−1（1&lt;i≤7）中，而在快照si中被修复。</p>
<p><strong>Type B</strong>。快照s1-s7中存在的阻塞链，而在进化过程中受其影响的脆弱路径的数量显著减少。</p>
<p><strong>Remediation pattern A.</strong>  阻塞包在其最高主要版本中发布了一个新版本，其中升级了直接依赖以过渡引入漏洞修复。通过最终将直接依赖项升级到安全版本，它们最终修复了其最高可用版本中的漏洞。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093517214.png" alt="image-20230228093517214"></p>
<p><strong>Remediation pattern B</strong> 中间包在其较低的主要版本中发布一个新版本，其中升级直接依赖，使非活动的阻塞包过渡地引入漏洞修复（100%的Type A阻塞链实例）。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093534796.png" alt="image-20230228093534796"></p>
<p><strong>Remediation pattern C</strong> </p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093801859.png" alt="image-20230228093801859"></p>
<p>这三种模式的<strong>补救成本</strong>标记如下：模式A&lt;模式B&lt;模式C</p>
<p>我们提炼了三种常见的修复模式及其传播漏洞修复的先决条件。对于由主动阻塞包引起的阻塞链，这种阻塞包可以纠正其最高可用版本（模式A）中的漏洞。对于由非活动阻塞包引起的阻塞链，中间包可以纠正其较低主要版本序列中的漏洞，使非活动阻塞包能够过渡地引入漏洞修复（模式B）。此外，受阻塞链影响的包也可以不弃用不活动的阻塞包，并迁移到其他维护良好的包，以修复漏洞（模式C）。</p>
<h2 id="5、Approach"><a href="#5、Approach" class="headerlink" title="5、Approach"></a>5、Approach</h2><p><img src="/2023/03/04/PLUMBER/image-20230301174303414.png" alt="image-20230301174303414"></p>
<p>和DTResolver有区别的点：</p>
<p>识别阻塞链：对于每个脆弱路径，PLUMBER从脆弱包pu开始，迭代计算每个包的安全版本µt，直到阻塞包的安全版本为空。最后，PLUMBER根据通过它们的脆弱路径的数量对识别出的阻塞链进行排序。排名最高的阻塞链被认为是关键的阻塞链，应该进行修复，以使漏洞修复能够传播到大量的包中。</p>
<p>我们的实证研究结果表明，三种策略的补救成本通常遵循：策略A&lt;策略B&lt;策略 C. 因此，对于由积极维护的软件包引起的阻塞链，水管工高度建议了补救策略 A. 对于由非活动阻塞包引起的阻塞链，在中间包（即阻塞包和脆弱包之间的包）被开放版本约束指定的情况下，水管工建议补救策略B，如果它们可以返回到较低版本的序列。否则，水管工将采用补救策略C来迁移非活性的阻塞链。</p>
<h2 id="6、Evaluation"><a href="#6、Evaluation" class="headerlink" title="6、Evaluation"></a>6、Evaluation</h2><h3 id="RQ4（PLUMBER的有效性）："><a href="#RQ4（PLUMBER的有效性）：" class="headerlink" title="RQ4（PLUMBER的有效性）："></a>RQ4（PLUMBER的有效性）：</h3><p>水管工制定的补救策略与开发人员是否一致？</p>
<p>方法：选择开发人员已经修复的一些包作为基准，将我们的修复方案和开发人员的修复方案进行比较。</p>
<p>结果：由水管工提出的362种补救策略中，有289种（79.8%）与我们的基准策略一致。对于73种不一致的补救策略，我们的工具通过平衡漏洞修复的补救成本和传播效果来生成建议。</p>
<h3 id="RQ5（补救挑战）："><a href="#RQ5（补救挑战）：" class="headerlink" title="RQ5（补救挑战）："></a>RQ5（补救挑战）：</h3><p>补救npm生态系统中的阻塞链有多具有挑战性？</p>
<p>方法：为了回答RQ5，对于在最近2021年8月1日的npm快照上确定的358,422条阻塞链，我们将它们分为不同的修复难度级别。此外，我们还观察了它们的分布情况，并讨论了补救方面的挑战。</p>
<p>结果：对于影响npm生态系统中大多数脆弱路径的前20%的关键阻断链，其中46.1%的关键阻断链难以修复。它们要么需要迁移非活动的阻塞包，要么需要升级其依赖项的主要版本，以引入漏洞修复，这需要更多的代码更改和测试工作。37.0%的顶级关键阻塞链可以通过所涉及的中间包的反向移植实践进行修复。只有16.9%的顶级关键阻塞链可以通过将主动阻塞包的依赖关系升级到安全的版本来轻松修复。</p>
<h3 id="RQ6（LUMBER的有用性）："><a href="#RQ6（LUMBER的有用性）：" class="headerlink" title="RQ6（LUMBER的有用性）："></a>RQ6（LUMBER的有用性）：</h3><p>水管工能否促进npm生态系统中脆弱性修复程序的传播，并为开发人员提供有用的补救策略？</p>
<p>方法：向开发人员提出Bug  report，挑选了前300个关键的阻塞软件包，并人工验证受影响的下游项目是否可以引入相关的漏洞修复程序</p>
<p>结果：47.4%的补救报告收到了来自许多著名的npm项目的积极反馈。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h2><p>出发点不同，DTResolver是根据root package构造依赖树，并检测依赖树中的漏洞和一些修复策略。 PLUMBER更注重npm生态系统的平衡，检测npm生态系统的Block Chain，并对包开发人员提出修复建议。</p>
<p>和DTResolver一样，都对npm漏洞的影响进行了研究，DTResolver注重于npm3正确依赖树的构造，Plumber更注重实证研究和漏洞的修复。</p>
<p>DTResolver的DTReme的修复有点突兀，没有前因后果，Plumber的修复是基于他的实证研究的结果，根据开发人员的建议制定的策略。</p>
<p>论文的组织模式和Watchman, Nufix很像，都是先实证研究，将问题进行分类，探索开发人员的修复策略； 再根据我们的工具进行分类检测，并提出修复策略，最后让开发人员确认。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</title>
    <url>/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<h1 id="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"><a href="#通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱" class="headerlink" title="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"></a>通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><p><code>本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。</code></p>
<p><a href="https://www.secrss.com/articles/43424">https://www.secrss.com/articles/43424</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/594160921">https://zhuanlan.zhihu.com/p/594160921</a></p>
<p><a href="https://sites.google.com/view/npm-vulnerability-study/">https://sites.google.com/view/npm-vulnerability-study/</a></p>
<p><a href="https://www.youtube.com/watch?v=CErMF3CgSc8">https://www.youtube.com/watch?v=CErMF3CgSc8</a></p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>NPM上发布了170多万个Node.js库，以促进软件开发。正如对比安全所揭示的，第三方库出现在当今软件的大多数（79%）中。然而，任何事物都有两面性。虽然使用库可以减少开发成本和时间，但这些集成库在实践中对软件生态系统构成了新的安全威胁，这些库中的漏洞可能会使依赖它们的软件不断面临安全风险。之前的工作已经调查了整个NPM生态系统的脆弱性影响，而他们的方法要么只是静态地考虑直接依赖性，或者基于依赖关系进行间接依赖的可达性分析，这可能会引入不准确的传递依赖关系，从而导致误报漏洞警告。现存的研究方法还没有提供一个精确的依赖关系。尤其是软件依赖关系之间的内部复杂关系，在很大程度上削弱了其分析的影响，并限制了进一步的解决方案（即精确修复）的提出。尽管一些现有的SCA工具（如Snyk和Blackduck）支持对用户项目进行NPM依赖性分析，但大多数工具都是从实际安装中检索依赖树，而不是从静态推理中检索依赖树。此外，由于语义版本控制的灵活性，依赖关系以及依赖关系中的漏洞实际上会随着时间的推移而发生动态变化。因此，尽管现有工作也调查了漏洞的影响，在没有静态和精确的依赖关系解决方案的情况下，大规模分析依赖关系中存在的漏洞传播的演变仍然是一个挑战，更不用说在防止漏洞动态引入依赖项方面获得实用的解决方案。</p>
<h2 id="2-论文主要成果"><a href="#2-论文主要成果" class="headerlink" title="2. 论文主要成果"></a>2. 论文主要成果</h2><ul>
<li>实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包（超过114万个库和1094万个版本）之间的依赖关系，以及来自NVD的800多个已知CVE（常见漏洞和暴露），进一步的支持对漏洞传播的分析</li>
<li>提出了一种基于DVGraph的新算法（DTResolver），可以静态、精确地解析任意安装时间的依赖树，精度高达90%以上，并通过大约100k个代表性软件包进行了验证</li>
<li>进一步对依赖树中的脆弱性传播进行了实证研究。首先，我们研究了NPM依赖解析带来的依赖树的特征，在此基础上，我们分析了依赖树中漏洞传播的影响和特征，特别是传递依赖的漏洞。此外，我们还将研究扩展到时间维度，以研究依赖树中漏洞传播随时间的演变，揭示依赖树中引入漏洞的原因，以及可能的解决方案</li>
</ul>
<h2 id="3-实验架构"><a href="#3-实验架构" class="headerlink" title="3. 实验架构"></a>3. 实验架构</h2><p>包括依赖漏洞知识图构建、依赖树解析、漏洞路径识别及其验证、大规模实证研究以及对经验教训和解决方案的讨论，以及可能的研究方向</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1ed5572cf3d56e315f7e865590c7f9ac.png" alt="img"></p>
<h2 id="4-DVGraph的构建"><a href="#4-DVGraph的构建" class="headerlink" title="4. DVGraph的构建"></a>4. DVGraph的构建</h2><p>为了支持高精度和高效率的大规模依赖漏洞分析，我们设计并实现了一套数据处理平台，以构建和维护完整而精确的依赖漏洞图DVGraph（基于neo4j）。</p>
<p>下图为改数据处理平台的框架：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/5d6447824371e7607b366407f7aad9fa.png" alt="img"></p>
<p><strong>Metadata Pipeline：</strong>将数据保存在元数据库中</p>
<p><strong>CVE Pipeline：</strong>从NVD数据集收集CVE数据</p>
<p><strong>CVE Triage Pipeline：</strong>手工标记CVE数据的对应的受影响的库和版本</p>
<p><strong>Graph Pipeline：</strong>解析新来的元数据和映射的CVE数据，计算要在DVGraph上执行的操作（即添加、更改和删除节点和边），并最终执行这些操作</p>
<h2 id="5-依赖树解析和脆弱路径识别"><a href="#5-依赖树解析和脆弱路径识别" class="headerlink" title="5. 依赖树解析和脆弱路径识别"></a>5. 依赖树解析和脆弱路径识别</h2><h3 id="5-1-依赖树解析"><a href="#5-1-依赖树解析" class="headerlink" title="5.1 依赖树解析"></a>5.1 依赖树解析</h3><p>目前还没有一个考虑到特定于平台的依赖关系解决规则，可能导致不准确的依赖关系解析。本文目标是实现静态解析与NPM在实际安装过程中动态解析和安装的依赖树一致的依赖树，以便我们能够准确有效地识别依赖树中的漏洞和脆弱路径，而无需实际安装。</p>
<p>为了提高精度，同时保持效率，我们提出了一种基于DVGraph的依赖解析算法（DTResolver），可以在不安装的情况下，对任意数据软件包依赖解析的过程中，识别并找出所有依赖中含有安全漏洞的组件及相应的依赖引入路径</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/0fffc83b26b8297bd142c0061a005fb8.png" alt="img"></p>
<p>Dependency Tree Resolution</p>
<p>此外由于NPM中广泛使用依赖约束条件（版本范围）而不是固定版本进行依赖定义，导致依赖安装结果随着时间可能发生变化</p>
<p>如下图中，在<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#46;&#49;">&#66;&#64;&#49;&#46;&#x30;&#46;&#49;</a>发布后，<a href="mailto:&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>的安装过程中，对B的依赖将解析成新发布的版本而不是原有的<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>, 图中<a href="mailto:&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;">&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;</a>的发布亦是如此。因此我们在DTResolver的基础上进一步增加了时间约束，使其能够支持在给定项目从其发布前到DVGraph更新时间内任意时刻的依赖树模拟解析。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/cb04b86c4aafea8676a467c495666079.jpg" alt="img"></p>
<h3 id="5-2-脆弱路径识别"><a href="#5-2-脆弱路径识别" class="headerlink" title="5.2 脆弱路径识别"></a>5.2 脆弱路径识别</h3><p>给出了脆弱点和路径的示例 通过反向深度优先搜索（DFS）实现了一个脆弱路径提取器，以彻底查找依赖树中从脆弱点到根节点的依赖关系</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/aed9b3b573cfcee4c57b966475f78199.png" alt="img"></p>
<h3 id="5-3-评估验证"><a href="#5-3-评估验证" class="headerlink" title="5.3 评估验证"></a>5.3 评估验证</h3><p>通过比较DTResolver解析的依赖树与实际安装的依赖树来验DTResolver。此外，我们将npm-remote-ls作为比较时的方法，这是一种广泛使用的公共API，在实践中无需实际安装即可获得依赖树，并且它完全遵循依赖范围来派生依赖树。</p>
<p>数据选择我们的验证基于两个标准收集的数据：（1）流行度，对于每个流行度指标（即过去、过去3年和去年下载量最多的明星、分叉、下载量多），我们分别选择了前2000个库。（2）中心性，对于每个中心性度量（即最大出入度），我们还选择了前2000个库和前20K个版本。分别地对于库，我们采用每个次要版本的最高补丁版本。最后，整理了15673个库中的103609个版本。</p>
<p><strong>DTResolver解析器的评估。</strong>根据结果，90.58%的图树在忽略无法计算的情况（例如，具有捆绑的依赖项并且包含没有时间的依赖项）后与安装树完全匹配。而只有53.33%的远程树与安装树完全匹配，这是因为npm远程ls错过了一些官方的解决规则（例如，未弃用版本的优先级选择）。此外，我们进一步确定了不匹配依赖树的两个主要原因：1）在npm ls的输出中消除了依赖，这省略了一些包和依赖关系以简化树视图。2） 由于环境问题，依赖项可能无法完全安装（例如，当缺少所需的操作系统支持时，某些程序包可能无法安装）。此外，缺少库版本（即不在NPM注册表中或爬网失败）也会导致依赖关系树中缺少一些包。</p>
<p><strong>漏洞检测和漏洞路径识别评估。</strong>除了DTResolver的评估，我们还扩展到比较检测到的漏洞和易受攻击的路径。由于从实际安装中检索到的安装树可能不完整（例如，依赖关系中的某些包由于环境问题而未安装），我们通过调用Graph Tree和Remote Tree中已识别的漏洞和漏洞路径来评估漏洞检测的准确性。我们发现DTResolver（98.1%）和npm远程ls（97.7%）在检测易受攻击组件方面具有相似的高覆盖率，但在识别易受攻击路径方面存在差异（92.60%对78.31%）。这可能是因为大多数依赖性约束都被解析为最满意的版本，并且依赖性范围也遵循这一规则，因此，仍然可以识别最脆弱的包。然而，通过依赖关系到达解决依赖关系忽略了NPM特定的解决规则，这会影响识别依赖关系路径的准确性。</p>
<h2 id="6-大规模实证研究"><a href="#6-大规模实证研究" class="headerlink" title="6. 大规模实证研究"></a>6. 大规模实证研究</h2><p>以下两个方面分析NPM中安全漏洞的影响：</p>
<ul>
<li>漏洞如何影响NPM生态系统？漏洞如何通过依赖关系树传播影响根包(root packages)？</li>
<li>漏洞传播如何在依赖树中发展？依赖关系树的变化如何影响漏洞传播的演变？</li>
</ul>
<h3 id="6-1-通过依赖树传播漏洞"><a href="#6-1-通过依赖树传播漏洞" class="headerlink" title="6.1 通过依赖树传播漏洞"></a>6.1 通过依赖树传播漏洞</h3><ul>
<li>据统计证明，漏洞广泛存在于NPM包的依赖关系中（整个生态系统中有19.96%的库的四分之一版本）</li>
<li>第三方库的最新版本（16.17%）仍然存在通过依赖关系受到漏洞影响的潜在风险。</li>
<li>其他用户使用的易受攻击的库中，有相当一部分（超过100个）仍然有易受攻击的最新版本</li>
<li>一些有影响力的已知CVE广泛存在于大部分包的依赖树中</li>
<li>包通常受到多个漏洞的影响，每个漏洞通过多个漏洞路径影响根包（平均一个漏洞引入8个漏洞路径）</li>
<li>漏洞仍然广泛存在于受影响库版本的直接依赖关系中（超过30%），即使是最新版本</li>
<li>在易受攻击的路径上也存在中心性，即大多数易受攻击的路径都会通过有限的直接依赖关系，这可以用来切断易受攻击的路径</li>
</ul>
<h3 id="6-2-依赖树中的漏洞传播演化"><a href="#6-2-依赖树中的漏洞传播演化" class="headerlink" title="6.2 依赖树中的漏洞传播演化"></a>6.2 依赖树中的漏洞传播演化</h3><ul>
<li>随着时间的推移，已知的漏洞正在对NPM生态系统造成更大的影响。它们不仅影响到更多的库版本，而且还影响到依赖树中更脆弱的点</li>
<li>大多数CVE（93%）在被发现之前已经被引入依赖树，这些CVE的固定版本（87%）也大多在CVE发布之前发布</li>
<li>依赖树中只有60%的CVE被DTC自动删除，即使如此，每个CVE删除仍需要一年以上的时间</li>
<li>过时的维护（提供者）和不合适的依赖约束（使用者）是阻碍依赖树中漏洞自动移除的主要原因。应该采取更多的对策和解决方案来避免、监控甚至纠正这些不良做法</li>
</ul>
<p>DTReme</p>
<p>添加了1)<strong>前向漏洞检查</strong>，在解析新的依赖关系的版本时（算法1中的第13行和第17行），只解析每个依赖关系的干净版本；2)<strong>向后安装的包跟踪</strong>，一旦没有干净版本可以解决，回滚到父节点的解析，并找到替代版本，以避免没有干净版本的情况。因此，我们可以彻底遍历所有可能的解决方案，找到可能的干净依赖树，并且可以为整个依赖树生成一个新的package-lock.json文件作为修复解决方案。</p>
<h2 id="7、有限性"><a href="#7、有限性" class="headerlink" title="7、有限性"></a>7、有限性</h2><p>首先，依赖关系中的漏洞可能永远不会影响根包，因为可能永远无法访问这些易受攻击的功能。这只能通过基于依赖树和调用图分析易受攻击的函数调用路径来进一步解决。我们将此作为我们未来的工作。其次，CVE和库版本的映射是手动标记的，这可能会导致数据错误标记，合作的作者已将数据与现有CVE交叉验证，以缓解此类威胁。第三，我们无法区分包含缺失依赖项的安装，这可能会使基本事实不准确，我们只接受依赖项中成功安装的包作为验证中的基本事实。第四，由于计算成本过高，在分析漏洞传播时，我们忽略了具有超过1k条漏洞路径的版本。总的来说，这样的版本只占2.01%，这只能对我们的结果造成有限的偏差。</p>
<h2 id="附录1-Npm依赖解析规则"><a href="#附录1-Npm依赖解析规则" class="headerlink" title="附录1 Npm依赖解析规则"></a>附录1 Npm依赖解析规则</h2><p><a href="https://docs.npmjs.com/cli/v9/commands/npm-install">https://docs.npmjs.com/cli/v9/commands/npm-install</a></p>
<p><a href="https://www.cnblogs.com/penghuwan/p/6970543.html">【npm】详解npm的模块安装机制 - 外婆的 - 博客园 (cnblogs.com)</a></p>
<p><font color="red"><strong>依赖树表面的逻辑结构与依赖树真实的物理结构</strong> </font></p>
<p>这里要先提到两个命令：tree -d（linux）和npm ls（npm）</p>
<p>在一个npm项目下：</p>
<p><strong>tree -d命令</strong>以树状图的方式列出一个项目下所有依赖的物理结构</p>
<p><strong>npm ls命令</strong>以树状图的方式列出一个项目下所有依赖的逻辑结构</p>
<p>以官方文档为例子：</p>
<p>项目example1有两个依赖模块：mod-a模块和mod-c模块；</p>
<p>mod-a模块有一个依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;">&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;</a>模块</p>
<p>mod-c模块有一个依赖模块<a href="mailto:&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;</a>模块</p>
<p>tree -d 和npm ls运行结果如下：（注意npm版本为npm3而非npm2）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092200262-641835535.png" alt="img"></p>
<p>先看看下面那个红框的结果，这应该是“最符合我们理解”的依赖树，首先项目下形成了一级依赖——mod-a模块和mod-b模块，然后以这两个模块为父模块再追加二级依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a>和<a href="mailto:mod-b@2.0.0">mod-b@2.0.0</a></p>
<p>但是！这却并不是物理上真实形成的依赖树的模样，物理上真实形成的依赖树是上面的那个红色框。<strong>mod-a,mod-c和mod-b竟然同为同一级</strong>的依赖。</p>
<p>你可能会问，为什么会形成这样的依赖树呢？下面我就来解释一番</p>
<p>【注意】：下面的图示全部为依赖树的物理结构，而不是逻辑结构</p>
<p><font color="red"><strong>关于npm模块安装机制的一点猜想</strong></font></p>
<p>安装模块时，可能的方式有两种：<strong>平级式</strong>的安装或<strong>嵌套式</strong>的安装（此处仅仅是猜想和假设）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092352262-1548398831.png" alt="img"></p>
<p>能不能完全采取平级的安装方式呢？——不能</p>
<p>我们取和上面相似的一个例子：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块Cv2.0。显然，它们并不能同时存在于同一个node_modules下，当安装的时候，由于npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092426950-802407609.png" alt="img"></p>
<p>但如果我们仅仅只安装一个版本的C依赖模块，将可能会导致A模块和B模块不兼容</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092458231-782438150.png" alt="img"></p>
<p><strong>基于以上原因，npm2选择了嵌套的安装方式——</strong></p>
<p><font color="red"><strong>npm2下的模块安装机制</strong></font></p>
<p>npm2安装多级的依赖模块采用嵌套的安装方式：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092546575-1188239142.png" alt="img"></p>
<p><strong>优点和弊端</strong></p>
<p><strong>优点：</strong>解决了版本单一时存在的存在的不兼容问题，实现多版本兼容</p>
<p><strong>弊端：</strong>可能造成相同模块大量冗余的问题，如下：</p>
<p>以上面例子为例，下面这种情况也是合理存在的：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092618981-1003798029.png" alt="img"></p>
<p>凭感觉也知道，这绝不是什么好现象，那我们如何能在实现依赖间多版本兼容的前提下，减少这种模块冗余呢？于是npm3做了一下改进</p>
<p><font color="red"><strong>npm3下的模块安装机制：</strong></font></p>
<p>npm3和npm2的不同主要体现在二级模块的安装上：</p>
<p>npm3会**”尽量”<strong>把逻辑上某个层级的模块在物理结构上</strong>“全部”**放在项目的第一层级里，具体我概括为以下三种情况：</p>
<p>1.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>还没有相同名称的模块</strong>，便<strong>把这第二层级的模块放在第一层级</strong></p>
<p>2.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，相同版本的模块</strong>，便<strong>直接复用那个模块</strong></p>
<p>3.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，但版本不同的模块</strong>，便<strong>只能嵌套在自身的父模块下方</strong></p>
<p>这一开始可能有些难理解，所以让我们看图说话吧！</p>
<p><strong>先说1：在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</strong></p>
<p>我们先简化一下上面的例子：现在项目APP下只有一个一级依赖模块A，它下面有一个二级依赖模块C，但npm install的时候，项目下安装依赖的</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092737903-1235721353.png" alt="img"></p>
<p>npm3中的二级模块（C v1.0),在项目的一级目录（node_modules）下没有相同名称的模块时，会被安装到一级目录下，从而跟它的父模块A同级。<strong>这就是本文一开始中依赖树的逻辑结构和物理结构不同的起因</strong>。</p>
<p>也就是说：</p>
<p><strong>在npm2中，依赖树的逻辑结构和它的物理结构相同</strong></p>
<p><strong>在npm3中，依赖树的逻辑结构和它的物理结构可能不同</strong></p>
<p><strong>再说2:在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</strong></p>
<p>在1的基础上，我们把1的例子还原回之前的复杂一些的场景：：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块C v1.0（两个C模块版本相同）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092859168-1795479456.png" alt="img"></p>
<p>对npm2,两个C包是相同的，造成模块冗余</p>
<p>在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块</p>
<p><strong>npm3就是用这种方式，部分地解决了npm2的痛点（部分）</strong></p>
<p>【从1，2到3的过渡】我在这一小节的开始说：“npm3会”尽量”把逻辑上某个层级的模块”全部”放在项目的第一层级里”，我想你看完1，2后应该多少有些理解了**<em>“尽量”*<strong>的含义了，但我说了</strong></em>“尽量”***，同时也就意味着npm3存在着不能把二级依赖放在第一层级的情况。对此，请看3:</p>
<p><strong>最后说3:在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方</strong></p>
<p>在2中，A，B所依赖的两个C模块是相同的，<strong>但如果两个C模块的版本不同呢？</strong>，项目npm install情况如下：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093023575-1842293712.png" alt="img"></p>
<p>在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块</p>
<p><strong>（看到这里我想应该能解答你对文章开头那个例子的疑惑了吧，这个例子和那个例子是几乎完全一样的哦）</strong></p>
<p>看到这里，你对npm2和npm3下的模块工作机制，以及npm3针对npm2的优化有个大体的了解了吧，但请思考一个问题：n<strong>pm3是否已经把npm2的模块冗余的缺陷优化到极致了呢？</strong> ———答案是<strong>没有</strong>，请往下看：</p>
<p>实际上：<strong>npm3中仍然可能出现模块冗余的情况</strong>，因为一级目录下已经有v1.0的C模块了，<strong>所以所有的v2.0只能作为二级依赖模块被安装</strong>，这样你就会看到如下的情况</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093147262-345050329.png" alt="img"></p>
<p>并且在上图所示的这种特殊情况里，npm3和npm2表现得似乎并没什么区别</p>
<p>【过渡】那么这有没有什么解决的方式呢？当然是有的，当A模块下的C v1.0模块被更新至C v2.0的前提下，我们可以<strong>通过npm dedupe把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0</strong></p>
<p><font color="red"><strong>利用npm dedupe去除冗余模块</strong></font></p>
<p><strong>npm dedupe做了什么？****它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块</strong></p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093125700-1173491575.png" alt="img"></p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>01-编译Cpython</title>
    <url>/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/</url>
    <content><![CDATA[<h1 id="01-编译CPython"><a href="#01-编译CPython" class="headerlink" title="01-编译CPython"></a>01-编译CPython</h1><h3 id="CPython的目录结构"><a href="#CPython的目录结构" class="headerlink" title="CPython的目录结构"></a>CPython的目录结构</h3><p>源码中文件夹的大致含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpython/</span><br><span class="line">│</span><br><span class="line">├── Doc      ← Source for the documentation</span><br><span class="line">├── Grammar  ← The computer-readable language definition</span><br><span class="line">├── Include  ← The C header files</span><br><span class="line">├── Lib      ← Standard library modules written in Python</span><br><span class="line">├── Mac      ← macOS support files</span><br><span class="line">├── Misc     ← Miscellaneous files</span><br><span class="line">├── Modules  ← Standard Library Modules written in C</span><br><span class="line">├── Objects  ← Core types and the object model</span><br><span class="line">├── Parser   ← The Python parser source code</span><br><span class="line">├── PC       ← Windows build support files</span><br><span class="line">├── PCbuild  ← Windows build support files for older Windows versions</span><br><span class="line">├── Programs ← Source code for the python executable and other binaries</span><br><span class="line">├── Python   ← The CPython interpreter source code</span><br><span class="line">└── Tools    ← Standalone tools useful for building or extending Python</span><br></pre></td></tr></table></figure>

<ul>
<li>Grammar记录了关于python的语法定义，如tokens,grammar，CPython有专门的代码读取这些文件，再生成词法解析和语法解析的代码。</li>
<li>Objects目录里有Python的核心内置类型，与python的对象模型息息相关</li>
<li>Parser里包含了Python语言的前端，即词法解析，语法解析</li>
<li>Programs包含了Python可执行文件的入口和相关实现</li>
<li>Python目录包含了Python解释器的实现</li>
</ul>
<h3 id="编译CPython"><a href="#编译CPython" class="headerlink" title="编译CPython"></a>编译CPython</h3><p>首先在CPython的目录下运行configure脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure CFLAGS=&quot;-g -O0&quot;</span><br></pre></td></tr></table></figure>

<p>继续make指令编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>编译成功后会有一个Python可执行文件。</p>
<h3 id="CPython2-GEF插件让GDB更好用"><a href="#CPython2-GEF插件让GDB更好用" class="headerlink" title="CPython2-GEF插件让GDB更好用"></a>CPython2-GEF插件让GDB更好用</h3><p>gdb .&#x2F;python调试python,想看源码用list指令就可以了，想要看反汇编用disassemble命令就可以了，但是它的风格是AT&amp;T风格的，想要看内存用x，想要看寄存器用info命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -tui ./python</span><br></pre></td></tr></table></figure>

<p>GEF <a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(curl -fsSL https://gef.blah.cat/sh)&quot;</span><br></pre></td></tr></table></figure>

<p>可以使用hexdump命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexdump byte &amp;argc</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/image-20230329102126435.png" alt="image-20230329102126435"></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>02-一切对象皆PyObject</title>
    <url>/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/</url>
    <content><![CDATA[<h2 id="02-一切皆对象PyObject"><a href="#02-一切皆对象PyObject" class="headerlink" title="02-一切皆对象PyObject"></a>02-一切皆对象PyObject</h2><h3 id="一切皆对象PyObject"><a href="#一切皆对象PyObject" class="headerlink" title="一切皆对象PyObject"></a>一切皆对象PyObject</h3><p>Python中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230308194406865.png" alt="image-20230308194406865"></p>
<p>Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自object。因此，object是所有类型对象的”基类”、或者说”父类”。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144138069.png" alt="image-20230310144138069"></p>
<p><strong>我们说可以使用type和__class__查看一个对象的类型，并且还可以通过isinstance来判断该对象是不是某个已知类型的实例对象；那如果想查看一个类型对象都继承了哪些类该怎么做呢？我们目前都是使用issubclass来判断某个类型对象是不是另一个已知类型对象的子类，那么可不可以直接获取某个类型对象都继承了哪些类呢？</strong></p>
<p><strong>答案是可以的，方法有三种，我们分别来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先D继承自B和C, C又继承A, 我们现在要来查看D继承的父类</span></span><br><span class="line"><span class="comment"># 方法一: 使用__base__</span></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 使用__bases__</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三: 使用__mro__</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__base__: 如果继承了多个类, 那么只显示继承的第一个类, 没有显示继承则返回一个&lt;class &#39;object&#39;&gt;;</code></li>
<li><code>__bases__: 返回一个元组, 会显示所有直接继承的父类, 如果没有显示的继承, 则返回(&lt;class &#39;object&#39;&gt;,);</code></li>
<li><code>__mro__: mro表示Method Resolution Order, 表示方法查找顺序, 会从自身除法, 找到最顶层的父类, 因此返回自身、继承的基类、以及基类继承的基类, 一直找到object;</code></li>
</ul>
<p>最后我们来看一下type和object，估计这两个老铁之间的关系会让很多人感到困惑。</p>
<p>我们说type是所有类的元类，而object是所有的基类，这就说明type是要继承自object的，而object的类型是type。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144509108.png" alt="image-20230310144509108"></p>
<p>这就怪了，这难道不是一个先有鸡还是先有蛋的问题吗？其实不是的，这两个对象是共存的，它们之间的定义其实是互相依赖的。至于到底是怎么肥事，我们后面在看解释器源码的时候就会很清晰了。</p>
<p><strong>总之目前记住两点：</strong></p>
<ul>
<li><code>1. type站在类型金字塔的最顶端, 任何的对象按照类型追根溯源, 最终得到的都是type;</code></li>
<li><code>2. object站在继承金字塔的最顶端, 任何的类型对象按照继承追根溯源, 最终得到的都是object;</code></li>
</ul>
<p>我们说type的类型还是type，但是object的基类则不再是object，而是一个None。为什么呢？其实答案很简单，我们说Python在查找属性或方法的时候，会回溯继承链，自身如果没有的话，就会按照__mro__指定的顺序去基类中查找。所以继承链一定会有一个终点，否则就会像没有出口的递归一样出现死循环了。</p>
<p>最后将上面那张关系图再完善一下的话：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144643701.png" alt="image-20230310144643701"></p>
<h3 id="实现对象机制的基石-PyOBject"><a href="#实现对象机制的基石-PyOBject" class="headerlink" title="实现对象机制的基石-PyOBject"></a>实现对象机制的基石-PyOBject</h3><p><strong>根据对象的不同特点还可以进一步分类：</strong></p>
<ul>
<li><code>可变对象：对象创建之后可以本地修改;</code></li>
<li><code>不可变对象：对象创建之后不可以本地修改;</code></li>
<li><code>定长对象：对象所占用的内存大小固定;</code></li>
<li><code>不定长对象：对象所占用的内存大小不固定;</code></li>
</ul>
<p>但是”对象”在Python的底层是如何实现的呢？我们知道标准的Python解释器是C语言实现的CPython，但C并不是一个面向对象的语言，那么它是如何实现Python中的面向对象的呢？</p>
<p>首先对于人的思维来说，对象是一个比较形象的概念，但对于计算机来说，对象却是一个抽象的概念。它并不能理解这是一个整数，那是一个字符串，计算机所知道的一切都是字节。通常的说法是：对象是数据以及基于这些数据的操作的集合。在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的。</p>
<p><strong>而Python中的任何对象在C中都对应一个结构体实例，在Python中创建一个对象，等价于在C中创建一个结构体实例。所以Python中的对象本质上就是C中malloc函数为结构体实例在堆区申请的一块内存。</strong></p>
<p>Python中一切皆对象，而所有的对象都拥有一些共同的信息(也叫头部信息)，这些信息就在PyObject中，PyObject是Python整个对象机制的核心，我们来看看它的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>PyObject_HEAD_EXTRA</strong></font>    </p>
<p>PyObject_HEAD_EXTRA 定义了两个双向链表，用于指向堆上创建的活着的对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_next;           \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_prev;</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>Ob_refcnt</strong></font></p>
<p>ob_refcnt定义了引用计数器</p>
<p>当一个对象被引用时，那么ob_refcnt会自增1；引用解除时，ob_refcnt自减1。而一旦对象的引用计数为0时，那么这个对象就会被回收。</p>
<p>那么在哪些情况下，引用计数会加1呢？哪些情况下，引用计数会减1呢？</p>
<p><strong>导致引用计数加1的情况：</strong></p>
<ul>
<li><code>对象被创建：比如name = &quot;古明地觉&quot;, 此时对象就是&quot;古明地觉&quot;这个字符串, 创建成功时它的引用计数为1</code></li>
<li><code>变量传递使得对象被新的变量引用：比如Name = name</code></li>
<li><code>引用该对象的某个变量作为参数传到一个函数或者类中：比如func(name)</code></li>
<li><code>引用该对象的某个变量作为元组、列表、集合等容器的一个元素：比如lst = [name]</code></li>
</ul>
<p><strong>导致引用计数减1的情况：</strong></p>
<ul>
<li><code>引用该对象的变量被显示的销毁：del name</code></li>
<li><code>对象的引用指向了别的对象：name = &quot;椎名真白&quot;</code></li>
<li><code>引用该对象的变量离开了它的作用域，比如函数的局部变量在函数执行完毕的时候会被销毁</code></li>
<li><code>引用该对象的变量所在的容器被销毁，或者被从容器里面删除</code></li>
</ul>
<p>所以我们使用del删除一个对象，并不是删除这个对象，我们没有这个权力，del只是使对象的引用计数减一，至于到底删不删是解释器判断对象引用计数是否为0决定的。为0就删，不为0就不删，就这么简单。</p>
<p>而ob_refcnt的类型是<strong>Py_ssize_t</strong>，在64位机器上直接把这个类型看成long即可<code>(话说这都2020年了，不会还有人用32位机器吧)</code>，因此一个对象的引用计数不能超过long所表示的最大范围。但是显然，如果不是吃饱了撑的写恶意代码，是不可能超过这个范围的。</p>
<p><font color="red"><strong>ob_type：类型指针</strong></font></p>
<p>我们说一个对象是有类型的，类型对象描述实例对象的数据和行为，而ob_type存储的便是对应类型对象的指针，所以类型对象在底层对应的是struct  _typeobject实例。从这里我们可以看出，所有的类型对象在底层都是由同一个结构体实例化得到的，因为PyObject是所有的对象共有的，它们的ob_type指向的都是struct _typeobject。</p>
<blockquote>
<p><strong>所以不同的实例对象对应不同的结构体，但是类型对象对应的都是同一个结构体。</strong></p>
</blockquote>
<p>因此我们看到PyObject的定义非常简单，就是一个引用计数和一个类型指针，所以Python中的任意对象都必有：引用计数和类型这两个属性。</p>
<h3 id="实现变长对象的基石–PyVarObject"><a href="#实现变长对象的基石–PyVarObject" class="headerlink" title="实现变长对象的基石–PyVarObject"></a>实现变长对象的基石–PyVarObject</h3><p>我们说PyObject是所有对象的核心，它包含了所有对象都共有的信息，但是还有那么一个属性虽然不是每个对象都有，但至少有一大半的对象会有，能猜到是什么吗？</p>
<p>我们说Python中的对象根据所占的内存是否固定可以分为定长对象和变长对象，而变长对象显然有一个长度的概念，比如字符串、列表、元组等等，即便是相同的实例对象，但是长度不同，所占的内存也是不同的。比如：字符串内部有多少个字符、元组、列表内部有多少个元素，显然这里的多少*也是Python中很多对象的共有特征，虽然不像引用计数和类型那样是每个对象都必有的，但也是相当大一部分对象所具有的。</p>
<p><strong>所以针对变长对象，Python底层也提供了一个结构体，因为Python很多都是变长对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>所以我们看到PyVarObject实际上是PyObject的一个扩展，它在PyObject的基础上提供了一个ob_size字段，用于记录内部的元素个数。比如列表，列表<code>(PyListObject实例)</code>中的ob_size维护的就是列表的元素个数，插入一个元素，ob_size会加1，删除一个元素，ob_size会减1。所以我们使用len获取列表的元素个数是一个时间复杂度为O(1)的操作，因为ob_size是时刻都和内部的元素个数保持一致，使用len获取元素个数的时候会直接访问ob_size。</p>
<p><font color="green">因此在Python中，所有的变长对象都拥有PyVarObject，而所有的对象都拥有PyObject，这就使得在Python中，对”对象”的引用变得非常统一，我们只需要一个PyObject  *就可以引用任意一个对象，而不需要管这个对象实际是一个什么对象。所以在Python中，所有的变量、以及容器内部的元素，本质上都是一个PyObject *。</font></p>
<p>由于PyObject和PyVarObject要经常被使用，所以Python提供了两个宏，方便定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD          PyObject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure>

<p><strong>比如定长对象浮点数，在底层对应的结构体为PyFloatObject，只需在头部PyObject的基础上再加上一个double即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>而对于变长对象列表，在底层对应的结构体是PyListObject，所以它需要在PyVarObject的基础上再加上一个指向数组的二级指针和一个容量即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/listobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>这上面的每一个成员都代表什么，我们之前已经分析过了。ob_item就是指向指针数组的二级指针，而allocated表示已经分配的容量，一旦添加元素的时候发现ob_size自增1之后会大于allocated，那么解释器就会对ob_item指向的指针数组进行扩容了。更准确的说，是申请一个容量更大数组，然后将原来指向的指针数组内部的元素按照顺序一个一个地拷贝到新的数组里面去，并让ob_item指向新的数组，这一点在分析PyListObject的时候会细说。所以我们看到列表在添加元素的时候，地址是不会改变的，即使容量不够了也没有关系，直接让ob_item指向新的数组就好了，至于PyListObject对象本身的地址是不会变化的。</strong></p>
<p>最后再来<font color="green">介绍两个宏定义</font>，这个是针对于类型对象的，我们后面在介绍类型对象的时候会经常见到这两个宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Include/object.h</span><br><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>

<p>先看PyObject_HEAD_INIT，里面的_PyObject_EXTRA_INIT是用来实现refchain这个双向链表的，我们目前不需要管。里面的1指的是引用计数，我们看到刚创建的时候默认是设置为1的，至于type就是该类型对象的类型了，这个是作为宏的参数传进来的；而PyVarObject_HEAD_INIT，则是在PyObject_HEAD_INIT的基础之上，增加了一个size，显然我们从名字也能看出来这个size是什么。当然目前只是介绍这两个宏，先有个印象，类型对象的实现我们下面就会说。</p>
<h3 id="实现类型对象的基石–PyTypeObject"><a href="#实现类型对象的基石–PyTypeObject" class="headerlink" title="实现类型对象的基石–PyTypeObject"></a>实现类型对象的基石–PyTypeObject</h3><p>通过PyObject和PyVarObject，我们看到了Python中所有对象的共有信息以及变长对象的共有信息。对于任何一个对象，不管它是什么类型，内部必有引用计数<code>(ob_refcnt)</code>和类型指针<code>(ob_type)</code>；对于任意一个变长对象，不管它是什么类型，除了引用计数和类型指针之外，内部还有一个表示元素个数的ob_size。</p>
<p><strong>然目前是没有什么问题，一切都是符合我们的预期的，但是当我们顺着时间轴回溯的话，就会发现端倪。比如：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</p>
<p>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的PyObject中的ob_type，也就是类型指针。我们通过对象的ob_type成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</p>
<p>下面我们来看看类型对象在底层是怎么定义的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject; <span class="comment">//_typeobject正是PyObject里面的一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/Cpython/object.h</span></span><br><span class="line"><span class="comment">// 类型对象对应的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类型对象在底层对应的是struct _typeobject，当然也是PyTypeObject，它里面的成员非常非常多，我们暂时挑几个重要的说，因为有一部分成员并不是那么重要，我们在后续会慢慢说。</strong></p>
<p><strong>目前我们了解到Python中的类型对象在底层就是一个PyTypeObject实例，它保存了实例对象的元信息，描述对象的类型。</strong></p>
<blockquote>
<p><strong>Python中的实例对象在底层对应不同的结构体实例，而类型对象则是对应同一个结构体实例，换句话说无论是int、str、dict等等等等，它们在C的层面都是由PyTypeObject这个结构体实例化得到的，只不过成员的值不同PyTypeObject这个结构体在实例化之后得到的类型对象也不同。</strong></p>
</blockquote>
<p><font color="green"><strong>我们看一下PyTypeObject内部几个非常关键的成员：</strong></font></p>
<ul>
<li><code>PyObject_VAR_HEAD：我们说这是一个宏，对应一个PyVarObject，所以类型对象是一个变长对象。而且类型对象也有引用计数和类型，这与我们前面分析的是一致的。</code></li>
<li><code>tp_name：类型的名称，而这是一个char *，显然它可以是int、str、dict之类的。</code></li>
<li><code>tp_basicsize, tp_itemsize：创建对应实例对象时所需要的内存信息。</code></li>
<li><code>tp_dealloc：其实例对象执行析构函数时所作的操作。</code></li>
<li><code>tp_print：其实例对象被打印时所作的操作。</code></li>
<li><code>tp_as_number：其实例对象为数值时，所支持的操作。这是一个结构体指针，指向的结构体中的每一个成员都是一个函数指针，其函数就是整型对象可以执行的操作，比如：四则运算、左移、右移、取模等等</code></li>
<li><code>tp_as_sequence：其实例对象为序列时，所支持的操作。同样是一个结构体指针。</code></li>
<li><code>tp_as_mapping：其实例对象为映射时，所支持的操作。也是一个结构体指针。</code></li>
<li><code>tp_base：继承的基类。</code></li>
</ul>
<p><strong>我们暂时就挑这么几个，事实上从名字上你也能看出来这每一个成员代表的含义。而且这里面的成员虽然多，但并非每一个类型对象都具备，比如int类型它就没有tp_as_sequence和tp_as_mapping，所以int类型的这两个成员的值都是0。</strong></p>
<p><strong>具体的我们就在分析具体的类型对象的时候再说吧，然后先来看看Python对象在底层都叫什么名字吧。</strong></p>
<ul>
<li><code>整型 -&gt; PyLongObject结构体实例,  int -&gt; PyLong_Type(PyTypeObject结构体实例)</code></li>
<li><code>字符串 -&gt; PyUnicodeObject结构体实例,  str -&gt; PyUnicode_Type(PyTypeObject结构体实例)</code></li>
<li><code>浮点数 -&gt; PyFloatObject结构体实例,  float -&gt; PyFloat_Type(PyTypeObject结构体实例)</code></li>
<li><code>复数 -&gt; PyComplexObject结构体实例,  complex -&gt; PyComplex_Type(PyTypeObject结构体实例)</code></li>
<li><code>元组 -&gt; PyTupleObject结构体实例,  tuple -&gt; PyTuple_Type(PyTypeObject结构体实例)</code></li>
<li><code>列表 -&gt; PyListObject结构体实例,  list -&gt; PyList_Type(PyTypeObject结构体实例)</code></li>
<li><code>字典 -&gt; PyDictObject结构体实例,  dict -&gt; PyDict_Type(PyTypeObject结构体实例)</code></li>
<li><code>集合 -&gt; PySetObject结构体实例,  set -&gt; PySet_Type(PyTypeObject结构体实例)</code></li>
<li><code>不可变集合 -&gt; PyFrozenSetObject结构体实例,  frozenset -&gt; PyFrozenSet_Type(PyTypeObject结构体实例)</code></li>
<li><code>元类：PyType_Type(PyTypeObject结构体实例)</code></li>
</ul>
<p><strong>所以Python中的对象在底层的名字都遵循一定的标准，包括解释器提供的Python&#x2F;C API也是如此。</strong></p>
<p><font color="green"><strong>下面以浮点数为例，考察一下类型对象和实例对象之间的关系。</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; pi = 3.14</span><br><span class="line">&gt;&gt;&gt; e = 2.71</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; type(pi) is type(e) is float</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312165701421.png" alt="image-20230312165701421"></p>
<p><strong>两个变量均指向了浮点数(PyFloatObject结构体实例)，除了公共头部字段ob_refcnt和ob_type，专有字段ob_fval保存了对应的数值；浮点类型float则对应PyTypeObject结构体实例(PyFloat_Type)，保存了类型名、内存分配信息以及浮点数相关操作。而将这两者关联起来的就是ob_type这个类型指针，它位于PyObject中，是所有对象共有的，而Python便是根据这个ob_type来判断该对象的类型，进而获取该对象的元信息。</strong></p>
<blockquote>
<p><strong>我们说变量只是一个指针，那么int、float、dict这些是不是变量，显然是的，函数和类也是一个变量，所以它们在底层也是一个指针。只不过这些变量是内置的，直接指向了具体的PyTypeObject实例。只是为了方便，有时我们用int、float等等，来代指指向的对象。比如：float指向了底层的PyFloat_Type，所以它其实是PyFloat_Type的指针，但为了表述方便我们会直接用float来代指PyFloat_Type。</strong></p>
<p><strong>而且类型对象在解释器启动的时候就已经是创建好了的，不然的话我们怎么能够直接用呢？类型对象创建完毕之后，直接让float指向相应的类型对象。</strong></p>
</blockquote>
<p><strong>我们来看一下float对应的类型对象在底层是怎么定义的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    .tp_vectorcall = (vectorcallfunc)float_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyFloat_Type在源码中就直接被创建了，这是必须的，否则我们就没有办法直接访问float这个变量了，然后先看结构体中的第4行，我们看到tp_name被初始化成了”float”；第5行表示实例对象所占的字节数，我们看到就是一个PyFloatObject实例所占的内存大小，并且显然这个值是不会变的，说明无论创建多少个实例对象，它们的大小都是不变的，这也符合我们之前的测试结果，都是24字节。</strong></p>
<p><strong>再往下就是一些各种操作对应的函数指针，最后我们来看一下第3行，显然它接收的是一个PyVarObject，PyVarObject_HEAD_INIT这个宏无需赘言，但重点是里面的&amp;PyType_Type，说明了float被设置成了type类型。</strong></p>
<p><strong>而且所有的类型对象(还有元类)在底层都被定义成了静态的全局变量，因为它们的声明周期是伴随着整个解释器的，并且在任意地方都可以访问。</strong></p>
<p><font color="red"><strong>模改CPython如何修改Type的打印信息？</strong></font></p>
<p>例如，修改float的打印信息，进入到floatobject.h中，进入 PyAPI_DATA(PyTypeObject) PyFloat_Type; 中，进入(reprfunc)float_repr</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105008756.png" alt="image-20230309105008756"></p>
<p>重新编译CPython，发现打印的结果为：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105144313.png" alt="image-20230309105144313"></p>
<h3 id="类型对象的类型–PyType-Type"><a href="#类型对象的类型–PyType-Type" class="headerlink" title="类型对象的类型–PyType_Type"></a>类型对象的类型–PyType_Type</h3><p>我们考察了float类型对象，知道它在C的层面是PyFloat_Type这个静态全局变量，它的类型是type，包括我们自定义的类的类型也是type。而type在Python中是一个至关重要的对象，它是所有类型对象的类型，我们称之为元类型<code>(meta class)</code>，或者元类。借助元类型，我们可以实现很多神奇的高级操作。那么type在C的层面又长啥样呢？</p>
<p>在介绍PyFloat_Type的时候我们知道了type在底层对应PyType_Type，而它在”Object&#x2F;typeobject.c”中定义，因为我们说所有的类型对象加上元类都是要预先定义好的，所以要源码中就必须要以静态全局变量的形式出现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们所有的类型对象加上元类都是PyTypeObject这个结构体实例化得到的，所以它们内部的成员都是一样的，只不过传入的值不同，实例化之后的结果也不同，可以是PyLong_Type、可以是PyFloat_Type，也可以是这里的PyType_Type。</p>
<p><strong>PyType_Type的内部成员和PyFloat_Type是一样的，但是我们还是要重点看一下里面的宏PyVarObject_HEAD_INIT，我们看到它传递的是一个&amp;PyType_Type，说明它把自身的类型也设置成了PyType_Type，换句话说，PyType_Type里面的ob_type成员指向的还是PyType_Type。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type.__class__.__class__.__class__.__class__.__class__ is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(type(type(type(type(type))))) is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然不管我们套娃多少次，最终的结果都是True，显然这也是符合我们的预期的。</strong></p>
<h3 id="类型对象的基类–PyBaseObject-Type"><a href="#类型对象的基类–PyBaseObject-Type" class="headerlink" title="类型对象的基类–PyBaseObject_Type"></a>类型对象的基类–PyBaseObject_Type</h3><p>我们说Python中有两个类型对象比较特殊，一个是站在类型金字塔顶端的type，一个是站在继承金字塔顶端的object。说完了type，我们来说说object，我们说类型对象内部的tp_base表示继承的基类，对于PyType_Type来讲，它内部的tp_base肯定是PyBaseObject_Type。</p>
<p><strong>但令我们吃鲸的是，它的tp_base居然是个0，如果为0的话则表示没有这个属性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,                                          /* tp_base */</span><br></pre></td></tr></table></figure>

<p><strong>不是说type的基类是object吗？为啥tp_base是0，事实上如果你去看PyFloat_Type的话，它内部的tp_base也是0。为0的原因就在于我们目前看到的类型对象是一个半成品，因为Python的动态性，显然不可能在定义的时候就将所有成员属性都设置好、然后解释器一启动就会得到我们平时使用的类型对象。目前看到的类型对象是一个半成品，有一部分成员属性是在解释器启动之后再进行动态完善的。</strong></p>
<blockquote>
<p><strong>至于是怎么完善的，都有哪些成员需要解释器启动之后才能完善，我们后续系列会说。</strong></p>
</blockquote>
<p><font color="green">而PyBaseObject_Type位于Object&#x2F;object.c中，我们来一睹其芳容。</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/object.c</span></span><br><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;object&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject),                           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    object_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object_repr,                                <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyBaseObject_Type的类型也被设置成了PyType_Type，而PyType_Type类型在被完善之后，它的tp_base也会指向PyBaseObject_Type。所以之前我们说Python中的type和object是同时出现的，它们的定义是需要依赖彼此的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：解释器在完善PyBaseObject_Type的时候，是不会设置其tp_base的，因为继承链必须有一个终点，否对象沿着继承链进行属性查找的时候就会陷入死循环，而object已经是继承链的顶点了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object -&gt; PyBaseObject_Type</code></li>
<li><code>object() -&gt; PyBaseObject</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312171839520.png" alt="image-20230312171839520"></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>04-浮点数的底层实现</title>
    <url>/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="04-浮点数的底层实现"><a href="#04-浮点数的底层实现" class="headerlink" title="04-浮点数的底层实现"></a>04-浮点数的底层实现</h2><p>从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。</p>
<p>除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p><strong>float实例对象定义在Include&#x2F;floatobject.h中，结构非常简单：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了PyObject这个公共的头部信息之外，只有一个额外的ob_fval，用于存储具体的值，而且直接使用的C中的double。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195351664-171093404.png" alt="img"></p>
<p>​        <strong>那么float类型对象在底层长啥样子呢？</strong>    </p>
<p><strong>与实例对象不同，float类型对象全局唯一，因此可以作为全局变量定义。底层对应PyFloat_Type，位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PyFloat_Type中保存了很多关于浮点数对象的元信息，关键字段包括：</strong></p>
<ul>
<li><code>tp_name字段保存了类型名称，是一个char *，显然是&quot;float&quot;；</code></li>
<li><code>tp_dealloc、tp_init、tp_alloc和 tp_new字段是与对象创建销毁相关的函数；</code></li>
<li><code>tp_repr字段对应__repr__方法，生成语法字符串；</code></li>
<li><code>tp_str字段对应__str__方法，生成普通字符串；</code></li>
<li><code>tp_as_number字段对应数值对象支持的操作簇；</code></li>
<li><code>tp_hash字段是哈希值生成函数；</code></li>
</ul>
<p><strong>PyFloat_Type很重要，作为浮点类型对象，它决定了浮点数的生死和行为。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>在上一篇博客中，我们初步了解到创建实例对象的一般过程。对于内置类型的实例对象，可以使用Python&#x2F;C API创建，也可以通过调用类型对象创建。</strong></p>
<p><strong>调用类型对象float创建实例对象，Python执行的是type类型对象中的tp_call函数。tp_call中会先调用类型对象的tp_new为该对象的实例对象申请一份空间，申请完毕之后该对象就已经被创建了。然后会再调用tp_init，并将实例对象作为参数传递进去，进行初始化，也就是设置属性。</strong></p>
<p><strong>但是对于float来说，它内部的tp_init成员是0，从PyFloat_Type的定义我们也可以看到。说明float没有__init__函数，原因是float是一种很简单的类型对象，初始化操作只需要一个赋值语句，所以在tp_new中就可以完成。</strong></p>
<p>​        <strong>除了通过调用类型对象创建实例对象这种通用型方法之外，CPython还为内置类型对象提供了一些Python&#x2F;C  API来创建对应的实例对象。可以简化调用，提高效率。关于为什么可以提高效率，我们之前已经分析过了，我们说通过Python&#x2F;C  API创建的话，会直接解析成底层对应的数据结构，而通过类型对象调用的话则会有一些额外的开销。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromString</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>以上是底层提供的两个创建浮点数的C API，当然还有其它的。</strong></p>
<ul>
<li><code>PyFloat_FromDouble：通过C中的double创建float对象；</code></li>
<li><code>PyFloat_FromString：通过字符串对象创建float对象；</code></li>
</ul>
<p><strong>以PyFloat_FromDouble为例，我们看看底层是怎么创建的？该函数同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们之前在介绍引用计数的时候，说过引用计数为0了，那么对象会被销毁</span></span><br><span class="line">    <span class="comment">//但是对象所占的内存则不一定回收、或者说还给操作系统，而是会缓存起来</span></span><br><span class="line">    <span class="comment">//所以从这行代码我们就看到了，创建浮点数对象的时候会优先从缓存池里面获取</span></span><br><span class="line">    <span class="comment">//而缓存池是使用链表实现的，free_list(指针)指向的链表的第一个对象</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="comment">//op不是NULL，说明缓存池中有对象，成功获取</span></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//一旦获取了，那么要将free_list指向链表中当前获取的对象的下一个对象</span></span><br><span class="line">        <span class="comment">//但是Py_TYPE不是一个宏吗？它获取的应该是对象的ob_type啊，那么Py_TYPE(op)获取的不是PyFloat_Type指针吗？别急这一点我们后面会说</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        <span class="comment">//并且将缓存池的内部可以使用的浮点数对象的数量减1</span></span><br><span class="line">        <span class="comment">//关于缓存池, 以及为什么要使用缓存池下面也会细说</span></span><br><span class="line">        <span class="comment">//目前先知道Python在分配浮点数对象的时候会先从缓存池里面获取就可以了</span></span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，调用PyObject_MALLOC申请内存，PyObject_MALLOC是基于malloc的一个封装</span></span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="comment">//申请失败的话，证明内存不够了</span></span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//走到这里说明内存分配好了，PyFloatObject也创建了，但是不是还少了点啥呢？显然内部的成员还没有初始化</span></span><br><span class="line">    <span class="comment">//还是那句话内置类型的实例对象该分配多少空间，解释器了如指掌，因为通过PyFloatObject内部的成员一算就出来了。</span></span><br><span class="line">    <span class="comment">//因此虽然对象创建了，但是此时内部的ob_refcnt、ob_type、以及ob_fval三个成员还没有被初始化。</span></span><br><span class="line">    <span class="comment">//所以还要将其ob_refcnt设置为1(因为对于刚创建的对象来说,内部的引用计数显然为1)，将ob_type设置为指向PyFloat_Type的指针</span></span><br><span class="line">    <span class="comment">//而PyObject_INIT是一个宏，它就是专门用来设置ob_type以及ob_refcnt的，我们后面看这个宏的定义就知道了</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line">    <span class="comment">//将内部的ob_fval成员设置为fval，所以此时三个成员都已经初始化完毕</span></span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="comment">//将其转成PyObject *返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以整体流程如下：</strong></p>
<ul>
<li><code>1. 为实例对象分配内存空间，空间分配完了对象也就创建了，不过会优先使用缓存池；</code></li>
<li><code>2. 初始化实例对象内部的引用计数和类型指针；</code></li>
<li><code>3. 初始化ob_fval为指定的浮点值；</code></li>
</ul>
<p><strong>然后我们看一下PyObject_INIT这个宏，它位于Include&#x2F;objimpl.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_INIT(op, typeobj) \</span></span><br><span class="line"><span class="meta">    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</span></span><br><span class="line"><span class="comment">//这个宏接收两个参数，分别是：实例对象的指针和指向的类型对象的指针</span></span><br><span class="line"><span class="comment">//然后Py_TYPE(op)表示获取其内部的ob_type, 将其设置为typeobj, 而typeobj在源码中传入的就是&amp;PyFloat_Type</span></span><br><span class="line"><span class="comment">//然后是_Py_NewReference, 这个宏我们在上一篇博客中已经说过了，它用于将对象的引用计数初始化为1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p><strong>当删除一个变量时，Python会通过宏Py_DECREF或者Py_XDECREF来减少该变量指向的对象的引用计数；当引用计数为0时，就会回收该对象。而回收该对象会调用其类型对象中的tp_dealloc指向的函数。当然啦，CPython依旧为回收对象提供了一个宏，我们上一篇中也说过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">// _Py_Dealloc(op)会调用op指向的对象的类型对象中的析构函数，同时将op自身作为参数传递进去，表示将op指向的对象回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>而PyFloat_Type中的tp_dealloc成员被初始化为float_dealloc，所以析构函数最终执行的是float_dealloc，关于它的源代码我们会在一会儿介绍缓存池的时候细说。</strong></p>
<p><strong>总结一下的话，浮点数对象从创建到销毁整个生命周期所涉及的关键函数、宏、调用关系可以如下图所示：</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195401032-229146894.png" alt="img"></p>
<p><strong>我们看到通过类型对象调用的方式来创建实例对象，最终也是要走Python&#x2F;C API的，肯定没有直接通过Python&#x2F;C API创建的方式快，因为前者多了几个步骤。</strong></p>
<blockquote>
<p><strong>所以如果是float(3.14)，那么最终也会调用PyFloat_FromDouble(3.14)；如果是float(“3.14”)，那么最终会调用PyFloat_FromString(“3.14”)。所以调用类型对象的时候，会先兜个圈子再去使用Python&#x2F;C API，肯定没有直接使用Python&#x2F;C API的效率高。</strong></p>
</blockquote>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p><strong>我们说浮点数这种对象是经常容易被创建和销毁的，如果每创建一个就分配一次内存、每销毁一个就回收一次内存的话，那效率会低到可想而知了。我们知道Python在操作系统之上封装了一个内存池，可以用于小内存对象的快速创建和销毁，这便是Python的内存池机制。但浮点数使用的频率很高，我们有时会创建和销毁大量的临时对象，所以如果每一次对象的创建和销毁都伴随着内存相关的操作的话，这个时候即便是有内存池机制，效率也是不高的。</strong></p>
<p><strong>考虑如下代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi = <span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pi * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">12.56</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个语句首先计算半径r的平方，然后根据结果创建一个临时对象，假设是t；然后再将pi和t进行相乘，得到最终结果并赋值给s；最终销毁临时变量t，所以这背后是隐藏着一个临时对象的创建和删除的。</strong></p>
<p><strong>当然这里一行代码可能感觉不到啥，假设我们要计算很多很多个半径对应的面积呢？显然需要写for循环，如果循环一万次就意味着要创建和销毁临时对象各一万次。</strong></p>
<p>因此，如果每一次创建对象都需要分配内存，销毁对象时需要回收内存的话，那么大量临时对象的创建和销毁就意味着要伴随大量的<font color="red">内存分配以及回收操作</font>，这显然是无法忍受的，更何况Python的for循环本身就已经够慢了。</p>
<p>​        <strong>因此Python在浮点数对象被销毁后，并不急着回收对象所占用的内存，换句话说其实对象还在，只是将该对象放入一个空闲的链表中。因为我们说对象可以理解为就是一片内存空间，对象如果被销毁，那么理论上内存空间要归还给操作系统，或者回到内存池中；但Python考虑到效率，并没有真正的销毁对象，而是将对象放入到链表中，占用的内存还在；后续如果再需要创建新的浮点数对象时，那么从链表中直接取出之前放入的对象(我们认为被回收的对象)，根据新的浮点数对象重新初始化对应的成员即可，这样就避免了内存分配造成的开销。而这个链表就是我们说的缓存池，当然不光浮点数对象有缓存池，Python中的很多其它对象也有对应的缓存池，比如列表。</strong>    </p>
<p><strong>浮点对象的空闲链表同样在 Objects&#x2F;floatobject.c中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyFloat_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST    100  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;  </span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PyFloat_MAXFREELIST：缓存池中能容纳float实例对象的最大数量, 显然不可能将所有要销毁的对象都放入到缓存池中, 这里是100个;</code></li>
<li><code>numfree：表示当前缓存池(链表)中的已经存在的float实例对象的数量, 初始为0;</code></li>
<li><code>free_list: 指向链表头结点的指针, 链表里面存储的都是PyFloatObject, 所以头节点的指针就是PyFloatObject *</code></li>
</ul>
<p><strong>但是问题来了，如果是通过链表来存储的话，那么对象肯定要有一个指针，来指向下一个对象，但是浮点数对象内部似乎没有这样的指针啊。是的，因为Python是使用内部的ob_type来指向下一个对象，本来ob_type指向的应该是PyFloat_Type，但是在链表中指向的是下一个PyFloatObject。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195410257-1986378240.png" alt="img"></p>
<p><strong>所以我们再回过头来看看PyFloat_FromDouble：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然op是缓存池中第一个PyFloatObject的指针</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个时候链表中的第一个对象已经被取出来重新分配了，显然free_list要指向下一个PyFloatObject</span></span><br><span class="line">        <span class="comment">//我们说在链表中，ob_type被用于指向链表中的下一个PyFloatObject，换言之ob_type保存的是下一个PyFloatObject的地址</span></span><br><span class="line">        <span class="comment">//但ob_type虽然保存的是PyFloatObject的地址，但它的类型仍是struct _typeobject *, 或者说PyTypeObject *</span></span><br><span class="line">        <span class="comment">//所以在存储的时候，下一个PyFloatObject *一定是先转成了struct _typeobject *之后，再交给的ob_type,因为对于指针来说，是可以任意转化的</span></span><br><span class="line">        <span class="comment">//所以Py_TYPE(op)获取下一个对象的指针之后，还要再转成PyFloatObject *，然后交给free_list保存</span></span><br><span class="line">        <span class="comment">//如果没有下一个对象了，那么free_list就是NULL</span></span><br><span class="line">        <span class="comment">//因此在下一次分配的时候，上面if (op != NULL)就不成立了，因此会走下面的else，使用PyObject_MALLOC重新分配内存</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说对象创建时，会先从缓存池中获取。既然创建时可以从缓存池获取，那么销毁的时候，肯定要放入到缓存池中。而销毁对象会调用类型对象的析构函数tp_dealloc，对于浮点数而言就是float_dealloc，我们看一下源代码，同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">        <span class="comment">//如果numfree(当前缓存池中float实例对象的数量)达到了缓存池的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            <span class="comment">//那么调用PyObject_FREE回收对象所占内存</span></span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则的话，说明没有达到最大容量限制，显然此时不会真的销毁对象，而是将其放入缓存池中</span></span><br><span class="line">        <span class="comment">//将numfree加1</span></span><br><span class="line">        numfree++;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表的第一个元素，而这里是获取了op的ob_type,让其等于free_list，说明该对象内部的ob_type也指向了链表中的第一个元素</span></span><br><span class="line">        <span class="comment">//那么说明了什么，是不是意味着链表中第一个元素就变成该对象了。因此在将对象放入链表中的时候，是放在链表的头部位置</span></span><br><span class="line">        <span class="comment">//但我们说ob_type的类型是struct _typeobject *，所以还要将free_list进行转化</span></span><br><span class="line">        <span class="comment">//那么显然在获取的时候，还要再转成PyFloatObject *，这在上面的PyFloat_FromDouble中我们已经看到了</span></span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表中的第一个元素，但现在第一个元素变了</span></span><br><span class="line">        <span class="comment">//所以要让free_list = op, 指向新添加的PyFloatObject，因为它被插入到了链表的第一个位置上</span></span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则的话，说明PyFloat_CheckExact(op)为假, PyFloat_CheckExact(op)是用于检测op是不是指向PyFloatObject</span></span><br><span class="line">    <span class="comment">//说明此时op可能指向的其实不是PyFloatObject *，所以通过Py_TYPE(op)-&gt;tp_free直接获取对应的类型对象的tp_free，然后释放掉op指向的对象所占的内存。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>这便是Python的浮点数对象(或者浮点数空闲对象)缓存池的全部秘密，由于对象缓存池在提高对象分配效率方面发挥着至关重要的作用，所以Python中很多其它内置对象的实例对象也都实现了缓存池，我们后续在分析其它对象的时候会经常看到它的身影。</strong>    </p>
<p><strong>看一个思考题：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.414</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.732</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到两个对象的id是一样的，相信你肯定知道原因。因为a在del之后，指向对象被放入到缓存池中，然后创建b的时候会从缓存池中获取，所以a指向的对象被重新利用了，内存还是原来的那一块内存，所以前后地址没有变化。</strong></p>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p><strong>PyFloat_Type中定义了很多的函数指针，比如：type_repr、tp_str、tp_hash等等，这些函数指针将一起决定float实例对象的行为，例如：tp_hash决定float实例对象的哈希值是如何计算的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(e)</span><br><span class="line"><span class="number">1637148536541722626</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>tp_hash指向的是float_hash，还是那句话Python底层的函数命名以及API都是很有规律的，相信你能慢慢发现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_hash_t</span><br><span class="line"><span class="title function_">float_hash</span><span class="params">(PyFloatObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到调用了_Py_HashDouble，计算的就是ob_fval成员哈希值</span></span><br><span class="line">    <span class="keyword">return</span> _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>由于加减乘除等数值操作很常见， Python 将其抽象成数值操作簇 PyNumberMethods，并让内部成员tp_as_number指向。数值操作集 PyNumberMethods 在头文件 Include&#x2F;object.h 中定义：</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">    arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">    in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p><strong>PyNumberMethods定义了各种数学算子的处理函数，数值计算最终由这些函数执行。 处理函数根据参数个数可以分为： 一元函数(unaryfunc) 、 二元函数(binaryfunc) 和 三元函数(ternaryfunc )。</strong></p>
<p><strong>然后我们回到Objects&#x2F;floatobject.c中观察一下PyFloat_Type是如何初始化的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    (unaryfunc)float_neg, <span class="comment">/* nb_negative */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>以加法为例，显然最终执行float_add，源码位于Objects&#x2F;floatobject.c中，显然它是一个二元函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">float_add</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然两个Python对象相加，一定是先将其转成C的对象相加，加完之后再根据结果创建新的Python对象</span></span><br><span class="line">    <span class="comment">//所以声明了两个double</span></span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="comment">//CONVERT_TO_DOUBLE是一个宏，不用想，功能肯定是将PyFloatObject里面的ob_fval抽出来给double变量，从名字上也能看出来</span></span><br><span class="line">    <span class="comment">//这个宏有兴趣可以去源码中看一下，也在当前文件中</span></span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);  <span class="comment">// 将ob_fval赋值给a</span></span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);  <span class="comment">// 将ob_fval赋值给b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PyFPE_START_PROTECT和下面的PyFPE_END_PROTECT也都是宏，作用我们一会儿说。</span></span><br><span class="line">    PyFPE_START_PROTECT(<span class="string">&quot;add&quot;</span>, <span class="keyword">return</span> <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//将a和b相加赋值给a</span></span><br><span class="line">    a = a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line">    <span class="comment">//根据相加后的结果创建新的PyFloatObject对象，当然返回的是泛型指针PyObject *</span></span><br><span class="line">    <span class="keyword">return</span> PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以上就是float实例对象的运算，核心就是：</strong></p>
<ul>
<li><code>1. 定义两个double变量：a、b</code></li>
<li><code>2. 将用来相加的两个float实例对象中ob_fval维护的值抽出来赋值给a和b</code></li>
<li><code>3. 让a和b相加，将相加结果传入PyFloat_FromDouble中创建新的PyFloatObject，然后返回其PyObject *</code></li>
</ul>
<p><strong>所以如果是C中的两个浮点数相加，直接a +  b就可以了，编译之后就是一条简单的机器指令，然而Python则需要额外做很多其它工作。并且在介绍整型的时候，你会发现Python中的整型的相加会更麻烦，但对于C而言同样是一条简单的机器码就可以搞定。当然啦，因为Python3中的整型是不会溢出的，所以需要额外的一些处理，等介绍整型的时候再说吧。所以这里我们也知道Python为什么会比C慢几十倍了，从一个简单的加法上面就可以看出来。</strong></p>
<blockquote>
<p><strong>最后我们再说一下PyFPE_START_PROTECT和PyFPE_END_PROTECT这两个宏，其实它们对于我们了解浮点数在底层的计算没有什么意义。首先浮点数计算一般都遵循IEEE-754标准，如果计算时出现了错误，那么需要将IEEE-754异常转换成Python中的异常，而这两个宏就是用来干这件事情的。</strong></p>
<p><strong>所以我们不需要管它，这两个宏定义在Include&#x2F;pyfpe.h中，并且Python3.9的时候会被删除掉。</strong></p>
</blockquote>
<p>​        <strong>最后我们说一下Python解释器源代码的结构吧，因为我们每一次介绍函数的时候，都会说该函数定义在哪个文件里。所以突然想起来，介绍一下源代码的组织结构也是有必要的。</strong>    </p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195419135-1770620855.png" alt="img"></p>
<p><strong>我们从官网上将源代码下载下来之后，大概长这样，里面有几个目录是我们需要关注的。</strong></p>
<ul>
<li><code>Include：该目录包含了Python所提供的所有头文件，主要包含了一些实例对象在底层的定义，比如listobject.h、dictobject.h等等。如果用户需要自己使用C或者C++来编写自定义模块扩展Python，那么也需要用到这里的头文件。</code></li>
<li><code>Lib：这个无需多说，该目录包含了python自带的所有标准库，Lib中的库基本上都是使用python编写的。</code></li>
<li><code>Modules：该目录中包含了所有用C语言编写的模块，比如_random、_io等，而且gc也在里面。Modules中的模块是那些对速度要求非常严格的模块，而有一些对速度没有太严格要求的模块，比如os，就是用Python编写，并且是放在Lib目录下的。</code></li>
<li><code>Parser：该目录中包含了python解释器中的Scanner和Parser部分，即对python源代码进行词法分析和语法分析的部分。除了这些，Parser还包含了一些有用的工具，这些工具能够根据Python语言的语法自动生成Python语言的词法和语法分析器，与YACC非常类似。</code></li>
<li><code>Objects：该目录包含了所有Python的内置类型对象的实现，以及其实例对象相关操作的实现，比如浮点数相关操作就位于文件floatobject.c中、列表相关操作就位于文件listobject.c中，文件名也很有规律。同时，该目录还包含了Python在运行时需要的所有内部使用对象的实现，因为有很多对象比如&lt;class &#39;function&#39;&gt;是没有暴露给Python的，但是在底层它们是实现了的。</code></li>
<li><code>Python：虚拟机的实现相关，是python运行的核心所在。</code></li>
</ul>
<h3 id="PyFloatObjectに侵入し"><a href="#PyFloatObjectに侵入し" class="headerlink" title="PyFloatObjectに侵入し"></a>PyFloatObjectに侵入し</h3><p><strong>最后我们修改一下源码：当对象放入到缓冲池中，我们打印一下放入的浮点数对象的地址；当对象从缓存池中取出时，我们打印一下取出的浮点数对象的地址。</strong></p>
<p>对象从内存池中取出的时候加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line">    op = state-&gt;free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">        <span class="comment">// PyFloat_FromDouble() must not be called after _PyFloat_Fini()</span></span><br><span class="line">        assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        state-&gt;free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        state-&gt;numfree--;</span><br><span class="line">        OBJECT_STAT_INC(from_freelist);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Object gets from the memory pool,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        op = PyObject_Malloc(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _PyObject_Init((PyObject*)op, &amp;PyFloat_Type);</span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象放入内存池中加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyFloat_ExactDealloc(PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(PyFloat_CheckExact(obj));</span><br><span class="line">    PyFloatObject *op = (PyFloatObject *)obj;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">    <span class="comment">// float_dealloc() must not be called after _PyFloat_Fini()</span></span><br><span class="line">    assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">        PyObject_Free(op);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;numfree++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Objects are put back into the memory poo,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    Py_SET_TYPE(op, (PyTypeObject *)state-&gt;free_list);</span><br><span class="line">    state-&gt;free_list = op;</span><br><span class="line">    OBJECT_STAT_INC(to_freelist);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PyObject_Free(op);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195427317-1430841014.png" alt="img"></p>
<p><strong>我们看到在解释器刚启动的时候，内部就已经创建出很多对象了，然后我们自己来创建一个对象吧。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195432078-602851272.png" alt="img"></p>
<p><strong>我们第一次创建对象的时候，居然是从缓存池里面获取的，说明在解释器启动的时候那个链表中就已经有空闲对象了。然后我们使用Python获取其id，由于得到的是十进制整型，所以转成16进制，发现地址是一样的。然后放入到缓存池中，放入的对象的地址也是相同的，这和我们得到结论是一致的。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195437415-553253163.png" alt="img"></p>
<p><strong>我们再创建新的变量a、b并打印地址，然后删除a、b变量，再重新创建a、b变量、打印地址，结果发现它们存储的对象的地址在删除前后正好是相反的。至于原因，如果思考一下将对象放入缓存池、以及从缓存池获取对象的时候所采取的策略，那么很容易就明白了。</strong></p>
<p><strong>因为del a,  b的时候会先删除a，再删除b。删除a的时候，会将a指向的对象作为链表中的第一个元素，然后删除b的时候，会将b指向的对象作为链表中的第一个元素，所以之前a指向的对象就变成了链表中的第二个元素。而获取的时候，也会从链表的头部开始获取，所以当重新创建变量a的时候，其指向的对象实际上使用的是之前变量b指向的对象所占的内存，而一旦获取，那么free_list指针会向后移动；因此创建变量b的时候，其指向的对象显然使用的是之前变量a指向的对象所占的内存。因此前后打印的地址是相反的，所以我们算是通过实践从另一个角度印证了之前分析的结论。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        <strong>这一篇我们分析了Python中的浮点数在底层的实现方式，之所以选择浮点数是因为浮点数是最简单的了。至于整数，其实并没有那么简单，因为它的值底层是通过数组存储的，而浮点型底层是用一个double存储对应的值，所以更简单一些，我们就先拿浮点数”开刀了”。</strong>    </p>
<p>​        <strong>然后我们还介绍浮点数的创建和销毁，会调用类型对象内部的tp_dealloc，浮点数的话就是float_dealloc。当然为了保证效率，避免内存的创建和回收，Python底层为浮点数引入了缓存池机制，我们也分析了它的机制。当然浮点数还支持相关的数值型操作，PyFloat_Type中的tp_as_number指向了PyNumberMethods结构体，里面有大量的函数指针，每个指针指向了具体的函数，专门用于浮点数的运算。当然整型也有，只不过指针指向的函数是用于整型运算的。比如相加：对于浮点数来说，PyNumberMethods结构体成员nb_add指向了函数float_add；对于整数来说，nb_add则是指向了long_add。然后我们也以相加为例，看了float_add函数的实现，核心就是将Python中对象的值抽出来，转成C的类型，然后运算，最后再根据运算的结果，创建Python中的对象、返回。当然除了加法，它的减法、乘法、除法都是类似的，有兴趣可以”杀入”floatobject.c中，大肆探索一番。</strong>    </p>
<p>​        <strong>最后我们修改了PyFloatObject的部分源码，其实就是加上了两个printf语句，对float实例对象的缓存池机制进行了实践，并用之前的结论对结果进行了合理的解释。</strong>    </p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Bytes对象的底层操作</title>
    <url>/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="06-Bytes对象的底层操作"><a href="#06-Bytes对象的底层操作" class="headerlink" title="06-Bytes对象的底层操作"></a>06-Bytes对象的底层操作</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p>不少编程语言中的”字符串”都是使用字符数组(或者称字符序列)来表示，比如C语言和go语言就是这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;komeiji satori&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>一个字节最多能表示256个字符，所以对于英文来说足够了，因此一个英文字符占一个字节即可，然而对于那些非英文字符便力不从心了。因此为了表示这些非英文编码，于是多字节编码应运而生—-通过多个字节来表示一个字符。但由于原始字节序列不维护编码信息，因此操作不慎便导致各种乱码现象。</p>
<p>而Python提供的解决方案是使用unicode<code>(在Python3中等价于str)</code>表示字符串，因为unicode可以表示各种字符，不需要关心编码的问题。但在存储或网络通讯时，字符串不可避免地要序列化成字节序列。为此，Python除了提供字符串对象之外，还额外提供了字节序列对象—-bytes。</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223900719-724141880.png" alt="img"></p>
<p><strong>如上图，str对象统一表示一个字符串，不需要关心编码；计算机通过字节序列和存储介质、网络介质打交道，字节序列由bytes对象表示；在存储和传输str对象的时候，需要将其序列化成字节序列，序列化也是编码的过程。</strong></p>
<p><strong>下面我们就来看看bytes对象在底层的数据结构。</strong></p>
<h3 id="PyBytesObject"><a href="#PyBytesObject" class="headerlink" title="PyBytesObject"></a>PyBytesObject</h3><p><strong>我们说bytes对象是由若干个字节组成的，显然这是一个变长对象，有多少个字节说明其长度是多少。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/bytesobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyBytesObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下里面的成员对象：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD：变长对象的公共头部</code></li>
<li><code>ob_shash：保存该字节序列的哈希值，之所以选择保存是因为在很多场景都需要bytes对象的哈希值。而Python在计算字节序列的哈希值的时候，需要遍历每一个字节，因此开销比较大。所以会提前计算一次并保存起来，这样以后就不需要算了，可以直接拿来用，并且bytes对象是不可变的，所以哈希值是不变的。</code></li>
<li><code>ob_sval：这个和PyLongObject中的ob_digit的声明方式是类似的，虽然声明的时候长度是1,  但具体是多少则取决于bytes对象的字节数量。这是C语言中定义&quot;变长数组&quot;的技巧, 虽然写的长度是1, 但是你可以当成n来用,  n可取任意值。显然这个ob_sval存储的是所有的字节，因此Python中的bytes的值，底层是通过字符数组存储的。而且通过注释，我们发现会多申请一个空间，用于存储\0，因为C中是通过\0来表示一个字符数组的结束，但是计算ob_size的时候不包括\0。</code></li>
</ul>
<p>​        <strong>我们创建几个不同的bytes对象，然后通过画图感受一下：</strong>    </p>
<p><strong>val &#x3D; b””</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223908475-1596108760.png" alt="img"></p>
<p><strong>我们看到一个空的字节序列，底层的ob_savl也是需要一个’\0’的，那么这个结构体实例占多大内存呢？我们说上面ob_sval之外的四个成员，显然每个都是8字节，而ob_savl每个成员都是一个char、也就是占1字节，所以Python中bytes对象占的内存等于32 +  ob_sval的长度。而ob_sval里面至少有一个’\0’，因此对于一个空的字节序列，显然占33个字节。注意：ob_size统计的是ob_sval中有效字节的个数，不包括’\0’，但是计算占用内存的时候，显然是需要考虑在内的，因为它确实多占用了一个字节的空间。或者说bytes对象占的内存等于33 + ob_size也是可以的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>val &#x3D; b”abc”</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223922037-1082582124.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">36</span>  <span class="comment"># 32 + 4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="bytes对象的行为"><a href="#bytes对象的行为" class="headerlink" title="bytes对象的行为"></a>bytes对象的行为</h3><p><strong>介绍bytes对象在底层的数据结构之后，我们要考察bytes对象的行为。我们说实例对象的行为由其类型对象决定，所以bytes对象具有哪些行为，就看bytes类型对象本身定义了哪些操作。bytes类型对象，显然对应PyBytes_Type，根据我们之前介绍的规律，也可以猜出来，它定义在Object&#x2F;bytesobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/bytesobject.c</span></span><br><span class="line">PyTypeObject PyBytes_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &amp;bytes_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;bytes_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;bytes_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)bytes_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>到了现在，相信你对类型对象的结构肯定非常熟悉了，因为类型对象都是由PyTypeObject结构体实例化得到的。我们看到tp_as_number，它居然不是0，而是传递了一个指针，说明确实指向了一个PyNumberMethods结构体实例。难道bytes支持数值运算，这显然是不可能的啊，所以我们需要进入bytes_as_number中一探究竟。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods bytes_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    bytes_mod,      <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到它只定义了一个取模操作，也就是%</span></span><br><span class="line"><span class="comment">//看到%估计有人已经明白了，这是格式化</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">bytes_mod(PyObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyBytes_Check(self)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，bytes对象只是借用了%运算实现了格式化，谈不上数值运算，虚惊一场。不过由此也看到了Python的动态特性，即使是相同的操作，但如果是不同类型的对象执行的话，也会有不同的表现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>info = <span class="string">b&quot;name: %s, age: %d&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>info % (<span class="string">b&quot;satori&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;name: satori, age: 16&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>​        <strong>除了tp_as_number，PyBytes_Type还给tp_as_sequence成员传递了bytes_as_sequence指针，说明bytes对象支持序列操作。显然这是肯定的，而且bytes对象显然是序列型对象，所以序列型操作才是我们的研究的重点，下面看看bytes_as_sequence的定义。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>根据定义我们看到，bytes对象支持的序列型操作一共有5个：</strong></p>
<ul>
<li><code>sq_length：查看序列的长度</code></li>
<li><code>sq_concat：将两个序列合并为一个</code></li>
<li><code>sq_repeat：将序列重复多次</code></li>
<li><code>sq_item：根据索引获取指定的下表, 得到一个整型;如果是切片，那么还会得到一个bytes对象</code></li>
<li><code>sq_contains：判断某个序列是不是在该序列中，显然它等价于Python中的in操作</code></li>
</ul>
<p><strong>查看序列长度：</strong></p>
<p><strong>显然这是最简单的，直接获取ob_size即可，比如：val &#x3D; b”abcde”，那么长度就是5。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">bytes_length</span><span class="params">(PyBytesObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将两个序列合并为一个：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&quot;def&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line"><span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而且我们看到这里相当于是加法运算，我们很容易想到会是PyNumberMethods中的nb_add，比如：PyLongObject对应的long_add、PyFloatObject对应的float_add，但对于bytes对象而言，加法操作对应PySequenceMethods的sq_concat。所以我们看到Python中的同一个操作符，在底层会对应不同的函数，比如：long_add和float_add、以及这里的bytes_concat，在Python的层面都是+这个操作符。然后我们看看底层是怎么对两个字节序列进行相加的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_concat</span><span class="params">(PyObject *a, PyObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//两个局部变量，用于维护缓冲区</span></span><br><span class="line">    Py_buffer va, vb;</span><br><span class="line">    <span class="comment">//result用于保存结果</span></span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将缓冲区的长度设置为-1, 可以认为此时缓冲区啥也没有</span></span><br><span class="line">    va.len = <span class="number">-1</span>;</span><br><span class="line">    vb.len = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将a、b中ob_sval拷贝到缓冲区中，拷贝成功返回0，拷贝失败返回非0</span></span><br><span class="line">    <span class="comment">//如果下面的条件不成功, 就意味着拷贝失败了, 说明至少有一个老铁不是bytes类型</span></span><br><span class="line">    <span class="keyword">if</span> (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) != <span class="number">0</span> ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//然后设置异常，PyExc_TypeError表示TypeError(类型错误)，专门用来指对一个对象执行了它所不支持的操作</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;can&#x27;t concat %.100s to %.100s&quot;</span>,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//比如：&quot;123&quot; + 123, 会得到: TypeError: can&#x27;t concat int to bytes, 和这里设置的异常信息是一样的</span></span><br><span class="line">        <span class="comment">//这里直接跳转到done</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是判断是否有一方长度为0, 如果a长度为0，那么相加之后结果就是b</span></span><br><span class="line">    <span class="keyword">if</span> (va.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(b)) &#123;</span><br><span class="line">        <span class="comment">//将b拷贝给result</span></span><br><span class="line">        result = b;</span><br><span class="line">        <span class="comment">//增加result的引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和上面同理，如果b长度为0，那么相加之后的结果就是a</span></span><br><span class="line">    <span class="keyword">if</span> (vb.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//将a拷贝给result</span></span><br><span class="line">        result = a;</span><br><span class="line">        <span class="comment">//增加引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是判断两个字节序列合并之后，长度是否超过限制，因为不允许超过PY_SSIZE_T_MAX</span></span><br><span class="line">    <span class="comment">//所以更直观的写法应该是 if (va.len + vb.len &gt; PY_SSIZE_T_MAX), 但是这个条件基本不可能满足，除非你写恶意代码</span></span><br><span class="line">    <span class="keyword">if</span> (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话，声明指定容量PyBytesObject</span></span><br><span class="line">    result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, va.len + vb.len);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//将缓冲区va里面内容拷贝到result的ob_sval中，拷贝的长度为va.len</span></span><br><span class="line">        <span class="comment">//PyBytes_AS_STRING是一个宏，用于获取PyBytesObject中的ob_sval</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        <span class="comment">//然后将缓冲区vb里面的内容拷贝到result的ob_sval中，拷贝的长度为vb.len，但是从va.len的位置开始拷贝, 不然会把内容覆盖掉</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="comment">//如果长度不会-1，那么要将缓冲区里面的内容释放掉，否则可能导致内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (va.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    <span class="keyword">if</span> (vb.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    <span class="comment">//返回result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虽然代码很长，但是不难理解。不过可能有人认为为什么非要先将a、b的内容拷贝到Py_buffer里面，再通过Py_buffer拷贝到result里面去呢？直接拷贝不可以吗？答案是Py_buffer提供了一套操作对象缓冲区的统一接口，屏蔽不同类型对象的内部差异。</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223933085-875268687.png" alt="img"></p>
<p><strong>将序列重复多次：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * <span class="number">3</span></span><br><span class="line"><span class="string">b&#x27;abcabcabc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * -<span class="number">1</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span>  <span class="comment"># 如果乘上一个负数，等于乘上0，那么会得到一个空的字节序列</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_repeat</span><span class="params">(PyBytesObject *a, Py_ssize_t n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    Py_ssize_t j;</span><br><span class="line">    Py_ssize_t size;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="type">size_t</span> nbytes;</span><br><span class="line">    <span class="comment">//如果n小于0, 那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里条件写成Py_SIZE(a) * n &gt; PY_SSIZE_T_MAX更容易理解</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; Py_SIZE(a) &gt; PY_SSIZE_T_MAX / n) &#123;</span><br><span class="line">        <span class="comment">//先计算相乘之后字节序列的长度是否超过最大限制，如果超过了，直接报错</span></span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算Py_SIZE(a) * n得到size</span></span><br><span class="line">    size = Py_SIZE(a) * n;</span><br><span class="line">    <span class="keyword">if</span> (size == Py_SIZE(a) &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//如果两者相等，那么证明n = 1，直接增加引用计数，然后返回a即可</span></span><br><span class="line">        Py_INCREF(a);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型转化，此时是size_t类型，相当于无符号64位整型</span></span><br><span class="line">    nbytes = (<span class="type">size_t</span>)size;</span><br><span class="line">    <span class="comment">//PyBytesObject_SIZE是一个宏，表示PyBytesObject的基本大小</span></span><br><span class="line">    <span class="comment">//它是一个宏，等价于(offsetof(PyBytesObject, ob_sval) + 1), 显然是33</span></span><br><span class="line">    <span class="comment">//所以nbytes + PyBytesObject_SIZE就是bytes对象所需要的空间</span></span><br><span class="line">    <span class="comment">//如果nbytes + PyBytesObject_SIZE还小于等于nbytes, 所以相加之后size_t类型存不下了</span></span><br><span class="line">    <span class="comment">//说明超过所占内存的极限了</span></span><br><span class="line">    <span class="keyword">if</span> (nbytes + PyBytesObject_SIZE &lt;= nbytes) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请空间，大小为PyBytesObject_SIZE + nbytes</span></span><br><span class="line">    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + nbytes);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//返回NULL，表示申请失败</span></span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//PyObject_INIT_VAR是一个宏，设置ob_type和ob_size</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size);</span><br><span class="line">    <span class="comment">//设置ob_shash为-1</span></span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将ob_sval最后一位设置为&#x27;\0&#x27;</span></span><br><span class="line">    op-&gt;ob_sval[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然这里是在a对应的bytes对象长度为1时，所走的逻辑</span></span><br><span class="line">        <span class="comment">//直接将op-&gt;ob_sval里面元素设置a-&gt;ob_sval[0], 设置n个</span></span><br><span class="line">        <span class="built_in">memset</span>(op-&gt;ob_sval, a-&gt;ob_sval[<span class="number">0</span>] , n);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则将a -&gt; ob_sval拷贝到op -&gt; ob_sval中, 拷贝n次, 因为size = Py_SIZE(a) * n;</span></span><br><span class="line">    <span class="comment">//这里是先拷贝了一次</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval, a-&gt;ob_sval, Py_SIZE(a));</span><br><span class="line">        i = Py_SIZE(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后拷贝n - 1次</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">        j = (i &lt;= size-i)  ?  i  :  size-i;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval+i, op-&gt;ob_sval, j);</span><br><span class="line">        i += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据索引获取指定元素：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>], <span class="built_in">type</span>(val[<span class="number">1</span>])</span><br><span class="line">(<span class="number">98</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>: <span class="number">4</span>], <span class="built_in">type</span>(val[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">(<span class="string">b&#x27;bcd&#x27;</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_item</span><span class="params">(PyBytesObject *a, Py_ssize_t i)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果i &lt; 0或者 i &gt;= a的ob_size，那么会报错:索引越界</span></span><br><span class="line">    <span class="comment">//但是我们记得Python支持负数索引的啊，是的，只不过会手动帮你变成正的</span></span><br><span class="line">    <span class="comment">//因为C是不支持负数索引的，所以通过C的索引获取，那么索引一定是正的</span></span><br><span class="line">    <span class="comment">//因此我们填上的负数，Python会帮你加上长度。比如：长度为5，但是我们写的索引为-1, 那么Python会帮你变成4之后再获取</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= Py_SIZE(a)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们看到获取第i个元素之后直接转成了PyLongObject，然后返回指针</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)a-&gt;ob_sval[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那切片呢？切片的话对应bytes_subscript，但它不是在PySequenceMethods tp_as_sequence里面，而是在PyMappingMethods bytes_as_mapping里面，它是一个映射操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到映射操作，bytes对象中只有两个，一个bytes_length获取长度，这个在bytes_as_sequence中已经实现了，还有一个就是bytes_subscript进行切片操作</span></span><br><span class="line"><span class="type">static</span> PyMappingMethods bytes_as_mapping = &#123;</span><br><span class="line">    (lenfunc)bytes_length,</span><br><span class="line">    (binaryfunc)bytes_subscript,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>因为映射操作只有两个，一个是重复的，还有一个是必须要在这里说的，所以映射操作我们就放在这里介绍了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject*</span><br><span class="line"><span class="title function_">bytes_subscript</span><span class="params">(PyBytesObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//参数是self和item，那么在Python的层面上就类似于self[item]</span></span><br><span class="line">    <span class="comment">//检测item，看它是不是一个整型</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//如果是转成Ssize_t</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果i小于0，那么将i加上序列的长度，得到正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyBytes_GET_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= PyBytes_GET_SIZE(self)) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                            <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到整型</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)self-&gt;ob_sval[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测是否是一个切片</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//起始、终止、步长、拷贝的字节个数、循环变量</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, i;</span><br><span class="line">        <span class="type">size_t</span> cur; <span class="comment">//拷贝的字节所在的位置</span></span><br><span class="line">        <span class="comment">//两个缓存</span></span><br><span class="line">        <span class="type">char</span>* source_buf;</span><br><span class="line">        <span class="type">char</span>* result_buf;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        <span class="comment">//这里是会将item解包</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到拷贝的字节个数比如：ob_sval长度为9, 但是未必拷贝9个，所以这个slicelength是计算的拷贝的字节个数</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(PyBytes_GET_SIZE(self), &amp;start,</span><br><span class="line">                                            &amp;stop, step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//slicelength小于等于0的话，直接返回空的字节序列，比如val[3: 2]，显然此时是不循环的，因为start对应的位置在end之后，而且步长为正</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果起始位置为0，步长为1，且拷贝的字节个数等于字节序列的长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start == <span class="number">0</span> &amp;&amp; step == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                 slicelength == PyBytes_GET_SIZE(self) &amp;&amp;</span><br><span class="line">                 PyBytes_CheckExact(self)) &#123;</span><br><span class="line">            <span class="comment">//那么增加引用计数，直接返回</span></span><br><span class="line">            Py_INCREF(self);</span><br><span class="line">            <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果步长是1，那么从start开始拷贝，拷贝slicelength个字字节</span></span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(</span><br><span class="line">                PyBytes_AS_STRING(self) + start,</span><br><span class="line">                slicelength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里，说明步长不是1，只能一个一个拷贝了</span></span><br><span class="line">            source_buf = PyBytes_AS_STRING(self);</span><br><span class="line">            <span class="comment">//创建PyBytesObject对象，空间为slicelength</span></span><br><span class="line">            result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, slicelength);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//拿到内部的ob_sval</span></span><br><span class="line">            result_buf = PyBytes_AS_STRING(result);</span><br><span class="line">            <span class="comment">//从start开始然后一个字节一个字节的拷贝过去</span></span><br><span class="line">            <span class="comment">//start开始拷贝，依旧循环slicelength，通过cur记录拷贝的位置，然后每次循环都加上步长step</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += step, i++) &#123;</span><br><span class="line">                result_buf[i] = source_buf[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//item要么是整数、要么是切片，走到这里说明不满足条件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//比如：item我们传递了一个字符串，显然此时在通过这种方式获取的话，这属于字典的操作</span></span><br><span class="line">        <span class="comment">//所以抛出TypeError异常</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;byte indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     Py_TYPE(item)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以从底层我们可以看到，Python为我们做的事情是真的不少，我们通过一个简单的切片，在底层要这么多行代码。不过在我们分析完逻辑之后，会发现其实也不过如此，毕竟逻辑很好理解。</strong></p>
<p><strong>但是在Python中，索引操作和切片操作，我们都可以通过__getitem__实现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">123</span>])  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])  <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>])  <span class="comment"># slice(1, 5, None)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>: <span class="number">2</span>])  <span class="comment"># slice(1, 5, 2)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;yo&quot;</span>: <span class="string">&quot;ha&quot;</span>: <span class="string">&quot;哼哼&quot;</span>])  <span class="comment"># slice(&#x27;yo&#x27;, &#x27;ha&#x27;, &#x27;哼哼&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过__getitem__，我们可以同时实现切片、索引获取，但是当item为字符串时，我们还可以实现字典操作</span></span><br><span class="line"><span class="comment"># 当然这部分内容，我们会在后面系列中分析类的时候介绍。</span></span><br></pre></td></tr></table></figure>

<p><strong>判断一个序列是否在指定的序列中：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;abc&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;cbd&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果让你来实现的话，显然是两层for循环，那么Python是怎么做的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bytes_contains</span><span class="params">(PyObject *self, PyObject *arg)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//比如: b&quot;abc&quot; in b&quot;abcde&quot;会调用这里的bytes_contains</span></span><br><span class="line">    <span class="comment">//self就是b&quot;abcde&quot;对应的PyBytesObject的指针,arg是b&quot;abc&quot;对应的PyBytesObject的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显然这里调用了_Py_bytes_contains, 传入了self -&gt; ob_sval, self -&gt; ob_size, arg</span></span><br><span class="line">    <span class="keyword">return</span> _Py_bytes_contains(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的源码没有说明，显然是在bytesobject.c中</span></span><br><span class="line"><span class="comment">//但是_Py_bytes_contains位于bytes_methods.c中</span></span><br><span class="line">_Py_bytes_contains(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t len, PyObject *arg)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//将arg转成整型, 但是显然只有当arg -&gt; ob_savl的有效字节为1时才可以这么做</span></span><br><span class="line">    Py_ssize_t ival = PyNumber_AsSsize_t(arg, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ival == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="comment">//所以如果ival == -1 &amp;&amp; PyErr_Occurred()，说明arg -&gt; ob_sval的有效字节数大于1</span></span><br><span class="line">        Py_buffer varg;<span class="comment">//缓冲区</span></span><br><span class="line">        Py_ssize_t pos;<span class="comment">//遍历位置</span></span><br><span class="line">        PyErr_Clear();<span class="comment">//这里将异常清空</span></span><br><span class="line">        <span class="comment">//将arg -&gt; ob_sval设置到缓存区中</span></span><br><span class="line">        <span class="keyword">if</span> (PyObject_GetBuffer(arg, &amp;varg, PyBUF_SIMPLE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//调用stringlib_find找到其位置，里面也是使用了循环</span></span><br><span class="line">        pos = stringlib_find(str, len,</span><br><span class="line">                             varg.buf, varg.len, <span class="number">0</span>);</span><br><span class="line">        PyBuffer_Release(&amp;varg); <span class="comment">//释放缓冲区</span></span><br><span class="line">        <span class="comment">//如果pos大于0确实找到了，否则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> pos &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明字节不合法</span></span><br><span class="line">    <span class="keyword">if</span> (ival &lt; <span class="number">0</span> || ival &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;byte must be in range(0, 256)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明是单个字节，直接调用C中memchr去寻找即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memchr</span>(str, (<span class="type">int</span>) ival, len) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p><strong>我们知道Python中对于不可变对象运算的处理方式就是，再创建一个新的。所以三个bytes对象a、b、c相加时，那么会先根据a + b创建新的临时对象，然后再根据”临时对象+c”创建新的对象，返回指针。所以：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> bytes_list:</span><br><span class="line">    result += _</span><br></pre></td></tr></table></figure>

<p><strong>这是一种效率非常低下的做法，因为涉及大量临时对象的创建和销毁，不仅是这里bytes，后面即将分析的字符串也是同样的道理。官方推荐的做法是，使用join，字符串和字节序列都可以对一个列表进行join，将列表里面的多个字符串或者字节序列join在一起。</strong></p>
<p><strong>举个Python中的例子，我们以字符串为例，字节序列同样如此：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad</span>():</span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        s += <span class="built_in">str</span>(_)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">good</span>():</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        l.append(<span class="built_in">str</span>(_))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">better</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">best</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<p>+号在拼接字符串的时候，会先开辟一块空间，把+号左边的字符串和+号右边的字符串合起来放在新开辟的空间内，这样有几个+号，就会开辟几次空间。<br>加号操作符</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210306369.png" alt="image-20230315210306369"></p>
<p>join拼接字符串也需要开辟空间，但是会提前算好总共需要开辟多大的空间，一次性把内存申请好，然后把所有的字符串合起来放在这个新的空间中，这样就不用频繁申请空间了。节约空间又节约时间。<br>join连接</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210318179.png" alt="image-20230315210318179"></p>
<p>从上面的例子中，可以看到join比+少申请了一块a+b的空间。</p>
<h3 id="字节序列缓冲池"><a href="#字节序列缓冲池" class="headerlink" title="字节序列缓冲池"></a>字节序列缓冲池</h3><p><strong>为了优化单字节bytes对象的创建效率，Python底层内部维护了一个缓冲池。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyBytesObject *characters[UCHAR_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>Python内部创建单字节bytes对象时，先检查目标对象是否已在缓冲池中。PyBytes_FromStringAndSize函数是负责创建bytes对象的通用接口，同样位于 Objects&#x2F;bytesobject.c 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyBytesObject对象的指针</span></span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然size不可以小于0</span></span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;Negative size passed to PyBytes_FromStringAndSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size为1表名创建的是单字节对象，当然str不可以为NULL, 而且获取到的字节必须要在characters里面</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        _Py_one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	</span></span><br><span class="line">        <span class="comment">//增加引用计数，返回指针</span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话创建新的PyBytesObject，此时是个空</span></span><br><span class="line">    op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//不管size是多少，都直接拷贝即可</span></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line">    <span class="comment">//但是size是1的话，除了拷贝还会放到缓存池characters中</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回其指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，当 Python 程序开始运行时，字符缓冲池是空的。随着单字节 bytes*对象的创建，缓冲池中的对象慢慢多了起来。</strong></p>
<p><strong>这样一来，字符对象首次创建后便在缓冲池中缓存起来；后续再次使用时，  Python 直接从缓冲池中取，避免重复创建和销毁。与前面章节介绍的小整数对象池一样，字符对象只有为数不多的 256  个，但使用频率非常高。缓冲池技术作为一种以时间换空间的优化手段，只需较小的内存为代价，便可明显提升执行效率。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然此时不需要我解释了，单字节bytes对象会缓存起来，不是单字节则不会缓存。</strong></p>
<h3 id="bytearray对象"><a href="#bytearray对象" class="headerlink" title="bytearray对象"></a>bytearray对象</h3><p><strong>除了bytes对象之外，Python中还有一个bytearray对象，它和bytes对象类似，只不过bytes对象是不可变的，而bytearray对象是可变的。所以就不单独分析了，这里简单提一嘴。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入一个整型组成的列表创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>([<span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;cde&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个bytes对象创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个字符串，同时指定encoding编码创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">&quot;古明地觉&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们对s进行decode会直接得到字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：bytearray对象是可以变的</span></span><br><span class="line"><span class="comment"># 如果是中文，为了防止出现乱码，所以一次要改变3个字节</span></span><br><span class="line">s[-<span class="number">3</span>:] = <span class="string">&quot;恋&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe6\x81\x8b&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地恋</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们同样可以根据索引、切片获取</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="comment"># 获取单个元素也会得到整型，这一点和bytes对象是一样的</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>])  <span class="comment"># 97 98 99</span></span><br><span class="line"><span class="comment"># 通过切片得到bytearray</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">2</span>])  <span class="comment"># bytearray(b&#x27;ab&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对多个bytearray对象进行join, 会得到一个bytes对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;--&quot;</span>.join([<span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>), <span class="built_in">bytearray</span>(<span class="string">b&quot;def&quot;</span>)]))  <span class="comment"># b&#x27;abc--def&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此把bytearray对象想象成可变的bytes对象即可，它的使用和bytes对象非常类似，一些操作的行为也是一样的，所以就不单独分析了，下一篇将会分析Python中的字符串。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们分析了bytes对象的底层实现，我们说：</strong></p>
<ul>
<li><code>bytes对象是一个变长、不可变对象，内部的值是通过一个C的字符数组来维护的;</code></li>
<li><code>bytes也是序列型操作，它支持的操作在bytes_as_sequence中;</code></li>
<li><code>Python内部维护字符缓冲池来优化单字节bytes对象的创建和销毁操作;</code></li>
<li><code>缓冲池是一种常用的以空间换时间的优化技术;</code></li>
</ul>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Python引用计数器和底层对象管理</title>
    <url>/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="03-Python引用计数器以及底层对象管理"><a href="#03-Python引用计数器以及底层对象管理" class="headerlink" title="03-Python引用计数器以及底层对象管理"></a>03-Python引用计数器以及底层对象管理</h2><p>在上一篇中我们说到了Python中的对象在底层的数据结构，我们知道Python底层通过<strong>PyObject</strong>和<strong>PyTypeObject</strong>完成了C++所提供的对象的多态特性。在Python中创建一个对象，会分配内存并进行初始化，然后Python会用一个PyObject *来保存和维护这个对象，当然所有对象都是如此。因为指针是可以相互转化的，所以变量在保存一个对象的指针时，会将该指针转成PyObject *之后再交给变量保存。因此在Python中，变量的传递<code>(包括函数的参数传递)</code>实际上传递的都是一个泛型指针：PyObject *。这个指针具体是指向的什么类型我们并不知道，只能通过其内部的ob_type成员进行动态判断，而正是因为这个ob_type，Python实现了多态机制。</p>
<p>比如：a.pop()，我们不知道这个a指向的对象到底是什么类型，但只要a可以调用pop方法即可，因此a可以是一个列表、也可以是一个字典、或者是我们实现了pop方法的类的实例对象。所以如果a的ob_type是一个PyList_Type  *，那么就调用PyList_Type中定义的pop操作；如果a的ob_type是一个PyDict_Type，那么就调用PyDict_Type中定义的pop操作。</p>
<blockquote>
<p><strong>所以变量a在不同的情况下，会表现出不同的行为，这正是Python多态的核心所在。</strong></p>
</blockquote>
<p>再比如列表，其内部的元素都是PyObject *，当我们通过索引获取到该指针进行操作的时候，会先通过ob_type获取其类型指针，然后再获取该操作对应的C一级的函数、进行执行，如果不支持相应的操作便会报错。</p>
<p><strong>从这里我们也能看出来Python为什么慢了，因为有相当一部分时间浪费在类型和属性的查找上面。</strong></p>
<blockquote>
<p><strong>以变量a +  b为例，这个a和b指向的对象可以是整型、浮点型、字符串、列表、元组、甚至是我们自己实现了某个魔法方法的类的实例对象，因为我们说Python中的变量都是一个PyObject *，所以它可以指向任意的对象，因此Python它就无法做基于类型方面的优化。</strong></p>
<p><strong>首先Python要通过ob_type判断变量到底指向的是什么类型，这在C级至少需要一次属性查找。然后Python将每一个操作都抽象成了一个魔法方法，所以实例相加时要在对应的类型对象中找到该方法对应的函数指针，这又是一次属性查找。找到了之后将a、b作为参数传递进去，这会发生一次函数调用，会将a和b中维护的值拿出来进行运算，然后根据相加结果创建一个新的对象，再返回其对应的PyObject *指针。</strong></p>
<p><strong>而对于C来讲，由于已经规定好了类型，所以a + b在编译之后就是一条简单的机器指令，所以两者在效率上差别很大。</strong></p>
</blockquote>
<p><strong>当然我们不是来吐槽Python效率的问题的，因为任何语言都擅长的一面和不擅长的一面，只是通过回顾前面的知识来解释为什么Python效率慢。</strong></p>
<blockquote>
<p><strong>因此当别人问你Python为什么效率低的时候，希望你能从这个角度来回答它。不要动不动就GIL，那是在多线程情况下才需要考虑的问题，所以有时真的很反感那些在没涉及到多线程的时候还提Python GIL的人。</strong></p>
</blockquote>
<p><strong>简单回顾了一下前面的内容，下面我们说一说Python中的对象从创建到销毁的过程，了解一下Python中对象的生命周期。</strong></p>
<h3 id="Python-x2F-C-API"><a href="#Python-x2F-C-API" class="headerlink" title="Python&#x2F;C API"></a>Python&#x2F;C API</h3><p>当我们在控制台敲下这个语句的时候，Python内部是如何从无到有创建一个浮点数对象的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; e = 2.71</span><br></pre></td></tr></table></figure>

<p>另外Python又是怎么知道该如何将它打印到屏幕上面呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(e)</span><br><span class="line">2.71</span><br></pre></td></tr></table></figure>

<p>对象使用完毕时，Python还要将其销毁，那么销毁的时机又该如何确定呢？带着这些问题，我们来探寻一个对象从创建到销毁整个生命周期中的行为表现，然后从中寻找答案。</p>
<p>不过在探寻对象的创建之前，先介绍Python提供的C API，也叫Python&#x2F;C API。</p>
<p>Python对外提供了C API，让用户可以从C环境中与其交互。实际上，由于Python解释器是用C写成的，所以Python内部本身也在大量使用这些C API。为了更好的研读源码，系统地了解这些API的组成结构是很有必要的，而C API分为两类：<font color="red">泛型API和特型API</font></p>
<p><font color="red"><strong>泛型API</strong></font></p>
<p>“泛型API”与类型无关，属于”抽象对象层(Abstract Object Layer，AOL)”，这类API的第一个参数是PyObject  *，可以处理任意类型的对象，API内部会根据对象的类型进行区别处理。而且泛型API名称也是有规律的，具有PyObject_xxx这种形式。</p>
<p>以对象打印函数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PyObject_Print</span><span class="params">(PyObject *op, FILE *fp, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<p>接口的第一个参数为待打印的对象的指针，可以是任意类型的对象的指针，因此参数类型是PyObject *。而我们说PyObject  *是Python底层的一个泛型指针，通过这个泛型指针来实现多态的机制。第二个参数是文件句柄，表示输出的位置，默认是stdout、即控制台；而flags表示是要以<code>__str__</code>打印还是要以<code>__repr__</code>打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有两个PyObject *, fo和lo</span></span><br><span class="line"><span class="comment">// fo指向PyFloatObject, lo指向PyLongObject, 但是它们在打印的时候都可以调用这个相同的打印方法</span></span><br><span class="line">PyObject_Print(fo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">PyObject_Print(lo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PyObject_Print接口内部会根据对象类型，决定如何输出对象。</strong></p>
<p><font color="red"><strong>特型API</strong></font></p>
<p>特型API与类型相关，属于”具体对象层(Concrete Object Layer，COL)”。这类API只能作用于某种具体类型的对象，比如：浮点数PyFloatObject，而Python内部为每一种内置对象的实例对象都提供了很多的特型API。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过C的中double创建PyFloatObject</span></span><br><span class="line">PyObject* <span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过C中的long创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromLong</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="comment">// 通过C中的char *来创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **pend, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure>

<p><strong>特型API也是有规律的，尤其是关于C类型和Python类型互转的时候，会用到以下两种特型API：</strong></p>
<ul>
<li><code>Py###_From@@@: 根据C的对象创建Python的对象，###表示Python的类型， @@@表示C的类型，比如PyFloat_FromDouble表示根据C中的double创建Python的float。</code></li>
<li><code>Py###_As@@@: 根据Python的对象创建C的对象,  ###表示Python的类型，@@@表示C的类型，比如PyFloat_AsDouble表示根据Python的float创建C的double;  PyLong_AsLong表示根据Python中的int创建C中的long，因为Python中的int是没有长度限制的，所以在底层使用的是PyLongObject，而不是PyIntObject。</code></li>
</ul>
<p><strong>了解了Python&#x2F;C API之后，我们看对象是如何创建的。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>经过前面的理论学习，我们知道对象的 ** <font color="red">元数据</font>保存在对应的<font color="red">类型对象</font>，元数据当然也包括对象如何创建等信息。</strong></p>
<blockquote>
<p><strong>比如执行pi &#x3D; 3.14，那么这个过程都发生了什么呢？首先解释器会根据3.14推断出要创建的对象是浮点数，所以会创建出维护的值为3.14的PyFloatObject，并将其指针转化成PyObject *交给变量pi。</strong></p>
<p><strong>另外需要注意的是，我们说对象的元数据保存在对应的类型对象中，这就意味着对象想要被创建是需要借助对应的类型对象的，但是这是针对于创建我们自定义的类的实例对象而言。创建内置类型的实例对象是直接创建的，至于为什么，我们下面会说。</strong></p>
</blockquote>
<p><strong>而创建对象的方式有两种，一种是通过”泛型API”创建，另一种是通过”特型API”创建。比如创建一个浮点数：</strong></p>
<p><font color="cornflowerblue"><strong>使用泛型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyObject_New(PyObject, &amp;PyFloat_Type);</span><br></pre></td></tr></table></figure>

<p><font color="cornflowerblue"><strong>使用特型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyFloat_FromDouble(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyTupleObject</span></span><br><span class="line">PyObject* tpl = PyTuple_New(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyListObject, 当然了这是初始容量, 列表可以扩容的</span></span><br><span class="line">PyObject* tpl = PyList_New(<span class="number">5</span>);    </span><br></pre></td></tr></table></figure>

<p>但不管采用哪种方式创建，最终的关键步骤都是分配内存，而创建内置类型的实例对象，Python是可以直接分配内存的。因为它们有哪些成员在底层都是写死的，而Python对它们了如指掌，因此可以通过Python&#x2F;C  API直接分配内存并初始化。以PyFloat_FromDouble为例，直接在接口内部为PyFloatObject结构体实例分配内存，并初始化相关字段即可。</p>
<blockquote>
<p><strong>比如：pi &#x3D; 3.14，解释器通过3.14知道要创建的对象是PyFloatObject，那么直接根据PyFloatObject里面的成员算一下就可以了，一个引用计数<code>(ob_refcnt)</code> + 一个指针<code>(ob_type)</code> + 一个double<code>(ob_fval)</code> 显然是24个字节，所以直接就分配了。然后将ob_refcnt始化为1，ob_type设置为&amp;PyFloat_Type，ob_fval设置为3.14即可。</strong></p>
<p><strong>同理可变对象也是一样，因为成员都是固定的，类型、以及内部容纳的元素有多少个也可以根据赋的值得到，所以内部的所有元素<code>(PyObject \*)</code>占用了多少内存也是可以算出来的，因此也是可以直接分配内存的。</strong></p>
</blockquote>
<p>但对于我们自定义的类型就不行了，假设我们通过class Girl:定义了一个类，显然实例化的时候不可能通过<code>PyGirl_New</code>、或者<code>PyObject_New(PyObject, &amp;PyGirl_Type)</code>这样的API去创建，因为根本就没有PyGirl_New这样的API，也没有PyGirl_Type这个类型对象。这种情况下，创建Girl的实例对象就需要Girl这个类型对象来创建了。因此自定义类的实例对象如何分配内存、如何进行初始化，答案是需要在对应的类型对象里面寻找的。</p>
<p><strong>总的来说：Python内部创建一个对象的方法有两种：</strong></p>
<ul>
<li><code>通过Python/C API，可以是泛型API、也可以是特型API，用于内置类型；</code></li>
<li><code>通过对应的类型对象去创建，多用于自定义类型；</code></li>
</ul>
<p>​        抛出个问题: e &#x3D; 2.71 和 e &#x3D; float(2.71)得到的结果都是2.71，但它们之间有什么不同呢。或者说列表: lst &#x3D; [] 和 lst &#x3D; list()得到的lst也都是一个空列表，但这两种方式有什么区别呢？    </p>
<p>我们说创建实例对象可以通过Python&#x2F;C API，用于内置类型；也可以通过对应的类型对象去创建，多用于自定义类型。但是通过对应类型对象去创建实例对象其实是一个更加通用的流程，因为它除了支持自定义类型之外、还支持内置类型。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst = []  # 通过Python/C API创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; lst = list()  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; e = 2.71  # 通过Python/C API创建 </span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt; e = float(2.71)  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到了对象的两种创建方式，我们写上2.71、或者[]，Python会直接解析成底层对应的数据结构；而float(2.71)、或者list()，虽然结果是一样的，但是我们看到这是一个调用，因此要进行参数解析、类型检测、创建栈帧、销毁栈帧等等，所以开销会大一些。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = []</span><br><span class="line">t2 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t2 - t1)  <span class="comment"># 0.5595989</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t3 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = <span class="built_in">list</span>()</span><br><span class="line">t4 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t4 - t3)  <span class="comment"># 1.1722419999999998</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>通过[]的方式创建一千万次空列表需要0.56秒，但是通过list()的方式创建一千万次空列表需要1.17秒，主要就在于list()是一个调用，而[]直接会被解析成底层对应的PyListObject，因此[]的速度会更快一些。同理3.14和float(3.14)也是如此。</strong></p>
</blockquote>
<p><strong>虽说使用Python&#x2F;C API的方式创建的速度会更快一些，但这是针对内置类型而言。以我们上面那个自定义了Girl为例，如果想创建一个Girl的实例对象，除了通过Girl这个类型对象去创建，你还能想到其它方式吗？</strong></p>
<blockquote>
<p><strong>列表的话：可以list()、也可以[]；元组：可以tuple()、也可以()；字典：可以dict()、也可以{}，前者是通过类型对象去创建的，后者是通过Python&#x2F;C API创建，会直接解析为对应的C一级数据结构。因为这些结构在底层都是已经实现好了的，是可以直接用的，无需通过调用的方式。</strong></p>
<p><strong>但是显然自定义类型就没有这个待遇了，它的实例对象只能通过它自己去创建，比如：Girl这个类，Python不可能在底层定义一个PyGirlObject、然后把API提供给我们。所以，我们只能通过Girl()这种方式去创建Girl的实例对象。</strong></p>
</blockquote>
<p><strong>所以我们需要通过Girl这个类来创建它的实例对象，也就是调用Girl这个类，而一个对象可以是可调用的，也可以是不可调用的。如果一个对象可以被调用，那么这个对象就是callable，否则就不是callable。</strong></p>
<p><strong>而决定一个对象是不是callable，就取决于其对应的类型对象中是否定义了某个方法。如果从Python的角度看的话，这个方法就是<code>__call__</code>，从解释器角度看的话，这个方法就是tp_call。</strong></p>
<p><font color="red"><strong>1. 从Python的角度来看对象的调用：</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int可以调用, 那么它的类型对象(type)内部一定有__call__方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(<span class="built_in">type</span>, <span class="string">&quot;__call__&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 因为我们自定义的类A里面没有__call__, 所以a是不可以被调用的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 告诉我们A的实例对象不可以被调用</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;A&#x27; object is not callable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们给A设置了一个__call__</span></span><br><span class="line"><span class="built_in">type</span>.__setattr__(A, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="comment"># 发现可以调用了</span></span><br><span class="line"><span class="built_in">print</span>(a())  <span class="comment"># 这是__call__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这就是动态语言的特性, 即便在类创建完毕之后, 依旧可以通过type进行动态设置</span></span><br><span class="line"><span class="comment"># 而这在静态语言中是不支持的, 所以type是所有类的元类, 它控制了我们自定义类的生成过程</span></span><br><span class="line"><span class="comment"># type这个古老而又强大的类可以让我们玩出很多新花样</span></span><br><span class="line"><span class="comment"># 但是对于内置的类type是不可以对其动态增加、删除或者修改的，因为内置的类在底层是静态定义好的</span></span><br><span class="line"><span class="comment"># 因为从源码中我们看到, 这些内置的类、包括元类，它们都是PyTypeObject对象, 在底层已经被声明为全局变量了</span></span><br><span class="line"><span class="comment"># 所以type虽然是所有类型对象的元类，但是只有在面对我们自定义的类的时候，type具有增删改的能力</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">type</span>.__setattr__(<span class="built_in">dict</span>, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;dict&#x27;</span></span><br><span class="line"><span class="comment"># 我们看到抛异常了, 提示我们&quot;不可以给内置/扩展类型dict设置属性&quot;</span></span><br><span class="line"><span class="comment"># 而dict属于内置类型，至于扩展类型是我们在编写扩展模块中定义的类</span></span><br><span class="line"><span class="comment"># 内置类和扩展类是等价的，它们直接就指向了C一级的数据结构, 不需要经历被解释器解释这一步</span></span><br><span class="line"><span class="comment"># 而动态特性是解释器在解释执行字节码(翻译成C级代码执行)的时候动态赋予的</span></span><br><span class="line"><span class="comment"># 而内置类/扩展类它们本身就已经是指向C一级的数据结构了，绕过了解释器解释执行这一步, 所以它们的属性不能被动态设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__dict__[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 它们的属性字典也是不可以设置的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>: </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line">g.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="comment"># 实例对象我们也可以手动设置属性</span></span><br><span class="line"><span class="built_in">print</span>(g.a)  <span class="comment"># xx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 但是内置类型的实例对象是不可以的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;list&#x27; object has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># 可能有人奇怪了，为什么不行呢？</span></span><br><span class="line"><span class="comment"># 答案是内置类型的实例对象没有__dict__属性字典, 有多少属性或方法底层已经定义好了，不可以动态添加</span></span><br><span class="line"><span class="comment"># 如果我们自定义类的时候，设置了__slots__, 那么效果和内置的类是相同的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(lst, <span class="string">&quot;__dict__&quot;</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>2. 从解释器的角度来看对象的调用：</strong></font></p>
<p><strong>我们以内置类型float为例，我们说创建一个PyFloatObject，可以通过3.14或者float(3.14)的方式。前者使用Python&#x2F;C  API创建，3.14直接被解析为C一级数据结构PyFloatObject的对象；后者使用类型对象创建，通过对float进行一个调用、将3.14作为参数，最终也得到指向C一级数据结构PyFloatObject的对象。Python&#x2F;C API的创建方式我们已经很清晰了，就是根据值来推断在底层应该对应哪一种数据结构，然后直接创建即可。我们重点看一下通过调用来创建实例对象的方式。</strong></p>
<p><strong>如果一个对象可以被调用，我们说它的类型对象中一定要有tp_call<code>(更准确的说成员tp_call的值一定一个是函数指针, 不可以是0)</code>，而PyFloat_Type是可以调用的，这就说明PyType_Type内部的tp_call是一个函数指针，这在Python的层面是上我们已经验证过了，下面我们就来看看。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="comment">//...                                          /* tp_hash */</span></span><br><span class="line">    (ternaryfunc)type_call,                     <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="green"><strong>我们看到在实例化PyType_Type的时候PyTypeObject内部的成员tp_call被设置成了type_call，这是一个函数指针，当我们调用PyFloat_Type的时候，会触发这个type_call指向的函数。</strong></font></p>
<p>因此float(3.14)在C层面上等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFloat_Type.ob_type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">//即：</span></span><br><span class="line">PyType_Type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">// 而在创建PyType_Type的时候，给tp_call成员传递的是type_call, 因此最终相当于</span></span><br><span class="line">type_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>

<p><strong>调用参数通过args和kwargs两个对象传递，关于参数传递暂时先不展开，留到函数机制中再详细介绍。</strong></p>
<p><strong>然后我们围观一下type_call函数，它位于Object&#x2F;typeobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 如果我们调用的是float，那么显然这里的type就是&amp;PyFloat_Type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是声明一个PyObject *，显然这是要返回的实例对象的指针</span></span><br><span class="line">    PyObject *obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里的tp_new是什么估计有人已经猜到了，我们说__call__对应底层的tp_call</span></span><br><span class="line">    <span class="comment">//那么这里tp_new呢？然后对应Python中的__new__方法，这里是为实例对象分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;cannot create &#x27;%.100s&#x27; instances&quot;</span>,</span><br><span class="line">                     type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过tp_new分配空间，此时实例对象就已经创建完毕了，这里会返回其指针</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line">    <span class="comment">//类型检测，暂时不用管</span></span><br><span class="line">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断参数的，我们说这里的参数type是类型对象，但也可以是元类，元类也是由PyTypeObject结构体实例化得到的</span></span><br><span class="line">    <span class="comment">//元类在调用的时候执行的依旧是type_call，所以这里是检测type指向的是不是PyType_Type</span></span><br><span class="line">    <span class="comment">//如果是的话，那么实例化得到的obj就不是实例对象了，而是类型对象，要单独检测一下</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span><br><span class="line">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (kwds == <span class="literal">NULL</span> ||</span><br><span class="line">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="number">0</span>)))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，后面为了方便在Python层面就不提指针了，直接用实例对象代替了</span></span><br><span class="line">    <span class="comment">//但如果返回的不是，那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//拿到obj的类型</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//执行tp_init，显然这个tp_init就是__init__函数，这与Python中类的实例化过程是一致的。</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//执行tp_init, 设置参数</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//执行失败，将引入计数减1，然后将obj设置为NULL</span></span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回obj</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此从上面我们可以看到关键的部分有两个：</strong></p>
<ul>
<li><code>调用类型对象的tp_new函数指针指向的函数为实例对象申请内存。</code></li>
<li><code>调用tp_init函数指针指向的函数为实例对象进行初始化，也就是设置属性。</code></li>
</ul>
<p><strong>所以这对应Python中的<code>__new__</code>和<code>__init__</code>，我们说<code>__new__</code>是为实例对象开辟一份内存，然后返回指向这片内存<code>(对象)</code>的指针，会自动传递给<code>__init__</code>中的self。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        <span class="comment"># 写法非常固定，调用object.__new__(cls)就会创建Girl的实例对象</span></span><br><span class="line">        <span class="comment"># 因此这里的cls指的就是这里的Girl, 但是一定要返回, 因为__new__会将自己的返回值交给__init__中的self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl(<span class="string">&quot;古明地觉&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(g.name, g.age)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">__init__方法执行啦</span></span><br><span class="line"><span class="string">古明地觉 16</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>*<em>但是注意：__new__里面的参数要和__init__里面的参数保持一致，因为我们会先执行__new__，然后解释器会将__new__的返回值和我们传递的参数组合起来一起传递给self。因此__new__里面的参数位置除了cls之外，一般都会写*args和*<em>kwargs。</em></em></p>
<p><strong>然后再回过头来看一下type_call中的这几行代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，但如果返回的不是</span></span><br><span class="line">    <span class="comment">//那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说tp_new应该返回该类型对象的实例对象指针，而且一般情况下我们是不写__new__的，会默认执行。但是我们一旦重写了，那么必须要手动返回object.<strong>new</strong>(cls)，那么如果我们不返回，或者返回其它的话，会怎么样呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="comment"># 打印看看instance到底是个什么东东</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;instance:&quot;</span>, instance)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;type(instance):&quot;</span>, <span class="built_in">type</span>(instance))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正确做法是将instance返回, 但是我们不返回, 而是返回个123</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">instance: &lt;__main__.Girl object at 0x000002C0F16FA1F0&gt;</span></span><br><span class="line"><span class="string">type(instance): &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里面有很多可以说的点，首先就是__init__里面需要两个参数，但是我们没有传，却还不报错。原因就在于这个__init__压根就没有执行，因为__new__返回的不是Girl的实例对象。</strong></p>
<p><strong>通过打印instance，我们知道了object.<strong>new</strong>(cls)返回的就是cls的实例对象，而这里的cls就是Girl这个类本身，我们必须要返回instance，才会执行对应的__init__，否则__new__直接就返回了。我们来打印一下其返回值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g, <span class="built_in">type</span>(g))  <span class="comment"># 123 &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到直接打印的就是123，所以再次总结一些tp_new和tp_init之间的区别，当然也对应__new__和__init__的区别：</strong></p>
<ul>
<li><code>tp_new：为该类型对象的实例对象申请内存，在Python的__new__方法中通过object.__new__(cls)的方式申请，然后将其返回。</code></li>
<li><code>tp_init：tp_new的返回值会自动传递给self，然后为self绑定相应的属性，也就是执行构造函数进行初始化。</code></li>
</ul>
<blockquote>
<p><strong>但如果tp_new返回的不是对应类型的实例对象指针，比如type_call中第一个参数接收的&amp;PyFloat_Type，但是tp_new中返回的却是PyLongObject类型的指针，所以此时就不会执行tp_init。</strong></p>
<p><strong>以Python为例，我们Girl中的__new__应该返回Girl的实例对象才对，但实际上返回了整型，因此类型不一致，所以不会执行__init__。</strong></p>
</blockquote>
<p><strong>所以通过类型对象去创建实例对象的整体流程如下：</strong></p>
<ul>
<li><code>1. 获取类型对象的类型对象，说白了就是元类，执行元类中的type_call指向的函数；</code></li>
<li><code>2.  tp_call会调用该类型对象的tp_new指向的函数，如果tp_new为NULL(实际上肯定不会NULL，但是我们假设为NULL)，那么会到tp_base指定的父类里面去寻找tp_new。在新式类当中，所有的类都继承自object，因此最终会找到一个不为NULL的tp_new。然后通过tp_new会访问对应类型对象中的tp_basicsize信息，继而完成申请内存的操作。这个信息记录着一个该对象的实例对象需要占用多大内存。在为实例对象分配空间之后，会将指向这片空间的指针交给tp_init；</code></li>
<li><code>3. 在调用type_new完成创建对象之后，流程就会转向PyLong_Type的tp_init，完成初始化对象的工作。当然这个tp_init也可能不被调用，原因我们上面已经分析过了；</code></li>
</ul>
<p><strong>所以我们说Python中__new__调用完了会自动调用__init__，而且还会将其返回值传递给__init__中的第一个参数。那是因为在type_call中先调用的tp_new，然后再调用的tp_init，同时将tp_new的返回值传进去了。从源码的角度再分析一遍：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//当我们创建一个类的实例对象的时候，会去调用元类的__call__方法，所以是这里的tp_call</span></span><br><span class="line">    <span class="comment">//比如Girl(&quot;古明地觉&quot;, 16) 等价于 type.__call__(Girl, &quot;古明地觉&quot;, 16)</span></span><br><span class="line">    <span class="comment">//所以走到了这一步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用__new__方法， 拿到其返回值</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用__init__，将返回值obj传递给__init__中的self，并在里面设置属性</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此底层所表现出来的和我们在Python中看到的，是一样的。</strong></p>
<h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><p>​        我们说Python创建一个对象，比如PyFloatObject，会分配内存并进行初始化。然后Python内部会统一使用一个叫做PyObject*的泛型指针来保存和维护这个对象，而不是PyFloatObject *。    </p>
<p>​    	通过PyObject *保存和维护对象，可以实现更加抽象的上层逻辑，而不用关心对象的实际类型和实现细节。比如：哈希计算 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数可以计算任意对象的哈希值，而不用关心对象的类型是啥，它们都可以使用这个函数。</p>
<p><strong>但是不同类型的对象，其行为也千差万别，哈希值计算的方式也是如此，那么PyObject_Hash函数是如何解决这个问题的呢？不用想，因为元信息存储在对应的类型对象之中，所以肯定会通过其ob_type拿到指向的类型对象。而类型对象中有一个成员叫做tp_hash，它是一个函数指针，指向的函数专门用来计算其实例对象的哈希值，我们看一下PyObject_Hash的函数定义吧，它位于Object&#x2F;Object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//Py_TYPE是一个宏，用来获取一个PyObject *内部的ob_type，不过从名字也能看出来</span></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(v);</span><br><span class="line">    <span class="comment">//获取对应的类型对象内部的tp_hash方法，tp_hash是一个函数指针</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果tp_hash不为空,证明确实指向了具体的hash函数，那么拿到拿到函数指针之后，通过*获取对应的函数</span></span><br><span class="line">        <span class="comment">//然后将PyObject *传进去计算哈希值，返回。</span></span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果tp_hash为空，那么有两种可能。1. 说明该类型对象可能还未初始化, 导致tp_hash暂时为空; 2. 说明该类型本身就不支持其&quot;实例对象&quot;被哈希</span></span><br><span class="line">    <span class="comment">// 如果是第1种情况，那么它的tp_dict、也就是属性字典一定为空，tp_dict是动态设置的，因此它若为空，是该类型对象没有初始化的重要特征</span></span><br><span class="line">    <span class="comment">//如果它不为空，说明类型对象一定已经被初始化了，所以此时tp_hash为空，就真的说明该类型不支持实例对象被哈希</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，那么先进行类型的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后再看是否tp_hash是否为空，为空的话，说明不支持哈希</span></span><br><span class="line">        <span class="comment">//不为空则调用对应的哈希函数</span></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里代表以上条件都不满足，说明该对象不可以被hash</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数先通过ob_type指针找到对象的类型，然后通过类型对象的tp_hash函数指针调用对应的哈希计算函数。所以PyObject_Hash根据对象的类型，调用不同的哈希函数，这不正是实现了多态吗？</strong></p>
<blockquote>
<p><strong>通过ob_type字段，Python在C语言的层面实现了对象的多态特性，思路跟C++中的”虚表指针”有着异曲同工之妙。</strong></p>
</blockquote>
<p><strong>另外可能有人觉得这个函数的源码写的不是很精简，比如一开始已经判断过内部的tp_hash是否为NULL，然后在下面又判断了一次。那么可不可以先判断tp_dict是否为NULL，为NULL进行初始化，然后再判断tp_hash是否NULL，不为NULL的话执行tp_hash。这样的话，代码会变得精简很多。</strong></p>
<blockquote>
<p><strong>答案是可以的，而且这种方式似乎更直观，但是效率上不如源码。因为我们这种方式的话，无论是什么对象，都需要判断其类型对象中tp_dict和tp_hash是否为NULL。而源码中先判断tp_hash是否为NULL，不为NULL的话就不需要再判断tp_dict了；如果tp_hash为NULL，再判断是否tp_dict也为NULL，如果tp_dict为NULL则初始化，再进一步再判断tp_hash是否还是NULL。所以对于已经初始化<code>(tp_hash不为NULL)</code>的类型对象，源码中少了一次对tp_dict是否为NULL的判断，所以效率会更高。</strong></p>
<p><strong>当然这并不是重点，我想说的重点是类似于<code>先判断tp_hash是否为空、如果不为空则直接调用</code>这种方式，叫做CPython中的快分支。而且CPython中还有很多其它的快分支，快分支的特点就是命中率极高，可以尽早做出判断、尽早处理。回到当前这个场景，只有当类型未被初始化的时候，才会不走快分支，而其余情况都走快分支。也就是说快分支只有在第一次调用的时候才可能不会命中，其余情况都是命中，因此没有必要每次都对tp_dict进行判断。所以源码的设计是非常合理的，我们在后面分析函数调用的时候，也会看到很多类似于这样的快分支。</strong></p>
<p><strong>再举个生活中的栗子解释一下快分支：好比你去见心上人，但是心上人说你今天没有打扮，于是你又跑回去打扮一番之后再去见心上人。所以既然如此，那为什么不能先打扮完再去见心上人呢？答案是在绝大部分情况下，即使你不打扮，心上人也不会介意，只有在极少数情况下，比如心情不好，才会让你回去打扮之后再过来。所以不打扮直接去见心上人就能牵手便属于快分支，它的特点就是命中率极高，绝大部分都会走这个情况，所以没必要每次都因为打扮耽误时间，只有在极少数情况下快分支才不会命中。</strong></p>
</blockquote>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p>这里说一句，关于对象我们知道Python中的类型对象和实例对象都属于对象，但是我们更关注的是实例对象的行为。</p>
<p>而不同对象的行为不同，比如hash值的计算方法就不同，由类型对象中tp_hash字段决定。但除了tp_hash，PyTypeObject中还定义了很多函数指针，这些指针最终都会指向某个函数，或者为空表示不支持该操作。这些函数指针可以看做是”类型对象”中定义的操作，这些操作决定了其”实例对象”在运行时的”行为”。虽然所有类型对象在底层都是由同一个结构体PyTypeObject实例化得到的，但内部成员接收的值不同，得到的类型对象就不同；类型对象不同，导致其实例对象的行为就不同，这也正是一种对象区别于另一种对象的关键所在。</p>
<blockquote>
<p><strong>比如列表支持append，这说明在PyList_Type中肯定有某个函数指针，能够找到用于列表append操作的函数。</strong></p>
<p><strong>整型支持除法操作，说明PyLong_Type中也有对应除法操作的函数指针。</strong></p>
<p><strong>整型、浮点型、字符串、元组、列表都支持加法操作，说明它们也都有对应加法操作的函数指针，并且类型不同，也会执行不同的加法操作。比如：1 + 1 &#x3D; 2，”xx” + “yy” &#x3D;  “xxyy”，不可能对字符串使用整型的加法操作。而字典不支持加法操作，说明创建PyDict_Type的时候，没有给相应的结构体成员设置函数指针，可能传了一个空。</strong></p>
</blockquote>
<p><strong>而根据支持的操作不同，Python中可以将对象进行以下分类：</strong></p>
<ul>
<li><code>数值型操作：比如整型、浮点型的加减乘除；</code></li>
<li><code>序列型操作：比如字符串、列表、元组的通过索引、切片取值行为；</code></li>
<li><code>映射型操作：比如字典的通过key映射出value，相当于y = f(x)，将x传进去映射出y；另外有一本专门讲Python解释器的书，基于Python2.5，书中的这里不叫映射型，而是叫关联型。但我个人喜欢叫映射型，所以差不多都是一个东西，理解就可以。</code></li>
</ul>
<p>​        <strong>而这三种操作，PyTypeObject中分别定义了三个指针。每个指针指向一个结构体实例，这个结构体实例中有大量的成员，成员也是函数指针，指向了具体的函数。</strong>    </p>
<p><strong>我们看一下定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    PyNumberMethods *tp_as_number;  <span class="comment">// 数值型相关操作</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;   <span class="comment">// 序列型相关操作</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;  <span class="comment">// 映射型相关操作</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下tp_as_number，它是PyNumberMethods类型的结构体指针：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">       arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">       in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="type">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p>​        <strong>你看到了什么，是的，这不就是python里面的魔法方法嘛。在PyNumberMethods里面定义了作为一个数值应该支持的操作。如果一个对象能被视为数值对象，比如整数，那么在其对应的类型对象PyLong_Type中，tp_as_number -&gt;  nb_add就指定了对该对象进行加法操作时的具体行为。同样，PySequenceMethods和PyMappingMethods中分别定义了作为一个序列对象和映射对象应该支持的行为，这两种对象的典型例子就是list和dict。所以，只要 类型对象 提供相关 操作 ， 实例对象 便具备对应的 行为 。</strong>    </p>
<p><strong>然而对于一种类型来说，它完全可以同时定义三个函数中的所有操作。换句话说，一个对象既可以表现出数值对象的特征，也可以表现出映射对象的特征。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Int(<span class="number">1</span>)</span><br><span class="line">b = Int(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;(嘎~嘎~嘎~)&quot;</span>])  <span class="comment"># (嘎~嘎~嘎~)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看上去a[“”]这种操作是一个类似于dict这样的对象才支持的操作。从int继承出来的Int自然是一个数值对象，但是通过重写__getitem__这个魔法函数，可以视为指定了Int在python内部对应的PyTypeObject对象的tp_as_mapping -&gt;  mp_subscript操作。最终Int实例对象表现的像一个map一样。归根结底就在于PyTypeObject中允许一种类型对象同时指定多种不同的行为特征。  默认使用PyTypeObject结构体实例化出来的PyLong_Type对象所生成的实例对象是不具备list和dict的属性特征的，但是我们继承PyLong_Type，同时指定__getitem__，使得我们自己构建出来的类型对象所生成的实例对象，同时具备int、list(部分)、dict(部分)的属性特征，就是因为python支持同时指定多种行为特征。</strong>     </p>
<p><strong>我们以浮点型为例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到了该类型对象在创建时，给成员tp_as_number，传入了一个float_as_number指针</span></span><br><span class="line"><span class="comment">//那么这个float_as_number指针就应该指向一个PyNumberMethods结构体实例</span></span><br><span class="line"><span class="comment">//而指向的结构体实例中也应该有大量和浮点数运算相关的函数指针，每个函数指针指向了浮点数运算相关的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//里面的float_add、float_sub、float_mul等等显然都是已经定义好的函数的指针</span></span><br><span class="line"><span class="comment">//然后创建PyNumberMethods结构体实例float_as_number的时候，分别赋值给了成员nb_add、nb_substract、nb_multiply等等等等</span></span><br><span class="line"><span class="comment">//创建完浮点数相关操作的PyNumberMethods结构体实例float_as_number之后，将其指针交给PyFloat_Type中的tp_as_number成员</span></span><br><span class="line"><span class="comment">//所以浮点数相加的时候，会执行object -&gt; ob_type -&gt; tp_as_number -&gt; nb_add, 而浮点类型对象的tp_as_number就是&amp;float_as_number</span></span><br><span class="line"><span class="comment">//所以再获取其成员nb_add的时候，拿到的就是float_add指针，然后调用float_add函数</span></span><br></pre></td></tr></table></figure>

<p><strong>所以PyFloat_Type是支持数值型操作的，但是我们看到tp_as_sequence和tp_as_mapping这两个成员接收到的值则不是一个函数指针，而是0，相当于空。因此float对象、即浮点数不支持序列型操作和映射型操作，比如：pi &#x3D;  3.14，我们无法使用len计算长度、无法通过索引或者切片获取指定位置的值、无法通过key获取value，这和我们使用Python时候的表现是一致的。</strong></p>
<blockquote>
<p><strong>我们看到PyFloat_Type中tp_as_number指向的结构体中的nb_add成员对应的函数指针是float_add，但如果是PyLong_Type的话，那么nb_add对应的函数指针则是long_add。</strong></p>
<p><strong>不同对象，使用的操作是不同的。整型相加，使用的肯定是long_add，浮点型相加使用的是float_add。</strong></p>
</blockquote>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在c和c++中，程序员被赋予了极大的自由，可以任意的申请内存。但是权利的另一面对应着责任，程序员最后不使用的时候，必须负责将申请的内存释放，并释放无效指针。可以说，这一点是万恶之源，大量内存泄漏、悬空指针、越界访问的bug由此产生。</p>
<p>现代的开发语言当中都有垃圾回收机制，语言本身负责内存的管理和维护，比如C#和golang。垃圾回收机制将开发人员从维护内存分配和清理的繁重工作中解放出来，但同时也剥夺了程序员和内存亲密接触的机会，并牺牲了一定的运行效率。但好处就是提高了开发效率，并降低了bug发生的几率。Python里面同样具有垃圾回收机制，代替程序员进行繁重的内存管理工作，而引用计数正是垃圾收集机制的一部分。</p>
<p>python通过对一个对象的引用计数的管理来维护对象在内存中的存在与否。我们知道Python中每一个东西都是一个对象，都有一个ob_refcnt成员。这个成员维护这该对象的引用计数，从而也最终决定着该对象的创建与消亡。</p>
<p>​        在python中，主要是通过Py_INCREF(op)和Py_DECREF(op)两个宏，来增加和减少一个对象的引用计数，当一个对象的引用计数减少到0后，Py_DECREF将调用该对象的析构函数来释放该对象所占有的内存和系统资源。这个析构函数就是对象的类型对象(Py***_Type)中定义的函数指针来指定的，也就是tp_dealloc。    </p>
<p>​        如果熟悉设计模式中的Observer模式，就可以看到，这里隐隐约约透着Observer模式的影子。在ob_refcnt减少到0时，将触发对象的销毁事件。从python的对象体系来看，各个对象提供了不同事件处理函数，而事件的注册动作正是在各个对象对应的类型对象中完成的。    </p>
<p><strong>我们在研究对象的行为的时候，说了比起类型对象，我们更关注实例对象的行为。那么对于引用计数也是一样的，只有实例对象，我们探讨引用计数才是有意义的。类型对象<code>(内置)</code>是超越引用计数规则的，永远都不会被析构，或者销毁，因为它们在底层是被静态定义好的。同理，我们自定义的类，虽然可以被回收，但是探讨它的引用计数也是没有价值的。我们以内置类型对象int为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># del关键字只能作用于变量, 不可以作用于对象</span></span><br><span class="line"><span class="comment"># 比如：pi = 3.14, 你可以del pi, 但是不可以del 3.14, 这是不符合语法规则的</span></span><br><span class="line"><span class="comment"># 而int虽然我们说它是整型的类型对象, 但这是从Python的层面</span></span><br><span class="line"><span class="comment"># 如果从底层来讲, int它也是一个变量, 指向了对应的数据结构(PyLong_Type)</span></span><br><span class="line"><span class="comment"># 既然是变量, 那么就可以删除, 但是这个删除并不是直接删除对象，而是将变量指向的对象的引用计数减去1，然后将这个变量也给删掉。</span></span><br><span class="line"><span class="comment"># Python中的对象是否被删除是通过其引用计数是否为0决定的, &quot;del 变量&quot;只是删除了这个变量，让这个变量不再指向该对象罢了</span></span><br><span class="line"><span class="comment"># 所以&quot;del 变量&quot;得到的结果就是我们没办法再使用这个变量了，这个变量就没了，但是变量之前指向的对象是不是也没了就看还有没有其它的引用也指向它。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;int&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 神奇的事情发生了, 告诉我们int这个变量没有被定义</span></span><br><span class="line"><span class="comment"># 原因就在于del关键字不会删除内置作用域里面的变量</span></span><br><span class="line"><span class="comment"># 我们看一下int的引用计数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(<span class="built_in">int</span>))  <span class="comment"># 138</span></span><br></pre></td></tr></table></figure>

<p><strong>惊了，居然有130多个变量在指向int，这130多个变量分别都是谁我们就无需关注了，找出这130多个变量显然是一件很恐怖的事情。</strong></p>
<blockquote>
<p><strong>总之，我们探讨类型对象的引用计数是没有太大意义的，而且内置类型对象是超越了引用计数的规则的，所以我们没必要太关注，我们重心是在实例对象上。我们真正的操作也都是依赖实例对象进行操作的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span>  <span class="comment"># 创建一个新对象，显然此时的引用计数为1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 估计有人好奇了，为啥引用计数是2, 难道不是1吗？因为e这个变量作为参数传到了sys.getrefcount这个函数里面</span></span><br><span class="line">   <span class="comment"># 所以函数里面的参数也指向2.71这个PyFloatObject，所以引用计数加1。当函数结束后，局部变量被销毁，再将引用计数减1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e1 = e  <span class="comment"># 变量间的传递会传递指针，所以e1也会指向2.71这个浮点数，因此它的引用计数加1。</span></span><br><span class="line">		   <span class="comment"># 注意：我们说变量只是个符号，引用计数是针对变量指向的对象而言的，变量本身没有所谓的引用计数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  <span class="comment"># 此时变量指向的对象的引用计数为3(sys.getrefcount函数参数对&quot;对象&quot;的引用也算在内)</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e1)  <span class="comment"># 我们说操作变量相当于操作变量指向的对象,e和e1都指向同一个对象，所以获取也是同一个对象的引用计数</span></span><br><span class="line"><span class="number">3</span>  <span class="comment"># 因此结果是一样的,都是3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [e, e1]  <span class="comment"># 放在容器里面，显然列表l中多了两个指针，这两个指针也指向这里的PyFloatObject对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">5</span>  <span class="comment"># 因此结果为5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l  <span class="comment"># 将列表删除、或者将列表清空，那么里面的变量也就没了，因此在删除变量的时候，会先将变量指向的对象的引用计数减去1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">3</span>  <span class="comment"># 所以又变成了3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e1  <span class="comment"># 再删除一个变量，引用计数再减1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 结果为2，说明外部还有一个变量在引用它，因为这个浮点数不会被回收。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e  <span class="comment"># 再次del，此时引用计数为0，这个浮点数就真的没了。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>另外，引用计数什么时候会加1，什么时候会减1，我们在上一篇博客中也说的很详细了，可以去看一下。</strong></p>
<p>​        <strong>关于引用计数，Python底层也提供了几个宏。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_NewReference(op) (                          \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span></span><br><span class="line"><span class="meta">    Py_REFCNT(op) = 1)<span class="comment">//对于新创建的对象，引用计数为1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">//引用计数为0时执行析构函数, Py_TYPE(op)-&gt;tp_dealloc获取析构函数对应的函数指针，再通过*获取指向的函数</span></span><br><span class="line"><span class="comment">//将传入PyObject *指针，将其回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++) <span class="comment">//引用计数自增1</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                             \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">            <span class="comment">//引用计数减1，如果减完1变成了0，则执行析构函数</span></span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//注意：Py_INCREF和Py_DECREF不可以处理NULL指针的，会报错</span></span><br><span class="line"><span class="comment">//所以又有两个宏，做了一层检测，会判断对象指针为NULL的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XINCREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xincref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xincref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_INCREF(_py_xincref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XDECREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xdecref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xdecref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_DECREF(_py_xdecref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然减少引用计数，除了Py_DECREF和Py_XDECREF之外，还有一个Py_CLEAR，也可以处理空指针的情况</span></span><br></pre></td></tr></table></figure>

<p><strong>因此这几个宏作用如下：</strong></p>
<ul>
<li><code>_Py_NewReference:  接收一个对象，将其引用计数设置为1，用于新创建的对象。此外我们在定义里面还看到了一个宏Py_REFCNT，这是用来获取对象引用计数的，当然除了Py_REFCNT之外，我们之前还见到了一个宏叫Py_TYPE，这是专门获取对象的类型的。</code></li>
<li><code>_Py_Dealloc: 接收一个对象, 执行该对象的类型对象里面的析构函数, 来对该对象进行回收。</code></li>
<li><code>Py_INCREF: 接收一个对象, 将该对象引用计数自增1。</code></li>
<li><code>Py_DECREF: 接收一个对象, 将该对象引用计数自减1。</code></li>
<li><code>Py_XINCREF: 和Py_INCREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_XDECREF: 和Py_DECREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_CLEAR: 和Py_XDECREF类似，也可以处理空指针。</code></li>
</ul>
<p>​        在一个对象的引用计数为0时，与该对象对应的析构函数就会被调用，但是要特别注意的是，我们刚才一致调用析构函数，会回收对象、销毁对象或者删除对象等等，意思都是将这个对象从内存中抹去，但是这并不意味着最终一定调用free释放空间，<strong>换句话说就是对象没了，但是对象占用的内存却有可能还在。</strong>如果对象没了，占用的内存也要释放的话，那么频繁申请、释放内存空间会使Python的执行效率大打折扣(更何况Python已经背负了人们对其执行效率的不满这么多年)。一般来说，Python中大量采用了<strong>内存对象池</strong>的技术，使用这种技术可以避免频繁地申请和释放内存空间。因此在析构的时候，只是将对象占用的空间归还到内存池中。Python在操作系统之上提供了一个内存池，说白了就是对malloc进行了一层封装，事先申请一部分内存，然后用于对象(占用内存低)的创建，这样就不必频繁地向操作系统请求空间了，从而大大的节省时间。<strong>这一点，在后面的Python内置类型对象(PyLongObject，PyListObject等等)的实现中，将会看得一清二楚。</strong>当然内存比较大的对象，还是需要向操作系统申请的，内存池只是用于那些内存占用比较小的对象的创建，因为这种对象显然没必要每次都和操作系统内核打交道。关于内存池，我们在后续系列中也会详细说。     </p>
<h3 id="python对象的分类"><a href="#python对象的分类" class="headerlink" title="python对象的分类"></a>python对象的分类</h3><p><strong>我们之前根据支持的操作，将Python对象分成了数值型、序列型、映射型，但其实我们是可以分为5类的：</strong></p>
<ul>
<li><code>Fundamental对象：类型对象，如int、float、bool</code></li>
<li><code>Numeric对象：数值对象，如int实例、float实例、bool实例</code></li>
<li><code>Sequence对象：序列对象，如str实例、list实例、tuple实例</code></li>
<li><code>Mapping对象：关联对象(映射对象)，如dict实例</code></li>
<li><code>Internal对象：python虚拟机在运行时内部使用的对象，如function实例(函数)、code实例(字节码)、frame实例(栈帧)、module实例(模块)、method实例(方法)，没错，函数、字节码、栈帧、模块、方法等等它们在底层一个一个类的实例对象。比如：函数的类型是&lt;class &#39;function&#39;&gt;，在底层对应PyFunctionObject，那么&lt;class  &#39;function&#39;&gt;的类型对象是什么呢？显然就是&lt;class &#39;type&#39;&gt;啦。</code></li>
</ul>
<p><strong>关于Internal对象，我们在后续系列中会细说。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一次我们说了Python中创建对象的两种方式，可以通过Python&#x2F;C  API创建，也可以通过类型对象创建。以及分析了对象的多态性，Python底层是如何通过C来实现多态，答案是通过ob_type。还说了对象的行为，对象进行某个操作的时候在底层发生了什么。最后说了引用计数，Python是通过引用计数来决定一个对象是否被回收的，但是有人知道它无法解决循环引用的问题。是的，所以Python中的gc就是为了解决这一点的，不过这也要等到介绍垃圾回收的时候再细说了。</p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Python整数的底层实现</title>
    <url>/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="05-Python整数的底层实现"><a href="#05-Python整数的底层实现" class="headerlink" title="05-Python整数的底层实现"></a>05-Python整数的底层实现</h2><p>这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？</p>
<p>既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。</p>
<h3 id="int实例对象的底层实现"><a href="#int实例对象的底层实现" class="headerlink" title="int实例对象的底层实现"></a>int实例对象的底层实现</h3><p><strong>Python中的整数底层对应的结构体是PyLongObject，它位于longobject.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合起来可以看成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125; PyLongObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把这个PyLongObject更细致的展开一下就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">//维护的元素个数</span></span><br><span class="line">    digit ob_digit[<span class="number">1</span>]; <span class="comment">//digit类型的数组,长度为1</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>别的先不说，就冲里面的ob_size我们就可以思考一番。首先Python中的整数有大小、但应该没有长度的概念吧，那为什么会有一个ob_size呢？从结构体成员来看，这个ob_size指的应该就是ob_digit数组的长度，而这个ob_digit数组显然只能是用来维护具体的值了。而数组的长度不同，那么对应的整数占用的内存也不同。所以答案出来了，整数虽然没有我们生活中的那种长度的概念，但它是个变长对象，因为不同的整数占用的内存可能是不一样的。</strong></p>
<p><strong>因此这个ob_size它指的是底层数组的长度，因为Python中整数对应的值在底层是使用数组来存储的。尽管它没有字符串、列表那种长度的概念，或者说无法对整型使用len方法，但它是个变长对象。</strong></p>
<p>​        <strong>那么下面的重点就在这个ob_digit数组了，我们要从它的身上挖掘信息，看看Python中整数对应的值(比如123)，是怎么放在这个数组里面的。不过首先我们要看看这个digit是个什么类型，它同样定义在longintrepr.h中</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PYLONG_BITS_IN_DIGIT是一个宏，如果你的机器是64位的，那么它会被定义为30，32位机器则会被定义为15</span></span><br><span class="line"><span class="comment">//至于这个宏是做什么的我们先不管</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而我们的机器现在基本上都是64位的，所以PYLONG_BITS_IN_DIGIT会等于30，因为digit等价于uint32_t<code>(unsigned int)</code>，所以它是一个无符号32位整型。</strong></p>
<p><strong>所以ob_digit这个数组是一个无符号32位整型数组，长度为1。当然这个数组具体多长则取决于你要存储的Python整数有多大，因为C中数组的长度不属于类型信息，你可以看成是长度n，而这个n是多少要取决于你的整数大小。显然整数越大，这个数组就越长，那么占用空间就越大。</strong></p>
<p>​        <strong>搞清楚了PyLongObject里面的所有成员，那么下面我们就来分析ob_digit是怎么存储Python中的整数，以及Python中的整数为什么不会溢出。</strong>    </p>
<p>​        <strong>不过说实话，关于Python的整数不会溢出这个问题，其实相信很多人已经有答案了，因为底层是使用数组存储的嘛，而数组的长度又没有限制，所以当然不会溢出啦。</strong>    </p>
<p>​        <strong>另外，还存在一个问题，那就是digit是一个无符号32位整型，那负数怎么存储？别着急，我们会举栗说明，将上面的疑问一一解答。</strong>    </p>
<p><strong>首先如果你是Python的设计者，要保证整数不会溢出，你会怎么办？我们把问题简化一下，假设有一个8位的无符号整数类型，我们知道它能表示的最大数字是255，但这时候如果我想表示256，要怎么办？</strong></p>
<p><strong>可能有人会想，那用两个数来存储不就好了。一个存储255，一个存储1，将这两个数放在数组里面。这个答案的话，虽然有些接近，但其实还有很大偏差：那就是我们并不能简单地按照大小拆分的，256拆分为255和1，要是265就拆分成255和10，而是要通过二进制的方式，我们来简单看一下。</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">我们知道<span class="number">8</span>位整数最大就是 <span class="number">2</span> ^ <span class="number">8</span> <span class="selector-tag">-</span> <span class="number">1</span>,也就是它的八位全部都是<span class="number">1</span>,结果是<span class="number">255</span></span><br><span class="line">所以<span class="number">255</span>对应的数组就是: <span class="selector-attr">[255]</span>, 因为此时一个<span class="number">8</span>位整数就能存下</span><br><span class="line"></span><br><span class="line">但如果是<span class="number">256</span>,那么<span class="number">8</span>位显然存不下了,此时就还需要一个位</span><br><span class="line">所以这个时候会使用两个<span class="number">8</span>位整数, 但并不是简单的相加, 而是使用一个新的<span class="number">8</span>位整数来模拟更高的位</span><br></pre></td></tr></table></figure>

<p>​        <strong>而Python底层也是类似这种做法，但是考虑的会更加全面。下面就以Python中的整数为例，看看底层数组的存储方式。</strong>    </p>
<p><strong>整数0：</strong></p>
<p><strong>注意：当要表示的整数为0时，ob_digit这个数组为空，不存储任何值，ob_size为0，表示这个整数的值为0，这是一种特殊情况。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002206919-1398161118.png" alt="img"></p>
<p><strong>整数1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002212476-1473281999.png" alt="img"></p>
<p><strong>当然存储的值为1时，ob_size的值就是1，此时ob_digit数组就是[1]。</strong></p>
<p><strong>整数-1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002220242-1580767637.png" alt="img"></p>
<p><strong>我们看到ob_digit数组没有变化，但是ob_size变成了-1，没错，整数的正负号是通过这里的ob_size决定的。ob_digit存储的其实是绝对值，无论n取多少，<code>-n</code>和<code>n</code>对应的ob_digit是完全一致的，但是ob_size则互为相反数。所以ob_size除了表示数组的长度之外，还可以表示对应整数的正负。</strong></p>
<p><strong>所以我们之前说整数越大，底层的数组就越长。更准确的说是绝对值越大，底层数组就越长。所以Python在比较两个整型的大小时，会先比较ob_size，如果ob_size不一样则可以直接比较出大小来。显然ob_size越大，对应的整数越大，不管ob_size是正是负，都符合这个结论，可以想一下。</strong></p>
<p><strong>整数2 ^ 30 -1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002228080-1963789840.png" alt="img"></p>
<p><strong>如果想表示2 ^30 - 1<code>(^这里代指幂运算,当然对于Python程序猿来说两个星号也是幂运算,表达的意义是一样的)</code>，那么也可以使用一个digit表示。虽然如此，但为什么突然举2 ^ 30 - 1这个数字呢？答案是，虽然digit是4字节、32位，但是Python只用30个位。</strong></p>
<blockquote>
<p><strong>之所以这么做是和加法进位有关系，如果32个位全部用来存储其绝对值，那么相加产生进位的时候，可能会溢出，比如有一个将32个位全部占满的整数<code>(2 ^ 32 - 1)</code>，即便它只加上1，也会溢出。这个时候为了解决这个问题，就需要先强制转换为64位再进行运算。</strong></p>
<p><strong>但如果只用30个位的话，那么加法是不会溢出的，或者说相加之后依旧可以用32位整数保存。因为30个位最大就是2 ^ 30 - 1，即便两个这样的值相加，结果也是(2 ^ 30 - 1) * 2，即：2 ^ 31 - 2。而32个位的话最大是2 ^ 32 - 1，所以肯定不会溢出的；如果一开始30个位就存不下，那么数组中会有两个digit。</strong></p>
</blockquote>
<p><strong>所以虽然将32位全部用完，可以只用一个digit表示更多、更大的整数，但是可能面临相加之后一个digit存不下的情况，于是只用30个位，如果数值大到30个位存不下的话，那么就会多使用一个digit。可能有人发现了，如果是用31个位的话，那么相加产生的最大值就是2 ^ 32 - 2，结果依旧可以使用一个32位整型存储啊，那Python为啥要牺牲两个位呢？答案是为了乘法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还记得这个宏吗？PYLONG_BITS_IN_DIGIT指的就是Python使用digit的位数</span></span><br><span class="line"><span class="comment">// 我们看到在32位机器上，digit相当于2字节、16位的整型，而它用了15位，只牺牲了一个位</span></span><br><span class="line"><span class="comment">// 64 位机器上则牺牲两个位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>整数2 ^ 30：</strong></p>
<p><strong>问题来了，我们说digit只用30位，所以2 ^ 30 - 1是一个digit能存储的最大值，那么现在是2 ^ 30，所以数组中就要有两个digit了。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002236296-672861305.png" alt="img"></p>
<p><em><em>我们看到此时就用两个digit来存储了，此时的数组里面的元素就是0和1，而且充当高位的放在后面，因为我们说了使用新的digit来模拟更高的位。由于一个digit只用30位，那么数组中第一个digit的最低位就是1，第二个digit的最低位就是31，第三个digit的最低位就是61，以此类推，所以如果ob_digit为[a, b, c]，那么对应的整数就为: a * 2 *</em> 0 + b * 2 *</em> 30 + c  * 2 ** 60，如果ob_digit不止3个，那么就按照30个位往上加，比如ob_digit还有第四个元素d，那么就再加上d * 2  ** 90即可。**</p>
<p><strong>再比如我们反推一下，如果a &#x3D; 88888888888，那么底层数组ob_digit中的值是多少？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="number">88888888888</span></span><br><span class="line"><span class="comment"># 我们说1个digit用30个位, 那么n个digit所能表示的最大整数就是2 ** (30 * n) - 1, 至于原因的话其实很好理解，但我们还是可以严格推导一下</span></span><br><span class="line"><span class="comment"># 我们以n = 2为例, 显然两个digit最高能表示 (2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30,</span></span><br><span class="line"><span class="comment"># 它等于 (2 ** 30 - 1) + (2 ** 60 - 2 ** 30) = 2 ** 60 - 1, 因此两个digit最大可以表示 2 ** 60 - 1</span></span><br><span class="line"><span class="comment"># 同理你可以n取3, 看看(2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30 + (2 ** 30 - 1) * 2 ** 60是不是等于2 ** 90 - 1</span></span><br><span class="line"><span class="comment"># 或者试试更大的数, 结论都是成立的</span></span><br><span class="line"><span class="built_in">print</span>(np.log2(a))  <span class="comment"># 36.37128404230425</span></span><br><span class="line"><span class="comment"># 36超过了30个位、但小于90个位, 因此需要两个digit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说 &quot;整数 = ob_digit[0] + ob_digit[1] * 2 ** 30 + ob_digit[2] * 2 ** 60 + ...&quot;</span></span><br><span class="line"><span class="comment"># 但是对于ob_digit长度为2的情况下, 这里的a = ob_digit[0] + ob_digit[1] * 2 ** 30</span></span><br><span class="line"><span class="built_in">print</span>(a // <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 82</span></span><br><span class="line"><span class="built_in">print</span>(a - <span class="number">82</span> * <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 842059320</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明此时底层对应的ob_digit数组就是[842059320, 82]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002245710-535862489.png" alt="img"></p>
<p><strong>我们修改解释器源代码重新编译，通过在创建整数的时候打印ob_digit里面的元素的值，也印证了这个结论。</strong></p>
<p>​        <strong>这个时候，我们可以分析整数所占的字节了。相信所有人都知道可以使用sys.getsizeof计算大小，但是这大小到底是怎么来的，估计会一头雾水。因为Python中对象的大小，是根据底层的结构体计算出来的。</strong>    </p>
<p>​        <strong>我们说ob_refcnt、ob_type、ob_size这三个是整数所必备的，它们都是8字节，加起来24字节。所以任何一个整数所占内存都至少24字节，至于具体占多少，则取决于ob_digit里面的元素都多少个。</strong>    </p>
<p>​        <strong>因此Python中整数所占内存 &#x3D; 24 + 4 * ob_digit数组长度</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是0的话, ob_digit数组为空, 所以此时就是24字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">0</span>))  <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是1的话, ob_digit数组有一个元素, 所以此时是24 + 4 = 28字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个digit只用30位, 所以最大能表示2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 如果是2 ** 30, 那么就需要两个元素, 所以是24 + 4 * 2 = 32字节</span></span><br><span class="line"><span class="comment"># 如果是两个digit, 那么能表示的最大整数就是2 ** 60 - 1</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span>))  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">60</span> - <span class="number">1</span>))  <span class="comment"># 32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">相信下面的不需要解释了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">60</span>))  <span class="comment"># 36</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof((<span class="number">1</span> &lt;&lt; <span class="number">90</span>) - <span class="number">1</span>))  <span class="comment"># 36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">90</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<h3 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h3><p><strong>由于分析过了浮点数以及浮点类型对象，因此int类型对象的实现以及int实例对象的创建啥的就不说了，可以自己去源码中查看，我们后面会着重介绍它的一些操作。还是那句话，Python中的API设计的很优美，都非常的相似，比如创建浮点数可以使用PyFloat_FromDouble、PyFloat_FromString等等，那么创建整数也可以使用PyLong_FromLong、PyLong_FromDouble、PyLong_FromString等等，直接去Objects中对应的源文件中查看即可。</strong></p>
<p><strong>这里说一下Python中的小整数对象池，我们知道Python中的整数属于不可变对象，运算之后会创建新的对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274354736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355024</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以这种做法就势必会有性能缺陷，因为程序运行时会有大量对象的创建和销毁。根据浮点数的经验，我们猜测Python应该也对整数使用了缓存池吧。答案是差不多，只不过不是缓存池，而是</strong><font color="red"><strong>小整数对象池</strong></font></p>
<p><strong>Python将那些使用频率高的整数预先创建好，而且都是单例模式，这些预先创建好的整数会放在一个静态数组里面，我们称为小整数对象池。如果需要使用的话会直接拿来用，而不用重新创建。注意：这些整数在Python解释器启动的时候，就已经创建了。</strong></p>
<p><strong>小整数对象池的实现位于longobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NSMALLPOSINTS宏规定了对象池中正数的个数 (从 0 开始，包括 0 )，默认 257 个；</code></li>
<li><code>NSMALLNEGINTS宏规定了对象池中负数的个数，默认5个；</code></li>
<li><code>small_ints是一个整数对象数组，保存预先创建好的小整数对象；</code></li>
</ul>
<p><strong>以默认配置为例，Python解释器在启动的时候就会预先创建一个可以容纳262个整数的数组，并会依次初始化 -5 到 256<code>(包括两端)</code>之间的262个PyLongObject。所以小整数对象池的结构如下：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002308727-1460169599.png" alt="img"></p>
<p><strong>但是为什么要实现缓存从-5到256之间的整数呢？因为Python认为这个范围内的整数使用频率最高，而缓存这些整数的内存相对可控。因此这只是某种权衡，很多程序的开发场景都没有固定的正确答案，需要根据实际情况来权衡利弊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140714000246400</span>, <span class="number">140714000246400</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>256位于小整数对象池内，所以全局唯一，需要使用的话直接去取即可，因此它们的地址是一样的。但是257不再小整数对象池内，所以它们的地址不一样。</strong></p>
<p><strong>我们上面是在交互式下演示的，但如果有小伙伴不是通过交互式的话，那么会得到出乎意料的结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>可能有人会好奇，为什么地址又是一样的了，257明明不在小整数对象池中啊。虽然涉及到了后面的内容，但是提前解释一下也是可以的。主要区别就在于一个是在交互式下执行的，另一个是通过 python3 xxx.py的方式执行的。</strong></p>
<blockquote>
<p><strong>首先Python的编译单元是函数，每个函数都有自己的作用域，在这个作用域中出现的所有常量都是唯一的，并且都位于常量池中，由co_consts指向。虽然我们上面的不是函数，而是在全局作用域中，但是全局你也可以看成是一个函数，它也是一个独立的编译单元。同一个编译单元中，常量只会出现一次。</strong></p>
<p><strong>当a &#x3D; 257的时候，会创建257这个整数、并放入常量池中；所以b &#x3D; 257的时候就不会再创建了，因为常量池中已经有了，所以会直接从常量池中获取，因此它们的地址是一样的，因为是同一个PyLongObject。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3.6下执行, 该系列的所有代码都是基于Python3.8, 但是这里先使用Python3.6, 至于原因, 后面会说</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140042202371968, 140042204149712)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140042202371968, 140042204255024)</span></span><br></pre></td></tr></table></figure>

<p><strong>此时f1和f2显然是两个独立的编译单元，256属于小整数对象池中的整数、全局唯一，因此即便不在同一个编译单元的常量池中，它的地址也是唯一的，因为它是预先定义好的，所以直接拿来用。但是257显然不是小整数对象池中的整数，而且不在同一个编译单元的常量池中，所以地址是不一样的。</strong></p>
<p><strong>而对于交互式环境来说，因为我们输入一行代码就会立即执行一行，所以任何一行可独立执行的代码都是一个独立的编译单元。注意：是可独立执行的代码，比如变量赋值、函数、方法调用等等；但如果是if、for、while、def等等需要多行表示的话，比如：<code>if 2 &gt; 1:</code>，显然这就不是一行可独立执行的代码，它还依赖你输入的下面的内容。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span>:  <span class="comment"># 此时按下回车，我们看到不再是&gt;&gt;&gt;, 而是..., 代表还没有结束, 还需要你下面的内容</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;2 &gt; 1&quot;</span>)</span><br><span class="line"><span class="meta">... </span> <span class="comment"># 此时这个if语句整体才是一个独立的编译单元</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是像a &#x3D; 1、foo()、lst.appned(123)这些显然它们是一行可独立执行的代码，因此在交互式中它们是独立的编译单元。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>  <span class="comment"># 此时这行代码已经执行了，它是一个独立的编译单元</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span>  <span class="comment"># 这行代码也是独立的编译单元，所以它里面的常量池为空，因此要重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)  <span class="comment"># 由于它们是不同常量池内的整数，所以id是不一样的。</span></span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，看看下面的代码，a和b的地址为啥又一样了呢？666和777明显也不在常量池中啊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span>;b=<span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354896</span>, <span class="number">2431274354896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">777</span>, <span class="number">777</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354800</span>, <span class="number">2431274354800</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>显然此时应该已经猜到原因了，因为上面两种方式无论哪一种，都是在同一行，因此整体会作为一个编译单元，所以地址是一样的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在Python3.8中，如果是通过 python xxx.py的方式执行的话，即便是大整数、并且不再同一个编译单元的常量池中，它们的地址也是一样的，说明Python在3.8版本的时候做了优化。</strong></p>
<blockquote>
<p><strong>另外，如果没有特殊说明，那么我们这个系列的所有代码都是在Python3.8下执行的。说实话，我就是因为发现在Python3.8中，打印的地址都是一样的，才在上面试了一下Python3.6。但是Python3.8中具体是怎么优化的，这里就暂时不讨论了<code>(明明是你没有仔细研究)</code>。</strong></p>
</blockquote>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p><strong>整数溢出是程序开发中一大难题，由此引发的 BUG  不计其数，而且相当隐蔽。之前使用golang刷LeetCode的时候，怎么也通不过，最后发现是因为LeetCode后台有一个测试用例比较特殊，导致整数太大，golang中的int64存不下。而Python 选择从语言层面彻底解决这个痛点，殚心竭虑地设计了整数对象。而我们也探索了整数对象，并初步掌握了整数对象的内部结构。</strong></p>
<p><strong>Python中的整数是串联了多个C中的digit<code>(uint32_t)</code>，通过一个C数组的形式来实现整数的表示。这么做的好处就是Python中的整数没有长度限制了，因此不会溢出<code>(而浮点数使用C的double，所以它会溢出)</code>。之所以不会溢出，是因为数组是没有长度限制的，所以只要你的内存足够，就可以算任意大的数。所以Python表示：存不下？会溢出？这都不是事儿，直接继续往数组里面塞digit就ok了。</strong></p>
<blockquote>
<p><strong>这里再重温一下PyLongObject的数据结构，我们说它是一个变长对象。ob_size指的是数组的长度，并且它除了表示长度还能体现出整数的正负，而ob_digit这个数组只用来存储其绝对值。</strong></p>
<p><strong>但是说实话，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<p><strong>所以我们在分析浮点数的时候，一直说整数要比浮点数复杂，原因就在于此。浮点数相加的话直接两个double相加即可，但是整数相加可就没有那么简单了。</strong></p>
</blockquote>
<p><strong>整数支持的操作定义在什么地方相信不用我说了，直接去longobject.c中查看就可以了，根据浮点数的经验我们知道PyLong_Type中的tp_as_number成员也指向了PyNumberMethods结构体实例，里面的成员都是指向与整型运算相关的函数的指针。</strong></p>
<p><strong>注意：图中有一个箭头画错了，应该是 ob_type 指向 PyLong_Type，但图中不小心变成了 ob_size。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002525586-1003237779.png" alt="img"></p>
<h4 id="整数的大小比较"><a href="#整数的大小比较" class="headerlink" title="整数的大小比较"></a>整数的大小比较</h4><p><strong>先来看看Python中的整数在底层是如何比较的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">long_compare</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//sign是一个8字节的long, 用来表示a和b之间的比较结果</span></span><br><span class="line">    <span class="comment">//如果a == b, 那么sign = 0; 如果a &gt; b, 那么sign &gt; 0; 如果a &lt; b, 那么sign &lt; 0</span></span><br><span class="line">    Py_ssize_t sign;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Py_SIZE是一个宏:获取对象的ob_size,除此之外我们之前还见到了Py_REFCNT和Py_TYPE, 用来获取对象的引用计数和类型指针</span></span><br><span class="line">    <span class="comment">//如果两个整数的ob_size不一样, 我们说a和b一定不相等, 所以可以直接比较出大小</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) != Py_SIZE(b)) &#123;</span><br><span class="line">        <span class="comment">//如果一正一负, 那么肯定正的大, 因为ob_size还体现整数的正负, 所以正的ob_size对应的整数也会更大</span></span><br><span class="line">        <span class="comment">//如果都为正, 那么ob_size越大, 对应数组元素就越多, 显然整数就越大</span></span><br><span class="line">        <span class="comment">//如果都为负, 那么ob_size越大, 其绝对值就越小, 因为越接近0,所以对应的整数的绝对值也越小</span></span><br><span class="line">          <span class="comment">//但因为是负数,所以乘上-1之后,所以整数值反而会越大。比如: 1 &lt; 100, 但是乘上-1之后, 小于号就要变成大于号</span></span><br><span class="line">        <span class="comment">//因此无论是哪种情况，如果两个整数的ob_size不一样，是可以直接比较出大小的。</span></span><br><span class="line">        sign = Py_SIZE(a) - Py_SIZE(b);</span><br><span class="line">        <span class="comment">//所以sign &gt; 0的话a &gt; b, sign &lt; 0的话a &lt; b, 因为ob_size不一样, 所以sign不可能等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果相等, 那么说明a和b的符号相同, 数组中使用的digit也是一样的</span></span><br><span class="line">        <span class="comment">//那么接下来就只能挨个比较数组中的digit了</span></span><br><span class="line">        <span class="comment">//这里是获取数组的长度, 赋值给变量i</span></span><br><span class="line">        Py_ssize_t i = Py_ABS(Py_SIZE(a));</span><br><span class="line">        <span class="comment">//我们之前说，一个digit存不下，那么会使用两个digit, 以此类推</span></span><br><span class="line">        <span class="comment">//并且代表整数高位的digit会放在后面, 而比较两个数的大小显然是从高位开始比</span></span><br><span class="line">        <span class="comment">//因此遍历数组是从后往前遍历的, 先比较a -&gt; ob_digit[n]和 b -&gt; ob_digit[n]</span></span><br><span class="line">        <span class="comment">//如果一样就比较a -&gt; ob_digit[n-1]和a -&gt; ob_digit[n-1],直到将数组的元素全部比完,显然只要有一个不一样,就可以直接决定绝对值的大小</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            <span class="comment">//进行while循环, i是数组的长度, 因此数组的最大索引是i - 1, 所以这里的--i会先将i自减1,再判断自减1之后的i是否&gt;=0</span></span><br><span class="line">            <span class="comment">//然后比较a-&gt;ob_digit[i]和b-&gt;ob_digit[i], 如果数组内元素全部一样, 那么循环结束之后i肯定是-1,只要有一个不一样, 那么i一定&gt;=0</span></span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以如果i &lt; 0,说明两个整数的数组全部一样, 因此两个整数是一样的</span></span><br><span class="line">            <span class="comment">//所以sign = 0</span></span><br><span class="line">            sign = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话, 说明数组中索引为i的元素不一样, 那么直接相减就可以了</span></span><br><span class="line">            <span class="comment">//如果sign大于0, 显然a对应的绝对值比大, 否则a对应的绝对值比b小</span></span><br><span class="line">            sign = (sdigit)a-&gt;ob_digit[i] - (sdigit)b-&gt;ob_digit[i];</span><br><span class="line">            <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//但是我们说计算的是绝对值，如果ob_size小于0，绝对值越大其值反而越小，那么sign还要乘上-1</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因此最终: a &gt; b则sign &gt; 0, a &lt; b则sign &lt; 0, a == b则sign == 0</span></span><br><span class="line">    <span class="comment">//然后这里是一个嵌套的三元表达式, sign大于0则直接返回1表示a &gt; b, 小于0返回-1表示a &lt; b, 等于0则返回0表示a == b</span></span><br><span class="line">    <span class="keyword">return</span> sign &lt; <span class="number">0</span> ? <span class="number">-1</span> : sign &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到Python中的整数就是按照上面这种方式比较的，总的来说就是先比较ob_size，ob_size不一样则可以直接比较。如果ob_size一样的话，那么会从后往前挨个比较数组中的元素，最终确定大小关系。</strong></p>
<h4 id="整数的相加"><a href="#整数的相加" class="headerlink" title="整数的相加"></a>整数的相加</h4><p><strong>再来看看Python中的整数在底层是如何相加的，加法的实现显然是long_add，我们看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//a和b是两个PyLongObject *</span></span><br><span class="line">    <span class="comment">//z显然是指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//CHECK_BINOP是一个宏, 接收两个指针, 检测它们是不是都指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断a和b的ob_size的绝对值是不是都小于等于1, 如果是的话, 那么说明数组中最多只有一个元素</span></span><br><span class="line">    <span class="comment">//数组没有元素,说明整数是0;有一个元素,那么直接取出来、再判断正负号即可,然后直接相加。</span></span><br><span class="line">    <span class="comment">//所以显然这里走的是快分支,因为绝对值超过2 ** 30 - 1的整数还是比较少的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//MEDIUM_VALUE是一个宏, 接收一个abs(ob_size) &lt;= 1的PyLongObject的指针</span></span><br><span class="line">        <span class="comment">//如果ob_size是0, 那么结果为0; 如果ob_size绝对值为1, 那么结果为 ob_digit[0] 或者 -ob_digit[0]</span></span><br><span class="line">        <span class="comment">//所以直接将MEDIUM_VALUE(a) + MEDIUM_VALUE(b)之后的结果转成PyLongObject,然后返回其指针即可</span></span><br><span class="line">        <span class="comment">//因此如果数组中元素不超过1个的话, 那么显然是可以直接相加的</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里, 说明至少有一方的ob_size大于1</span></span><br><span class="line">    <span class="comment">//如果a &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果a &lt; 0并且b &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明两者符号相同, 那么通过x_add直接将两个整数相加即可</span></span><br><span class="line">            <span class="comment">//这个x_add专门用于整数的绝对值相加,并且会返回PyLongObject *,它的实现我们后面会说</span></span><br><span class="line">            <span class="comment">//所以z指向的PyLongObject的内部成员是已经设置好了的</span></span><br><span class="line">            <span class="comment">//只不过x_add加的是两者的绝对值, z指向的PyLongObject内部ob_type的符号我们还需要再度判断一下</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//因为a和b指向的整数都是负数, 所以将相加之后还要将ob_size乘上-1</span></span><br><span class="line">                Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//走到这里说明a &lt; 0并且b &gt; 0, 那么直接让b - a即可, 此时得到的结果一定是正</span></span><br><span class="line">            <span class="comment">//因此不需要考虑ob_size的符号问题</span></span><br><span class="line">            z = x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明a &gt; 0并且b &lt; 0, 所以让a - b即可</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两个整数均为正, 直接相加</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回z的指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以long_add这个函数并不长，但是调用了辅助函数x_add和x_sub，显然核心逻辑是在这两个函数里面。至于long_add函数，它的逻辑如下：</strong></p>
<ul>
<li><code>1. 定义一个变量z, 用于保存计算结果;</code></li>
<li><code>2. 判断两个整数底层对应的数组是不是都不超过1, 如果是的话那么通过宏MEDIUM_VALUE直接将其转成C中的一个digit, 然后直接相加、返回即可。显然这里走的是快分支,或者快速通道;</code></li>
<li><code>3. 但如果有一方ob_size绝对值不小于1, 那么判断两者的符号。如果都为负,那么通过x_add计算两者绝对值之和、再将ob_size乘上-1即可;</code></li>
<li><code>4. 如果a的ob_size小于0, b的ob_size大于0, 那么通过x_sub计算b和a绝对值之差即可;</code></li>
<li><code>5. 如果a的ob_size大于0, b的ob_size小于0, 那么通过x_sub计算a和b绝对值之差即可;</code></li>
<li><code>6. 如果a的ob_size大于0, b的ob_size大于0, 那么通过x_add计算让b和a绝对值之和即可;</code></li>
</ul>
<p><strong>所以Python中整数的设计非常的巧妙，ob_digit虽然是用来维护具体数值，但是它并没有考虑正负，而是通过ob_size来表示整数的正负号。这样运算的时候，计算的都是整数的绝对值，因此实现起来会方便很多。将绝对值计算出来之后，再通过ob_size来判断正负号。</strong></p>
<p><strong>因此long_add将整数加法转成了 “绝对值加法(x_add)”和”绝对值减法(x_sub)”：</strong></p>
<ul>
<li><code>x_add(a, b), 计算两者的绝对值之和, 即:|a| + |b|;</code></li>
<li><code>x_sub(a, b), 计算两者的绝对值之差, 即:|a| - |b|;</code></li>
</ul>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002538412-969820254.png" alt="img"></p>
<p><strong>由于绝对值加、减法不用考虑符号对计算结果的影响，实现更为简单，这是Python将整数运算转化成绝对值运算的缘由。虽然我们还没看到x_add和x_sub是如何对整数的绝对值进行相加和相减运算的，但也能从中体会到程序设计中逻辑的 划分 与 组合 的艺术，优秀的代码真的很美。</strong></p>
<blockquote>
<p><strong>那么下面我们的重心就在x_add和x_sub中了，看看它们是如何对大整数绝对值进行运算的。但是你可能会有疑问，大整数运算肯定很复杂，效率会差吧。显然这是必然的，整数数值越大，整数对象底层数组越长，运算开销也就越大。好在运算处理函数均以快速通道对小整数运算进行优化，将额外开销降到最低。</strong></p>
<p><strong>比如上面的long_add，如果a和b对应的整数的绝对值都小于等于2 ^  30 - 1，那么会直接转成C中的整型进行运算，性能损耗极小。并且走快速通道的整数的范围是：-(2 ^ 30 - 1) ~ 2 ^ 30 -  1，即：-1073741823 ~ 1073741823，显然它可以满足我们绝大部分的运算场景。</strong></p>
</blockquote>
<p>​        <strong>绝对值加法x_add：</strong>    </p>
<p><strong>在介绍绝对值加法之前，先来看看几个宏，先不管它们是干什么的，会在x_add中有体现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_SHIFT    30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_MASK     ((digit)(PyLong_BASE - 1))</span></span><br><span class="line"><span class="comment">//所以PyLong_MASK等于(1 &lt;&lt; 30) - 1, 就等于2 ** 30 - 1, 说明32个位, 前两个位为0, 后面三十个位则都是1</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，再想象一下我们平时算加法的时候是怎么算的：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002550125-674752602.png" alt="img"></p>
<p><strong>而x_add在逻辑和上面是类似的，下面分析x_add的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然a和b指向了两个要想加的整数对象</span></span><br><span class="line">    <span class="comment">//这里获取a和b的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//根据a和b的相加结果所创建的新的PyLongObject的指针</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//重点也是最难理解的地方: carry用于每个部分的运算结果(可不是大神带你carry哦)</span></span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size_a小于size_b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么将a和b进行交换, 以及size_a和size_b也进行交换, 为什么这么做呢?因为方便</span></span><br><span class="line">        <span class="comment">//我们小时候计算两个整数相加时候, 如果一个位数多,一个位数少, 也会习惯将位数多的放在左边</span></span><br><span class="line">        <span class="comment">//最终从右往左, 也就是从低位往高位逐个相加, 大于10则进1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//如果size_a和size_b相等, 或者size_a大于size_b, 那么该if就无需执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是创建一个ob_size为size_a + 1的PyLongObject, 然后返回其指针</span></span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//但为什么是size_a + 1呢?</span></span><br><span class="line">    <span class="comment">//因为此时size_a 一定不小于 size_b, 那么a和b相加之后的z的ob_size一定不小于size_a</span></span><br><span class="line">    <span class="comment">//但是也可以也可能比size_a多1, 比如: a = 2 ** 60 - 1, b = 1</span></span><br><span class="line">    <span class="comment">//所以相加之后结果为2 ** 60次方, 所以ob_size就变成了3, 因此在创建z的时候，ob_digit的容量会等于size_a + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正常情况下, z是一个PyLongObject *, 但如果z == NULL, 表示分配失败(解释器也会异常退出)</span></span><br><span class="line">    <span class="comment">//但说实话, 除非你内存不够了, 否则这种情况不会发生</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, 如果a和b的ob_size不一样, 那么size_a会大于size_b</span></span><br><span class="line">    <span class="comment">//所以显然是先以size_b为准, 两者从低位向高位依次对应相加; 当b到头了, 再单独算a的剩余部分;</span></span><br><span class="line">    <span class="comment">//假设size_a == 4, size_b == 2, 对应到ob_digit的话</span></span><br><span class="line">    <span class="comment">//就是a -&gt; ob_digit[0] + b -&gt; ob_digit[0], 作为z -&gt; ob_digit[0], 当然还需要考虑进位, 下面说</span></span><br><span class="line">    <span class="comment">//然后a -&gt; ob_digit[1] + b -&gt; ob_digit[1], 作为z -&gt; ob_digit[1], 此时b到头了</span></span><br><span class="line">    <span class="comment">//继续a -&gt; ob_digit[2]作为z -&gt; ob_digit[2], a -&gt; ob_digit[3]作为z -&gt; ob_digit[3]</span></span><br><span class="line">    <span class="comment">//此时a和b相加就结束了, 如果不考虑相加进位的话, 那么整体流程就是这个样子。然后我们继续往下看</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从索引为0开始遍历, 以i &lt; size_b为条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]作为carry, 显然carry如果没有超过2 ** 30 - 1的话</span></span><br><span class="line">        <span class="comment">//显然它就是z -&gt; ob_digit[i]</span></span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//但是carry是可能溢出的, 所以z -&gt; ob_digit[i] = carry &amp; PyLong_MASK</span></span><br><span class="line">        <span class="comment">//这个PyLong_MASK就是我们在介绍x_add之前先介绍的几个宏之一, 它表示的是2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//我们说它的前两个位为0, 后面三十个位全是1, 因此对于后面三十个位来说, 在和carry进行&quot;与运算&quot;之后,对应的位还和carry保持一致</span></span><br><span class="line">        <span class="comment">//所以在carry小于等于2 ** 30 - 1的时候carry &amp; PyLong_MASK就等于carry</span></span><br><span class="line">        <span class="comment">//但如果carry大于2 ** 30 - 1, 由于PyLong_MASK的前两位为0, 所以这一步可以确保carry不会超过2 ** 30 - 1</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//但是carry的前两位显然不可以丢, 所以它们要作用在数组中下一个元素相加的结果上</span></span><br><span class="line">        <span class="comment">//比如a -&gt; ob_digit[0] + b -&gt; ob_digit[0]得到结果正好是2 ** 32 - 1, 那么carry的前两位也是1</span></span><br><span class="line">        <span class="comment">//而数组中下一元素相加之后, 其结果对应的位要比本次循环高出30</span></span><br><span class="line">        <span class="comment">//所以这里将carry右移30位, 然后作用到下一次循环中</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果当b到头了, 那么继续从当前的i开始, 直到i == size_a, 逻辑还是和上面一样的</span></span><br><span class="line">        <span class="comment">//只不过将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]换成了a-&gt;ob_digit[i], 因为b到头了</span></span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//这里也要&quot;与上&quot;PyLong_MASK, 因为也可能存在进位的情况, 拿生活中的99999 + 1为例</span></span><br><span class="line">        <span class="comment">//此时a = 99999, b = 1, 显然第一次循环b就到头了, 但后面单独循环a的时候, 依旧是要加进位的</span></span><br><span class="line">        <span class="comment">//所以这里也是同理</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//carry右移30位</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个循环结束之后, 其实还差一步, 还拿99999 + 1举例子, 按照顺序相加最后得到的是00000</span></span><br><span class="line">    <span class="comment">//因为最后还进了一个1, 所以这里的carry也是同理, 因此z的ob_size要比size_a多1, 目的就在于此</span></span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="comment">//但如果最后的carry没有进位的话, 显然其结果就是0, 所以最后没有直接返回z, 而是返回了long_normalize(z)</span></span><br><span class="line">    <span class="comment">//这个long_normalize函数作用就是从后往前依次检查ob_digit的元素, 如果为0, 那么就将其ob_size减去1, 直到出现一个不为0的元素</span></span><br><span class="line">    <span class="comment">//当然对于我们当前来说, 显然最多只会检查一次</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python中的整数在底层实现的很巧妙，不理解的话可以多看几遍，然后我们在Python的层面上再反推一下，进一步感受底层运算的过程。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有a和b两个整数, 当然这里是使用列表直接模拟的底层数组ob_digit</span></span><br><span class="line">a = [<span class="number">1073741744</span>, <span class="number">999</span>, <span class="number">765</span>, <span class="number">123341</span>]</span><br><span class="line">b = [<span class="number">841</span>, <span class="number">1073741633</span>, <span class="number">2332</span>]</span><br><span class="line"><span class="comment"># 然后创建z, 表示a和b的相加结果</span></span><br><span class="line">z = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更直观, 我们一步步手动相加</span></span><br><span class="line"><span class="comment"># 首先是将a[0] + b[0], 得到carry</span></span><br><span class="line">carry = a[<span class="number">0</span>] + b[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1), 我们看到结果是761</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 761</span></span><br><span class="line"><span class="comment"># 因为如果carry小于等于 2 ** 30 - 1, 那么结果就是carry, 而这里是761, 显然carry肯定大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 因为carry &amp; (2 ** 30 - 1) == 761, 所以z的第一个元素就是761</span></span><br><span class="line">z.append(<span class="number">761</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算a[1] + b[1]得到新的carry, 但是之前的carry大于 2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还要再加上之前的右移30位的carry</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">1</span>] + b[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1)得到809</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 809</span></span><br><span class="line"><span class="comment"># 说明carry依旧大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 然后z的第二个元素就是809</span></span><br><span class="line">z.append(<span class="number">809</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算a[2] + b[2]的时候也是同理</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">2</span>] + b[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 但是显然此时的carry已经不大于 2 ** 30 - 1了</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 所以carry和carry &amp; (2 ** 30 - 1)的结果都是carry本身</span></span><br><span class="line"><span class="built_in">print</span>(carry, carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 3098 3098</span></span><br><span class="line"><span class="comment"># 说明z的第三个元素是3098</span></span><br><span class="line">z.append(<span class="number">3098</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时b到头了, 所以直接将a[3]作为carry, 当然我们不知道carry是否大于2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还是右移30位即可, 不过carry不大于2 ** 30 - 1的话, 那么 carry &gt;&gt; 30 就是0罢了</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(carry)  <span class="comment"># 123341</span></span><br><span class="line"><span class="comment"># 说明z的最后一个元素是123341, 当然理论上我们还要在对carry和 2 ** 30 - 1进行一次判断</span></span><br><span class="line"><span class="comment"># 当然由于我们知道carry肯定不会超过2 ** 30 - 1, 所以就不判断了</span></span><br><span class="line">z.append(<span class="number">123341</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时z为[761, 809, 3098, 123341]</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># [761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以ob_digit为[1073741744, 999, 765, 123341]和[841, 1073741633, 2332]的两个PyLongObject相加</span></span><br><span class="line"><span class="comment"># 得到的新的PyLongObject的ob_digit为[761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们根据ob_digit按照规则转成整数, 那么a + b的结果要和z是相等的</span></span><br><span class="line">a = <span class="number">1073741744</span> + <span class="number">999</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">765</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line">b = <span class="number">841</span> + <span class="number">1073741633</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">2332</span> * <span class="number">2</span> ** <span class="number">60</span></span><br><span class="line">z = <span class="number">761</span> + <span class="number">809</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">3098</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 152688762386380073438430860672944</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 2689765870042689307465</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># 152688762389069839308473549980409</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然结果为True, 由此证明我们之前的结论是成立的。</span></span><br><span class="line"><span class="built_in">print</span>(a + b == z)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看完绝对值加法x_add之后，再来看看绝对值减法x_sub，显然有了加法的经验之后再看减法会简单很多。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//依旧是获取两者的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//z指向相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//如果size_a 小于 size_b, 那么sign就是-1, 否则就是1</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//之前carry保存的相加的结果, borrow保存相减的结果</span></span><br><span class="line">    <span class="comment">//名字很形象, 相加要进位叫carry、相减要结尾叫borrow</span></span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果size_a比size_b小, 说明a的绝对值比b小</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么令sign = -1, 相减之后再乘上sign</span></span><br><span class="line">        <span class="comment">//因为计算的是绝对值之差, 符号是在绝对值之差计算完毕之后通过sign判断的</span></span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后依旧交换两者的位置, 相减的时候也确保大的一方在左边</span></span><br><span class="line">        <span class="comment">//相加的时候其实大的一方在左边还是在右边没有太大影响, 但是相减的时候大的一方在左边显然会省事很多</span></span><br><span class="line">        <span class="comment">//但是交换之后再相减, 肯定要变符号, 因此将sign设置为-1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//可能有人会有疑问了，那如果a的ob_size是1, b的ob_size是-3，一正一负,此时起到的效果是相加才对啊</span></span><br><span class="line">        <span class="comment">//是的, 所以此时会将a和b传到x_add里面，而不是这里, 后面我们会总结</span></span><br><span class="line">        <span class="comment">//由于ob_digit里面的元素都为正, 所以x_add计算的是绝对值之和，x_sub计算的绝对值之差, 总之在理解逻辑的时候把a和b都想象成正数即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">//这一个条件语句可能有人会觉得费解，我们分析一下</span></span><br><span class="line">        <span class="comment">//如果两者相等, 那么两个ob_digit里面对应的元素也是有几率都相等的</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="comment">//所以从ob_digit的尾巴开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">//如果都相等, 那么i会等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以直接返回0即可</span></span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//下面下面是为了计算相减之后的PyLongObject的ob_size</span></span><br><span class="line">        <span class="comment">//如果对应元素不相等, 假设a的ob_digit里面的元素是[2, 3, 4, 5], b的ob_digit是[1, 2, 3, 5]</span></span><br><span class="line">        <span class="comment">//因此上面的while循环结束之后, i会等于2, 显然只需要计算[2, 3, 4]和[1, 2, 3]之间的差即可, 因为最高位的5是一样的</span></span><br><span class="line">        <span class="comment">//然后判断索引为i时, 对应的值谁大谁小</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            <span class="comment">//如果a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i], 那么同样说明a小于b, 因此将sign设置为-1, 然后交换a和b的位置</span></span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为做减法, 所以size_a和size_b直接设置成i + 1即可, 因为高位在减法的时候会被抵消掉, 所以它们完全可以忽略</span></span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里依旧是申请空间</span></span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="comment">//申请失败返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后下面的逻辑和x_add是类似的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//让a-&gt;ob_digit[i] - b-&gt;ob_digit[i], 但如果存在借位, 那么还要减掉</span></span><br><span class="line">        <span class="comment">//但是问题来了, 我们说digit貌似是无符号的吧, 但是对于低位来说a-&gt;ob_digit[i] 是完全可以小于 b-&gt;ob_digit[i]的</span></span><br><span class="line">        <span class="comment">//但是这样减出来不成负数了, 所以C语言中有这么个特点, 比如：这里相减得到的是-100</span></span><br><span class="line">        <span class="comment">//那么结果就是2 ** 32 - 100, 因为digit是无符号32位, 所以存储的负数会变成 2 ** 32 + 该负数, 或者2 ** 32 - 负数的绝对值</span></span><br><span class="line">        <span class="comment">//以我们平时做的减法为例：32 - 19, 我们知道结果是13, 但是低位的2减去低位的9结果是-7, 如果是负数</span></span><br><span class="line">        <span class="comment">//那么要像高位借个1, 从而得到10,因此最后一位是10 - 7 = 3</span></span><br><span class="line">        <span class="comment">//以此为例, a -&gt; ob_digit[i] - b -&gt; ob_digit[i], 如果小于0, 那么肯定要像数组中i + 1的元素进行借位, 但我们说它会比当前高30个位</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        <span class="comment">//因此这里借个1, 借的就不是10了, 而是2 ** 30次方</span></span><br><span class="line">        <span class="comment">//所以borrow为负, 那么结果显然加上2 ** 30才对, 但是当前borrow加的是2 ** 32次方</span></span><br><span class="line">        <span class="comment">//所以将borrow 还要 与上 PyLong_MASK，然后其结果才是z-&gt;ob_digit[i]的值</span></span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//如果真的借了个1, 那么ob_digit中下一个元素肯定是要减去1的, 所以borrow右移30位</span></span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        <span class="comment">//和1进行与运算, 如果a -&gt; ob_digit[i] - b -&gt; ob_digit[i]为负, 那么就必须要借位</span></span><br><span class="line">        <span class="comment">//但由于digit只用30个位, 因此再加上2 ** 32次方之后，其结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以borrow右移30位之后, 再和1进行与运算之后结果肯定是1, 由此可以判断这次相减一定是借位了</span></span><br><span class="line">        <span class="comment">//如果为0代表结果为正、没有加上2 ** 32次方,那么结果borrow &amp; 1的结果就是0</span></span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//所以Python底层的整数只用了30个位真的非常巧妙, 尤其是在减法的时候</span></span><br><span class="line">        <span class="comment">//因为借位一次借2 ** 30, 可由于C的特性会加上2 ** 32次方, 但是它们的结果只有前两个高位不一样, 后面30个位是一样的</span></span><br><span class="line">        <span class="comment">//所以再与上PyLong_MASK, 所以就等价于加上了2 ** 30次方，从而得到正确的结果</span></span><br><span class="line">        <span class="comment">//但如果一旦借位, 那么数组下一个元素要减去1。但问题是怎么判断它有没有借位呢？判断有没有借位就是判断两个元素相减之后是否为负</span></span><br><span class="line">        <span class="comment">//如果为负数,那么C会将这个负数加上2 ** 32次方, 而两个不超过2 ** 30 - 1的数相减得到的负数的绝对值显然也不会超过2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//换句话说其结果对应的第31位一定是0, 那么再和32个位全部是1的2 ** 32次方相加, 得到的结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以再让borrow右移30位、并和1进行与运算。如果结果为1, 证明相减为负数, 确实像下一个元素借了1, 因此下一次循环的会减去1</span></span><br><span class="line">        <span class="comment">//如果borrow为0, 那么就证明a-&gt;ob_digit[i] - b-&gt;ob_digit[i]得到的结果为正,根本不需要借位, 所以下一次循环等于减了一个0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size_a和size_b一样, 那么这里的for循环是不会满足条件的, 但不一样的话, 肯定会走这里</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//我们看到这里的逻辑和之前分析x_add是类似的</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只不过由于不会产生进位, 因此不需要对borrow再做额外判断, x_add中最后还要判断carry有没有进位</span></span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sign &lt; 0, 那么证明是负数</span></span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后同样从后往前将z -&gt; ob_digit中为0的元素删掉, 直到遇见一个不为0的元素, 比如: 10000 - 9999, 虽然位数多, 但是结果是1</span></span><br><span class="line">    <span class="comment">//而z -&gt; ob_digit在申请空间的时候只是根据长度申请的, 所以最后还需要这样的一次判断</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以Python整数在底层的设计确实很精妙，尤其是在减法的时候，强烈建议多看几遍回味一下。</strong></p>
<h4 id="整数的相减"><a href="#整数的相减" class="headerlink" title="整数的相减"></a>整数的相减</h4><p><strong>整数的相减调用的是long_sub函数，显然long_sub和long_add的思路都是一样的，核心还是在x_add和x_sub上面，所以long_sub就没有什么可细说的了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//z指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//判断a和b是否均指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里依旧是快分支</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//直接相减，然后转成PyLongObject返回其指针</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) - MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a小于0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//a小于0，b小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用绝对值减法, 因为两者符号一样</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两者符号不一样，那么相加起到的是相加的效果</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//但是x_add和x_sub运算的是绝对值, x_sub中考虑的sign是基于绝对值而言的</span></span><br><span class="line">            <span class="comment">//比如：x_sub接收的a和b的ob_size分别是-5和-3, 那么得到的结果肯定是正的, 因为会用绝对值大的减去绝对值小的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是负数, 所以还要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果x_sub接收的a和b的ob_size分别是-3和-5, 由于还是用绝对值大的减去绝对值小的,所以会交换、从而变号，得到的结果是负的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是正数, 所以也要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//至于x_add就更不用说了, 当a为负、b为正的时候, a - b，就等于a和b的绝对值相加乘上-1</span></span><br><span class="line">            assert(Py_SIZE(z) == <span class="number">0</span> || Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">            Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//a大于0, b小于0, 所以a - b等于a和b的绝对值相加</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//a大于0, b大于0, 所以直接绝对值相减即可</span></span><br><span class="line">            <span class="comment">//而正数等于其绝对值, 所以x_sub里面考虑的符号就是真正的结果的符号</span></span><br><span class="line">            <span class="comment">//如果是上面的负数, 那么还要乘上-1</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以关于什么时候调用x_add、什么时候调用x_sub，我们总结一下，总之核心就在于它们都是对绝对值进行运算的，掌握好这一点就不难了：</strong></p>
<p><strong>a + b</strong></p>
<ul>
<li><code>如果a是正、b是正，调用x_add(a, b)，直接对绝对值相加返回结果</code></li>
<li><code>如果a是负、b是负，调用x_add(a, b)，但相加的是绝对值，所以long_add中在接收到结果之后还要对ob_size乘上-1</code></li>
<li><code>如果a是正、b是负，调用x_sub(a,  b)，此时等价于a的绝对值减去b的绝对值。并且x_sub是使用绝对值大的减去绝对值小的，如果a的绝对值大，那么显然正常；如果a的绝对值小，x_sub中会交换，但同时也会自动变号，因此结果也是正常的。举个普通减法的例子：5 + -3, 那么在x_sub中就是5 - 3; 如果是3 + -5, 那么在x_sub中就是-(5 - 3),  因为发生了交换。但不管那种情况，符号都是一样的</code></li>
<li><code>如果a是负、b是正，调用x_sub(b, a)，此时等价于b的绝对值减去a的绝对值。所以这个和上面a是正、b是负是等价的。</code></li>
</ul>
<p><strong>所以符号相同，会调用x_add、符号不同会调用x_sub。</strong></p>
<p><strong>a - b</strong></p>
<ul>
<li><code>如果a是正、b是负，调用x_add(a, b)直接对a和b的绝对值相加即可</code></li>
<li><code>如果a是正、b是正，调用x_sub(a, b)直接对a和b的绝对值相减即可，会根据绝对值自动处理符号，而a、b为正，所以针对绝对值处理的符号，也是a - b的符号</code></li>
<li><code>如果a是负、b是正，调用x_add(a, b)对绝对值进行相加, 但是结果显然为负，因此在long_sub中还要对结果的ob_size成员乘上-1</code></li>
<li><code>如果a是负、b是负，调用x_sub(a, b)对绝对值进行相减, 会根据绝对值自动处理符号,  但是在为负的情况下绝对值越大，其值反而越小, 因此针对绝对值处理的符号，和a -  b的符号是相反的。所以最终在long_sub中，也要对结果的ob_size成员乘上-1。举个普通减法的例子：-5 - -3,  那么在x_sub中就类似于5 - 3; 如果是-3 - -5, 那么在x_sub中就类似于-(5 - 3),  因为发生了交换。但不管那种情况得到的值的正负号都是相反的，所以要再乘上-1</code></li>
</ul>
<p><strong>所以符号相同，会调用x_sub、符号不同会调用x_add。</strong></p>
<p>​        <strong>所以可以仔细回味一下Python中整数的设计思想，以及运算方式。为什么只使用digit的30个位, 以及在相加、相减的时候是怎么做的。</strong>    </p>
<p>​        <strong>当然还有乘法和除法，乘法Python内部采用的是效率更高的karatsuba算法，相当来说比较复杂，有兴趣可以自己查看一下。重点还是了解Python中的整数在底层是怎么存储的，以及为什么要这么存储。</strong>    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>这一节我们介绍了整数的底层实现，并分析了Python中的整数为什么不会溢出，以及Python如何计算一个整数所占的字节。当然我们还说了小整数对象池，以及通过分析源码中的long_add和long_sub来了解底层是如何对整数进行运算的。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
</search>
