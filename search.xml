<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级刷题指南</title>
    <url>/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="PAT甲级刷题指南"><a href="#PAT甲级刷题指南" class="headerlink" title="PAT甲级刷题指南"></a>PAT甲级刷题指南</h1><h2 id="《算法笔记》C-标准模板库-STL-介绍"><a href="#《算法笔记》C-标准模板库-STL-介绍" class="headerlink" title="《算法笔记》C++标准模板库(STL)介绍"></a>《算法笔记》C++标准模板库(STL)介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>变长数组</p>
<h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、vector&lt;int&gt; v(size,0);  //初始化为0</span><br><span class="line">2、vector&lt;int&gt; v;  v.resize(n,0);  //resize一个大小为n，初值为0的可变数组</span><br><span class="line">3、vector&lt;type&gt; v;   //不初始化,type可以是一个结构体</span><br><span class="line">4、vector&lt;int&gt; ilist2(v);  vector&lt;int&gt; ilist2  = v;   //两种方式等价，都是深拷贝</span><br><span class="line">5、vector&lt;int&gt; ilist = &#123;1,2,3.0,4,5,6,7&#125;;   //和数组初始化方法一样</span><br><span class="line">6、vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1);   //迭代器初始化</span><br></pre></td></tr></table></figure>

<h5 id="访问："><a href="#访问：" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、随机访问数组下标访问 v[i]</span><br><span class="line">2、迭代器访问数组</span><br><span class="line">    vector&lt;int&gt;::iterator iter;</span><br><span class="line">    for(iter = vi.begin();iter != vi.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a><strong>常用函数</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、插入push_back  v.push_back(i);</span><br><span class="line">2、删除pop_back   v.pop_back();  //删除最后一个元素，回溯的时候常用</span><br><span class="line">3、大小size    v.size();  //获取数组大小</span><br><span class="line">4、清空clear   v.clear(); //清空数组</span><br><span class="line">5、插入insert  //尽量不要频繁使用这个函数，会引起大量数据移动，降低程序效率</span><br><span class="line">    v.insert(v.begin(),8);//在最前面插入新元素</span><br><span class="line">    v.insert(v.begin()+3,1);//在迭代器中下标为3的元素前插入新元素</span><br><span class="line">    v.insert(v.end(),3);//在向量末尾追加新元素</span><br><span class="line">    v.insert(v.end(),3,0);//在尾部插入3个0</span><br><span class="line">6、删除erase  //erase函数有两种函数原型，一种是给定要删除的位置，另一种是给定删除的区域。</span><br><span class="line">	有两种函数原型，c.erase (p),c.erase(b,e);第一个删除迭代器p所指向的元素，第二个删除迭代器b,e所标记的范围内的元素，c为容器对象，返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点）</span><br><span class="line">	应用一：删除连续数字</span><br><span class="line">	//但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); iter++)  </span><br><span class="line">	&#123;</span><br><span class="line">      if(*iter == 3)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">	&#125;</span><br><span class="line">	//可以删除连续的数字3</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">     if( *iter == 3)</span><br><span class="line">          iter = veci.erase(iter);//当删除时erase函数自动指向下一个位置，就不需要进行++</span><br><span class="line">      else</span><br><span class="line">            iter ++ ;    //当没有进行删除的时候，迭代器++</span><br><span class="line">	&#125;</span><br><span class="line">	//另一种解决无法删除连续的数字的方法</span><br><span class="line">	我们先介绍一下remove函数:</span><br><span class="line">    remove是个stl的通用算法std::remove(first,last,val)移除[first, last)范围内等于val的元素在vector里面用就类似于 iter=std::remove(vec.begin(), vec.end(), val)但这个函数只是把val移到vec的末尾，并不真正删除,真正删除还是要调用一次erase函数</span><br><span class="line">    veci.erase(remove(vec.begin(),vec.end(),3),vec.end());</span><br><span class="line">    </span><br><span class="line">    应用二：删除重复数字，顺序不发生变化</span><br><span class="line">    如果不要求顺序的话，我们可以直接调用unique函数进行操作，这里介绍一下unique函数：从头到尾，判断当前元素是否等于上一个元素，将不重复的元素移到前面来(赋值操作)，而不是将重复的元素移动到后面去。</span><br><span class="line">    vec.erase(unique(vec.begin(),vec.end()),vec.end())  //将重复的区域删除，顺序会改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a><strong>常见错误</strong>：</h5><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814163126705.png" alt="image-20210814163126705"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>是一个内部自动有序且不含重复元素的容器</p>
<p>unordered_set 无序 其余和set的用法一样，效率更高</p>
<h5 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s(b, e);</span><br><span class="line">比如：</span><br><span class="line">int arr[]=&#123;1,2,3,4,3,2,1&#125;;</span><br><span class="line">set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-1"><a href="#访问：-1" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、迭代器访问</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt;::iterator it</span><br><span class="line">for(it = st.begin();it != st.end();it++)&#123;</span><br><span class="line">	printf(&quot;%d &quot;,*it);</span><br><span class="line">&#125; </span><br><span class="line">2、随机访问   在set中查找2，返回其迭代器</span><br><span class="line">set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">printf(&quot;%d &quot;,*it);</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	set&lt;int&gt; st;</span><br><span class="line">1、插入 insert()</span><br><span class="line">	st.insert(3);</span><br><span class="line">2、查找 find()</span><br><span class="line">	set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">	if(st.find(2)==st.end()) printf(&quot;没找到&quot;);</span><br><span class="line">3、删除  erase()</span><br><span class="line">st.erase(it) it为需要删除元素的迭代器，复杂度O(1)</span><br><span class="line">st.erase(value) value为要删除元素的值，复杂度O(logN)</span><br><span class="line">	st.erase(st.find(2));</span><br><span class="line">	st.erase(2)，效果一致，两种用法</span><br><span class="line">4、获取元素个数 size()</span><br><span class="line">	cout&lt;&lt;&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">5、清空 clear()</span><br><span class="line">	st.clear(); </span><br><span class="line">6、判空 empty()</span><br><span class="line">	st.empty()</span><br></pre></td></tr></table></figure>





<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>字符串</p>
<h5 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string s1;  s1为空字符串</span><br><span class="line">2、string s2(&quot;ABC&quot;);  用字符串字面值初始化s2</span><br><span class="line">3、string s3(s2);  用s3初始化为s2的一个副本</span><br><span class="line">4、string s4(n,&#x27;c&#x27;);  将s4初始化为字符&#x27;c&#x27;的n个副本</span><br></pre></td></tr></table></figure>

<h5 id="访问：-2"><a href="#访问：-2" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过下标访问</span><br><span class="line">    string str = &quot;abcd&quot;;</span><br><span class="line">    for(int i=0;i &lt; str.length();i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,str[i]);</span><br><span class="line">    &#125; </span><br><span class="line">2、通过迭代器访问</span><br><span class="line">    cout&lt;&lt;&quot;通过迭代器访问如下：&quot;&lt;&lt;endl;</span><br><span class="line"> for(string::iterator;it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,*it);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-2"><a href="#常用函数：-2" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、判空 s.empty()</span><br><span class="line">2、统计字符个数  s.size()  /   s.length()</span><br><span class="line">3、拼接字符串 += </span><br><span class="line">	str3 = str1+str2;  //拼接后再赋值</span><br><span class="line">	str1 += str2;  //直接接在后面，效率更高</span><br><span class="line">4、字符串比较大小 == != &gt;=等等</span><br><span class="line">5、插入 insert()</span><br><span class="line"> insert(pos,string) 在pos位置插入string</span><br><span class="line"> insert(it,it2,it3) 在it位置插入 [it2,it3)的串，it2,it3为待插字符串的首尾迭代器</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line"> 	str2 = &quot;opq&quot;;     //insert(pos,string)</span><br><span class="line">	str1.insert(3,str2);</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.insert(str1.begin()+3,str2.begin(),str2.end());     //insert(it,it2,it3)</span><br><span class="line">	cout&lt;&lt;&quot;abcopqxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">6、删除单个元素、区间元素 erase()</span><br><span class="line"> 删除单个元素 str.erase(it)  it为删除元素的迭代器</span><br><span class="line"> 删除一个区间内的所有元素 str.erase(first,last) [first,last)</span><br><span class="line"> str.erase(pos,length) pos为开始位置，length为长度</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcopqopqxyz&quot;;</span><br><span class="line"> 	str1.erase(str1.begin()+3);//str.erase(it)删除4号位o </span><br><span class="line">	cout&lt;&lt;&quot;abcopqopqxyz字符串删除第四个位置o字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(str1.begin()+3,str1.end()-3);//str.erase(first,last)</span><br><span class="line">	cout&lt;&lt;&quot;abcpqopqxyz字符串删除第4~8位置字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(3,3);//str.erase(ipos,length)</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串删除从第4位置开始的3个字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">7、清空 clear()</span><br><span class="line">	str1.clear();</span><br><span class="line">8、子串 substr()</span><br><span class="line"> substr(pos,len) 返回从pos号开始，长度为len子串</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串从下标2开始长度为3的子串为：&quot;&lt;&lt;str1.substr(2,3)&lt;&lt;endl;</span><br><span class="line">9、查找 find()</span><br><span class="line"> str.find(str2) 当str2是str的子串时，返回其在str中第一次出现的位置，如果str2不是str的子串，返回string::npos（常数）</span><br><span class="line"> str.find(str2,pos) 从str的pos号位置开始匹配str2，返回指相同</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;,str2=&quot;xyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;xyz子串在abcxyz中第一次出现的位置为：&quot;&lt;&lt;str1.find(str2)&lt;&lt;endl;  </span><br><span class="line">	</span><br><span class="line">	position = s.find(&quot;jk&quot;);</span><br><span class="line">	if (position != s.npos) printf(&quot;position is : %d\n&quot; ,position);  //查找成功</span><br><span class="line">	else printf(&quot;Not found the flag\n&quot;);  //查找失败</span><br><span class="line"> 10、替换 replace()</span><br><span class="line">  str.replace(pos,len,str2) 把str从pos号开始，长度为len的子串替换为str2</span><br><span class="line">  str.replace(it1,it2,str) 把str的迭代器[it1,it2)返回的子串替换为str2</span><br><span class="line">  	str1 = &quot;Maybe you will turn around.&quot;;</span><br><span class="line">	str2 = &quot;will not&quot;;str3 = &quot;surely&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will turn around.字符串从第10位开始的4位替换为str2后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(10,4,str2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will not turn around.字符串从起始位开始的5位替换为str3后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(str1.begin(),str1.begin()+5,str3)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h5 id="string和char-的转换"><a href="#string和char-的转换" class="headerlink" title="string和char[]的转换"></a>string和char[]的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string转char*</span><br><span class="line">printf(&quot;%s&quot;,str.c_str());</span><br><span class="line">2、char* 转string</span><br><span class="line">	char* p = &quot;abc&quot;;</span><br><span class="line">    string s = p;</span><br></pre></td></tr></table></figure>

<h5 id="string和int等类型的转换"><a href="#string和int等类型的转换" class="headerlink" title="string和int等类型的转换"></a>string和int等类型的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转string:</span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br><span class="line">转Int</span><br><span class="line">stoi(str1);  //int</span><br><span class="line">stof(str1);  //float</span><br><span class="line">stoll(str1);  //long long </span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string strA = &quot;yasaken@126.com&quot;;</span><br><span class="line">    string strB = &quot;LURY@LENOVO.com&quot;;</span><br><span class="line">    printf(&quot;Before transform:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::toupper);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::toupper);</span><br><span class="line">    printf(&quot;After transform to toupper:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::tolower);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::tolower);</span><br><span class="line">    printf(&quot;After transform to lower:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>map即映射，是常用的STL容器，它可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<p>uordered_map无序容器，效率更高</p>
<h5 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、直接赋值</span><br><span class="line">map&lt;string, int&gt; m1;</span><br><span class="line">m1[string(&quot;abc&quot;)] ++;</span><br><span class="line">//如果“abc&quot;已经存在，会在原来的基础上++，如果不存在，则会创建一个hash_key</span><br><span class="line"></span><br><span class="line">2、用insert添加</span><br><span class="line">map&lt;string, int&gt; m2;</span><br><span class="line">m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-3"><a href="#访问：-3" class="headerlink" title="访问："></a>访问：</h5><p>map会以键从小到大的顺序自动排序，unordered_map则不会排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过key访问value</span><br><span class="line">	map&lt;char,int&gt; mp;</span><br><span class="line">	//通过下标访问 </span><br><span class="line">	mp[&#x27;c&#x27;] = 20;</span><br><span class="line">	mp[&#x27;c&#x27;] = 30;//20被覆盖</span><br><span class="line">	printf(&quot;%d\n&quot;,mp[&#x27;c&#x27;]);//输出30</span><br><span class="line">2、通过迭代器访问</span><br><span class="line">	for(map&lt;char,int&gt;::iterator it = mp.begin();it != mp.end();it++)&#123;</span><br><span class="line">		//it-&gt;first是当前映射的键；it-&gt;second是当前映射的值 </span><br><span class="line">		printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-3"><a href="#常用函数：-3" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查找  find()</span><br><span class="line">     if(M.find(exponent)!=M.end())&#123;</span><br><span class="line">     	printf(&quot;%d&quot;,M[exponent]);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	printf(&quot;没找到&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	map&lt;char,int&gt;::iterator it = mp.find(&#x27;b&#x27;);</span><br><span class="line">	printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">2、删除 erase</span><br><span class="line"> mp.erase(key);  key为想要删除的键</span><br><span class="line"> mp.erase(first,last); 删除一个区间内的元素，first,last为迭代器</span><br><span class="line"> 	it = mp.find(&#x27;m&#x27;);</span><br><span class="line">	mp.erase(it);//删除b 2</span><br><span class="line">	mp.erase(&#x27;r&#x27;);//删除b 2</span><br><span class="line">3、获取大小 size()</span><br><span class="line">	cout&lt;&lt;&quot;此时map的长度为：&quot;&lt;&lt;mp.size();</span><br><span class="line">4、清空 clear()</span><br><span class="line">	mp.clear();</span><br></pre></td></tr></table></figure>

<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap:"></a>multimap:</h5><p>multimap 和 map 很相似，但是 multimap 允许重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multimap&lt;int, string&gt; multi_map;		// 可实现多重映射</span><br><span class="line"></span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng1&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng2&quot; &#125;);</span><br><span class="line">for (auto&amp; i: multi_map)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; &quot;  &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">520  huameng</span><br><span class="line">520  huameng1</span><br><span class="line">520  huameng2</span><br></pre></td></tr></table></figure>



<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>Queue翻译为队列，理解为一个先进先出的容器</p>
<h5 id="queue初始化："><a href="#queue初始化：" class="headerlink" title="queue初始化："></a>queue初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; first;                 // empty queue</span><br></pre></td></tr></table></figure>

<h5 id="访问：-4"><a href="#访问：-4" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问队首元素：如q.front()</span><br><span class="line">访问队尾元素，如q.back();</span><br><span class="line">printf(&quot;%d %d\n&quot;,q.front(),q.back());</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-4"><a href="#常用函数：-4" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size()-容器大小</span><br><span class="line">empty()-容器判空</span><br><span class="line">push()尾部增加元素</span><br><span class="line">pop()删除尾部元素</span><br></pre></td></tr></table></figure>

<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue:"></a>priority_queue:</h5><p>在&lt; queue&gt;头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</p>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义priority_queue对象</span><br><span class="line">priority_queue&lt;int &gt;q1;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q2;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;//定义小的先出队</span><br><span class="line">//其中第二个参数( vector )，是来承载底层数据结构堆的容器，第三个参数( less )，则是一个比较类，</span><br><span class="line">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span><br></pre></td></tr></table></figure>

<p>priority_queue的基本操作均与queue相同，<strong>优先队列没有back（）操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>

<p>操作示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//---1---push()</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---2---top()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;优先队列341的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());  <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//---3---pop()</span></span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;弹出队首元素后优先队列的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());   <span class="comment">//3</span></span><br><span class="line">	<span class="comment">//---4---empty()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列为空吗？&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;Not Empty\n&quot;</span>);</span><br><span class="line">	<span class="comment">//---5---size()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列大小为：&quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级操作示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级队列优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//---1---基本数据类型：设置优先级队列总是把最小的元素放在队首 </span></span><br><span class="line">	<span class="comment">// priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //小顶堆</span></span><br><span class="line">    <span class="comment">//注意&lt;int&gt; &gt;之间的空格 </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//大顶堆</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体优先级的设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;  <span class="comment">//价格大的优先</span></span><br><span class="line">        <span class="comment">//return f1.price &gt; f2.price; //价格小的优先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"><span class="comment">//需要重载小于号，只能重载小于号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;fruit&gt; q;  <span class="comment">//价格大的优先</span></span><br><span class="line">    <span class="comment">//这边就不能再加greater或less了</span></span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似Cmp写在外面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//重载优先级结构体进行排序 </span></span><br><span class="line">	priority_queue&lt;fruit&gt; q;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//梨子 4</span></span><br><span class="line">    <span class="comment">//用cmp函数优先级排序 </span></span><br><span class="line">	priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; qq;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	qq.<span class="built_in">push</span>(f1);</span><br><span class="line">	qq.<span class="built_in">push</span>(f2);</span><br><span class="line">	qq.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;qq.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;qq.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//苹果 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>stack即栈，是一种先进后出的容器，区别于queue；</p>
<h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stk;</span><br></pre></td></tr></table></figure>

<h5 id="访问：-5"><a href="#访问：-5" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问栈顶元素 stk.top()</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-5"><a href="#常用函数：-5" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push() 压栈</span><br><span class="line">top() 取栈顶元素</span><br><span class="line">pop() 出栈</span><br><span class="line">empty() 判空</span><br><span class="line">size() 获取大小</span><br><span class="line">//---1、2、3---push()、top()、pop() </span><br><span class="line">for(int i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line">	st.push(i);//将i压入栈 </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;入栈12345的栈顶为：&quot;;</span><br><span class="line">cout&lt;&lt;st.top()&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i &lt;= 3;i++)&#123;</span><br><span class="line">	st.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;出栈3个元素后栈顶为：&quot;;</span><br><span class="line">printf(&quot;%d\n&quot;,st.top());</span><br><span class="line">//---4---empty()</span><br><span class="line">cout&lt;&lt;&quot;此时栈为空吗？&quot;&lt;&lt;endl;</span><br><span class="line">if(st.empty() == true)  printf(&quot;Empty\n&quot;);</span><br><span class="line">else printf(&quot;Not Empty\n&quot;);</span><br><span class="line">//---5---size()</span><br><span class="line">cout&lt;&lt;&quot;此时队列大小为：&quot;&lt;&lt;st.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>Pair可以看作一个内部有两个元素的结构体，且这两个元素的类型可以指定</p>
<h5 id="初始化：-5"><a href="#初始化：-5" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">pair&lt;int, double&gt; p2(1, 2.4);  //用给定值初始化</span><br><span class="line">pair&lt;int, double&gt; p3(p2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<h5 id="访问：-6"><a href="#访问：-6" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &#x27; &#x27; &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-6"><a href="#常用函数：-6" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、比较操作数 &lt;.&gt;,&lt;=,==</span><br><span class="line">//比较规则是先比较first，再比较second</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; p1(5,10);</span><br><span class="line">	pair&lt;int,int&gt; p2(5,15);</span><br><span class="line">	pair&lt;int,int&gt; p3(10,5);</span><br><span class="line">	if(p1 &lt; p3)	printf(&quot;p1 &lt; p3\n&quot;);</span><br><span class="line">	if(p1 &lt;= p3)	printf(&quot;p1 &lt;= p3\n&quot;);</span><br><span class="line">	if(p1 &lt; p2)	printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2、make_pair 赋值</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line"> </span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line"> </span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br></pre></td></tr></table></figure>

<h5 id="常用于作为map的键值对进行插入："><a href="#常用于作为map的键值对进行插入：" class="headerlink" title="常用于作为map的键值对进行插入："></a>常用于作为map的键值对进行插入：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">//pair作为map键值对进行插入 </span><br><span class="line">mp.insert(make_pair(&quot;heihei&quot;,5));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,10));</span><br></pre></td></tr></table></figure>



<h3 id="algorithm常用函数"><a href="#algorithm常用函数" class="headerlink" title="algorithm常用函数"></a>algorithm常用函数</h3><h5 id="max-、min-、abs"><a href="#max-、min-、abs" class="headerlink" title="max()、min()、abs()"></a>max()、min()、abs()</h5><p>最大值、最小值、绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=-2;</span><br><span class="line">printf(&quot;%d %d\n&quot;,max(x,y),min(x,y));</span><br><span class="line">printf(&quot;%d %d\n&quot;,abs(x),abs(y));</span><br></pre></td></tr></table></figure>

<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换两个元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=2;</span><br><span class="line">swap(x,y);</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>1.会将区间内的元素全部逆序。常用于数组，字符串，容器等，其本身的函数参数也不复杂。<br>2.容器类型的要用begin()和end()来指定反转的区域，数组类型的直接用int类型即可。<br>3.reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;</span><br><span class="line">reverse(v.begin(),v.end());//v的值为1,2,3,4,5</span><br><span class="line">string str=&quot;www.mathor.top&quot;;</span><br><span class="line">reverse(str.begin(),str.end());//str结果为pot.rohtam.wwww</span><br></pre></td></tr></table></figure>

<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>1.按照单元赋值，将一个区间的元素都赋同一个值<br> 2.fill(arr, arr + n, 要填入的内容);<br> fill(vector.begin(), vector.end(), val);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">fill(arr, arr + 10, 2);</span><br><span class="line">vector&lt;int&gt;  v&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">fill(v.begin(), v.end(), -1);</span><br><span class="line">vector&lt;int&gt; myvector (8);// myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">fill (myvector.begin(),myvector.begin()+4,5);</span><br><span class="line">// myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">fill (myvector.begin()+3,myvector.end()-2,8);</span><br><span class="line">// myvector: 5 5 5 8 8 8 0 0</span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>1.Sort函数有三个参数：<br>（1）第一个是要排序的数组的起始地址。<br>（2）第二个是结束的地址（最后一位要排序的地址的下一地址）<br>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。<br>2.Sort函数使用模板:Sort(start,end,排序方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组排序</span><br><span class="line">int IntValue[5] = &#123;1,4,3,8,5&#125;;</span><br><span class="line">sort(IntValue,IntValue+5);</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">	cout&lt;&lt;IntValue[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">2、vector排序</span><br><span class="line">vector&lt;int&gt; v = &#123;2,6,4,9,6,0,3&#125;;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">vector&lt;int&gt;::iterator  start;</span><br><span class="line">for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">	cout&lt;&lt;(*start)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">3、自定义排序</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">linli1 20</span><br><span class="line">linli2 24</span><br><span class="line">linli6 8</span><br><span class="line">linli3 8</span><br><span class="line"> * */</span><br><span class="line">typedef struct stu&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;stu;</span><br><span class="line">bool cmp(stu u,stu g)&#123;  //&lt;表示升序排序</span><br><span class="line">    if(u.age==g.age)&#123;</span><br><span class="line">        return u.name&lt;g.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.age&lt;g.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;stu&gt; v;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        stu c ;</span><br><span class="line">        cin&gt;&gt;c.name&gt;&gt;c.age;</span><br><span class="line">        v.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end(),cmp);</span><br><span class="line">    vector&lt;stu&gt;::iterator  start;</span><br><span class="line">    for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">        cout&lt;&lt;(*start).name&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h5><p><strong>lower_bound：</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于或等于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;lower_bound(a+l,a+r,key)-a；(a是数组)。</p>
<p><strong>upper_bound:</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（同样这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;upper_bound(a+l,a+r,key)-a；(a是数组)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int board[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int t1 = lower_bound(board,board+5,3)-board; //2</span><br><span class="line">int t2 = upper_bound(board,board+5,3)-board; //3</span><br></pre></td></tr></table></figure>



<h2 id="PAT真题模拟"><a href="#PAT真题模拟" class="headerlink" title="PAT真题模拟"></a>PAT真题模拟</h2><h3 id="PAT-1001"><a href="#PAT-1001" class="headerlink" title="PAT 1001"></a>PAT 1001</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330182108486.png" alt="image-20210330182108486"></p>
<p>我的做法，难点在于如何3位3位加一个逗号，我用栈来存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="type">int</span> cishu;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(c);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">3</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;s[i];</span></span><br><span class="line">    <span class="comment">// 	if(s[i]!=&#x27;-&#x27;&amp;&amp;(i!=s.length()-1)&amp;&amp;(s.length()-i-1)%3==0) cout&lt;&lt;&quot;,&quot;;//后面剩下3n个数时 要加&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大神的做法见注释，好像比较难想到。</p>
<h3 id="PAT-1002"><a href="#PAT-1002" class="headerlink" title="PAT 1002"></a>PAT 1002</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330183857126.png" alt="image-20210330183857126"></p>
<p>多项式加法，通过第一个测试点不是很难。</p>
<p>注意点： <strong>系数为0时不进行输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line">    <span class="type">int</span> n,m;   cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a; <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">find</span>(a)!=M.<span class="built_in">end</span>()) M[a] += b;</span><br><span class="line">        <span class="keyword">else</span> M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330190215218.png" alt="image-20210330190215218"></p>
<p>具体还有两个未通过也不知道是怎么回事</p>
<p>map的倒叙遍历需要掌握</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1003-dijstra"><a href="#PAT-1003-dijstra" class="headerlink" title="PAT 1003 (dijstra)"></a>PAT 1003 (dijstra)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155146524.png" alt="image-20210401155146524"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155200043.png" alt="image-20210401155200043"></p>
<p> 题目翻译：</p>
<p>你是一个救援队长，你要救援有危险的城市，你需要尽可能快的到达有危险的城市，并且带尽可能多的人。</p>
<p>输入：</p>
<p>第1行：4个正整数： 城市数量N、 路数量M、你在的城市、你要救援的城市。</p>
<p>第2行：N个整数，第i个数表示第i个城市的救援队数量。</p>
<p>然后M行：每一行表示一条路，三个数字分别是起点、终点、距离。</p>
<p>保证至少有一条路让你去你要救援的城市。</p>
<p>输出：</p>
<p>最短路径条数  可带的最多人数  (我输出理解成了最短路径长度…)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *dist;   <span class="comment">//保存最短路径</span></span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//s集合，表示已经访问过</span></span><br><span class="line"><span class="type">int</span> *rescue;    <span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> **e;      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> *pre;     <span class="comment">//pre记录路径</span></span><br><span class="line"><span class="type">int</span> *rm;      <span class="comment">//能够到达i点的最多人数</span></span><br><span class="line"><span class="type">int</span> *num_of_shortest;  <span class="comment">//能够到达i点的最短路径条数</span></span><br><span class="line"><span class="type">int</span> N,M,C1,C2;</span><br><span class="line"><span class="type">int</span> maxrescue = <span class="number">0</span>;  <span class="comment">//最大救援队数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    rescue = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    pre = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    rm = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(rm,<span class="number">0</span>,<span class="built_in">sizeof</span>(rm));</span><br><span class="line">    num_of_shortest = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  <span class="comment">//初始化城市救援队数量</span></span><br><span class="line">        cin&gt;&gt;rescue[i];</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">new</span> <span class="type">int</span>*[N];     <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> e[i][j]=<span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c1,c2,length;  </span><br><span class="line">        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length;</span><br><span class="line">        e[c1][c2] = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;N;j++)</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;&quot;e[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]&quot;&lt;&lt;e[i][j]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[C1] = <span class="number">1</span>;</span><br><span class="line">    num_of_shortest[C1] = <span class="number">1</span>;</span><br><span class="line">    rm[C1] = rescue[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dist[i] = e[C1][i];</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&lt;<span class="number">9999</span>)&#123;   <span class="comment">//能够到达</span></span><br><span class="line">            pre[i]=C1;</span><br><span class="line">            rm[i] = rescue[C1]+rescue[i];</span><br><span class="line">            num_of_shortest[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;e[C1][4]&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; :&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">99999</span>,u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//选出下一次要加入s集合的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[i]&lt;min)&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//更新dist数组</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]&lt;dist[i])&#123;</span><br><span class="line">                dist[i] = dist[u] + e[u][i];</span><br><span class="line">                pre[i]=u;</span><br><span class="line">                rm[i] = rm[u]+rescue[i];</span><br><span class="line">                num_of_shortest[i] = num_of_shortest[u];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]==dist[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(rm[u]+rescue[i]&gt;rm[i])&#123;</span><br><span class="line">                    pre[i]=u;</span><br><span class="line">                    rm[i] = rm[u]+rescue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num_of_shortest[i] += num_of_shortest[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dijstra</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num_of_shortest[C2]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rm[C2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401160800655.png" alt="image-20210401160800655"></p>
<p>dijstra的套路算法，关键是需要增加几个判别的数组，一个是有多少条最短路径num_of_shortest，另一个是当前可以到达的最多救援队数量rm。</p>
<h3 id="PAT-1004（按层统计树的叶子节点）"><a href="#PAT-1004（按层统计树的叶子节点）" class="headerlink" title="PAT 1004（按层统计树的叶子节点）"></a>PAT 1004（按层统计树的叶子节点）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405155805312.png" alt="image-20210405155805312"></p>
<p>题意：按照每一层统计树的叶子节点个数</p>
<p>第一行输入 N&#x3D;2 树的节点       M&#x3D;1 非叶子节点个数</p>
<p>下面M行表示非叶子节点所跟的孩子  01 1 02    01表示 01号节点 ，1表示有一个孩子，02表示01的孩子的ID。</p>
<p><strong>题解</strong>：</p>
<p>第一步当然是想数据结构，用什么数据结构来存储这棵树呢？由于树的度不确定，我们很难使用二叉树的链式结构来存储，最初想到的是使用孩子兄弟链表进行存储，但最后发现构造这一棵树并不是太容易，而且我们只是需要统计每一层的非叶子节点数而已。我们不如直接使用结构体数组来存储这棵树，结构体包括ID，节点的孩子vector<int> child ，layer层数，这样我们统计每个节点是否是叶子节点的时候就可以使用child.size()来判断。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br></pre></td></tr></table></figure>

<p>其次就是有几个注意点：在分配内存空间的时候需要注意 如果是new，在堆上分配，内存的数据可以是任意的，意味着我们需要额外的初始化。如果使用Tseq[N+1]这种在栈上分配内存的状况，就可以不用初始化，这也导致我几个测试点过不了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">Tree_Node Tseq[N+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>还有一个坑点是，我们统计每一个节点的层数是，利用双亲节点的层数+1，这样有一个问题，要是先输入孩子节点，再输入双亲节点统计就有问题。<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20210405160649369.png" alt="image-20210405160649369" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以需要对输入的结点ID的大小进行排序，确保上层的节点先被统计进来。这样做法虽然有点蠢，但最后得了27分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">next_input</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numvec;</span><br><span class="line">&#125;next_input;</span><br><span class="line">vector&lt;next_input&gt; input_vector;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(next_input a,next_input b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;   cin&gt;&gt;N&gt;&gt;M;    <span class="comment">//N节点数  M非叶子节点数  </span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// Tree_Node* Tseq; </span></span><br><span class="line">    <span class="type">int</span> maxlayer;  <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">    Tree_Node Tseq[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        Tseq[i].ID = i;  <span class="comment">//分配序号</span></span><br><span class="line">    Tseq[<span class="number">1</span>].layer = <span class="number">1</span>;  <span class="comment">//01节点为根节点，层数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//把输入变成一个vector，然后再排序，以免计算层数时出错</span></span><br><span class="line">        next_input input;</span><br><span class="line">        <span class="type">int</span> id,num,child;  </span><br><span class="line">        cin&gt;&gt;id&gt;&gt;num;</span><br><span class="line">        input.id = id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;child;  input.numvec.<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        input_vector.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(input_vector.<span class="built_in">begin</span>(),input_vector.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//统计节点的层数和孩子</span></span><br><span class="line">        <span class="type">int</span> id,num,childnum;</span><br><span class="line">        id = input_vector[i].id;</span><br><span class="line">        num = input_vector[i].numvec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            childnum = input_vector[i].numvec[j];</span><br><span class="line">            Tseq[id].child.<span class="built_in">push_back</span>(childnum);</span><br><span class="line">            Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        maxlayer = <span class="built_in">max</span>(maxlayer,Tseq[i].layer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;  <span class="comment">//第i层有几个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxlayer;i++)&#123;</span><br><span class="line">        Map[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Tseq[i].child.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;   <span class="comment">//是叶子节点</span></span><br><span class="line">            Map[Tseq[i].layer]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ::iterator iter;</span><br><span class="line">    cout&lt;&lt;Map.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    iter = Map.<span class="built_in">begin</span>(); iter++;</span><br><span class="line">    <span class="keyword">for</span>(;iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405160805791.png" alt="image-20210405160805791"></p>
<p>最后一个测试点有点懵</p>
<p>如果考虑到只有一个节点的情况，if(N&#x3D;&#x3D;1){ cout&lt;&lt;”1”&lt;&lt;endl;return 0;} 这句话会根据出现在不同的位置而产生不同的结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405161716830.png" alt="image-20210405161716830"></p>
<h3 id="PAT-1005"><a href="#PAT-1005" class="headerlink" title="PAT 1005"></a>PAT 1005</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404205053583.png" alt="image-20210404205053583"></p>
<p>计算一个数的个位数字之和，英文输出。比较简单，十分钟搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string Map[] = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        count += (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ss = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ss;</span></span><br><span class="line">    cout&lt;&lt;Map[ss[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ss.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Map[ss[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1006"><a href="#PAT-1006" class="headerlink" title="PAT 1006"></a>PAT 1006</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404211724478.png" alt="image-20210404211724478"></p>
<p>水题，比较来上班最早的和来上班最晚的，直接写一个结构体比较就好了，二十分钟能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    string early;</span><br><span class="line">    string later;</span><br><span class="line">&#125;person;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpearly</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.early);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.early);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&lt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmplater</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.later);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.later);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&gt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt;  vec_person;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        person p;</span><br><span class="line">        cin&gt;&gt;p.id&gt;&gt;p.early&gt;&gt;p.later;</span><br><span class="line">        vec_person.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmpearly);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmplater);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1007（动态规划）"><a href="#PAT-1007（动态规划）" class="headerlink" title="PAT 1007（动态规划）"></a>PAT 1007（动态规划）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404222558427.png" alt="image-20210404222558427"></p>
<p>leetcode经典题，最大连续子序列和，一想就知道使用动态规划。</p>
<p>坑点1： output the one with the smallest indices i and j (as shown by the sample case). 这句话的意思是输出开始的数，而不是下标，整了一小时。</p>
<p>坑点2： If all the K numbers are negative, then its maximum sum is defined to be 0, and you  are supposed to output the first and the last numbers of the whole  sequence.  这句话记得看就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; seq.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[seq.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="type">int</span> pre[seq.<span class="built_in">size</span>()];</span><br><span class="line">    dp[<span class="number">0</span>] = seq[<span class="number">0</span>];  pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>,maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;seq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+seq[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = seq[i];</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsub)&#123;</span><br><span class="line">            maxsub = dp[i];  maxi = pre[i]; maxj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxsub&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxsub&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxi]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxj];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这儿的dp定义的略有不同，不过无伤大雅，dp[i]是指以i结尾的最大连续子序列和。</p>
<h3 id="PAT-1008"><a href="#PAT-1008" class="headerlink" title="PAT 1008"></a>PAT 1008</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404223852830.png" alt="image-20210404223852830"></p>
<p>水题。电梯上升一层6s，下降一层4s，每层有需要停留5s，求电梯所需要时间。十分钟解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; v.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//代表现在电梯到哪一层了</span></span><br><span class="line">    <span class="type">int</span> total_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((v[i]-temp)&gt;=<span class="number">0</span>)&#123;  <span class="comment">//上升</span></span><br><span class="line">            total_time += (v[i]-temp)*<span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//下降</span></span><br><span class="line">            total_time += (temp-v[i])*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = v[i];</span><br><span class="line">        total_time += <span class="number">5</span>; <span class="comment">//停留</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total_time;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1009"><a href="#PAT-1009" class="headerlink" title="PAT 1009"></a>PAT 1009</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210409154552498.png" alt="image-20210409154552498"></p>
<p>和pat1002类似，这里做的是乘法A * B,可以采用暴力法二重循环。</p>
<p>注意的是如果系数等于0则不输出。</p>
<p>不能使用cout&lt;&lt;M.size();  来统计输出的个数，因为会把系数为0的统计进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n]; <span class="type">double</span> b[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k; cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> ai; <span class="type">double</span> bi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> exponent = ai+a[j];</span><br><span class="line">            <span class="type">double</span> coefficient = bi*b[j];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(exponent)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                M[exponent] += coefficient;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                M[exponent] = coefficient;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;M.size();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1010（数学题）"><a href="#PAT-1010（数学题）" class="headerlink" title="PAT 1010（数学题）"></a>PAT 1010（数学题）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202035024.png" alt="image-20210410202035024"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202048687.png" alt="image-20210410202048687"></p>
<p>题目大意：N1 N2 tag radix</p>
<p>N1 N2 为两个数，基数未定，范围从[0-9] [a-z]，radix表示一个数的基数（tag&#x3D;1，则表示N1 的基数，tag&#x3D;2则表示N2的基数）我们要求另一个数的基数，使得N1&#x3D;N2。若不存在则输出”Impossible”。</p>
<p>最初的想法是把一个数的十进制算出来，另一个数从2 一直往上遍历，遍历到什么时候是个头呢，无从知晓。看了答案之后方才明白。</p>
<p><strong>进制范围的确定</strong>   （关键步骤+二分查找）</p>
<p>进制的最小取值为：各个位数最大值+1 如123的最小进制一定大于3， abc的最小进制一定大于12  （这个比较好理解）</p>
<p>现在来讨论进制的上限（max_radix）  (这个不好理解)<br>　　那么现在在题目中，给出了两个数，一个数记为a是已知进制的，另一个记为b未知，假设a&#x3D;675,为10进制，b&#x3D;1，未知进制<br>　　很显然，b的最低进制min_radix是2<br>　　那么b的最高进制max_radix 是多少呢<br>　　我们的目的是让a&#x3D;b，b不可过小也不可过大<br>　　<br>　　假设 max_radix&#x3D;1000<br>　　很显然b &#x3D; 1(1000) &#x3D; 1000 &gt; a &#x3D; 675<br>　　所以，发现了吗<br>　　想让a&#x3D;b，b的最大进制就是a的值,即675<br>　　因为我举的例子比较特殊，如果b不为1，那么就很难直接得到b的精确的最高进制max_radix<br>　　但是 ，可以肯定的是，当b为1 的时候，max_radix是最大的（因为此时b最小）<br>　　因此，我们虽然不知道b&#x3D;10,20,80,13671…时，对应的max_radix是多少，但是，他们一定比b&#x3D;1对应的max_radix小<br>　　那么我们就可以用最大的max_radix作为进制的上限，在min_radix 到max_radix中二分查找<br>　　同时需要注意，max_radix&gt;&#x3D;min_radix<br>　　故有 max_radix &#x3D; max(a,min_radix);</p>
<p><strong>坑点</strong>：</p>
<p>计算过程中会出现数据溢出。<br> 举个极端例子：<br> 一亿进制的zzzzzzzzzz转化为十进制。 即使用long long也无法保存。<br> 那么应该怎么判断呢？ 可以判断计算结束后的值是否小于0，因为溢出后的值一定小于0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202935463.png" alt="image-20210410202935463"></p>
<p>这一句显得至关重要，有6个测试点来自这。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">transfer_to_ten</span><span class="params">(string a,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll total=<span class="number">0</span>;</span><br><span class="line">    ll basement = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) total += (a[i]-<span class="string">&#x27;0&#x27;</span>)*basement;</span><br><span class="line">        <span class="keyword">else</span> total += (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>)*basement;</span><br><span class="line">        basement *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_base</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// if(a[i]&lt;=&#x27;9&#x27;) min_base = max(min_base,a[i]-&#x27;0&#x27;+1);</span></span><br><span class="line">        <span class="comment">// else min_base = max(min_base,a[i]-&#x27;a&#x27;+11);</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) min_base = min_base&gt;(a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>) ? min_base : (a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> min_base = min_base&gt;(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>) ? min_base : (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search_base</span><span class="params">(string a,<span class="type">int</span> min_base,<span class="type">int</span> max_base,<span class="type">long</span> <span class="type">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_base&lt;<span class="number">2</span>) min_base = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_base&gt;max_base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll mid_base = min_base + (max_base-min_base)/<span class="number">2</span>;</span><br><span class="line">    ll temp = <span class="built_in">transfer_to_ten</span>(a,mid_base);</span><br><span class="line">    <span class="keyword">if</span>(temp==target) <span class="keyword">return</span> mid_base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target || temp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">search_base</span>(a,min_base,mid_base<span class="number">-1</span>,target);  <span class="comment">//关键 temp可能会溢出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search_base</span>(a,mid_base+<span class="number">1</span>,max_base,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    string cc;</span><br><span class="line">    ll tag,radix;</span><br><span class="line">    ll target;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(a,radix);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;radix;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;target: &quot;&lt;&lt;target&lt;&lt;endl;</span></span><br><span class="line">        cc = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(b,radix);</span><br><span class="line">        cc = a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll min_base = <span class="built_in">find_min_base</span>(cc);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;min_base: &quot;&lt;&lt;min_base&lt;&lt;endl;</span></span><br><span class="line">    ll max_base = target&gt;min_base ? target : min_base;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;max_base: &quot;&lt;&lt;max_base&lt;&lt;endl;</span></span><br><span class="line">    ll mid_base = <span class="built_in">search_base</span>(cc,min_base,max_base,target);</span><br><span class="line">    <span class="keyword">if</span>(mid_base) cout&lt;&lt;mid_base;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410203111819.png" alt="image-20210410203111819"></p>
<p>第10个测试点据说是：10测试点是输入为0<br> 当其中一个输入为0时，base若等于最大数字加1则为1，但我们知道进制的最小值为2，故在搜索前需要进行检查。（不太清楚）</p>
<h3 id="PAT-1011"><a href="#PAT-1011" class="headerlink" title="PAT 1011"></a>PAT 1011</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153118330.png" alt="image-20210422153118330"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153134396.png" alt="image-20210422153134396"></p>
<p>给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大。每一场都选最大的。无脑题，关键在于读懂题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ca</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> pro;</span><br><span class="line">&#125;ca;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ca a,ca b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pro&gt;b.pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>]=&#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"><span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ca&gt;&gt; <span class="built_in">v</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            ca d; </span><br><span class="line">            cin&gt;&gt;d.pro;</span><br><span class="line">            d.a = a[j];</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        res *= v[i][<span class="number">0</span>].pro;</span><br><span class="line">        cout&lt;&lt;v[i][<span class="number">0</span>].a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1012"><a href="#PAT-1012" class="headerlink" title="PAT 1012"></a>PAT 1012</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163238958.png" alt="image-20210422163238958"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163249988.png" alt="image-20210422163249988"></p>
<p>这一题竟然解决了一个小时。</p>
<p>题目大意：输入学生 以及三门课的成绩，然后每输入一个学生的id就打印最高的排名和对应排名的分类。排名分成三门课的单独排名和平均分的排名。排名也有优先级，A&gt;C&gt;M&gt;E。还算模拟题吧。</p>
<p>我的思路是建立一个学生表Map[string , stu]；stu包含学生的信息，包括成绩，排名等等。在第一波输入的时候，我们可以将成绩信息，填入学生表，同时将每科的成绩分门别列进行排序，第二轮遍历学生表Map时我们按照成绩查找对应的排名，本来想用二分查找，（但也必须是改进的二分查找，查找目标&#x3D;&#x3D;target的最小边界）。然后printinfo函数输出每个学生的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    string ID;</span><br><span class="line">    <span class="type">int</span> C,M,E,A;  <span class="comment">//成绩</span></span><br><span class="line">    <span class="type">int</span> rC,rM,rE,rA;  <span class="comment">//排名</span></span><br><span class="line">&#125;stu;</span><br><span class="line">map&lt;string,stu&gt; Map;  <span class="comment">//学生表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; CC;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; MM;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; EE;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AA;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int binary_search(vector&lt;int&gt; A,int target,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">//     if(l&gt;r) return -2;</span></span><br><span class="line"><span class="comment">//     int mid = (l+r)/2;</span></span><br><span class="line"><span class="comment">//     if(A[mid]==target) return mid+1;</span></span><br><span class="line"><span class="comment">//     if(A[mid]&gt;target) return binary_search(A,target,mid+1,r);</span></span><br><span class="line"><span class="comment">//     else return binary_search(A,target,l,mid-1);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]==target) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstu</span><span class="params">(stu S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.rA&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rA&lt;&lt;<span class="string">&quot; A&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rC&lt;=<span class="built_in">min</span>(S.rA,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rC&lt;&lt;<span class="string">&quot; C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rM&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rA)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rM&lt;&lt;<span class="string">&quot; M&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rE&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rA,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rE&lt;&lt;<span class="string">&quot; E&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string a; <span class="type">int</span> b,c,d;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        CC.<span class="built_in">push_back</span>(b);   MM.<span class="built_in">push_back</span>(c);  </span><br><span class="line">        EE.<span class="built_in">push_back</span>(d); </span><br><span class="line">        <span class="type">int</span> aver = (<span class="type">int</span>)((<span class="type">double</span>)(b+c+d)/<span class="number">3.0</span>+<span class="number">0.5</span>);</span><br><span class="line">        AA.<span class="built_in">push_back</span>(aver);</span><br><span class="line">        stu temp; </span><br><span class="line">        temp.ID = a; temp.C=b; temp.M=c; temp.E=d; temp.A=aver;</span><br><span class="line">        Map[a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(CC.<span class="built_in">begin</span>(),CC.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(EE.<span class="built_in">begin</span>(),EE.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(MM.<span class="built_in">begin</span>(),MM.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(AA.<span class="built_in">begin</span>(),AA.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    map&lt;string,stu&gt; :: iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="comment">// int a = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rA = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rC = binary_search(CC,iter-&gt;second.C,0,CC.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rE = binary_search(EE,iter-&gt;second.E,0,EE.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rM = binary_search(MM,iter-&gt;second.M,0,MM.size()-1);</span></span><br><span class="line">        iter-&gt;second.rA = <span class="built_in">search</span>(AA,iter-&gt;second.A);</span><br><span class="line">        iter-&gt;second.rC = <span class="built_in">search</span>(CC,iter-&gt;second.C);</span><br><span class="line">        iter-&gt;second.rE = <span class="built_in">search</span>(EE,iter-&gt;second.E);</span><br><span class="line">        iter-&gt;second.rM = <span class="built_in">search</span>(MM,iter-&gt;second.M);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string s;  cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(s)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printstu</span>(Map[s]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163816564.png" alt="image-20210422163816564"></p>
<h3 id="PAT-1013（连通分量）"><a href="#PAT-1013（连通分量）" class="headerlink" title="PAT 1013（连通分量）"></a>PAT 1013（连通分量）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172221670.png" alt="image-20210422172221670"></p>
<p>题意：给出城市个数为N，连接城市间的道路的条数为M，以及询问次数为K</p>
<p>然后输入这M条道路连接的两个端点城市的编号Ａ和Ｂ</p>
<p>然后是K次询问，每次询问的方法是：给出一个编号为Q城市，然后将这个城市和与其相连的道路从网络中删除，要求让你求出添加多少条道路，才能使得被删除了编号为Q的城市的网络仍然联通</p>
<p>转化成求连通分量个数。即图的遍历，我这里使用广度优先搜索遍历图，求连通分量k。</p>
<p>bfs(int node)；除去node结点的连通分量，从1..N遍历结点，设置一个visited数组表示该结点是否访问过。如果访问过则记作1.k++，然后是用一个栈广度优先搜索该连通分量中可以到达的结点。</p>
<p>最后需要增加的路径&#x3D;连通分量个数-1</p>
<p>注意：每一次考虑新的结点的时候visited必须复位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//1..N 0不用</span></span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">int</span> k;  <span class="comment">//连通分量个数</span></span><br><span class="line"><span class="type">int</span> **Graph;   <span class="comment">//Graph  1..N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;   <span class="comment">//不考虑node结点,求连通分量个数k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==node) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==node) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Graph[top][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                    visited[j]=<span class="number">1</span>;</span><br><span class="line">                    S.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="comment">//visited数组初始化，表示没有访问过</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph初始化</span></span><br><span class="line">    Graph = <span class="keyword">new</span> <span class="type">int</span>*[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Graph[i] = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(Graph[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(Graph[i]));  <span class="comment">//Graph[i][u] = 0代表i,u之间没有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">        Graph[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// memset(visited,0,sizeof(visited));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) visited[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(a);</span><br><span class="line">        cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=K<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 5 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">2 1 3 4 5 6 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172806405.png" alt="image-20210422172806405"></p>
<h3 id="PAT-1014-队列模拟"><a href="#PAT-1014-队列模拟" class="headerlink" title="PAT 1014 (队列模拟)"></a>PAT 1014 (队列模拟)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174327230.png" alt="image-20210422174327230"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174337754.png" alt="image-20210422174337754"></p>
<p><strong>题目大意</strong>：银行有N个窗口，每个窗口划分成两部分，黄线内的和黄线外的</p>
<p>顾客排队有以下几个要求：</p>
<p>1、每个窗口黄线内可以站M个人，第（MN+1)个人得排在黄线外</p>
<p>2、每个顾客选择最短的队伍，（队伍长度相同选择序号小的）</p>
<p>3、顾客i将花费 Ti 的时间处理问题</p>
<p>3、每个窗口的第一位顾客将于8:00被服务</p>
<p>给定每个顾客的处理问题的时间，求每位顾客解决问题的时间点。</p>
<p>输入：第一行 N(窗口）、M（黄线内的人数）、K（顾客人数）、Q（要求的顾客完成时间）  五点之前下班</p>
<p><strong>思路</strong>：用一个vector表示一个窗口，窗口里是一个queue<int>表示窗口队列，首先初始化窗口，之后模拟每一次完成（查找所有窗口剩余时间最少的出队，如果还有人在黄线外等候则加入该窗口的队列，然后更新每个窗口front元素的剩余时间）。持续下去直到所有窗口都为空。 用一个变量nowtime记录当前时间，也即每个顾客的完成时间。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M,K,Q;  <span class="comment">//N 窗口  M 黄线内人数  K 顾客人数  Q 询问时间</span></span><br><span class="line"><span class="type">int</span> Time[<span class="number">1001</span>];   <span class="comment">//表示第i位顾客还剩多少时间完成</span></span><br><span class="line"><span class="type">int</span> process[<span class="number">1001</span>];   <span class="comment">//最多有1001个顾客，time表示第i个顾客的完成时间，单位分钟</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Custom;  <span class="comment">//顾客队列,按照编号进行</span></span><br><span class="line">vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; Window; <span class="comment">//窗口vector，每个窗口维护一个队列，队列长度不超过M</span></span><br><span class="line"><span class="type">int</span> nowtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断所有窗口是否还有人在排队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isemptyWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最早出队的窗口号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mintime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_time = <span class="number">9999</span>; </span><br><span class="line">    <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>() &amp;&amp; Time[Window[i].<span class="built_in">front</span>()]&lt;min_time)&#123;</span><br><span class="line">            min_time = Time[Window[i].<span class="built_in">front</span>()];</span><br><span class="line">            min_i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新每个窗口的出队时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> subtime,<span class="type">int</span> t)</span></span>&#123;  <span class="comment">//subtime减去的时间，t除外</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=t &amp;&amp; !Window[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Time[Window[i].<span class="built_in">front</span>()] -= subtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_to_clock</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour = time/<span class="number">60</span>+<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> minn = time%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;<span class="number">17</span> || (hour==<span class="number">17</span>&amp;&amp;minn&gt;<span class="number">0</span>)) cout&lt;&lt;<span class="string">&quot;Sorry&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>,hour,minn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> pCustom = <span class="number">1</span>;  <span class="comment">//顾客指针，在pCustom之前的都已经安排到Windows黄线内去了</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Time[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//初始化窗口</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;  Window.<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口队列</span></span><br><span class="line">    <span class="keyword">while</span>(pCustom&lt;=N*M &amp;&amp; pCustom&lt;=K)&#123;</span><br><span class="line">        Window[(pCustom+<span class="number">1</span>)%M].<span class="built_in">push</span>(pCustom);  <span class="comment">//按照顺序每个窗口依次安排人</span></span><br><span class="line">        pCustom++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isemptyWindow</span>())&#123;</span><br><span class="line">        <span class="type">int</span> min_i = <span class="built_in">mintime</span>();  <span class="comment">//最早出队的窗口号</span></span><br><span class="line">        <span class="type">int</span> subtime = Time[Window[min_i].<span class="built_in">front</span>()];  <span class="comment">//需要更新的时间</span></span><br><span class="line">        nowtime += subtime;   <span class="comment">//更新当前时间</span></span><br><span class="line">        process[Window[min_i].<span class="built_in">front</span>()] = nowtime;   <span class="comment">//记录该顾客已经完成</span></span><br><span class="line">        Window[min_i].<span class="built_in">pop</span>();  <span class="comment">//当前窗口出队</span></span><br><span class="line">        <span class="keyword">if</span>(pCustom&lt;=K)&#123;</span><br><span class="line">            Window[min_i].<span class="built_in">push</span>(pCustom);   <span class="comment">//加入新元素</span></span><br><span class="line">            pCustom++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(subtime,min_i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">time_to_clock</span>(process[a]);</span><br><span class="line">        <span class="keyword">if</span>(i!=Q<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193023153.png" alt="image-20210422193023153"></p>
<p>看答案发现五点前还没处理完的不可能赶人家走吧，所以修改了一下代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193841669.png" alt="image-20210422193841669"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193858472.png" alt="image-20210422193858472"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193918612.png" alt="image-20210422193918612"></p>
<p>参考了网上的AC代码，还是没看出来自己为什么错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> win_num, win_len, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;win_num, &amp;win_len, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">times</span>(win_num); <span class="comment">//times按顺序记录每个窗口中排队的人的结束时间，用以标示下一个进入的人的开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n)</span>, <span class="title">start_time</span><span class="params">(n)</span></span>; <span class="comment">//data记录每个用户的耗时，start_time记录每个用户的开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i&lt;win_num*win_len; i++)&#123;  <span class="comment">//先把黄线内的人排队排好</span></span><br><span class="line">        <span class="type">int</span> t = i%win_num; <span class="comment">//第t个窗口</span></span><br><span class="line">        start_time[i] = i&lt;win_num?<span class="number">0</span>:times[t][i/win_num<span class="number">-1</span>]; <span class="comment">//第一排的开始时间是0，之后的开始时间是前一排的结束时间，从times中获取</span></span><br><span class="line">        times[t].<span class="built_in">push_back</span>(start_time[i]+data[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=win_num*win_len; i&lt;n; i++)&#123;  <span class="comment">//黄线外的人进入队伍</span></span><br><span class="line">        <span class="type">int</span> mint=<span class="number">540</span>, w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;win_num; j++)&#123;  <span class="comment">//选择队伍，按队伍中size()-win_len个人的最早开始时间选择</span></span><br><span class="line">            <span class="type">int</span> st = times[j][times[j].<span class="built_in">size</span>()-win_len];</span><br><span class="line">            <span class="keyword">if</span>(st&lt;mint)&#123;</span><br><span class="line">                mint = st;</span><br><span class="line">                w = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">-1</span>) start_time[i] = <span class="number">540</span>; <span class="comment">//没窗口选，全都已经超时，按540计</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start_time[i] = times[w][times[w].<span class="built_in">size</span>()<span class="number">-1</span>]; <span class="comment">//计算开始时间</span></span><br><span class="line">            times[w].<span class="built_in">push_back</span>(start_time[i]+data[i]); <span class="comment">//排队进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(start_time[x]&gt;=<span class="number">540</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (start_time[x]+data[x])/<span class="number">60</span>+<span class="number">8</span>, (start_time[x]+data[x])%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PAT-1015"><a href="#PAT-1015" class="headerlink" title="PAT 1015"></a>PAT 1015</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210426090709927.png" alt="image-20210426090709927"></p>
<p>最初这题题目没看懂</p>
<p>题目大意：给出一个素数，判断在d进制下反转后在十进制下是否是素数，如果是，则输出”Yes”，否，则输出”No”。</p>
<p>Sample input:</p>
<p>73 在十进制下反转 37</p>
<p>23(10111) 在2进制下反转(11101) 29 是质数</p>
<p>23在10进制下反转32不是质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//判断n是否是素数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>) <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> zNum = <span class="number">0</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//转换为p进制</span></span><br><span class="line">        z[zNum++] = n % d;</span><br><span class="line">        n /=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zNum; ++i) &#123;<span class="comment">//逆序转为10进制</span></span><br><span class="line">        n = n * d + z[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">true</span>)&#123;<span class="comment">//是素数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;<span class="comment">//是负数，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Check</span>(n, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1016"><a href="#PAT-1016" class="headerlink" title="PAT 1016"></a>PAT 1016</h3><p>题目大意： 打长途电话每分钟要花一定的费用，这取决于一天中打电话的时间。当客户开始连接长途电话时，时间会被记录下来，客户挂断电话的时间也会被记录下来。每个日历月，每一分钟都会向客户发送一张账单（按一天中的时间确定的费率）。你的工作是准备每个月的账单，给你一套电话记录。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210429204459301.png" alt="image-20210429204459301"></p>
<h3 id="PAT-1039"><a href="#PAT-1039" class="headerlink" title="PAT 1039"></a>PAT 1039</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182936179.png" alt="image-20210420182936179"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182949322.png" alt="image-20210420182949322"></p>
<p>题目大意：有一个表保存了学生的选课信息，根据学生姓名来查询信息，输出该名学生选课情况。</p>
<p>样例解释，有11个学生，共5门课，接下来10行表示每门课的选课情况，例如2,3行，第4门课（4是课程号），7个人选，选课名单BOB5…</p>
<p>最后一行按顺序输出学生的名单。结果输出每个学生的名字，选课门数和课程号。</p>
<p>思路比较清楚，我定义的数据结构还算比较复杂</p>
<p>Query_List 代表学生的选课列表（索引就代表学号），Course_List代表课程的学生列表。</p>
<p>我们先把数据读入课程列表中，再用一个Map将学生的名字和学号一一对应。然后遍历Course_List，查到Course_List的学生选的哪门课就往Query_List中添加。最后将Query_List中的list排序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br></pre></td></tr></table></figure>

<p>坑点：最后一个测试数据比较大，据说要用scanf和printf，或者用char</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;Course_List&gt; CList;</span><br><span class="line">    vector&lt;Query_List&gt; QList;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> i1,i2;  </span><br><span class="line">        string i3;  </span><br><span class="line">        cin&gt;&gt;i1&gt;&gt;i2;</span><br><span class="line">        Course_List C; </span><br><span class="line">        C.cno = i1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;i2;i++)&#123;</span><br><span class="line">            cin&gt;&gt;i3;  </span><br><span class="line">            C.name.<span class="built_in">push_back</span>(i3);</span><br><span class="line">        &#125;</span><br><span class="line">        CList.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name;  cin&gt;&gt;name;</span><br><span class="line">        M[name] = i;</span><br><span class="line">        Query_List Q;  Q.name = name;</span><br><span class="line">        QList.<span class="built_in">push_back</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;CList[i].name.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//M[CList[i].name[j]].list.push_back(CList[i].cno);</span></span><br><span class="line">            QList[M[CList[i].name[j]]].list.<span class="built_in">push_back</span>(CList[i].cno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;QList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(QList[i].list.<span class="built_in">begin</span>(),QList[i].list.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;QList[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;QList[i].list.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=QList.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420183645306.png" alt="image-20210420183645306"></p>
<h3 id="PAT-1040（dp"><a href="#PAT-1040（dp" class="headerlink" title="PAT 1040（dp)"></a>PAT 1040（dp)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420235614633.png" alt="image-20210420235614633"></p>
<p>题目大意：查询长度最长的对称串</p>
<p>动态规划，dp[i] [j] 表示从 i 开始到 j 结束的对称串。（ i&lt;&#x3D;j ） </p>
<p>dp[i] [i] &#x3D; 1;</p>
<p>dp [i] [i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</p>
<p>dp[i] [i+k] &#x3D; (s[i] &#x3D;&#x3D; s[i+k] &amp;&amp; dp[i+1] [i+k-1] )</p>
<p>i，j的状态取决于 i+1,j-1是不是对称串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> dp[length][length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="built_in">memset</span>(dp[i],<span class="literal">false</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    <span class="type">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//Initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) &#123;dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>; maxlength=<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;length;k++)&#123;  <span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length &amp;&amp; i+k&lt;length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+k] &amp;&amp; dp[i+<span class="number">1</span>][i+k<span class="number">-1</span>]==<span class="literal">true</span>)&#123; </span><br><span class="line">                dp[i][i+k]=<span class="literal">true</span>;</span><br><span class="line">                maxlength=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="PAT-1041"><a href="#PAT-1041" class="headerlink" title="PAT 1041"></a>PAT 1041</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233542571.png" alt="image-20210420233542571"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233553640.png" alt="image-20210420233553640"></p>
<p>题目大意，找到最近的一个不重复的数，如果找不到输出none。</p>
<p>直接一个map存放出现的次数，之后再从前往后遍历。无脑题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> unicode;</span><br><span class="line">    <span class="type">int</span> Map[<span class="number">50000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">0</span>,<span class="built_in">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a ;cin&gt;&gt;a;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a);</span><br><span class="line">        Map[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(!unique &amp;&amp; j&lt;A.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[A[j]]==<span class="number">1</span>)&#123;</span><br><span class="line">            unique = <span class="literal">true</span>;</span><br><span class="line">            unicode = A[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unique) cout&lt;&lt;unicode;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1081"><a href="#PAT-1081" class="headerlink" title="PAT 1081"></a>PAT 1081</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210423091333960.png" alt="image-20210423091333960"></p>
<p>简单题，模拟分数乘法操作。</p>
<p>注意点：题目准确说明数的范围是Long ing型，第四个测试点出现浮点错误，需要判断一下分母为0的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fenzi[N]; <span class="type">long</span> <span class="type">long</span> fenmu[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,&amp;fenzi[i],&amp;fenmu[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> denominator = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) denominator *= fenmu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) numerator += denominator/fenmu[i]*fenzi[i];</span><br><span class="line">    <span class="keyword">if</span>(denominator==<span class="number">0</span>)&#123;  <span class="comment">//这里一定要判断一下，第四个测试点可能会出现浮点错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> interger = numerator/denominator;</span><br><span class="line">    <span class="keyword">if</span>(interger) cout&lt;&lt;interger;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re_numerator = numerator - interger*denominator;</span><br><span class="line">    <span class="keyword">if</span>(re_numerator)&#123;</span><br><span class="line">        <span class="keyword">if</span>(interger) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(re_numerator,denominator);</span><br><span class="line">        re_numerator /= g;    denominator/= g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,re_numerator,denominator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2021-7-10"><a href="#2021-7-10" class="headerlink" title="2021.7.10"></a>2021.7.10</h2><h3 id="PAT-1152"><a href="#PAT-1152" class="headerlink" title="PAT 1152"></a>PAT 1152</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153004327.png" alt="image-20210710153004327"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153023441.png" alt="image-20210710153023441"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153032898.png" alt="image-20210710153032898"></p>
<p>题目大意：给定一个N位的数，寻找第一次出现的m位素数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(LL t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL s = <span class="number">2</span>; s&lt;<span class="built_in">sqrt</span>(t) ;s++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i++)&#123;</span><br><span class="line">        res = s.<span class="built_in">substr</span>(i,n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issushu</span>(<span class="built_in">stoi</span>(res)))&#123;</span><br><span class="line">            cout&lt;&lt;res;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153216499.png" alt="image-20210710153216499"></p>
<h3 id="PAT-1153"><a href="#PAT-1153" class="headerlink" title="PAT 1153"></a>PAT 1153</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210514325.png" alt="image-20210710210514325"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210537819.png" alt="image-20210710210537819"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210558121.png" alt="image-20210710210558121"></p>
<p>题目大意：给出一组学生的准考证号和成绩，准考证号包含了等级(乙甲顶)，考场号，日期，和个人编号信息，并有三种查询方式<br>查询一：给出考试等级，找出该等级的考生，按照成绩降序，准考证升序排序<br>查询二：给出考场号，统计该考场的考生数量和总得分<br>查询三：给出考试日期，查询改日期下所有考场的考试人数，按照人数降序，考场号升序排序<br><strong>修改前的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;p1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    <span class="keyword">if</span>(M.<span class="built_in">find</span>(cc)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        M[cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        M[cc] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">dic1</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;dic1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;N<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710211717494.png" alt="image-20210710211717494"></p>
<p>改后发现格式不需要那么复杂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1.second==o2.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.first&lt;o2.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; </span><br><span class="line">                    total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    M[cc] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; dic1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : M) dic1.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it.first, it.second));</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一格多一个换行也没关系</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710220609566.png" alt="image-20210710220609566"></p>
<p><strong>修改后的AC代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testees</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;testees;</span><br><span class="line">vector&lt;testees&gt; t;</span><br><span class="line"><span class="type">int</span> N,M,type;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(testees a,testees b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,t[i].id.<span class="built_in">c_str</span>(),t[i].score);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>))&#123;</span><br><span class="line">                sum += t[i].score;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>))&#123;</span><br><span class="line">                mp[t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">vec_mp</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec_mp.<span class="built_in">begin</span>(),vec_mp.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec_mp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,vec_mp[i].first.<span class="built_in">c_str</span>(),vec_mp[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        testees ta;</span><br><span class="line">        cin&gt;&gt;ta.id&gt;&gt;ta.score;</span><br><span class="line">        t.<span class="built_in">push_back</span>(ta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>,i,type,s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">deal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710215520857.png" alt="image-20210710215520857"></p>
<h3 id="PAT-1154"><a href="#PAT-1154" class="headerlink" title="PAT 1154"></a>PAT 1154</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222438518.png" alt="image-20210710222438518"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222450152.png" alt="image-20210710222450152"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222458698.png" alt="image-20210710222458698"></p>
<p>题目大意：</p>
<p>相邻的两边不能同色，不用邻接矩阵，直接用边进行判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Graph</span><span class="params">(V,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> query; cin&gt;&gt;query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;query;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">            Graph[i] = a;</span><br><span class="line">            M[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[Edge[i].first] == Graph[Edge[i].second])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;-coloring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222553175.png" alt="image-20210710222553175"></p>
<h3 id="PAT-1155（回溯）"><a href="#PAT-1155（回溯）" class="headerlink" title="PAT 1155（回溯）"></a>PAT 1155（回溯）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230530365.png" alt="image-20210710230530365"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230546043.png" alt="image-20210710230546043"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230612772.png" alt="image-20210710230612772"></p>
<p>题目大意：给定一个二叉树，判断是不是大顶堆或小顶堆，并且输出路径，从右到左输出，可以利用回溯法解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> MAX_OR_MIN;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&gt;N)&#123;   <span class="comment">//到头了，输出路径</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    V.<span class="built_in">resize</span>(N+<span class="number">1</span>);  <span class="comment">//下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;  <span class="comment">//确定大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&gt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&lt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(V[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">backtrace</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==res[i].<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230634645.png" alt="image-20210710230634645"></p>
<h2 id="2021-7-17"><a href="#2021-7-17" class="headerlink" title="2021.7.17"></a>2021.7.17</h2><h3 id="PAT-1148"><a href="#PAT-1148" class="headerlink" title="PAT 1148"></a>PAT 1148</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174748111.png" alt="image-20210717174748111"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174800947.png" alt="image-20210717174800947"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174812459.png" alt="image-20210717174812459"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174821796.png" alt="image-20210717174821796"></p>
<p>题目大意：狼人杀，给出N个人，其中只有两个是狼人，找出狼人，其中所有人中有两个人说谎，说谎的人里包含一个狼人。</p>
<p>本来是想通过假设说谎的人数 i,j  来找到狼人，后来发现通过假定狼人i,j来验证是否成立来得更加方便。整了一个半小时了都。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Data</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> istrue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;   <span class="comment">//i,j是werewolf,其他是human</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i || k==j) output[k] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> output[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始验证</span></span><br><span class="line">            <span class="type">int</span> fa = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> wefa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[k] * output[<span class="built_in">abs</span>(Data[k])]&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">                     fa++;</span><br><span class="line">                     <span class="keyword">if</span>(k==i || k==j) wefa++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa==<span class="number">2</span> &amp;&amp; wefa==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717175023186.png" alt="image-20210717175023186"></p>
<h3 id="PAT-1149"><a href="#PAT-1149" class="headerlink" title="PAT 1149"></a>PAT 1149</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193857126.png" alt="image-20210717193857126"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193908755.png" alt="image-20210717193908755"></p>
<p>题目大意：集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No～</p>
<p>分析：用map存储每一个货物的所有不兼容货物～在判断给出的一堆货物是否是相容的时候，判断任一货物的不兼容货物是否在这堆货物中～如果存在不兼容的货物，则这堆货物不能相容～如果遍历完所有的货物，都找不到不兼容的两个货物，则这堆货物就是兼容的～</p>
<p>用map存储每一个货物的所有不相容货物，然后逐一进行比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(a)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(b);</span><br><span class="line">            Map[a] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(b)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(a);</span><br><span class="line">            Map[b] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(Q)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;Q;k++)&#123;</span><br><span class="line">            cin&gt;&gt;res[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;res.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jj=<span class="number">0</span>;jj&lt;res.<span class="built_in">size</span>();jj++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ii==jj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Map.<span class="built_in">find</span>(res[ii])== Map.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vector&lt;string&gt; temp = Map[res[ii]];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> zz=<span class="number">0</span>;zz&lt;temp.<span class="built_in">size</span>();zz++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp[zz]==res[jj])&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193955512.png" alt="image-20210717193955512"></p>
<p>修改后，在查找是否兼容这一部分，需要通过map定位到该值所在的结点，然后往节点后的链表顺序查找，这样可能比较浪费时间。</p>
<p>牺牲空间的方法，首先开辟一个大空间res，存放所有可能的物品，每遍历一个物品，就往res中添入不可兼容的物品，之后再查找时，如果在res中，则不可兼容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(res[x]==<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            res[x] = <span class="number">1</span>;   <span class="comment">//表示不兼容  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Map[x].<span class="built_in">size</span>();j++)</span><br><span class="line">                res[Map[x][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717202436733.png" alt="image-20210717202436733"></p>
<h3 id="PAT-1150"><a href="#PAT-1150" class="headerlink" title="PAT 1150"></a>PAT 1150</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210722721.png" alt="image-20210717210722721"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210738857.png" alt="image-20210717210738857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210750029.png" alt="image-20210717210750029"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210800815.png" alt="image-20210717210800815"></p>
<p>题目大意：旅行商问题，给定一个图，并给定路径，判断该路径是否满足一下条件：</p>
<p>Ts a simple cycle 每个城市只访问一次，并且回到远点</p>
<p>Not a TS cycle 没有访问到每个城市，或者没有回到原点</p>
<p>NA not a TS cycle  路径不可达</p>
<p>TS cycle  多次访问每个城市</p>
<p>然后求距离最短的路径。</p>
<p>思路：构建邻接矩阵，一个visited数组判断是否访问过，按照路径一次模拟一遍即可，水题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> shortest = INT_MAX;  <span class="comment">//存放最短路径</span></span><br><span class="line">    <span class="type">int</span> shortestindex = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d1,d2,dist; cin&gt;&gt;d1&gt;&gt;d2&gt;&gt;dist;</span><br><span class="line">        Graph[d1][d2] = dist;</span><br><span class="line">        Graph[d2][d1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T; cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=T;kk++)&#123;</span><br><span class="line">        <span class="type">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//0 可达性  1 是否都访问过  2  是否多次访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> C;  cin&gt;&gt;C;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(C+<span class="number">1</span>)</span></span>;   <span class="comment">//路径也从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visited[path[1]] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[path[i]][path[i+<span class="number">1</span>]]==<span class="number">0</span>) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total_cost += Graph[path[i]][path[i+<span class="number">1</span>]];</span><br><span class="line">                visited[path[i]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;visited.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) flag[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//没有访问过,flag=1 Not a TS cycle</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]&gt;<span class="number">1</span>) flag[<span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//多次访问  TS cycle;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="keyword">if</span>(!flag[<span class="number">0</span>] &amp;&amp; !flag[<span class="number">1</span>] &amp;&amp; !flag[<span class="number">2</span>] &amp;&amp; path[<span class="number">1</span>]==path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>,kk);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">1</span>] || path[<span class="number">1</span>]!=path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest Dist(%d) = %d&quot;</span>,shortestindex,shortest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210659132.png" alt="image-20210717210659132"></p>
<h3 id="PAT-1151"><a href="#PAT-1151" class="headerlink" title="PAT 1151"></a>PAT 1151</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190008683.png" alt="image-20210718190008683"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190019702.png" alt="image-20210718190019702"></p>
<p>题目大意：给出中序序列和先序序列，再给出两个点，求这两个点的最近公共祖先～</p>
<p>柳神题解：不用建树～已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。中序加先序可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点，在此时并入lca算法可以确定两个结点的公共祖先～</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,<span class="type">int</span> node1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> pre_right,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,pre_left+<span class="number">1</span>,mid_position,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,mid_position+<span class="number">1</span>,pre_right,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190202986.png" alt="image-20210718190202986"></p>
<p>问题出在递归过程中变量设置太多，导致递归栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(vector&lt;int&gt; preorder,vector&lt;int&gt; inorder,int node1,</span><br><span class="line">    int node2,int pre_left,int pre_right,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>改成，将preorder,inorder设置成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(int node1,int node2,int pre_left,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,pre_left+<span class="number">1</span>,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,mid_position+<span class="number">1</span>,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(node1,node2,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190952587.png" alt="image-20210718190952587"></p>
<h2 id="2021-7-24"><a href="#2021-7-24" class="headerlink" title="2021.7.24"></a>2021.7.24</h2><h3 id="PAT-1144"><a href="#PAT-1144" class="headerlink" title="PAT 1144"></a>PAT 1144</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103108325.png" alt="image-20210724103108325"></p>
<p>题目大意：给一个数串，找到数串中没有出现的最小正整数</p>
<p>思路：用一个长度为N的哈希表就可以了，因为最小整数不可能超过N，符合条件就放入，不符合条件就跳过，最后从1开始遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(N+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;=<span class="number">1</span> &amp;&amp; L[i]&lt;=N)</span><br><span class="line">            M[L[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103224067.png" alt="image-20210724103224067"></p>
<h3 id="PAT-1145"><a href="#PAT-1145" class="headerlink" title="PAT 1145"></a>PAT 1145</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724143956305.png" alt="image-20210724143956305"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144007126.png" alt="image-20210724144007126"></p>
<p>题目大意：</p>
<p>（quadratic：平方的）</p>
<p><strong>给定一个序列，用平方探测法（只用正数）解决哈希冲突，然后给出m个数字（皆为正数），如果这个数字不能够被插入就输出”X cannot be inserted.”，然后输出这m个数字的平均查找次数</strong></p>
<p>思路：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144235052.png" alt="image-20210724144235052"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//0  1  2  3  4</span></span><br><span class="line"><span class="comment">//10 6  11    4</span></span><br><span class="line"><span class="comment">//11 2次  4 1次  15 6次  2 2次</span></span><br><span class="line"><span class="comment">//11/4 = 2.8</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Msize,N,M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;Msize&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isprime</span>(Msize)) Msize++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Hash</span><span class="params">(Msize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构建哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断插入不成功？</span></span><br><span class="line">            <span class="keyword">if</span>(Hash[(a+j*j)%Msize]==<span class="number">0</span>)&#123;</span><br><span class="line">                Hash[(a+j*j)%Msize] = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==Msize) <span class="built_in">printf</span>(<span class="string">&quot;%d cannot be inserted.\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均查找次数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断找不到?</span></span><br><span class="line">            <span class="type">int</span> t = (b+j*j)%Msize;</span><br><span class="line">            <span class="keyword">if</span>(Hash[t]==b || Hash[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">        sum += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum/M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144253395.png" alt="image-20210724144253395"></p>
<h3 id="PAT-1146"><a href="#PAT-1146" class="headerlink" title="PAT 1146"></a>PAT 1146</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150143550.png" alt="image-20210724150143550"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150158871.png" alt="image-20210724150158871"></p>
<p>题目大意：判断一个序列是不是拓扑序列。</p>
<p>思路：构建邻接矩阵，计算入度，根据给出序列判断入度是否为0，然后将以该顶点为起点的边的终点的入度—1,依次判断下一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  <span class="comment">//N:定点数 M：边数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个顶点的入度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[j][i]==<span class="number">1</span>) in++;</span><br><span class="line">        &#125;</span><br><span class="line">        indegree[i] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为拓扑序列</span></span><br><span class="line">    <span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree1</span><span class="params">(indegree)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree1[seq[j]]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Graph[seq[j]][k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        indegree1[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150354679.png" alt="image-20210724150354679"></p>
<h3 id="PAT-1147"><a href="#PAT-1147" class="headerlink" title="PAT 1147"></a>PAT 1147</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153528563.png" alt="image-20210724153528563"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153541846.png" alt="image-20210724153541846"></p>
<p>题目大意：给定一个完全二叉树，要求判断是否是大顶堆或小顶堆，并给出该二叉树的后序遍历。</p>
<p>判断大顶堆或小顶堆只需要遍历整个序列，判断seq[i] 和 seq[2<em>i] 和 seq[2</em>i+1]的关系即可。</p>
<p>后序遍历采用栈进行模拟，</p>
<p>如果有左节点且左节点没被访问过，左节点入栈，</p>
<p>如果左节点被访问过且右节点没被访问过，右节点入栈</p>
<p>如果是叶子节点，且左右节点都被访问过，则出栈，visited设1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHEAP -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; seq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = seq.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">//第0个结点不用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(size+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node = S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node*<span class="number">2</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>+<span class="number">1</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>&gt;size || (node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>+<span class="number">1</span>])  <span class="comment">//访问该结点的条件 1、没有孩子结点 </span></span><br><span class="line">         || (node*<span class="number">2</span>+<span class="number">1</span>&gt;size &amp;&amp; node*<span class="number">2</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>]))&#123;   <span class="comment">//2、如果有右节点，且被访问过 3、如果没有右结点且左节点被访问过</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            visited[node] = <span class="number">1</span>;  <span class="comment">//标志该结点以访问过</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(seq[node]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)  cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_or_min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(seq[<span class="number">1</span>]&gt;seq[M]) max_or_min = MAX;</span><br><span class="line">        <span class="keyword">else</span> max_or_min = MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_or_min==MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&gt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&gt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&lt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&lt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_or_min==MAX) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN) cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==NOTHEAP) cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="built_in">postorder</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724154312977.png" alt="image-20210724154312977"></p>
<h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021.7.31"></a>2021.7.31</h2><h3 id="PAT-1140"><a href="#PAT-1140" class="headerlink" title="PAT 1140"></a>PAT 1140</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731211941856.png" alt="image-20210731211941856"></p>
<p>题目大意：</p>
<p>题意：后面一个数是前面一个数的描述，一般第一个数是d，代表0-9的任意一个数，第二 数是第一个数的描述，就是将d+d的个数。同样，第三个数是第二个数的描述，依次，例如:1   11(前一个1是第一个数，后一个1是第一个中1的个数)    12（代表前一个数中有2个1）  1121（前面一个数中有1个1，1个2，数放前，个数放后）  122111   112213  12221131  1123123111 。</p>
<p>思路：采用模拟的方法，c表示当前字符，如果遍历到的字符不是c，则输出到temp中，如果是c，则c的个数size++.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731212418772.png" alt="image-20210731212418772"></p>
<p>原因在于<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225304119.png" alt="image-20210731225304119"></p>
<p>使用&#x3D;是深拷贝，需将temp重新拷贝一份再赋值给temp</p>
<p>使用+&#x3D; 是直接在后面append。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225217330.png" alt="image-20210731225217330"></p>
<h3 id="PAT-1141"><a href="#PAT-1141" class="headerlink" title="PAT 1141"></a>PAT 1141</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225429215.png" alt="image-20210731225429215"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225444048.png" alt="image-20210731225444048"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225453525.png" alt="image-20210731225453525"></p>
<p>问题描述：给定每个考生的成绩和学校，统计该学校的总成绩并排序。</p>
<p>思路：用一个Map用于查找学校信息，便于统计学校总成绩，然后扔到vector进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total==b.total &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.total==b.total)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.total&gt;b.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].total),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231308137.png" alt="image-20210731231308137"></p>
<p>sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231840300.png" alt="image-20210731231840300"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231858291.png" alt="image-20210731231858291"></p>
<p>正确代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231804410.png" alt="image-20210731231804410"></p>
<h3 id="PAT-1142"><a href="#PAT-1142" class="headerlink" title="PAT 1142"></a>PAT 1142</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231938095-1677591493747.png" alt="image-20210731231938095"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231950482-1677591493747.png" alt="image-20210731231950482"></p>
<p>题目大意：问题描述：给定一个无向图，和一些顶点，判断这些顶点是否组成了集合（每两个顶点都相连）</p>
<p>Yes 是一个团，每两个顶点都相邻</p>
<p>Not Maximal  是一个团，但是可以再加入一个顶点，使得每两个顶点相连</p>
<p>Not a Clique  不是每两个顶点都相连。</p>
<p>思路：构造邻接矩阵，对给定序列依次判断是否是一个团，然后再尝试加入其他顶点，判断是否是最大团。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232208835-1677591493747.png" alt="image-20210731232208835"></p>
<h3 id="PAT-1143"><a href="#PAT-1143" class="headerlink" title="PAT 1143"></a>PAT 1143</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232235278.png" alt="image-20210731232235278"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232247776.png" alt="image-20210731232247776"></p>
<p>题目大意：用先序遍历的方式给出一棵排序二叉树。让你回答n个询问。<br> 找出每个询问的最近公共祖先。</p>
<p>用TreeMap存树的每个结点，第一步判断是否存在  否则not found</p>
<p>第二部查找最近的公共祖孙，这里利用二叉排序树的特点，如果n1 和 n2 一个大于根节点 一个小于根节点，则根节点必定是公共祖先，否则递归进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLCA</span><span class="params">(vector&lt;<span class="type">int</span>&gt; Tree,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = Tree[left];</span><br><span class="line">    <span class="keyword">if</span>((n1&lt;t &amp;&amp; n2&gt;t) || (n1&gt;t &amp;&amp; n2&lt;t) || (n1==t||n2==t)) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left+<span class="number">1</span>;  <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(Tree[i]&lt;t) i++;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;t &amp;&amp; n2&lt;t) <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,left+<span class="number">1</span>,i<span class="number">-1</span>,n1,n2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,i,right,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Tree</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; TreeMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;Tree[i];</span><br><span class="line">        TreeMap[Tree[i]]++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>() &amp;&amp; TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.&quot;</span>,n1,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> lca = <span class="built_in">searchLCA</span>(Tree,<span class="number">0</span>,N<span class="number">-1</span>,n1,n2);</span><br><span class="line">            <span class="keyword">if</span>(lca==n1)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n1,n2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lca==n2)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n2,n1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.&quot;</span>,n1,n2,lca);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232946850.png" alt="image-20210731232946850"></p>
<p>佬们的代码：他是直接利用先序遍历的特点，按顺序判断是否是祖先</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232910793.png" alt="image-20210731232910793"></p>
<h2 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021.8.7"></a>2021.8.7</h2><h3 id="PAT-1136"><a href="#PAT-1136" class="headerlink" title="PAT 1136"></a>PAT 1136</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112248715.png" alt="image-20210807112248715"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112302487.png" alt="image-20210807112302487"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112313001.png" alt="image-20210807112313001"></p>
<p>题目大意：一个数加它的翻转能否在10次内得到一个回文数</p>
<p>思路：模拟大数加法，并且模拟反转过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> benwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c = a[i]-<span class="string">&#x27;0&#x27;</span> + b[i]-<span class="string">&#x27;0&#x27;</span> + jinwei;</span><br><span class="line">        benwei = c%<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(benwei) + res;</span><br><span class="line">        jinwei = c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jinwei!=<span class="number">0</span>) res = <span class="built_in">to_string</span>(jinwei) + res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispalindromic</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ispalindromic</span>(a) &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s + &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        string c = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        a = <span class="built_in">add</span>(a,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Not found in 10 iterations.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s is a palindromic number.&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112447331.png" alt="image-20210807112447331"></p>
<h3 id="PAT-1137"><a href="#PAT-1137" class="headerlink" title="PAT 1137"></a>PAT 1137</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162201003.png" alt="image-20210807162201003"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162215605.png" alt="image-20210807162215605"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162226330.png" alt="image-20210807162226330"></p>
<p>题目大意：</p>
<p>判断一个学生是否有资格获得整数的条件有2个：1.学生是否能编程&gt;&#x3D;200题 2.学生的总评成绩是否&gt;&#x3D;60</p>
<p>由于题目是分开给出各项成绩，而且Id唯一，所以我们可以使用Map方便查找。最后进行判断，判断完后排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162636845.png" alt="image-20210807162636845"></p>
<p><strong>大坑</strong>：</p>
<p>题目中的-1的意思表示的是没有学生的某一项没有分数（而非分数为0！没有分数代表没来考试，而分数为0代表考试考了0分！）</p>
<p>所以mid的初值应该设为-1 而不应该设为0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162728149.png" alt="image-20210807162728149"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">-1</span>;  <span class="comment">//-1代表没有成绩，不代表0分</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;=<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162753507.png" alt="image-20210807162753507"></p>
<h3 id="PAT-1138"><a href="#PAT-1138" class="headerlink" title="PAT 1138"></a>PAT 1138</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162840383.png" alt="image-20210807162840383"></p>
<p>题目大意：给出数的前序、中序，求后序输出的第一个值</p>
<p>思路：按照前序、中序序列构造树的方法，采用递归，中间需要用到Map来查找中序序列的位置。</p>
<p>如果有左子树，后序遍历的第一个序列在左子树中寻找，否则在右子树中寻找。只有一个节点，则Return；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(preorder,inorder,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807163415544.png" alt="image-20210807163415544"></p>
<p>改进方法：函数传值的时候尽量不要把整个vector都传进去，否则会出现爆内存的情况。需要把vector设置成全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192348410.png" alt="image-20210807192348410"></p>
<h3 id="PAT-1139"><a href="#PAT-1139" class="headerlink" title="PAT 1139"></a>PAT 1139</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192751253.png" alt="image-20210807192751253"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192805065.png" alt="image-20210807192805065"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192815264.png" alt="image-20210807192815264"></p>
<p><strong>题意</strong>：如果一个男孩子A对一个女孩子B有好感，那么他需要跟他的好哥们C说，然后C再去找B的闺蜜，让闺蜜给B带话。</p>
<p>思路就是从A的同性朋友中找出C，再从B的同性朋友中找出D，然后C，D是好朋友的话，这个话就带到了。</p>
<p>但是输出那里规定A，B可以是同性，</p>
<p>If they are of the same gender, then both friends must be in the same gender as theirs.</p>
<p>emmmmmmm，这道题gay里gay气的。</p>
<p><strong>思路</strong>：Person结构体存储自己的Id,还有男朋友，女朋友（其实也可以一起存储），然后用一个Map&lt;id,Person&gt;方便使用Id找到相对应的朋友。</p>
<p>然后给定两个朋友A，朋友B，根据Map找到对应的A的男朋友或女朋友，and 找到B的男朋友或女朋友，最后写一个函数判断这两人之间是否存在关系，然后将存在关系的朋友排好序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; boyfriend;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; girlfriend;</span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfriend</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    Person p = Map[id];</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.boyfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.girlfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(id2&gt;<span class="number">0</span>) Map[id1].boyfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">else</span> Map[id1].girlfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span>) Map[id2].boyfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        <span class="keyword">else</span> Map[id2].girlfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807193412853.png" alt="image-20210807193412853"></p>
<p>参考了以下柳神的代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807200903777.png" alt="image-20210807200903777"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a != y.a ? x.a &lt; y.a : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> asa = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(a)),asb = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(b));</span><br><span class="line">        <span class="comment">// A/B ID 作为下标记录同性边数据，arr记录关系</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v[asa].<span class="built_in">push_back</span>(asb);</span><br><span class="line">            v[asb].<span class="built_in">push_back</span>(asa);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[asa * <span class="number">10000</span> + asb] = arr[asb * <span class="number">10000</span> + asa] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[<span class="built_in">abs</span>(c)].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v[<span class="built_in">abs</span>(d)].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// A在寻找同性朋友时，需要避免找到他想要的伴侣B，所以当前朋友就是B或B的同性朋友就是A时舍弃该结果</span></span><br><span class="line">                <span class="keyword">if</span> (v[<span class="built_in">abs</span>(c)][j] == <span class="built_in">abs</span>(d) || <span class="built_in">abs</span>(c) == v[<span class="built_in">abs</span>(d)][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// A/B，先找A的所有同性朋友C，再找B的所有同性朋友D，当C和D两人是朋友的时候则可以输出C和D</span></span><br><span class="line">                <span class="keyword">if</span> (arr[v[<span class="built_in">abs</span>(c)][j] * <span class="number">10000</span> + v[<span class="built_in">abs</span>(d)][k]] == <span class="literal">true</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node&#123;v[<span class="built_in">abs</span>(c)][j], v[<span class="built_in">abs</span>(d)][k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(ans.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进后</strong>，重新捋一下<strong>思路</strong>：</p>
<p><font color="red">重点!!!</font></p>
<ul>
<li><p>题目简化后为A寻找同性伴侣B，D寻找同性伴侣A，然后A和B是朋友，则添加到结果中。</p>
</li>
<li><p>由于数据错综复杂，所以不适合采用邻接矩阵，我们只需要记录他们之间的关系即可，数据结构可以直接采用 map&lt;pair&lt;int,int&gt;,bool&gt;来存储两者间的关系，其中make_pair&lt;int,int&gt;可以使用哈希映射，比如make_pair&lt;a,b&gt;可以等价为 a*10000+b,同时不会导致哈希冲突。</p>
</li>
<li><p>如何寻找同性朋友呢，可以使用结构体Person, Person下有一个vector用于存储同性朋友，为了快速找到 id 对应的结构体Person，我们可以用map将id直接映射到Person中。</p>
</li>
<li><p>如果用Int接收朋友，会出现+0000和-0000的情况，不能判断是否为同性朋友，题目说we use a negative sign to represent girls. 用一个符号代表女性朋友，我们可以先用string接收，然后stoi(s)转成Int形，用s.length是否相同来判断是否为同性朋友。  (对应2、3个测试点)</p>
</li>
<li><p>输出的数据必须从小到大排序</p>
</li>
<li><p>A在寻找同性朋友时应该避免找到他的同性伴侣D，坑点（对应4、5、6测试点）</p>
</li>
<li><p>输出要保留4位小数  %04d  对应（2、3测试点）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gayfriend;  <span class="comment">//同性朋友</span></span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;pair&lt;int,int&gt;,bool&gt; isfriend;  key不能是pair类型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; isfriend;   <span class="comment">//可以建立Int,Int的哈希映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string sd1,sd2;  cin&gt;&gt;sd1&gt;&gt;sd2;</span><br><span class="line">        <span class="type">int</span> id1 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd1)),id2 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建朋友关系</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id1,id2)]=true;</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id2,id1)]=true;</span></span><br><span class="line">        isfriend[id1*<span class="number">10000</span>+id2]=<span class="literal">true</span>;</span><br><span class="line">        isfriend[id2*<span class="number">10000</span>+id1]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是同性朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(sd1.<span class="built_in">length</span>()==sd2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            Map[id1].gayfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">            Map[id2].gayfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        id1 = <span class="built_in">abs</span>(id1); id2 = <span class="built_in">abs</span>(id2);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        Person p1 = Map[id1];</span><br><span class="line">        Person p2 = Map[id2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p1.gayfriend.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p2.gayfriend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> fri1 = p1.gayfriend[i];</span><br><span class="line">                <span class="type">int</span> fri2 = p2.gayfriend[j];</span><br><span class="line">                <span class="keyword">if</span>(fri1==id2 || fri2==id1) <span class="keyword">continue</span>;  <span class="comment">// A在寻找同性朋友时，需要避免直接找到他想要的伴侣B</span></span><br><span class="line">                <span class="keyword">if</span>(isfriend[fri1*<span class="number">10000</span>+fri2] &amp;&amp; fri1!=fri2)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(fri1,fri2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807205353302.png" alt="image-20210807205353302"></p>
<h2 id="2021-8-14"><a href="#2021-8-14" class="headerlink" title="2021.8.14"></a>2021.8.14</h2><h3 id="PAT-1132"><a href="#PAT-1132" class="headerlink" title="PAT 1132"></a>PAT 1132</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125130500.png" alt="image-20210814125130500"></p>
<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20210814125141745.png" alt="image-20210814125141745" style="zoom:150%;">

<p>题目大意：<strong>一个偶数个位的正整数num，把它从中间分成左右两个整数a、b，问num能不能被a和b的乘积整除，能的话输出yes，不能的话输出no</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125236517.png" alt="image-20210814125236517"></p>
<p>因为没有判断c1*c2能不能是0，正确的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>((c1*c2) &amp;&amp;c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125323306.png" alt="image-20210814125323306"></p>
<h3 id="PAT-1133"><a href="#PAT-1133" class="headerlink" title="PAT 1133"></a>PAT 1133</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125357711.png" alt="image-20210814125357711"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125410450.png" alt="image-20210814125410450"></p>
<p>题目大意：给出一个链表，将链表分为三部分，第一部分小于0的数，第二部分小于&#x3D;K的数，第三部分，大于K的数。</p>
<p>思路：数据结构，一个结构体，存放地址address,数number，下一跳nextaddress，再采用map使得可以方便地根据address查找结点所在的位置，然后获取下一跳，以此类推。最后通过三次查找把合适的部分取出来放到vector中，这样就排好序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string address;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string nextaddress;</span><br><span class="line">    <span class="type">bool</span> isvisited = <span class="literal">false</span>;</span><br><span class="line">&#125;node;</span><br><span class="line">unordered_map&lt;string,node&gt; M;</span><br><span class="line">vector&lt;node&gt; res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string fadd;  cin&gt;&gt;fadd;</span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        node n; </span><br><span class="line">        cin&gt;&gt;n.address&gt;&gt;n.number&gt;&gt;n.nextaddress;</span><br><span class="line">        M[n.address] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    string nextaddress = fadd;</span><br><span class="line">    <span class="comment">//第一遍寻找负数</span></span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一遍寻找小于K的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;=K) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三遍加入剩余的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=res.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number,res[i+<span class="number">1</span>].address.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d -1&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125702974.png" alt="image-20210814125702974"></p>
<h3 id="PAT-1134"><a href="#PAT-1134" class="headerlink" title="PAT 1134"></a>PAT 1134</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125742396.png" alt="image-20210814125742396"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125753908.png" alt="image-20210814125753908"></p>
<p>题目大意：n个顶点和m条边的图，分别给出m条边的两端顶点，然后对其进行k次查询，每次查询输入一个顶点集合，要求判断这个顶点集合是否能完成顶点覆盖，即图中的每一条边都至少有一个顶点在这个集合中。</p>
<p>思路：很简单，将顶点集合用map存，然后遍历边，判断是否有一个顶点在map中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edgeset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        edgeset.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e1,e2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> c;  cin&gt;&gt;c; Map[c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;edgeset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> e1 = edgeset[j].first, e2 = edgeset[j].second;</span><br><span class="line">            <span class="keyword">if</span>(Map.<span class="built_in">find</span>(e1)==Map.<span class="built_in">end</span>() &amp;&amp; Map.<span class="built_in">find</span>(e2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125924885.png" alt="image-20210814125924885"></p>
<h3 id="PAT-1135"><a href="#PAT-1135" class="headerlink" title="PAT 1135"></a>PAT 1135</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145832177.png" alt="image-20210814145832177"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145853993.png" alt="image-20210814145853993"></p>
<p><strong>题目大意</strong>：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</p>
<p>1、非红即黑</p>
<p>2、根结点是否为黑色       </p>
<p>3、将NULL看成1个叶子节点，为黑<code>black</code>色</p>
<p>4、如果1个结点是红色，它的孩子节点是否都为黑色       </p>
<p>5、从任意结点到叶子结点的路径中，黑色结点的个数是否相同       </p>
<p><strong>考场错误思路一</strong>：由于是二叉排序树加上先序序列，可以递归构造二叉树。然后dfs的过程中判断第4个条件，并统计第5个条件（黑色结点个数是否相同）</p>
<p>一开始理解错了，从根节点到叶子结点的路径中，黑色结点个数相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; black_num;   <span class="comment">//统计路径上的黑色结点的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,<span class="type">int</span> black)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&gt;<span class="number">0</span>) black++;   <span class="comment">//黑色结点+1</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        black_num.<span class="built_in">push_back</span>(black);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    black_num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="type">bool</span> dfs = <span class="built_in">DFS</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfs==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;black_num.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(black_num[i]!=black_num[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814150547067.png" alt="image-20210814150547067"></p>
<p>第3个结点段错误，建树过程中存在一些问题。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814154047150.png" alt="image-20210814154047150"></p>
<p><strong>考场错误思路二</strong>：为了使得每一层到叶子结点的黑色结点数相同，我私自认为</p>
<p>&#x2F;&#x2F;判断是否为红黑树</p>
<p>&#x2F;&#x2F;1、红黑树一定是一棵平衡二叉树</p>
<p>&#x2F;&#x2F;2、红黑树一定层次分明,一层黑一层白</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lefthigh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> righhigh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lefthigh,righhigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh-rh&gt;<span class="number">1</span> || rh-lh&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">levelsearch</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> black = <span class="number">1</span>;  <span class="comment">//第一层是black</span></span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> lsize = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsize;i++)&#123;</span><br><span class="line">            TreeNode* p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val*black&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        black*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">levelsearch</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然是错误的，所以红黑树不是平衡二叉树</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155039169.png" alt="image-20210814155039169"></p>
<p><strong>正确思路</strong>：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155458247.png" alt="image-20210814155458247"></p>
<p>这里是判断平衡二叉树的变体，算高度时只统计黑色结点的个数</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155547670.png" alt="image-20210814155547670"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? <span class="built_in">max</span>(l, r) + <span class="number">1</span> : <span class="built_in">max</span>(l, r);</span><br><span class="line">    <span class="comment">// return 1+max(l,r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh!=rh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">DFS</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155614848.png" alt="image-20210814155614848"></p>
<h2 id="2021-8-20"><a href="#2021-8-20" class="headerlink" title="2021.8.20"></a>2021.8.20</h2><h3 id="PAT-1128"><a href="#PAT-1128" class="headerlink" title="PAT 1128"></a>PAT 1128</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184132575.png" alt="image-20210820184132575"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184145438.png" alt="image-20210820184145438"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184157300.png" alt="image-20210820184157300"></p>
<p>判断同一行同一列对角线上有无N皇后，同一列题目已经保证了，同一行用map保证，对角线判断j-i&#x3D;&#x3D;abs(row[j]-row[i] ） O(n*n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> K;   cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//第一个元素不用，下标表示col，数值表示row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;row[i];</span><br><span class="line">            <span class="keyword">if</span>(map[row[i]]==<span class="number">1</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> map[row[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;row.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;row.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="built_in">abs</span>(row[j]-row[i])) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184442560.png" alt="image-20210820184442560"></p>
<h3 id="PAT-1129"><a href="#PAT-1129" class="headerlink" title="PAT 1129"></a>PAT 1129</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184523153.png" alt="image-20210820184523153"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184533785.png" alt="image-20210820184533785"></p>
<p><strong>题目大意</strong>：给定一个序列，求目前出现次数最多的k个数字。如果数字出现次数相同，升序排列。</p>
<p><strong>解题思路</strong>：类似LRU，寻找出现次数最多的三个。</p>
<p>数据结构的设计，一个vector&lt;pair&lt;int,int&gt;&gt; KWindow;   存放出现次数最多的K个数字,pair-&gt;first代表数字，pair-&gt;second代表出现的次数，每加入一个数字，我们就要判断是否要更新KWindow.采用unordered_map存放这个数字在目前出现了几次。</p>
<p>判断是否需要更新KWindow? </p>
<p>情况一：新加入的数字在KWindow中，直接在KWindow中更新就好了，然后排序。</p>
<p>情况二：新加入的数字不在KWindow中，而且KWindow还没满，直接加入，然后排序。</p>
<p>情况三：新加入的数字不在KWindow中，而且KWindow满了，判断是否需要替换，由于之前已经排好序了，只要和最后一个比较，如果次数&lt;最后一个，或者次数相同，数字小于最后一个，则替换掉最后一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;    <span class="comment">//统计在j之前出现的次数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; KWindow;  <span class="comment">//存放出现次数最多的K个数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">finda</span><span class="params">(<span class="type">int</span> target,<span class="type">int</span> fre)</span></span>&#123;  <span class="comment">//查找当前数字是不是在KWindow中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(KWindow[i].first==target)&#123;</span><br><span class="line">            KWindow[i].second = fre;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Min = <span class="number">0</span>;  <span class="comment">//当前最小的次数</span></span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp; cin&gt;&gt;temp;</span><br><span class="line">        input.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Map[input[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">finda</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]))&#123;  <span class="comment">//本来就在窗口里面，不用处理</span></span><br><span class="line">            <span class="keyword">if</span>(KWindow.<span class="built_in">size</span>()&lt;K)&#123;  <span class="comment">//窗口还有容量</span></span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]&gt;Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]==Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].first&gt;input[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                    KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(KWindow.<span class="built_in">begin</span>(),KWindow.<span class="built_in">end</span>(),cmp);  <span class="comment">//将窗口排好序</span></span><br><span class="line">        Min = KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;KWindow[i].first;</span><br><span class="line">            <span class="keyword">if</span>(i!=KWindow.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185242648.png" alt="image-20210820185242648"></p>
<h3 id="PAT-1130"><a href="#PAT-1130" class="headerlink" title="PAT 1130"></a>PAT 1130</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185308171.png" alt="image-20210820185308171"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185322504.png" alt="image-20210820185322504"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185334088.png" alt="image-20210820185334088"></p>
<p><strong>题目大意</strong>：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级</p>
<p><strong>解题思路</strong>：给定的输入建树的过程我感觉比较复杂。在输入的第一遍建立TreeNode，然后将string映射到TreeNode中，但这样会有一个问题，就是string的值可能相同，所以我给每个输入结点设置了一个id，第二遍结点全部都创建好了，我们就可以根据左子树所在的行数，和右子树所在的行数 所 映射到的结点建立连接。  最后就是寻找根节点的过程，用set就可以了，把有父节点的加入set，最后不在set的那个就是根节点。</p>
<p>后面就是中序遍历，很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; Set;  <span class="comment">//用来寻找没有前驱的结点,寻找根节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; MM;  <span class="comment">//建立id到TreeNode的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">input</span></span><br><span class="line">&#123;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">&#125;input;</span><br><span class="line">vector&lt;input&gt; I;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        TreeNode* r = MM[I[i].id];</span><br><span class="line">        <span class="keyword">if</span>(I[i].left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* left = MM[I[I[i].left].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].left].id);</span><br><span class="line">            r-&gt;left = left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(I[i].right!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* right = MM[I[I[i].right].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].right].id);</span><br><span class="line">            r-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(I[i].id)==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> MM[I[i].id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)  <span class="comment">//如果不是叶子结点则加括号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    I.<span class="built_in">push_back</span>(input&#123;&#125;);  <span class="comment">//第一个数不用</span></span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        input ii;  cin&gt;&gt;ii.val&gt;&gt;ii.left&gt;&gt;ii.right;</span><br><span class="line">        ii.id=i;</span><br><span class="line">        I.<span class="built_in">push_back</span>(ii);</span><br><span class="line">        TreeNode* r = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ii.val);</span><br><span class="line">        MM[ii.id] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185818116.png" alt="image-20210820185818116"></p>
<h3 id="PAT-1131"><a href="#PAT-1131" class="headerlink" title="PAT 1131"></a>PAT 1131</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181205412.png" alt="image-20210820181205412"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181223417.png" alt="image-20210820181223417"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181241538.png" alt="image-20210820181241538"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181255465.png" alt="image-20210820181255465"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181307918.png" alt="image-20210820181307918"></p>
<p><strong>题目大意</strong>：</p>
<p>给出各地铁线所经过的站点，构成一张地铁交通图。再给出起点和终点，让你找出最快的一条路径，<strong>如果路径不唯一就选择中转次数最少的那一条</strong>。 </p>
<p><strong>解题思路</strong>：</p>
<p>我没有考虑到这一点，所以2，4测试点没有过。</p>
<p>1、本来想用Floyd算法，但是发线每条边权值都为1，所以用BFS搜索即可。</p>
<p>2、构造邻接矩阵有一个问题，就是要解决0000四位整数映射问题，不然开辟10000*10000个空间未免太大了，我的做法是读入是写到set中，然后遍历set建立string-int的映射，还有int-string的映射。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181854943.png" alt="image-20210820181854943"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181916383.png" alt="image-20210820181916383"></p>
<p>3、建图，采用邻接矩阵，这里存储的是无向图，因此根据线路构造的时候要存储两次，邻接矩阵存储的边值代表线路（几号线）而不是代价。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182051111.png" alt="image-20210820182051111"></p>
<p>4、BFS寻找最短路径，用path来存储路径，path[i] &#x3D; j表示，从j-&gt;i，方便往回寻找</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182130533.png" alt="image-20210820182130533"></p>
<p>5、找到后需要输出路径，顺着path往回寻找，将结果放到path_中。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182243168.png" alt="image-20210820182243168"></p>
<p>6、最后在把path带入到Graph中构造出所要的线路结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182317542.png" alt="image-20210820182317542"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; input;   <span class="comment">//input[i]表示i+1号线的站点</span></span><br><span class="line">unordered_set&lt;string&gt; Set;  <span class="comment">//实现站点映射</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; MapStoI; <span class="comment">//相互映射</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,string&gt; MapItoS; <span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;   <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> kkk=<span class="number">0</span>;  <span class="comment">//结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(string start,string destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> begin = MapStoI[start];</span><br><span class="line">    <span class="type">int</span> end = MapStoI[destination];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(kkk,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(kkk,<span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(begin);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   <span class="comment">//BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kkk;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span> &amp;&amp; Graph[t][i])&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">//访问过</span></span><br><span class="line">                path[i] = t;  <span class="comment">//记录从t-i的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="type">int</span> p = end;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path_;  path_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(p!=begin)&#123;</span><br><span class="line">        <span class="type">int</span> temp = path[p];</span><br><span class="line">        path_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;path_.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(path_.<span class="built_in">begin</span>(),path_.<span class="built_in">end</span>());  <span class="comment">//反转</span></span><br><span class="line">    <span class="type">int</span> bbbb = path_[<span class="number">0</span>];  <span class="type">int</span> eeee = path_[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> xianlu = Graph[path_[<span class="number">0</span>]][path_[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[path_[i]][path_[i<span class="number">-1</span>]]==xianlu) eeee = path_[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[eeee].<span class="built_in">c_str</span>());</span><br><span class="line">            xianlu = Graph[path_[i]][path_[i<span class="number">-1</span>]];</span><br><span class="line">            bbbb = eeee;</span><br><span class="line">            eeee = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[end].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph.<span class="built_in">resize</span>(kkk,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(kkk,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;input[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            Graph[MapStoI[input[i][j<span class="number">-1</span>]]][MapStoI[input[i][j]]] = i+<span class="number">1</span>;  <span class="comment">//后面的数字代表几号线 ,0 表示不连通</span></span><br><span class="line">            Graph[MapStoI[input[i][j]]][MapStoI[input[i][j<span class="number">-1</span>]]] = i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="comment">//1  处理输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">C</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;C[j];</span><br><span class="line">            Set.<span class="built_in">insert</span>(C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        input.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 站点映射</span></span><br><span class="line">    unordered_set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Set.<span class="built_in">begin</span>();iter!=Set.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        MapItoS[kkk] = *iter;</span><br><span class="line">        MapStoI[*iter]=kkk++;</span><br><span class="line">    &#125;<span class="comment">//映射完后共有Kkk个结点，从0..kkk-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 建图</span></span><br><span class="line">    <span class="built_in">BuildGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 广度优先搜索寻找最短路径</span></span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        string start,end; cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182348064.png" alt="image-20210820182348064"></p>
<p><strong>答案正解</strong>：</p>
<p>1、使用邻接表存储     2、使用line的键为a*10000+b,建立边到线路的映射      3、dfs暴力深搜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[<span class="number">10000</span>],minCnt,minTransfer;  <span class="comment">//是否访问过 最小代价  最小中转次数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10000</span>);  <span class="comment">//采用邻接表存储</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path,tempPath;<span class="comment">//路径vector</span></span><br><span class="line"><span class="type">int</span> start,end1;<span class="comment">//起点 终点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; line;  <span class="comment">//结点到路线的映射</span></span><br><span class="line"><span class="comment">/*unordered_map&lt;int,int&gt;line存储两个结点的边所属的路线</span></span><br><span class="line"><span class="comment">假设边两端为a到b，line的键为a*10000+b,值为这条边所属的路线*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transferCnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//传入临时路径，传出中转站个数</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">-1</span>,preLine=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]] != preLine) </span><br><span class="line">			cnt++;<span class="comment">//换乘数cnt+1</span></span><br><span class="line">		preLine=line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;<span class="comment">//输出换乘数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> cnt)</span></span>&#123; <span class="comment">//cnt为换乘数</span></span><br><span class="line">    <span class="comment">//搜索到路径，需要更新</span></span><br><span class="line">	<span class="keyword">if</span>(node==end1 &amp;&amp; (cnt&lt;minCnt || (cnt ==minCnt&amp;&amp;<span class="built_in">transferCnt</span>(tempPath) &lt;minTransfer))) &#123;</span><br><span class="line">		minCnt=cnt;<span class="comment">//更新cnt</span></span><br><span class="line">		minTransfer=<span class="built_in">transferCnt</span>(tempPath);<span class="comment">//更新最小换乘次数</span></span><br><span class="line">		path=tempPath;<span class="comment">//更新路径vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node == end1) <span class="keyword">return</span>;<span class="comment">//搜索到，但不需要更新</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[node].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//dfs寻找路径</span></span><br><span class="line">		<span class="keyword">if</span>(visit[v[node][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">			visit[v[node][i]]=<span class="number">1</span>;<span class="comment">//加锁</span></span><br><span class="line">			tempPath.<span class="built_in">push_back</span>(v[node][i]);</span><br><span class="line">			<span class="built_in">dfs</span>( v[node][i] ,cnt+<span class="number">1</span>); <span class="comment">//cnt+1，进入下一层dfs</span></span><br><span class="line">			visit[v[node][i] ]=<span class="number">0</span>;<span class="comment">//解锁  类似回溯，只对这一层dfs有效</span></span><br><span class="line">			tempPath.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	<span class="type">int</span> n,m,k,pre,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//地铁路线数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;pre);<span class="comment">//pre为m线路的首站</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;<span class="comment">//for循环剩下的m-1个站</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">			v[pre].<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="comment">//首站为pre的线路(vector里)加上temp站</span></span><br><span class="line">			v[temp].<span class="built_in">push_back</span>(pre);</span><br><span class="line">			<span class="comment">//temp站的vector里加入首站(pre)</span></span><br><span class="line">			line[pre*<span class="number">10000</span>+temp]=line[temp*<span class="number">10000</span>+pre]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//pre到temp的线路=temp到pre的线路+1</span></span><br><span class="line">			pre=temp;<span class="comment">//首站为temp</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);<span class="comment">//k次查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;end1);</span><br><span class="line">		<span class="comment">//查询start站到end1站</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//minCnt为最小换乘数，minTransfer为换乘站</span></span><br><span class="line">		minCnt=<span class="number">99999</span>,minTransfer=<span class="number">99999</span>;<span class="comment">//初始化</span></span><br><span class="line">		tempPath.<span class="built_in">clear</span>();</span><br><span class="line">		tempPath.<span class="built_in">push_back</span>(start);<span class="comment">//把start压入临时路径vector</span></span><br><span class="line">		visit[start]=<span class="number">1</span>; <span class="comment">//加锁</span></span><br><span class="line">		<span class="built_in">dfs</span>(start,<span class="number">0</span>); <span class="comment">//递归DFS！！！！！！！！！</span></span><br><span class="line">		visit[start]=<span class="number">0</span>; <span class="comment">//解锁</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//以下为output</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minCnt);<span class="comment">//起点&amp;终点之间的min站数</span></span><br><span class="line">		<span class="type">int</span> preLine=<span class="number">0</span>,preTransfer=start;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;path.<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]] != preLine)&#123;</span><br><span class="line">				<span class="keyword">if</span>(preLine != <span class="number">0</span>) <span class="comment">//每当line和preline不等则输出这句话</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>,</span><br><span class="line">					preLine,preTransfer,path[j<span class="number">-1</span>] );</span><br><span class="line">				preLine=line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]];<span class="comment">//更新上一条线路号</span></span><br><span class="line">				preTransfer = path[j<span class="number">-1</span>];<span class="comment">//更新上一个换乘站</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, </span><br><span class="line">				preLine,preTransfer,end1);<span class="comment">//输出最后一小截线路</span></span><br><span class="line">				<span class="comment">//preLine路线 从preTransfer站到end1站</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820183834493.png" alt="image-20210820183834493"></p>
<h2 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h2><p>1h40min搞定  98分</p>
<h3 id="PAT-1124"><a href="#PAT-1124" class="headerlink" title="PAT 1124"></a>PAT 1124</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105622634.png" alt="image-20210829105622634"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105636286.png" alt="image-20210829105636286"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105648351.png" alt="image-20210829105648351"></p>
<p><strong>题目大意</strong>：明PAT考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔N个人就发出一个红包。请你编写程序帮助他确定中奖名单。注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出“Keep going…”</p>
<p><strong>思路</strong>：只要读懂题目，没有任何头脑的题，一个while循环，加一个set判断重复轻松搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> M,N,S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;S;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">L</span><span class="params">(M+<span class="number">1</span>,<span class="string">&quot;&quot;</span>)</span></span>; </span><br><span class="line">    set&lt;string&gt; Set;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = S;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(L[cur])==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(L[cur]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(L[cur]);</span><br><span class="line">            cur += N;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Keep going...&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105856839.png" alt="image-20210829105856839"></p>
<h3 id="PAT-1125"><a href="#PAT-1125" class="headerlink" title="PAT 1125"></a>PAT 1125</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105926511.png" alt="image-20210829105926511"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105937843.png" alt="image-20210829105937843"></p>
<p>题目大意：　绳子每次打结长度都会减小到原来的一半，那么打结的顺序会影响到最终的长度。求最终长度不超过的数。</p>
<p>刚开始都没太懂题目的意思…最后想想应该是排序+模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = <span class="built_in">double</span>(possible)/<span class="number">2</span> + <span class="built_in">double</span>(Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">    <span class="comment">// printf(&quot;%.0f&quot;,possible);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110128163.png" alt="image-20210829110128163"></p>
<p>注意：只需排序一次，觉得要每次有新绳子就要排序一下，比你小的两个数的平均数肯定也是最小的呀！</p>
<p>测试点1是只有一段绳子，开始的两段绳子要特殊处理，总长度初值应该是最小绳子长度，而不是0</p>
<p>稍加修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = Input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = (possible+Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110627305.png" alt="image-20210829110627305"></p>
<h3 id="PAT-1126"><a href="#PAT-1126" class="headerlink" title="PAT 1126"></a>PAT 1126</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110921087.png" alt="image-20210829110921087"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110935002.png" alt="image-20210829110935002"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110945243.png" alt="image-20210829110945243"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110956289.png" alt="image-20210829110956289"></p>
<p>题目大意：</p>
<p>对于无向图来说：</p>
<ol>
<li>是欧拉图，连通且所有节点的度为偶数</li>
<li>是半欧拉图，连通且只有两个节点的度为奇数</li>
</ol>
<p>转化为统计图的度，然后判断几个节点的度是奇数，如果仅仅只是这样简单处理测试点3过不去，后向仔细看题看到了<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111134310.png" alt="image-20210829111134310"></p>
<p>需要是连通图才可以。</p>
<p>由于懒得构造邻接矩阵再进行遍历，这里使用并查集来判断是不是完全连通图、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *parents;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> total)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;total = total;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="type">int</span>[total+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">find</span>(node1);</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">find</span>(node2);</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;</span><br><span class="line">            parents[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents[node]!=node)&#123;</span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(node1)==<span class="built_in">find</span>(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEurn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isConnected</span>(i,i+<span class="number">1</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    UnionFind* uf = <span class="keyword">new</span> <span class="built_in">UnionFind</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        degree[n1]++; degree[n2]++;</span><br><span class="line">        uf-&gt;<span class="built_in">Union</span>(n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==N) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">if</span>(degree[i]%<span class="number">2</span>) oddnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uf-&gt;<span class="built_in">isEurn</span>()==<span class="literal">false</span>) &#123;cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(oddnum==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oddnum==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Semi-Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111235971.png" alt="image-20210829111235971"></p>
<h3 id="PAT-1127"><a href="#PAT-1127" class="headerlink" title="PAT 1127"></a>PAT 1127</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111310015.png" alt="image-20210829111310015"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111320873.png" alt="image-20210829111320873"></p>
<p><strong>题目大意</strong>：给定中序和后序序列，建立一棵树，然后对这棵树进行Z型层序遍历。</p>
<p><strong>思路</strong>：就是在层序遍历的时候需要把层数分出来，然后设置一个flag，需要的时候把序列翻转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorder;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> inleft,<span class="type">int</span> inright,<span class="type">int</span> postleft,<span class="type">int</span> postright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inleft&gt;inright) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;postright&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> curnode = postorder[postright];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(curnode);</span><br><span class="line">    <span class="type">int</span> mid = M[curnode];</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(inleft,mid<span class="number">-1</span>,postleft,postleft+mid<span class="number">-1</span>-inleft);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(mid+<span class="number">1</span>,inright,postleft+mid<span class="number">-1</span>-inleft+<span class="number">1</span>,postright<span class="number">-1</span>);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> yinzi = <span class="number">-1</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(yinzi==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        yinzi *= <span class="number">-1</span>;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; inorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">        M[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; postorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ZigZag</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111516703.png" alt="image-20210829111516703"></p>
<h2 id="2021-9-5"><a href="#2021-9-5" class="headerlink" title="2021.9.5"></a>2021.9.5</h2><h3 id="PAT-1120"><a href="#PAT-1120" class="headerlink" title="PAT 1120"></a>PAT 1120</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154114163.png" alt="image-20210905154114163"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154125395.png" alt="image-20210905154125395"></p>
<p>题意：统计数的各位数字之和，并升序输出</p>
<p>用set啥的就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:15-8:25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            count += s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[count]++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154408271.png" alt="image-20210905154408271"></p>
<h3 id="PAT-1121"><a href="#PAT-1121" class="headerlink" title="PAT 1121"></a>PAT 1121</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154431389.png" alt="image-20210905154431389"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154440477.png" alt="image-20210905154440477"></p>
<p>题目大意：给N对夫妻编号，再给M个派对里的参与人的编号，输出单身的人的编号（包括夫妻没全部到场的也算单身）</p>
<p>用map统计夫妻配对的情况，再用一个map[10000]统计到场情况，最后一一排除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154613535.png" alt="image-20210905154613535"></p>
<p>改用set存储M个人的信息，就可以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">insert</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=res.<span class="built_in">begin</span>();it!=res.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it!=res.<span class="built_in">begin</span>())<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155315203.png" alt="image-20210905155315203"></p>
<h3 id="PAT-1122"><a href="#PAT-1122" class="headerlink" title="PAT 1122"></a>PAT 1122</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155357857.png" alt="image-20210905155357857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155408391.png" alt="image-20210905155408391"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155419998.png" alt="image-20210905155419998"></p>
<p>判断是否是哈密顿回路，随便写写就AC了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:40-9:00</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E; cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        graph[e1][e2]=<span class="number">1</span>; graph[e2][e1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Input[i];</span><br><span class="line">        <span class="keyword">if</span>(Input.<span class="built_in">size</span>()!=V+<span class="number">1</span> || Input[<span class="number">0</span>]!=Input[V])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[Input[j]][Input[j+<span class="number">1</span>]]==<span class="number">1</span>)&#123;</span><br><span class="line">                Set.<span class="built_in">insert</span>(Input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==V) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155456226.png" alt="image-20210905155456226"></p>
<h3 id="PAT-1123"><a href="#PAT-1123" class="headerlink" title="PAT 1123"></a>PAT 1123</h3>]]></content>
      <tags>
        <tag>算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubAction+Hexo搭建个人博客</title>
    <url>/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="GithubAction-Hexo搭建个人博客"><a href="#GithubAction-Hexo搭建个人博客" class="headerlink" title="GithubAction+Hexo搭建个人博客"></a>GithubAction+Hexo搭建个人博客</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信很多小伙伴们都在使用 Hexo + Github Page 的方式，先在本地生成自己博客的静态页面，然后再推送到 Github Page 来实现页面的更新。Github 近些年推出了 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a>，这是一个非常强大的 Workflow 自动化工作流，它可以帮助我们完成很多自动化部署任务。今天就来利用 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a> 自动化部署 Hexo 到 Github Page。</p>
<p>本来想使用 Travis CI 自动部署 Hexo 博客，一个私人仓库用于备份博客源码，另一个公开仓库用于托管静态页面，但是最近将修改的文章推送到私人仓库时没有触发 Travis CI 的工作流， Travis CI持续集成部署麻烦，而且还需付费，所以考虑了GIthub Action这种简单免费的部署方式。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>Node.JS</li>
<li>Git</li>
</ul>
<h3 id="Hexo本地博客搭建"><a href="#Hexo本地博客搭建" class="headerlink" title="Hexo本地博客搭建"></a>Hexo本地博客搭建</h3><h4 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h4><p>首先全局安装Hexo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Hexo</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，创建一个project文件夹，然后在该文件夹下初始化，（下面所有命令都是在该文件夹里执行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化 Hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>创建文章命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo new &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会发现在source&#x2F;_post文件夹里出现了”文章名字”.md的文件，Hexo采用markdown编辑。</p>
<p>在本地启动文章，就可以在<a href="http://localhost:4000/">http://localhost:4000/</a> 访问该博客了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo s   # 本地服务启动server</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228215744193.png" alt="image-20230228215744193"></p>
<p>Hexo常用的配置以及目录结构</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228220622909.png" alt="image-20230228220622909"></p>
<p>source&#x2F;_post用于存放用户文章 , _config.yml用于存放配置文件</p>
<h4 id="一些配置修改"><a href="#一些配置修改" class="headerlink" title="一些配置修改"></a>一些配置修改</h4><p>主题配置，在Hexo的官方网站上有许多可以选择的样式 <a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p>
<p>选择一个主题，按照主题里面提示的方法进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在Hexo目录下Clone这个主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"># 修改 Hexo 根目錄下的 _config.yml，把主題改為butterfly</span><br><span class="line">theme: butterfly</span><br><span class="line"></span><br><span class="line"># 安裝插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>





<p>在博客搭建完成之后会发现图片无法显示，</p>
<p>安装一个图片显示的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml的配置文件，然后把 _config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。将图片存放在这个文件夹里引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder = true</span><br></pre></td></tr></table></figure>





<h3 id="Hexo博客发布"><a href="#Hexo博客发布" class="headerlink" title="Hexo博客发布"></a>Hexo博客发布</h3><p>在github下创建一个 linli1724647576.github.io 的仓库，目前github采用的令牌代替密码，所以需要在 devoloper setting的设置里new 一个 Tokens，勾上所有的权限。</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228221853162.png" alt="image-20230228221853162"></p>
<p>然后，在_config.yml 的配置文件里做以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: &quot;https://github.com/linli1724647576/linli1724647576.github.io.git&quot;</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>执行上传命令，会提示输入github的用户名和密码，密码用令牌代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo d  #上传博客 deploy</span><br></pre></td></tr></table></figure>

<p>上传成功后就可以在github Pages里访问了。</p>
<h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;  等价于 hexo new &quot;我的第一篇文章&quot;  还等价于</span><br><span class="line">hexo p 等价于 hexo publish</span><br><span class="line">hexo g 等价于 hexo generate  </span><br><span class="line">hexo s等价于 hexo server     </span><br><span class="line">hexo d 等价于 hexo deploy</span><br></pre></td></tr></table></figure>

<p>下次发布时先运行hexo g生成静态网页，然后再hexo d </p>
<p>也可以采用admin模式自动发布,需要安装插件</p>
<p>npm install –save hexo-admin</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/BV1mU4y1j72n/">https://www.bilibili.com/video/BV1mU4y1j72n/</a></p>
<p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/2023/03/01/tags/</url>
    <content><![CDATA[<p>硕士在读，计算机技术专业，分享一些论文和一些技术，强迫自己以更加系统和严谨的态度梳理问题，也希望对他人有所帮助。</p>
]]></content>
  </entry>
  <entry>
    <title>PLUMBER</title>
    <url>/2023/03/04/PLUMBER/</url>
    <content><![CDATA[<h1 id="PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem"><a href="#PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem" class="headerlink" title="PLUMBER: Boosting the Propagation of Vulnerability Fixes in the npm Ecosystem"></a>PLUMBER: Boosting the Propagation of Vulnerability Fixes in the <em>npm</em> Ecosystem</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><ul>
<li>npm是JavaScript编程语言中最大的生态系统，截至2022年1月，它拥有超过180万个第三方软件包。</li>
<li>2017年11月2日的npm快照进行的调查显示，在610,097个包中，其中21.9%直接依赖于易受攻击的包。如果考虑到传递性依赖关系，这种脆弱性对npm生态系统的脆弱性影响可能会显著增加。</li>
<li>我们对npm包的3948个漏洞报告的初步研究发现，在发现漏洞后，60.6%涉及的包及时发布了修复版本。</li>
<li>漏洞修复工具例如 <em>npm</em> audit [6] and Dependabot [7] 来提醒那些直接地或过渡性地依赖于脆弱的软件包版本的项目。</li>
<li>我们对传播漏洞修复的滞后的原因进行了两个观察：大多数包只修复了其最高主要版本中的漏洞，而没有将修复移植到早期的流行版本中。由于缺乏生态系统级依赖图的完整概图，包开发人员几乎没有意识到它们是阻止修复程序传播到其许多下游包的关键因素。</li>
</ul>
<h2 id="2-Motivation-Example"><a href="#2-Motivation-Example" class="headerlink" title="2.Motivation Example"></a>2.Motivation Example</h2><p><img src="/2023/03/04/PLUMBER/image-20230226104613081.png" alt="image-20230226104613081"></p>
<ul>
<li>我们将阻止修复在依赖路径上传播的包称为阻塞包。上图中browser-sync和graphql为阻塞包。</li>
<li>从阻塞包到脆弱包的依赖路径被称为阻塞链。 上图中 browser-sync-&gt;socket.io -&gt;engine.io为一条阻塞链</li>
</ul>
<h2 id="3-Introduction"><a href="#3-Introduction" class="headerlink" title="3.Introduction"></a>3.Introduction</h2><h3 id="3-1-相关工作"><a href="#3-1-相关工作" class="headerlink" title="3.1 相关工作"></a>3.1 相关工作</h3><p>(1)脆弱性对生态系统的影响[2、10、10-16]；</p>
<p>(2)减少报告易受攻击的依赖项[17–22]的误报；</p>
<p>(3)易受攻击的程序包更新中的滞后[1,23-28]</p>
<p>[1] 他们进行了一项实证调查，以确定在脆弱的包发布和固定发布之间可能出现的滞后。为了确保快速采用和传播包含修复程序的版本，他们为开发人员和研究人员提供了可操作的建议：开发者要有更好的意识，以便更快地规划依赖项更新。</p>
<p>然而，现有的工作都没有探索生态系统中阻塞包和阻塞链的特征。如何设计一种技术来加速漏洞的修复仍然是一项主要问题。</p>
<h3 id="3-2-目标和挑战"><a href="#3-2-目标和挑战" class="headerlink" title="3.2 目标和挑战"></a>3.2 目标和挑战</h3><p>为关键软件包提供可行的补救策略，促进脆弱性修复的传播。</p>
<ul>
<li>获取最新的漏洞元数据和npm依赖元数据。</li>
<li>了解阻塞链的演化特征及其对脆弱性修复传播的影响。</li>
</ul>
<h3 id="3-3-方法和结果"><a href="#3-3-方法和结果" class="headerlink" title="3.3 方法和结果"></a>3.3 方法和结果</h3><p><strong>Empirical Study:</strong></p>
<p>（RQ1）含有漏洞的包的规模及其对其他项目的影响；</p>
<p>（RQ2）在连续npm快照上的阻塞链的演化特征；</p>
<p>（RQ3）对传播漏洞修复有更好效果的补救策略。</p>
<p><strong>Technique:</strong></p>
<p>(1)对漏洞和npm依赖元数据进行建模，并逐步更新其演化过程；</p>
<p>(2)识别阻碍漏洞修复通过依赖路径传播的关键阻塞链；</p>
<p>(3)分析阻塞链上的软件包的特性，定制修复方案。</p>
<p><strong>Evaluation:</strong></p>
<p>我们应用PLUMBER为最具影响力的阻塞链生成了268份修复报告。47.4%的补救报告得到了积极的反馈。PLUMBER生成的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个活跃的npm项目中。</p>
<p><strong>Contributions:</strong></p>
<ul>
<li>我们进行了第一个实证研究，以描述软件包在生态系统中阻碍脆弱性修复的传播的情况。</li>
<li>我们开发了PLUMBER工具，通过纠正关键的阻塞链，来促进npm生态系统中脆弱性修复的传播。</li>
<li>一个大规模的漏洞修复传播实验。我们的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个根包中。</li>
</ul>
<h2 id="4-Empirical-Study"><a href="#4-Empirical-Study" class="headerlink" title="4.Empirical Study"></a>4.Empirical Study</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2023/03/04/PLUMBER/image-20230227101417121.png" alt="image-20230227101417121"></p>
<p>搜集漏洞元数据：<em>GitHub Advisory DB</em>, <em>Snyk Vul</em> <em>nerability DB</em> and <em>NPM Security Advisories</em>. </p>
<p>收集npm依赖项元数据：（V，E，C） V版本集合， E依赖边 （最新版本）<em>E</em> &#x3D; <em>{<strong>p</strong>i*@<em>va</em> <em>→</em> <em>pj</em>@<em>v*<em>b</em></em>|<strong>p</strong>i*@<em>v*<em>a</em></em>, pj</em>@<em>vb</em> <em>∈</em></p>
<p><em>V</em> <em>}</em>.   C  依赖关系 <em>c</em>(<em>pi</em>@<em>v*<em>a</em></em>, pj* ) <em>∈</em> <em>C</em></p>
<p>识别易受攻击的路径：通过将漏洞元数据映射到npm依赖元数据G &#x3D;（V，E，C），在集合V中，我们定位了所有带有详细漏洞信息的脆弱包版本。通过可达性分析来识别所有的脆弱路径。</p>
<p>VP模型统计： Table 2</p>
<p><img src="/2023/03/04/PLUMBER/image-20230227102441166.png" alt="image-20230227102441166"></p>
<h3 id="RQ1（阻塞包的规模）："><a href="#RQ1（阻塞包的规模）：" class="headerlink" title="RQ1（阻塞包的规模）："></a>RQ1（阻塞包的规模）：</h3><p>在npm生态系统中阻止漏洞修复传播的包的规模是多少？它们在多大程度上影响了其他项目？</p>
<p>在npm生态系统的356283个活跃根系项目中，有20.0%)中有320个仍然通过1065723个脆弱路径直接或过渡地依赖于这些脆弱包。平均而言，每个根项目都会受到4.4个±7.5漏洞的影响。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228090108772.png" alt="image-20230228090108772"></p>
<p>在npm生态系统的快照中，有45,148个阻塞包和358,422个阻塞链导致983,336个依赖路径的漏洞修复传播滞后。在有影响力的阻塞软件包和阻塞链上都有明显的中心地位。20%的阻塞软件包和阻塞链影响了绝大多数脆弱的路径。</p>
<h3 id="RQ2（阻塞链的进化）："><a href="#RQ2（阻塞链的进化）：" class="headerlink" title="RQ2（阻塞链的进化）："></a>RQ2（阻塞链的进化）：</h3><p>阻断链在npm生态系统中是如何进化的？它们在npm的生态系统中存在了多久了？</p>
<p>方法：每隔两个月爬取一次npm快照，(a)通过比较快照si（1 &lt; i≤7）与s1的统计数据，我们研究了s1中阻塞链、脆弱路径和受影响的根项目的规模，这些项目在一年的进化过程中进行了修复。(b)通过比较两个连续快照si−1和si的统计数据，我们统计了每两个月间隔内修复的阻塞链、脆弱路径和受影响的根项目的数量。此外，我们还关注了与si−1相比，si是否引入了新的案例。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228091129135.png" alt="image-20230228091129135"></p>
<p>在2020年8月1日的npm快照中，经过一年的进化，77.0%的阻断链仍然存在。在此期间，受这些阻塞链影响的脆弱路径和根项目的数量分别下降了37.1%和17.3%。9,904个活动根项目通过17,612条脆弱路径仍然引用了9,808个与更高级漏洞捆绑的阻塞链。</p>
<h3 id="RQ3（补救模式）："><a href="#RQ3（补救模式）：" class="headerlink" title="RQ3（补救模式）："></a>RQ3（补救模式）：</h3><p>阻塞链如何从脆弱路径中去除？是否可以提炼出常见的补救模式，以促进漏洞修复的传播？</p>
<p>我们实证研究了在快照s1-s7（在RQ2中收集）和提炼的常见修复模式中，包更新是如何通过包更新进行修复的。我们关注两种类型的阻塞链，它们通过包更新进行了修复，具有传播漏洞修复的显著效果：</p>
<p><strong>Type A</strong>。阻断链存在于快照s1-si−1（1&lt;i≤7）中，而在快照si中被修复。</p>
<p><strong>Type B</strong>。快照s1-s7中存在的阻塞链，而在进化过程中受其影响的脆弱路径的数量显著减少。</p>
<p><strong>Remediation pattern A.</strong>  阻塞包在其最高主要版本中发布了一个新版本，其中升级了直接依赖以过渡引入漏洞修复。通过最终将直接依赖项升级到安全版本，它们最终修复了其最高可用版本中的漏洞。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093517214.png" alt="image-20230228093517214"></p>
<p><strong>Remediation pattern B</strong> 中间包在其较低的主要版本中发布一个新版本，其中升级直接依赖，使非活动的阻塞包过渡地引入漏洞修复（100%的Type A阻塞链实例）。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093534796.png" alt="image-20230228093534796"></p>
<p><strong>Remediation pattern C</strong> </p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093801859.png" alt="image-20230228093801859"></p>
<p>这三种模式的<strong>补救成本</strong>标记如下：模式A&lt;模式B&lt;模式C</p>
<p>我们提炼了三种常见的修复模式及其传播漏洞修复的先决条件。对于由主动阻塞包引起的阻塞链，这种阻塞包可以纠正其最高可用版本（模式A）中的漏洞。对于由非活动阻塞包引起的阻塞链，中间包可以纠正其较低主要版本序列中的漏洞，使非活动阻塞包能够过渡地引入漏洞修复（模式B）。此外，受阻塞链影响的包也可以不弃用不活动的阻塞包，并迁移到其他维护良好的包，以修复漏洞（模式C）。</p>
<h2 id="5、Approach"><a href="#5、Approach" class="headerlink" title="5、Approach"></a>5、Approach</h2><p><img src="/2023/03/04/PLUMBER/image-20230301174303414.png" alt="image-20230301174303414"></p>
<p>和DTResolver有区别的点：</p>
<p>识别阻塞链：对于每个脆弱路径，PLUMBER从脆弱包pu开始，迭代计算每个包的安全版本µt，直到阻塞包的安全版本为空。最后，PLUMBER根据通过它们的脆弱路径的数量对识别出的阻塞链进行排序。排名最高的阻塞链被认为是关键的阻塞链，应该进行修复，以使漏洞修复能够传播到大量的包中。</p>
<p>我们的实证研究结果表明，三种策略的补救成本通常遵循：策略A&lt;策略B&lt;策略 C. 因此，对于由积极维护的软件包引起的阻塞链，水管工高度建议了补救策略 A. 对于由非活动阻塞包引起的阻塞链，在中间包（即阻塞包和脆弱包之间的包）被开放版本约束指定的情况下，水管工建议补救策略B，如果它们可以返回到较低版本的序列。否则，水管工将采用补救策略C来迁移非活性的阻塞链。</p>
<h2 id="6、Evaluation"><a href="#6、Evaluation" class="headerlink" title="6、Evaluation"></a>6、Evaluation</h2><h3 id="RQ4（PLUMBER的有效性）："><a href="#RQ4（PLUMBER的有效性）：" class="headerlink" title="RQ4（PLUMBER的有效性）："></a>RQ4（PLUMBER的有效性）：</h3><p>水管工制定的补救策略与开发人员是否一致？</p>
<p>方法：选择开发人员已经修复的一些包作为基准，将我们的修复方案和开发人员的修复方案进行比较。</p>
<p>结果：由水管工提出的362种补救策略中，有289种（79.8%）与我们的基准策略一致。对于73种不一致的补救策略，我们的工具通过平衡漏洞修复的补救成本和传播效果来生成建议。</p>
<h3 id="RQ5（补救挑战）："><a href="#RQ5（补救挑战）：" class="headerlink" title="RQ5（补救挑战）："></a>RQ5（补救挑战）：</h3><p>补救npm生态系统中的阻塞链有多具有挑战性？</p>
<p>方法：为了回答RQ5，对于在最近2021年8月1日的npm快照上确定的358,422条阻塞链，我们将它们分为不同的修复难度级别。此外，我们还观察了它们的分布情况，并讨论了补救方面的挑战。</p>
<p>结果：对于影响npm生态系统中大多数脆弱路径的前20%的关键阻断链，其中46.1%的关键阻断链难以修复。它们要么需要迁移非活动的阻塞包，要么需要升级其依赖项的主要版本，以引入漏洞修复，这需要更多的代码更改和测试工作。37.0%的顶级关键阻塞链可以通过所涉及的中间包的反向移植实践进行修复。只有16.9%的顶级关键阻塞链可以通过将主动阻塞包的依赖关系升级到安全的版本来轻松修复。</p>
<h3 id="RQ6（LUMBER的有用性）："><a href="#RQ6（LUMBER的有用性）：" class="headerlink" title="RQ6（LUMBER的有用性）："></a>RQ6（LUMBER的有用性）：</h3><p>水管工能否促进npm生态系统中脆弱性修复程序的传播，并为开发人员提供有用的补救策略？</p>
<p>方法：向开发人员提出Bug  report，挑选了前300个关键的阻塞软件包，并人工验证受影响的下游项目是否可以引入相关的漏洞修复程序</p>
<p>结果：47.4%的补救报告收到了来自许多著名的npm项目的积极反馈。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h2><p>出发点不同，DTResolver是根据root package构造依赖树，并检测依赖树中的漏洞和一些修复策略。 PLUMBER更注重npm生态系统的平衡，检测npm生态系统的Block Chain，并对包开发人员提出修复建议。</p>
<p>和DTResolver一样，都对npm漏洞的影响进行了研究，DTResolver注重于npm3正确依赖树的构造，Plumber更注重实证研究和漏洞的修复。</p>
<p>DTResolver的DTReme的修复有点突兀，没有前因后果，Plumber的修复是基于他的实证研究的结果，根据开发人员的建议制定的策略。</p>
<p>论文的组织模式和Watchman, Nufix很像，都是先实证研究，将问题进行分类，探索开发人员的修复策略； 再根据我们的工具进行分类检测，并提出修复策略，最后让开发人员确认。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</title>
    <url>/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<h1 id="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"><a href="#通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱" class="headerlink" title="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"></a>通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><p><code>本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。</code></p>
<p><a href="https://www.secrss.com/articles/43424">https://www.secrss.com/articles/43424</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/594160921">https://zhuanlan.zhihu.com/p/594160921</a></p>
<p><a href="https://sites.google.com/view/npm-vulnerability-study/">https://sites.google.com/view/npm-vulnerability-study/</a></p>
<p><a href="https://www.youtube.com/watch?v=CErMF3CgSc8">https://www.youtube.com/watch?v=CErMF3CgSc8</a></p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>NPM上发布了170多万个Node.js库，以促进软件开发。正如对比安全所揭示的，第三方库出现在当今软件的大多数（79%）中。然而，任何事物都有两面性。虽然使用库可以减少开发成本和时间，但这些集成库在实践中对软件生态系统构成了新的安全威胁，这些库中的漏洞可能会使依赖它们的软件不断面临安全风险。之前的工作已经调查了整个NPM生态系统的脆弱性影响，而他们的方法要么只是静态地考虑直接依赖性，或者基于依赖关系进行间接依赖的可达性分析，这可能会引入不准确的传递依赖关系，从而导致误报漏洞警告。现存的研究方法还没有提供一个精确的依赖关系。尤其是软件依赖关系之间的内部复杂关系，在很大程度上削弱了其分析的影响，并限制了进一步的解决方案（即精确修复）的提出。尽管一些现有的SCA工具（如Snyk和Blackduck）支持对用户项目进行NPM依赖性分析，但大多数工具都是从实际安装中检索依赖树，而不是从静态推理中检索依赖树。此外，由于语义版本控制的灵活性，依赖关系以及依赖关系中的漏洞实际上会随着时间的推移而发生动态变化。因此，尽管现有工作也调查了漏洞的影响，在没有静态和精确的依赖关系解决方案的情况下，大规模分析依赖关系中存在的漏洞传播的演变仍然是一个挑战，更不用说在防止漏洞动态引入依赖项方面获得实用的解决方案。</p>
<h2 id="2-论文主要成果"><a href="#2-论文主要成果" class="headerlink" title="2. 论文主要成果"></a>2. 论文主要成果</h2><ul>
<li>实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包（超过114万个库和1094万个版本）之间的依赖关系，以及来自NVD的800多个已知CVE（常见漏洞和暴露），进一步的支持对漏洞传播的分析</li>
<li>提出了一种基于DVGraph的新算法（DTResolver），可以静态、精确地解析任意安装时间的依赖树，精度高达90%以上，并通过大约100k个代表性软件包进行了验证</li>
<li>进一步对依赖树中的脆弱性传播进行了实证研究。首先，我们研究了NPM依赖解析带来的依赖树的特征，在此基础上，我们分析了依赖树中漏洞传播的影响和特征，特别是传递依赖的漏洞。此外，我们还将研究扩展到时间维度，以研究依赖树中漏洞传播随时间的演变，揭示依赖树中引入漏洞的原因，以及可能的解决方案</li>
</ul>
<h2 id="3-实验架构"><a href="#3-实验架构" class="headerlink" title="3. 实验架构"></a>3. 实验架构</h2><p>包括依赖漏洞知识图构建、依赖树解析、漏洞路径识别及其验证、大规模实证研究以及对经验教训和解决方案的讨论，以及可能的研究方向</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1ed5572cf3d56e315f7e865590c7f9ac.png" alt="img"></p>
<h2 id="4-DVGraph的构建"><a href="#4-DVGraph的构建" class="headerlink" title="4. DVGraph的构建"></a>4. DVGraph的构建</h2><p>为了支持高精度和高效率的大规模依赖漏洞分析，我们设计并实现了一套数据处理平台，以构建和维护完整而精确的依赖漏洞图DVGraph（基于neo4j）。</p>
<p>下图为改数据处理平台的框架：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/5d6447824371e7607b366407f7aad9fa.png" alt="img"></p>
<p><strong>Metadata Pipeline：</strong>将数据保存在元数据库中</p>
<p><strong>CVE Pipeline：</strong>从NVD数据集收集CVE数据</p>
<p><strong>CVE Triage Pipeline：</strong>手工标记CVE数据的对应的受影响的库和版本</p>
<p><strong>Graph Pipeline：</strong>解析新来的元数据和映射的CVE数据，计算要在DVGraph上执行的操作（即添加、更改和删除节点和边），并最终执行这些操作</p>
<h2 id="5-依赖树解析和脆弱路径识别"><a href="#5-依赖树解析和脆弱路径识别" class="headerlink" title="5. 依赖树解析和脆弱路径识别"></a>5. 依赖树解析和脆弱路径识别</h2><h3 id="5-1-依赖树解析"><a href="#5-1-依赖树解析" class="headerlink" title="5.1 依赖树解析"></a>5.1 依赖树解析</h3><p>目前还没有一个考虑到特定于平台的依赖关系解决规则，可能导致不准确的依赖关系解析。本文目标是实现静态解析与NPM在实际安装过程中动态解析和安装的依赖树一致的依赖树，以便我们能够准确有效地识别依赖树中的漏洞和脆弱路径，而无需实际安装。</p>
<p>为了提高精度，同时保持效率，我们提出了一种基于DVGraph的依赖解析算法（DTResolver），可以在不安装的情况下，对任意数据软件包依赖解析的过程中，识别并找出所有依赖中含有安全漏洞的组件及相应的依赖引入路径</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/0fffc83b26b8297bd142c0061a005fb8.png" alt="img"></p>
<p>Dependency Tree Resolution</p>
<p>此外由于NPM中广泛使用依赖约束条件（版本范围）而不是固定版本进行依赖定义，导致依赖安装结果随着时间可能发生变化</p>
<p>如下图中，在<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#46;&#49;">&#66;&#64;&#49;&#46;&#x30;&#46;&#49;</a>发布后，<a href="mailto:&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>的安装过程中，对B的依赖将解析成新发布的版本而不是原有的<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>, 图中<a href="mailto:&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;">&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;</a>的发布亦是如此。因此我们在DTResolver的基础上进一步增加了时间约束，使其能够支持在给定项目从其发布前到DVGraph更新时间内任意时刻的依赖树模拟解析。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/cb04b86c4aafea8676a467c495666079.jpg" alt="img"></p>
<h3 id="5-2-脆弱路径识别"><a href="#5-2-脆弱路径识别" class="headerlink" title="5.2 脆弱路径识别"></a>5.2 脆弱路径识别</h3><p>给出了脆弱点和路径的示例 通过反向深度优先搜索（DFS）实现了一个脆弱路径提取器，以彻底查找依赖树中从脆弱点到根节点的依赖关系</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/aed9b3b573cfcee4c57b966475f78199.png" alt="img"></p>
<h3 id="5-3-评估验证"><a href="#5-3-评估验证" class="headerlink" title="5.3 评估验证"></a>5.3 评估验证</h3><p>通过比较DTResolver解析的依赖树与实际安装的依赖树来验DTResolver。此外，我们将npm-remote-ls作为比较时的方法，这是一种广泛使用的公共API，在实践中无需实际安装即可获得依赖树，并且它完全遵循依赖范围来派生依赖树。</p>
<p>数据选择我们的验证基于两个标准收集的数据：（1）流行度，对于每个流行度指标（即过去、过去3年和去年下载量最多的明星、分叉、下载量多），我们分别选择了前2000个库。（2）中心性，对于每个中心性度量（即最大出入度），我们还选择了前2000个库和前20K个版本。分别地对于库，我们采用每个次要版本的最高补丁版本。最后，整理了15673个库中的103609个版本。</p>
<p><strong>DTResolver解析器的评估。</strong>根据结果，90.58%的图树在忽略无法计算的情况（例如，具有捆绑的依赖项并且包含没有时间的依赖项）后与安装树完全匹配。而只有53.33%的远程树与安装树完全匹配，这是因为npm远程ls错过了一些官方的解决规则（例如，未弃用版本的优先级选择）。此外，我们进一步确定了不匹配依赖树的两个主要原因：1）在npm ls的输出中消除了依赖，这省略了一些包和依赖关系以简化树视图。2） 由于环境问题，依赖项可能无法完全安装（例如，当缺少所需的操作系统支持时，某些程序包可能无法安装）。此外，缺少库版本（即不在NPM注册表中或爬网失败）也会导致依赖关系树中缺少一些包。</p>
<p><strong>漏洞检测和漏洞路径识别评估。</strong>除了DTResolver的评估，我们还扩展到比较检测到的漏洞和易受攻击的路径。由于从实际安装中检索到的安装树可能不完整（例如，依赖关系中的某些包由于环境问题而未安装），我们通过调用Graph Tree和Remote Tree中已识别的漏洞和漏洞路径来评估漏洞检测的准确性。我们发现DTResolver（98.1%）和npm远程ls（97.7%）在检测易受攻击组件方面具有相似的高覆盖率，但在识别易受攻击路径方面存在差异（92.60%对78.31%）。这可能是因为大多数依赖性约束都被解析为最满意的版本，并且依赖性范围也遵循这一规则，因此，仍然可以识别最脆弱的包。然而，通过依赖关系到达解决依赖关系忽略了NPM特定的解决规则，这会影响识别依赖关系路径的准确性。</p>
<h2 id="6-大规模实证研究"><a href="#6-大规模实证研究" class="headerlink" title="6. 大规模实证研究"></a>6. 大规模实证研究</h2><p>以下两个方面分析NPM中安全漏洞的影响：</p>
<ul>
<li>漏洞如何影响NPM生态系统？漏洞如何通过依赖关系树传播影响根包(root packages)？</li>
<li>漏洞传播如何在依赖树中发展？依赖关系树的变化如何影响漏洞传播的演变？</li>
</ul>
<h3 id="6-1-通过依赖树传播漏洞"><a href="#6-1-通过依赖树传播漏洞" class="headerlink" title="6.1 通过依赖树传播漏洞"></a>6.1 通过依赖树传播漏洞</h3><ul>
<li>据统计证明，漏洞广泛存在于NPM包的依赖关系中（整个生态系统中有19.96%的库的四分之一版本）</li>
<li>第三方库的最新版本（16.17%）仍然存在通过依赖关系受到漏洞影响的潜在风险。</li>
<li>其他用户使用的易受攻击的库中，有相当一部分（超过100个）仍然有易受攻击的最新版本</li>
<li>一些有影响力的已知CVE广泛存在于大部分包的依赖树中</li>
<li>包通常受到多个漏洞的影响，每个漏洞通过多个漏洞路径影响根包（平均一个漏洞引入8个漏洞路径）</li>
<li>漏洞仍然广泛存在于受影响库版本的直接依赖关系中（超过30%），即使是最新版本</li>
<li>在易受攻击的路径上也存在中心性，即大多数易受攻击的路径都会通过有限的直接依赖关系，这可以用来切断易受攻击的路径</li>
</ul>
<h3 id="6-2-依赖树中的漏洞传播演化"><a href="#6-2-依赖树中的漏洞传播演化" class="headerlink" title="6.2 依赖树中的漏洞传播演化"></a>6.2 依赖树中的漏洞传播演化</h3><ul>
<li>随着时间的推移，已知的漏洞正在对NPM生态系统造成更大的影响。它们不仅影响到更多的库版本，而且还影响到依赖树中更脆弱的点</li>
<li>大多数CVE（93%）在被发现之前已经被引入依赖树，这些CVE的固定版本（87%）也大多在CVE发布之前发布</li>
<li>依赖树中只有60%的CVE被DTC自动删除，即使如此，每个CVE删除仍需要一年以上的时间</li>
<li>过时的维护（提供者）和不合适的依赖约束（使用者）是阻碍依赖树中漏洞自动移除的主要原因。应该采取更多的对策和解决方案来避免、监控甚至纠正这些不良做法</li>
</ul>
<p>DTReme</p>
<p>添加了1)<strong>前向漏洞检查</strong>，在解析新的依赖关系的版本时（算法1中的第13行和第17行），只解析每个依赖关系的干净版本；2)<strong>向后安装的包跟踪</strong>，一旦没有干净版本可以解决，回滚到父节点的解析，并找到替代版本，以避免没有干净版本的情况。因此，我们可以彻底遍历所有可能的解决方案，找到可能的干净依赖树，并且可以为整个依赖树生成一个新的package-lock.json文件作为修复解决方案。</p>
<h2 id="7、有限性"><a href="#7、有限性" class="headerlink" title="7、有限性"></a>7、有限性</h2><p>首先，依赖关系中的漏洞可能永远不会影响根包，因为可能永远无法访问这些易受攻击的功能。这只能通过基于依赖树和调用图分析易受攻击的函数调用路径来进一步解决。我们将此作为我们未来的工作。其次，CVE和库版本的映射是手动标记的，这可能会导致数据错误标记，合作的作者已将数据与现有CVE交叉验证，以缓解此类威胁。第三，我们无法区分包含缺失依赖项的安装，这可能会使基本事实不准确，我们只接受依赖项中成功安装的包作为验证中的基本事实。第四，由于计算成本过高，在分析漏洞传播时，我们忽略了具有超过1k条漏洞路径的版本。总的来说，这样的版本只占2.01%，这只能对我们的结果造成有限的偏差。</p>
<h2 id="附录1-Npm依赖解析规则"><a href="#附录1-Npm依赖解析规则" class="headerlink" title="附录1 Npm依赖解析规则"></a>附录1 Npm依赖解析规则</h2><p><a href="https://docs.npmjs.com/cli/v9/commands/npm-install">https://docs.npmjs.com/cli/v9/commands/npm-install</a></p>
<p><a href="https://www.cnblogs.com/penghuwan/p/6970543.html">【npm】详解npm的模块安装机制 - 外婆的 - 博客园 (cnblogs.com)</a></p>
<p><font color="red"><strong>依赖树表面的逻辑结构与依赖树真实的物理结构</strong> </font></p>
<p>这里要先提到两个命令：tree -d（linux）和npm ls（npm）</p>
<p>在一个npm项目下：</p>
<p><strong>tree -d命令</strong>以树状图的方式列出一个项目下所有依赖的物理结构</p>
<p><strong>npm ls命令</strong>以树状图的方式列出一个项目下所有依赖的逻辑结构</p>
<p>以官方文档为例子：</p>
<p>项目example1有两个依赖模块：mod-a模块和mod-c模块；</p>
<p>mod-a模块有一个依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;">&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;</a>模块</p>
<p>mod-c模块有一个依赖模块<a href="mailto:&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;</a>模块</p>
<p>tree -d 和npm ls运行结果如下：（注意npm版本为npm3而非npm2）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092200262-641835535.png" alt="img"></p>
<p>先看看下面那个红框的结果，这应该是“最符合我们理解”的依赖树，首先项目下形成了一级依赖——mod-a模块和mod-b模块，然后以这两个模块为父模块再追加二级依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a>和<a href="mailto:mod-b@2.0.0">mod-b@2.0.0</a></p>
<p>但是！这却并不是物理上真实形成的依赖树的模样，物理上真实形成的依赖树是上面的那个红色框。<strong>mod-a,mod-c和mod-b竟然同为同一级</strong>的依赖。</p>
<p>你可能会问，为什么会形成这样的依赖树呢？下面我就来解释一番</p>
<p>【注意】：下面的图示全部为依赖树的物理结构，而不是逻辑结构</p>
<p><font color="red"><strong>关于npm模块安装机制的一点猜想</strong></font></p>
<p>安装模块时，可能的方式有两种：<strong>平级式</strong>的安装或<strong>嵌套式</strong>的安装（此处仅仅是猜想和假设）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092352262-1548398831.png" alt="img"></p>
<p>能不能完全采取平级的安装方式呢？——不能</p>
<p>我们取和上面相似的一个例子：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块Cv2.0。显然，它们并不能同时存在于同一个node_modules下，当安装的时候，由于npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092426950-802407609.png" alt="img"></p>
<p>但如果我们仅仅只安装一个版本的C依赖模块，将可能会导致A模块和B模块不兼容</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092458231-782438150.png" alt="img"></p>
<p><strong>基于以上原因，npm2选择了嵌套的安装方式——</strong></p>
<p><font color="red"><strong>npm2下的模块安装机制</strong></font></p>
<p>npm2安装多级的依赖模块采用嵌套的安装方式：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092546575-1188239142.png" alt="img"></p>
<p><strong>优点和弊端</strong></p>
<p><strong>优点：</strong>解决了版本单一时存在的存在的不兼容问题，实现多版本兼容</p>
<p><strong>弊端：</strong>可能造成相同模块大量冗余的问题，如下：</p>
<p>以上面例子为例，下面这种情况也是合理存在的：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092618981-1003798029.png" alt="img"></p>
<p>凭感觉也知道，这绝不是什么好现象，那我们如何能在实现依赖间多版本兼容的前提下，减少这种模块冗余呢？于是npm3做了一下改进</p>
<p><font color="red"><strong>npm3下的模块安装机制：</strong></font></p>
<p>npm3和npm2的不同主要体现在二级模块的安装上：</p>
<p>npm3会**”尽量”<strong>把逻辑上某个层级的模块在物理结构上</strong>“全部”**放在项目的第一层级里，具体我概括为以下三种情况：</p>
<p>1.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>还没有相同名称的模块</strong>，便<strong>把这第二层级的模块放在第一层级</strong></p>
<p>2.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，相同版本的模块</strong>，便<strong>直接复用那个模块</strong></p>
<p>3.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，但版本不同的模块</strong>，便<strong>只能嵌套在自身的父模块下方</strong></p>
<p>这一开始可能有些难理解，所以让我们看图说话吧！</p>
<p><strong>先说1：在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</strong></p>
<p>我们先简化一下上面的例子：现在项目APP下只有一个一级依赖模块A，它下面有一个二级依赖模块C，但npm install的时候，项目下安装依赖的</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092737903-1235721353.png" alt="img"></p>
<p>npm3中的二级模块（C v1.0),在项目的一级目录（node_modules）下没有相同名称的模块时，会被安装到一级目录下，从而跟它的父模块A同级。<strong>这就是本文一开始中依赖树的逻辑结构和物理结构不同的起因</strong>。</p>
<p>也就是说：</p>
<p><strong>在npm2中，依赖树的逻辑结构和它的物理结构相同</strong></p>
<p><strong>在npm3中，依赖树的逻辑结构和它的物理结构可能不同</strong></p>
<p><strong>再说2:在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</strong></p>
<p>在1的基础上，我们把1的例子还原回之前的复杂一些的场景：：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块C v1.0（两个C模块版本相同）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092859168-1795479456.png" alt="img"></p>
<p>对npm2,两个C包是相同的，造成模块冗余</p>
<p>在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块</p>
<p><strong>npm3就是用这种方式，部分地解决了npm2的痛点（部分）</strong></p>
<p>【从1，2到3的过渡】我在这一小节的开始说：“npm3会”尽量”把逻辑上某个层级的模块”全部”放在项目的第一层级里”，我想你看完1，2后应该多少有些理解了**<em>“尽量”*<strong>的含义了，但我说了</strong></em>“尽量”***，同时也就意味着npm3存在着不能把二级依赖放在第一层级的情况。对此，请看3:</p>
<p><strong>最后说3:在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方</strong></p>
<p>在2中，A，B所依赖的两个C模块是相同的，<strong>但如果两个C模块的版本不同呢？</strong>，项目npm install情况如下：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093023575-1842293712.png" alt="img"></p>
<p>在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块</p>
<p><strong>（看到这里我想应该能解答你对文章开头那个例子的疑惑了吧，这个例子和那个例子是几乎完全一样的哦）</strong></p>
<p>看到这里，你对npm2和npm3下的模块工作机制，以及npm3针对npm2的优化有个大体的了解了吧，但请思考一个问题：n<strong>pm3是否已经把npm2的模块冗余的缺陷优化到极致了呢？</strong> ———答案是<strong>没有</strong>，请往下看：</p>
<p>实际上：<strong>npm3中仍然可能出现模块冗余的情况</strong>，因为一级目录下已经有v1.0的C模块了，<strong>所以所有的v2.0只能作为二级依赖模块被安装</strong>，这样你就会看到如下的情况</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093147262-345050329.png" alt="img"></p>
<p>并且在上图所示的这种特殊情况里，npm3和npm2表现得似乎并没什么区别</p>
<p>【过渡】那么这有没有什么解决的方式呢？当然是有的，当A模块下的C v1.0模块被更新至C v2.0的前提下，我们可以<strong>通过npm dedupe把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0</strong></p>
<p><font color="red"><strong>利用npm dedupe去除冗余模块</strong></font></p>
<p><strong>npm dedupe做了什么？****它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块</strong></p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093125700-1173491575.png" alt="img"></p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
</search>
