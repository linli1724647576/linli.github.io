<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级刷题指南</title>
    <url>/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="PAT甲级刷题指南"><a href="#PAT甲级刷题指南" class="headerlink" title="PAT甲级刷题指南"></a>PAT甲级刷题指南</h1><h2 id="《算法笔记》C-标准模板库-STL-介绍"><a href="#《算法笔记》C-标准模板库-STL-介绍" class="headerlink" title="《算法笔记》C++标准模板库(STL)介绍"></a>《算法笔记》C++标准模板库(STL)介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>变长数组</p>
<h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、vector&lt;int&gt; v(size,0);  //初始化为0</span><br><span class="line">2、vector&lt;int&gt; v;  v.resize(n,0);  //resize一个大小为n，初值为0的可变数组</span><br><span class="line">3、vector&lt;type&gt; v;   //不初始化,type可以是一个结构体</span><br><span class="line">4、vector&lt;int&gt; ilist2(v);  vector&lt;int&gt; ilist2  = v;   //两种方式等价，都是深拷贝</span><br><span class="line">5、vector&lt;int&gt; ilist = &#123;1,2,3.0,4,5,6,7&#125;;   //和数组初始化方法一样</span><br><span class="line">6、vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1);   //迭代器初始化</span><br></pre></td></tr></table></figure>

<h5 id="访问："><a href="#访问：" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、随机访问数组下标访问 v[i]</span><br><span class="line">2、迭代器访问数组</span><br><span class="line">    vector&lt;int&gt;::iterator iter;</span><br><span class="line">    for(iter = vi.begin();iter != vi.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a><strong>常用函数</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、插入push_back  v.push_back(i);</span><br><span class="line">2、删除pop_back   v.pop_back();  //删除最后一个元素，回溯的时候常用</span><br><span class="line">3、大小size    v.size();  //获取数组大小</span><br><span class="line">4、清空clear   v.clear(); //清空数组</span><br><span class="line">5、插入insert  //尽量不要频繁使用这个函数，会引起大量数据移动，降低程序效率</span><br><span class="line">    v.insert(v.begin(),8);//在最前面插入新元素</span><br><span class="line">    v.insert(v.begin()+3,1);//在迭代器中下标为3的元素前插入新元素</span><br><span class="line">    v.insert(v.end(),3);//在向量末尾追加新元素</span><br><span class="line">    v.insert(v.end(),3,0);//在尾部插入3个0</span><br><span class="line">6、删除erase  //erase函数有两种函数原型，一种是给定要删除的位置，另一种是给定删除的区域。</span><br><span class="line">	有两种函数原型，c.erase (p),c.erase(b,e);第一个删除迭代器p所指向的元素，第二个删除迭代器b,e所标记的范围内的元素，c为容器对象，返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点）</span><br><span class="line">	应用一：删除连续数字</span><br><span class="line">	//但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); iter++)  </span><br><span class="line">	&#123;</span><br><span class="line">      if(*iter == 3)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">	&#125;</span><br><span class="line">	//可以删除连续的数字3</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">     if( *iter == 3)</span><br><span class="line">          iter = veci.erase(iter);//当删除时erase函数自动指向下一个位置，就不需要进行++</span><br><span class="line">      else</span><br><span class="line">            iter ++ ;    //当没有进行删除的时候，迭代器++</span><br><span class="line">	&#125;</span><br><span class="line">	//另一种解决无法删除连续的数字的方法</span><br><span class="line">	我们先介绍一下remove函数:</span><br><span class="line">    remove是个stl的通用算法std::remove(first,last,val)移除[first, last)范围内等于val的元素在vector里面用就类似于 iter=std::remove(vec.begin(), vec.end(), val)但这个函数只是把val移到vec的末尾，并不真正删除,真正删除还是要调用一次erase函数</span><br><span class="line">    veci.erase(remove(vec.begin(),vec.end(),3),vec.end());</span><br><span class="line">    </span><br><span class="line">    应用二：删除重复数字，顺序不发生变化</span><br><span class="line">    如果不要求顺序的话，我们可以直接调用unique函数进行操作，这里介绍一下unique函数：从头到尾，判断当前元素是否等于上一个元素，将不重复的元素移到前面来(赋值操作)，而不是将重复的元素移动到后面去。</span><br><span class="line">    vec.erase(unique(vec.begin(),vec.end()),vec.end())  //将重复的区域删除，顺序会改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a><strong>常见错误</strong>：</h5><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814163126705.png" alt="image-20210814163126705"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>是一个内部自动有序且不含重复元素的容器</p>
<p>unordered_set 无序 其余和set的用法一样，效率更高</p>
<h5 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s(b, e);</span><br><span class="line">比如：</span><br><span class="line">int arr[]=&#123;1,2,3,4,3,2,1&#125;;</span><br><span class="line">set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-1"><a href="#访问：-1" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、迭代器访问</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt;::iterator it</span><br><span class="line">for(it = st.begin();it != st.end();it++)&#123;</span><br><span class="line">	printf(&quot;%d &quot;,*it);</span><br><span class="line">&#125; </span><br><span class="line">2、随机访问   在set中查找2，返回其迭代器</span><br><span class="line">set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">printf(&quot;%d &quot;,*it);</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	set&lt;int&gt; st;</span><br><span class="line">1、插入 insert()</span><br><span class="line">	st.insert(3);</span><br><span class="line">2、查找 find()</span><br><span class="line">	set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">	if(st.find(2)==st.end()) printf(&quot;没找到&quot;);</span><br><span class="line">3、删除  erase()</span><br><span class="line">st.erase(it) it为需要删除元素的迭代器，复杂度O(1)</span><br><span class="line">st.erase(value) value为要删除元素的值，复杂度O(logN)</span><br><span class="line">	st.erase(st.find(2));</span><br><span class="line">	st.erase(2)，效果一致，两种用法</span><br><span class="line">4、获取元素个数 size()</span><br><span class="line">	cout&lt;&lt;&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">5、清空 clear()</span><br><span class="line">	st.clear(); </span><br><span class="line">6、判空 empty()</span><br><span class="line">	st.empty()</span><br></pre></td></tr></table></figure>





<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>字符串</p>
<h5 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string s1;  s1为空字符串</span><br><span class="line">2、string s2(&quot;ABC&quot;);  用字符串字面值初始化s2</span><br><span class="line">3、string s3(s2);  用s3初始化为s2的一个副本</span><br><span class="line">4、string s4(n,&#x27;c&#x27;);  将s4初始化为字符&#x27;c&#x27;的n个副本</span><br></pre></td></tr></table></figure>

<h5 id="访问：-2"><a href="#访问：-2" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过下标访问</span><br><span class="line">    string str = &quot;abcd&quot;;</span><br><span class="line">    for(int i=0;i &lt; str.length();i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,str[i]);</span><br><span class="line">    &#125; </span><br><span class="line">2、通过迭代器访问</span><br><span class="line">    cout&lt;&lt;&quot;通过迭代器访问如下：&quot;&lt;&lt;endl;</span><br><span class="line"> for(string::iterator;it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,*it);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-2"><a href="#常用函数：-2" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、判空 s.empty()</span><br><span class="line">2、统计字符个数  s.size()  /   s.length()</span><br><span class="line">3、拼接字符串 += </span><br><span class="line">	str3 = str1+str2;  //拼接后再赋值</span><br><span class="line">	str1 += str2;  //直接接在后面，效率更高</span><br><span class="line">4、字符串比较大小 == != &gt;=等等</span><br><span class="line">5、插入 insert()</span><br><span class="line"> insert(pos,string) 在pos位置插入string</span><br><span class="line"> insert(it,it2,it3) 在it位置插入 [it2,it3)的串，it2,it3为待插字符串的首尾迭代器</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line"> 	str2 = &quot;opq&quot;;     //insert(pos,string)</span><br><span class="line">	str1.insert(3,str2);</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.insert(str1.begin()+3,str2.begin(),str2.end());     //insert(it,it2,it3)</span><br><span class="line">	cout&lt;&lt;&quot;abcopqxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">6、删除单个元素、区间元素 erase()</span><br><span class="line"> 删除单个元素 str.erase(it)  it为删除元素的迭代器</span><br><span class="line"> 删除一个区间内的所有元素 str.erase(first,last) [first,last)</span><br><span class="line"> str.erase(pos,length) pos为开始位置，length为长度</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcopqopqxyz&quot;;</span><br><span class="line"> 	str1.erase(str1.begin()+3);//str.erase(it)删除4号位o </span><br><span class="line">	cout&lt;&lt;&quot;abcopqopqxyz字符串删除第四个位置o字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(str1.begin()+3,str1.end()-3);//str.erase(first,last)</span><br><span class="line">	cout&lt;&lt;&quot;abcpqopqxyz字符串删除第4~8位置字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(3,3);//str.erase(ipos,length)</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串删除从第4位置开始的3个字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">7、清空 clear()</span><br><span class="line">	str1.clear();</span><br><span class="line">8、子串 substr()</span><br><span class="line"> substr(pos,len) 返回从pos号开始，长度为len子串</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串从下标2开始长度为3的子串为：&quot;&lt;&lt;str1.substr(2,3)&lt;&lt;endl;</span><br><span class="line">9、查找 find()</span><br><span class="line"> str.find(str2) 当str2是str的子串时，返回其在str中第一次出现的位置，如果str2不是str的子串，返回string::npos（常数）</span><br><span class="line"> str.find(str2,pos) 从str的pos号位置开始匹配str2，返回指相同</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;,str2=&quot;xyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;xyz子串在abcxyz中第一次出现的位置为：&quot;&lt;&lt;str1.find(str2)&lt;&lt;endl;  </span><br><span class="line">	</span><br><span class="line">	position = s.find(&quot;jk&quot;);</span><br><span class="line">	if (position != s.npos) printf(&quot;position is : %d\n&quot; ,position);  //查找成功</span><br><span class="line">	else printf(&quot;Not found the flag\n&quot;);  //查找失败</span><br><span class="line"> 10、替换 replace()</span><br><span class="line">  str.replace(pos,len,str2) 把str从pos号开始，长度为len的子串替换为str2</span><br><span class="line">  str.replace(it1,it2,str) 把str的迭代器[it1,it2)返回的子串替换为str2</span><br><span class="line">  	str1 = &quot;Maybe you will turn around.&quot;;</span><br><span class="line">	str2 = &quot;will not&quot;;str3 = &quot;surely&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will turn around.字符串从第10位开始的4位替换为str2后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(10,4,str2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will not turn around.字符串从起始位开始的5位替换为str3后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(str1.begin(),str1.begin()+5,str3)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h5 id="string和char-的转换"><a href="#string和char-的转换" class="headerlink" title="string和char[]的转换"></a>string和char[]的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string转char*</span><br><span class="line">printf(&quot;%s&quot;,str.c_str());</span><br><span class="line">2、char* 转string</span><br><span class="line">	char* p = &quot;abc&quot;;</span><br><span class="line">    string s = p;</span><br></pre></td></tr></table></figure>

<h5 id="string和int等类型的转换"><a href="#string和int等类型的转换" class="headerlink" title="string和int等类型的转换"></a>string和int等类型的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转string:</span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br><span class="line">转Int</span><br><span class="line">stoi(str1);  //int</span><br><span class="line">stof(str1);  //float</span><br><span class="line">stoll(str1);  //long long </span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string strA = &quot;yasaken@126.com&quot;;</span><br><span class="line">    string strB = &quot;LURY@LENOVO.com&quot;;</span><br><span class="line">    printf(&quot;Before transform:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::toupper);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::toupper);</span><br><span class="line">    printf(&quot;After transform to toupper:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::tolower);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::tolower);</span><br><span class="line">    printf(&quot;After transform to lower:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>map即映射，是常用的STL容器，它可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<p>uordered_map无序容器，效率更高</p>
<h5 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、直接赋值</span><br><span class="line">map&lt;string, int&gt; m1;</span><br><span class="line">m1[string(&quot;abc&quot;)] ++;</span><br><span class="line">//如果“abc&quot;已经存在，会在原来的基础上++，如果不存在，则会创建一个hash_key</span><br><span class="line"></span><br><span class="line">2、用insert添加</span><br><span class="line">map&lt;string, int&gt; m2;</span><br><span class="line">m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-3"><a href="#访问：-3" class="headerlink" title="访问："></a>访问：</h5><p>map会以键从小到大的顺序自动排序，unordered_map则不会排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过key访问value</span><br><span class="line">	map&lt;char,int&gt; mp;</span><br><span class="line">	//通过下标访问 </span><br><span class="line">	mp[&#x27;c&#x27;] = 20;</span><br><span class="line">	mp[&#x27;c&#x27;] = 30;//20被覆盖</span><br><span class="line">	printf(&quot;%d\n&quot;,mp[&#x27;c&#x27;]);//输出30</span><br><span class="line">2、通过迭代器访问</span><br><span class="line">	for(map&lt;char,int&gt;::iterator it = mp.begin();it != mp.end();it++)&#123;</span><br><span class="line">		//it-&gt;first是当前映射的键；it-&gt;second是当前映射的值 </span><br><span class="line">		printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-3"><a href="#常用函数：-3" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查找  find()</span><br><span class="line">     if(M.find(exponent)!=M.end())&#123;</span><br><span class="line">     	printf(&quot;%d&quot;,M[exponent]);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	printf(&quot;没找到&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	map&lt;char,int&gt;::iterator it = mp.find(&#x27;b&#x27;);</span><br><span class="line">	printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">2、删除 erase</span><br><span class="line"> mp.erase(key);  key为想要删除的键</span><br><span class="line"> mp.erase(first,last); 删除一个区间内的元素，first,last为迭代器</span><br><span class="line"> 	it = mp.find(&#x27;m&#x27;);</span><br><span class="line">	mp.erase(it);//删除b 2</span><br><span class="line">	mp.erase(&#x27;r&#x27;);//删除b 2</span><br><span class="line">3、获取大小 size()</span><br><span class="line">	cout&lt;&lt;&quot;此时map的长度为：&quot;&lt;&lt;mp.size();</span><br><span class="line">4、清空 clear()</span><br><span class="line">	mp.clear();</span><br></pre></td></tr></table></figure>

<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap:"></a>multimap:</h5><p>multimap 和 map 很相似，但是 multimap 允许重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multimap&lt;int, string&gt; multi_map;		// 可实现多重映射</span><br><span class="line"></span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng1&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng2&quot; &#125;);</span><br><span class="line">for (auto&amp; i: multi_map)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; &quot;  &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">520  huameng</span><br><span class="line">520  huameng1</span><br><span class="line">520  huameng2</span><br></pre></td></tr></table></figure>



<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>Queue翻译为队列，理解为一个先进先出的容器</p>
<h5 id="queue初始化："><a href="#queue初始化：" class="headerlink" title="queue初始化："></a>queue初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; first;                 // empty queue</span><br></pre></td></tr></table></figure>

<h5 id="访问：-4"><a href="#访问：-4" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问队首元素：如q.front()</span><br><span class="line">访问队尾元素，如q.back();</span><br><span class="line">printf(&quot;%d %d\n&quot;,q.front(),q.back());</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-4"><a href="#常用函数：-4" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size()-容器大小</span><br><span class="line">empty()-容器判空</span><br><span class="line">push()尾部增加元素</span><br><span class="line">pop()删除尾部元素</span><br></pre></td></tr></table></figure>

<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue:"></a>priority_queue:</h5><p>在&lt; queue&gt;头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</p>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义priority_queue对象</span><br><span class="line">priority_queue&lt;int &gt;q1;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q2;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;//定义小的先出队</span><br><span class="line">//其中第二个参数( vector )，是来承载底层数据结构堆的容器，第三个参数( less )，则是一个比较类，</span><br><span class="line">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span><br></pre></td></tr></table></figure>

<p>priority_queue的基本操作均与queue相同，<strong>优先队列没有back（）操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>

<p>操作示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//---1---push()</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---2---top()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;优先队列341的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());  <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//---3---pop()</span></span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;弹出队首元素后优先队列的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());   <span class="comment">//3</span></span><br><span class="line">	<span class="comment">//---4---empty()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列为空吗？&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;Not Empty\n&quot;</span>);</span><br><span class="line">	<span class="comment">//---5---size()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列大小为：&quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级操作示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级队列优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//---1---基本数据类型：设置优先级队列总是把最小的元素放在队首 </span></span><br><span class="line">	<span class="comment">// priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //小顶堆</span></span><br><span class="line">    <span class="comment">//注意&lt;int&gt; &gt;之间的空格 </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//大顶堆</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体优先级的设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;  <span class="comment">//价格大的优先</span></span><br><span class="line">        <span class="comment">//return f1.price &gt; f2.price; //价格小的优先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"><span class="comment">//需要重载小于号，只能重载小于号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;fruit&gt; q;  <span class="comment">//价格大的优先</span></span><br><span class="line">    <span class="comment">//这边就不能再加greater或less了</span></span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似Cmp写在外面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//重载优先级结构体进行排序 </span></span><br><span class="line">	priority_queue&lt;fruit&gt; q;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//梨子 4</span></span><br><span class="line">    <span class="comment">//用cmp函数优先级排序 </span></span><br><span class="line">	priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; qq;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	qq.<span class="built_in">push</span>(f1);</span><br><span class="line">	qq.<span class="built_in">push</span>(f2);</span><br><span class="line">	qq.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;qq.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;qq.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//苹果 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>stack即栈，是一种先进后出的容器，区别于queue；</p>
<h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stk;</span><br></pre></td></tr></table></figure>

<h5 id="访问：-5"><a href="#访问：-5" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问栈顶元素 stk.top()</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-5"><a href="#常用函数：-5" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push() 压栈</span><br><span class="line">top() 取栈顶元素</span><br><span class="line">pop() 出栈</span><br><span class="line">empty() 判空</span><br><span class="line">size() 获取大小</span><br><span class="line">//---1、2、3---push()、top()、pop() </span><br><span class="line">for(int i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line">	st.push(i);//将i压入栈 </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;入栈12345的栈顶为：&quot;;</span><br><span class="line">cout&lt;&lt;st.top()&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i &lt;= 3;i++)&#123;</span><br><span class="line">	st.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;出栈3个元素后栈顶为：&quot;;</span><br><span class="line">printf(&quot;%d\n&quot;,st.top());</span><br><span class="line">//---4---empty()</span><br><span class="line">cout&lt;&lt;&quot;此时栈为空吗？&quot;&lt;&lt;endl;</span><br><span class="line">if(st.empty() == true)  printf(&quot;Empty\n&quot;);</span><br><span class="line">else printf(&quot;Not Empty\n&quot;);</span><br><span class="line">//---5---size()</span><br><span class="line">cout&lt;&lt;&quot;此时队列大小为：&quot;&lt;&lt;st.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>Pair可以看作一个内部有两个元素的结构体，且这两个元素的类型可以指定</p>
<h5 id="初始化：-5"><a href="#初始化：-5" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">pair&lt;int, double&gt; p2(1, 2.4);  //用给定值初始化</span><br><span class="line">pair&lt;int, double&gt; p3(p2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<h5 id="访问：-6"><a href="#访问：-6" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &#x27; &#x27; &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-6"><a href="#常用函数：-6" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、比较操作数 &lt;.&gt;,&lt;=,==</span><br><span class="line">//比较规则是先比较first，再比较second</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; p1(5,10);</span><br><span class="line">	pair&lt;int,int&gt; p2(5,15);</span><br><span class="line">	pair&lt;int,int&gt; p3(10,5);</span><br><span class="line">	if(p1 &lt; p3)	printf(&quot;p1 &lt; p3\n&quot;);</span><br><span class="line">	if(p1 &lt;= p3)	printf(&quot;p1 &lt;= p3\n&quot;);</span><br><span class="line">	if(p1 &lt; p2)	printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2、make_pair 赋值</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line"> </span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line"> </span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br></pre></td></tr></table></figure>

<h5 id="常用于作为map的键值对进行插入："><a href="#常用于作为map的键值对进行插入：" class="headerlink" title="常用于作为map的键值对进行插入："></a>常用于作为map的键值对进行插入：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">//pair作为map键值对进行插入 </span><br><span class="line">mp.insert(make_pair(&quot;heihei&quot;,5));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,10));</span><br></pre></td></tr></table></figure>



<h3 id="algorithm常用函数"><a href="#algorithm常用函数" class="headerlink" title="algorithm常用函数"></a>algorithm常用函数</h3><h5 id="max-、min-、abs"><a href="#max-、min-、abs" class="headerlink" title="max()、min()、abs()"></a>max()、min()、abs()</h5><p>最大值、最小值、绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=-2;</span><br><span class="line">printf(&quot;%d %d\n&quot;,max(x,y),min(x,y));</span><br><span class="line">printf(&quot;%d %d\n&quot;,abs(x),abs(y));</span><br></pre></td></tr></table></figure>

<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换两个元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=2;</span><br><span class="line">swap(x,y);</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>1.会将区间内的元素全部逆序。常用于数组，字符串，容器等，其本身的函数参数也不复杂。<br>2.容器类型的要用begin()和end()来指定反转的区域，数组类型的直接用int类型即可。<br>3.reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;</span><br><span class="line">reverse(v.begin(),v.end());//v的值为1,2,3,4,5</span><br><span class="line">string str=&quot;www.mathor.top&quot;;</span><br><span class="line">reverse(str.begin(),str.end());//str结果为pot.rohtam.wwww</span><br></pre></td></tr></table></figure>

<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>1.按照单元赋值，将一个区间的元素都赋同一个值<br> 2.fill(arr, arr + n, 要填入的内容);<br> fill(vector.begin(), vector.end(), val);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">fill(arr, arr + 10, 2);</span><br><span class="line">vector&lt;int&gt;  v&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">fill(v.begin(), v.end(), -1);</span><br><span class="line">vector&lt;int&gt; myvector (8);// myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">fill (myvector.begin(),myvector.begin()+4,5);</span><br><span class="line">// myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">fill (myvector.begin()+3,myvector.end()-2,8);</span><br><span class="line">// myvector: 5 5 5 8 8 8 0 0</span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>1.Sort函数有三个参数：<br>（1）第一个是要排序的数组的起始地址。<br>（2）第二个是结束的地址（最后一位要排序的地址的下一地址）<br>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。<br>2.Sort函数使用模板:Sort(start,end,排序方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组排序</span><br><span class="line">int IntValue[5] = &#123;1,4,3,8,5&#125;;</span><br><span class="line">sort(IntValue,IntValue+5);</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">	cout&lt;&lt;IntValue[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">2、vector排序</span><br><span class="line">vector&lt;int&gt; v = &#123;2,6,4,9,6,0,3&#125;;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">vector&lt;int&gt;::iterator  start;</span><br><span class="line">for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">	cout&lt;&lt;(*start)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">3、自定义排序</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">linli1 20</span><br><span class="line">linli2 24</span><br><span class="line">linli6 8</span><br><span class="line">linli3 8</span><br><span class="line"> * */</span><br><span class="line">typedef struct stu&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;stu;</span><br><span class="line">bool cmp(stu u,stu g)&#123;  //&lt;表示升序排序</span><br><span class="line">    if(u.age==g.age)&#123;</span><br><span class="line">        return u.name&lt;g.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.age&lt;g.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;stu&gt; v;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        stu c ;</span><br><span class="line">        cin&gt;&gt;c.name&gt;&gt;c.age;</span><br><span class="line">        v.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end(),cmp);</span><br><span class="line">    vector&lt;stu&gt;::iterator  start;</span><br><span class="line">    for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">        cout&lt;&lt;(*start).name&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h5><p><strong>lower_bound：</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于或等于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;lower_bound(a+l,a+r,key)-a；(a是数组)。</p>
<p><strong>upper_bound:</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（同样这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;upper_bound(a+l,a+r,key)-a；(a是数组)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int board[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int t1 = lower_bound(board,board+5,3)-board; //2</span><br><span class="line">int t2 = upper_bound(board,board+5,3)-board; //3</span><br></pre></td></tr></table></figure>



<h2 id="PAT真题模拟"><a href="#PAT真题模拟" class="headerlink" title="PAT真题模拟"></a>PAT真题模拟</h2><h3 id="PAT-1001"><a href="#PAT-1001" class="headerlink" title="PAT 1001"></a>PAT 1001</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330182108486.png" alt="image-20210330182108486"></p>
<p>我的做法，难点在于如何3位3位加一个逗号，我用栈来存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="type">int</span> cishu;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(c);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">3</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;s[i];</span></span><br><span class="line">    <span class="comment">// 	if(s[i]!=&#x27;-&#x27;&amp;&amp;(i!=s.length()-1)&amp;&amp;(s.length()-i-1)%3==0) cout&lt;&lt;&quot;,&quot;;//后面剩下3n个数时 要加&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大神的做法见注释，好像比较难想到。</p>
<h3 id="PAT-1002"><a href="#PAT-1002" class="headerlink" title="PAT 1002"></a>PAT 1002</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330183857126.png" alt="image-20210330183857126"></p>
<p>多项式加法，通过第一个测试点不是很难。</p>
<p>注意点： <strong>系数为0时不进行输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line">    <span class="type">int</span> n,m;   cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a; <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">find</span>(a)!=M.<span class="built_in">end</span>()) M[a] += b;</span><br><span class="line">        <span class="keyword">else</span> M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330190215218.png" alt="image-20210330190215218"></p>
<p>具体还有两个未通过也不知道是怎么回事</p>
<p>map的倒叙遍历需要掌握</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1003-dijstra"><a href="#PAT-1003-dijstra" class="headerlink" title="PAT 1003 (dijstra)"></a>PAT 1003 (dijstra)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155146524.png" alt="image-20210401155146524"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155200043.png" alt="image-20210401155200043"></p>
<p> 题目翻译：</p>
<p>你是一个救援队长，你要救援有危险的城市，你需要尽可能快的到达有危险的城市，并且带尽可能多的人。</p>
<p>输入：</p>
<p>第1行：4个正整数： 城市数量N、 路数量M、你在的城市、你要救援的城市。</p>
<p>第2行：N个整数，第i个数表示第i个城市的救援队数量。</p>
<p>然后M行：每一行表示一条路，三个数字分别是起点、终点、距离。</p>
<p>保证至少有一条路让你去你要救援的城市。</p>
<p>输出：</p>
<p>最短路径条数  可带的最多人数  (我输出理解成了最短路径长度…)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *dist;   <span class="comment">//保存最短路径</span></span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//s集合，表示已经访问过</span></span><br><span class="line"><span class="type">int</span> *rescue;    <span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> **e;      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> *pre;     <span class="comment">//pre记录路径</span></span><br><span class="line"><span class="type">int</span> *rm;      <span class="comment">//能够到达i点的最多人数</span></span><br><span class="line"><span class="type">int</span> *num_of_shortest;  <span class="comment">//能够到达i点的最短路径条数</span></span><br><span class="line"><span class="type">int</span> N,M,C1,C2;</span><br><span class="line"><span class="type">int</span> maxrescue = <span class="number">0</span>;  <span class="comment">//最大救援队数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    rescue = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    pre = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    rm = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(rm,<span class="number">0</span>,<span class="built_in">sizeof</span>(rm));</span><br><span class="line">    num_of_shortest = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  <span class="comment">//初始化城市救援队数量</span></span><br><span class="line">        cin&gt;&gt;rescue[i];</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">new</span> <span class="type">int</span>*[N];     <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> e[i][j]=<span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c1,c2,length;  </span><br><span class="line">        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length;</span><br><span class="line">        e[c1][c2] = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;N;j++)</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;&quot;e[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]&quot;&lt;&lt;e[i][j]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[C1] = <span class="number">1</span>;</span><br><span class="line">    num_of_shortest[C1] = <span class="number">1</span>;</span><br><span class="line">    rm[C1] = rescue[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dist[i] = e[C1][i];</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&lt;<span class="number">9999</span>)&#123;   <span class="comment">//能够到达</span></span><br><span class="line">            pre[i]=C1;</span><br><span class="line">            rm[i] = rescue[C1]+rescue[i];</span><br><span class="line">            num_of_shortest[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;e[C1][4]&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; :&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">99999</span>,u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//选出下一次要加入s集合的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[i]&lt;min)&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//更新dist数组</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]&lt;dist[i])&#123;</span><br><span class="line">                dist[i] = dist[u] + e[u][i];</span><br><span class="line">                pre[i]=u;</span><br><span class="line">                rm[i] = rm[u]+rescue[i];</span><br><span class="line">                num_of_shortest[i] = num_of_shortest[u];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]==dist[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(rm[u]+rescue[i]&gt;rm[i])&#123;</span><br><span class="line">                    pre[i]=u;</span><br><span class="line">                    rm[i] = rm[u]+rescue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num_of_shortest[i] += num_of_shortest[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dijstra</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num_of_shortest[C2]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rm[C2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401160800655.png" alt="image-20210401160800655"></p>
<p>dijstra的套路算法，关键是需要增加几个判别的数组，一个是有多少条最短路径num_of_shortest，另一个是当前可以到达的最多救援队数量rm。</p>
<h3 id="PAT-1004（按层统计树的叶子节点）"><a href="#PAT-1004（按层统计树的叶子节点）" class="headerlink" title="PAT 1004（按层统计树的叶子节点）"></a>PAT 1004（按层统计树的叶子节点）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405155805312.png" alt="image-20210405155805312"></p>
<p>题意：按照每一层统计树的叶子节点个数</p>
<p>第一行输入 N&#x3D;2 树的节点       M&#x3D;1 非叶子节点个数</p>
<p>下面M行表示非叶子节点所跟的孩子  01 1 02    01表示 01号节点 ，1表示有一个孩子，02表示01的孩子的ID。</p>
<p><strong>题解</strong>：</p>
<p>第一步当然是想数据结构，用什么数据结构来存储这棵树呢？由于树的度不确定，我们很难使用二叉树的链式结构来存储，最初想到的是使用孩子兄弟链表进行存储，但最后发现构造这一棵树并不是太容易，而且我们只是需要统计每一层的非叶子节点数而已。我们不如直接使用结构体数组来存储这棵树，结构体包括ID，节点的孩子vector<int> child ，layer层数，这样我们统计每个节点是否是叶子节点的时候就可以使用child.size()来判断。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br></pre></td></tr></table></figure>

<p>其次就是有几个注意点：在分配内存空间的时候需要注意 如果是new，在堆上分配，内存的数据可以是任意的，意味着我们需要额外的初始化。如果使用Tseq[N+1]这种在栈上分配内存的状况，就可以不用初始化，这也导致我几个测试点过不了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">Tree_Node Tseq[N+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>还有一个坑点是，我们统计每一个节点的层数是，利用双亲节点的层数+1，这样有一个问题，要是先输入孩子节点，再输入双亲节点统计就有问题。<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20210405160649369.png" alt="image-20210405160649369" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以需要对输入的结点ID的大小进行排序，确保上层的节点先被统计进来。这样做法虽然有点蠢，但最后得了27分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">next_input</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numvec;</span><br><span class="line">&#125;next_input;</span><br><span class="line">vector&lt;next_input&gt; input_vector;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(next_input a,next_input b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;   cin&gt;&gt;N&gt;&gt;M;    <span class="comment">//N节点数  M非叶子节点数  </span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// Tree_Node* Tseq; </span></span><br><span class="line">    <span class="type">int</span> maxlayer;  <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">    Tree_Node Tseq[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        Tseq[i].ID = i;  <span class="comment">//分配序号</span></span><br><span class="line">    Tseq[<span class="number">1</span>].layer = <span class="number">1</span>;  <span class="comment">//01节点为根节点，层数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//把输入变成一个vector，然后再排序，以免计算层数时出错</span></span><br><span class="line">        next_input input;</span><br><span class="line">        <span class="type">int</span> id,num,child;  </span><br><span class="line">        cin&gt;&gt;id&gt;&gt;num;</span><br><span class="line">        input.id = id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;child;  input.numvec.<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        input_vector.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(input_vector.<span class="built_in">begin</span>(),input_vector.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//统计节点的层数和孩子</span></span><br><span class="line">        <span class="type">int</span> id,num,childnum;</span><br><span class="line">        id = input_vector[i].id;</span><br><span class="line">        num = input_vector[i].numvec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            childnum = input_vector[i].numvec[j];</span><br><span class="line">            Tseq[id].child.<span class="built_in">push_back</span>(childnum);</span><br><span class="line">            Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        maxlayer = <span class="built_in">max</span>(maxlayer,Tseq[i].layer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;  <span class="comment">//第i层有几个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxlayer;i++)&#123;</span><br><span class="line">        Map[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Tseq[i].child.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;   <span class="comment">//是叶子节点</span></span><br><span class="line">            Map[Tseq[i].layer]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ::iterator iter;</span><br><span class="line">    cout&lt;&lt;Map.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    iter = Map.<span class="built_in">begin</span>(); iter++;</span><br><span class="line">    <span class="keyword">for</span>(;iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405160805791.png" alt="image-20210405160805791"></p>
<p>最后一个测试点有点懵</p>
<p>如果考虑到只有一个节点的情况，if(N&#x3D;&#x3D;1){ cout&lt;&lt;”1”&lt;&lt;endl;return 0;} 这句话会根据出现在不同的位置而产生不同的结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405161716830.png" alt="image-20210405161716830"></p>
<h3 id="PAT-1005"><a href="#PAT-1005" class="headerlink" title="PAT 1005"></a>PAT 1005</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404205053583.png" alt="image-20210404205053583"></p>
<p>计算一个数的个位数字之和，英文输出。比较简单，十分钟搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string Map[] = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        count += (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ss = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ss;</span></span><br><span class="line">    cout&lt;&lt;Map[ss[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ss.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Map[ss[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1006"><a href="#PAT-1006" class="headerlink" title="PAT 1006"></a>PAT 1006</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404211724478.png" alt="image-20210404211724478"></p>
<p>水题，比较来上班最早的和来上班最晚的，直接写一个结构体比较就好了，二十分钟能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    string early;</span><br><span class="line">    string later;</span><br><span class="line">&#125;person;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpearly</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.early);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.early);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&lt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmplater</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.later);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.later);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&gt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt;  vec_person;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        person p;</span><br><span class="line">        cin&gt;&gt;p.id&gt;&gt;p.early&gt;&gt;p.later;</span><br><span class="line">        vec_person.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmpearly);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmplater);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1007（动态规划）"><a href="#PAT-1007（动态规划）" class="headerlink" title="PAT 1007（动态规划）"></a>PAT 1007（动态规划）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404222558427.png" alt="image-20210404222558427"></p>
<p>leetcode经典题，最大连续子序列和，一想就知道使用动态规划。</p>
<p>坑点1： output the one with the smallest indices i and j (as shown by the sample case). 这句话的意思是输出开始的数，而不是下标，整了一小时。</p>
<p>坑点2： If all the K numbers are negative, then its maximum sum is defined to be 0, and you  are supposed to output the first and the last numbers of the whole  sequence.  这句话记得看就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; seq.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[seq.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="type">int</span> pre[seq.<span class="built_in">size</span>()];</span><br><span class="line">    dp[<span class="number">0</span>] = seq[<span class="number">0</span>];  pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>,maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;seq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+seq[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = seq[i];</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsub)&#123;</span><br><span class="line">            maxsub = dp[i];  maxi = pre[i]; maxj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxsub&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxsub&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxi]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxj];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这儿的dp定义的略有不同，不过无伤大雅，dp[i]是指以i结尾的最大连续子序列和。</p>
<h3 id="PAT-1008"><a href="#PAT-1008" class="headerlink" title="PAT 1008"></a>PAT 1008</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404223852830.png" alt="image-20210404223852830"></p>
<p>水题。电梯上升一层6s，下降一层4s，每层有需要停留5s，求电梯所需要时间。十分钟解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; v.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//代表现在电梯到哪一层了</span></span><br><span class="line">    <span class="type">int</span> total_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((v[i]-temp)&gt;=<span class="number">0</span>)&#123;  <span class="comment">//上升</span></span><br><span class="line">            total_time += (v[i]-temp)*<span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//下降</span></span><br><span class="line">            total_time += (temp-v[i])*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = v[i];</span><br><span class="line">        total_time += <span class="number">5</span>; <span class="comment">//停留</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total_time;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1009"><a href="#PAT-1009" class="headerlink" title="PAT 1009"></a>PAT 1009</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210409154552498.png" alt="image-20210409154552498"></p>
<p>和pat1002类似，这里做的是乘法A * B,可以采用暴力法二重循环。</p>
<p>注意的是如果系数等于0则不输出。</p>
<p>不能使用cout&lt;&lt;M.size();  来统计输出的个数，因为会把系数为0的统计进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n]; <span class="type">double</span> b[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k; cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> ai; <span class="type">double</span> bi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> exponent = ai+a[j];</span><br><span class="line">            <span class="type">double</span> coefficient = bi*b[j];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(exponent)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                M[exponent] += coefficient;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                M[exponent] = coefficient;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;M.size();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1010（数学题）"><a href="#PAT-1010（数学题）" class="headerlink" title="PAT 1010（数学题）"></a>PAT 1010（数学题）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202035024.png" alt="image-20210410202035024"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202048687.png" alt="image-20210410202048687"></p>
<p>题目大意：N1 N2 tag radix</p>
<p>N1 N2 为两个数，基数未定，范围从[0-9] [a-z]，radix表示一个数的基数（tag&#x3D;1，则表示N1 的基数，tag&#x3D;2则表示N2的基数）我们要求另一个数的基数，使得N1&#x3D;N2。若不存在则输出”Impossible”。</p>
<p>最初的想法是把一个数的十进制算出来，另一个数从2 一直往上遍历，遍历到什么时候是个头呢，无从知晓。看了答案之后方才明白。</p>
<p><strong>进制范围的确定</strong>   （关键步骤+二分查找）</p>
<p>进制的最小取值为：各个位数最大值+1 如123的最小进制一定大于3， abc的最小进制一定大于12  （这个比较好理解）</p>
<p>现在来讨论进制的上限（max_radix）  (这个不好理解)<br>　　那么现在在题目中，给出了两个数，一个数记为a是已知进制的，另一个记为b未知，假设a&#x3D;675,为10进制，b&#x3D;1，未知进制<br>　　很显然，b的最低进制min_radix是2<br>　　那么b的最高进制max_radix 是多少呢<br>　　我们的目的是让a&#x3D;b，b不可过小也不可过大<br>　　<br>　　假设 max_radix&#x3D;1000<br>　　很显然b &#x3D; 1(1000) &#x3D; 1000 &gt; a &#x3D; 675<br>　　所以，发现了吗<br>　　想让a&#x3D;b，b的最大进制就是a的值,即675<br>　　因为我举的例子比较特殊，如果b不为1，那么就很难直接得到b的精确的最高进制max_radix<br>　　但是 ，可以肯定的是，当b为1 的时候，max_radix是最大的（因为此时b最小）<br>　　因此，我们虽然不知道b&#x3D;10,20,80,13671…时，对应的max_radix是多少，但是，他们一定比b&#x3D;1对应的max_radix小<br>　　那么我们就可以用最大的max_radix作为进制的上限，在min_radix 到max_radix中二分查找<br>　　同时需要注意，max_radix&gt;&#x3D;min_radix<br>　　故有 max_radix &#x3D; max(a,min_radix);</p>
<p><strong>坑点</strong>：</p>
<p>计算过程中会出现数据溢出。<br> 举个极端例子：<br> 一亿进制的zzzzzzzzzz转化为十进制。 即使用long long也无法保存。<br> 那么应该怎么判断呢？ 可以判断计算结束后的值是否小于0，因为溢出后的值一定小于0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202935463.png" alt="image-20210410202935463"></p>
<p>这一句显得至关重要，有6个测试点来自这。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">transfer_to_ten</span><span class="params">(string a,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll total=<span class="number">0</span>;</span><br><span class="line">    ll basement = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) total += (a[i]-<span class="string">&#x27;0&#x27;</span>)*basement;</span><br><span class="line">        <span class="keyword">else</span> total += (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>)*basement;</span><br><span class="line">        basement *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_base</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// if(a[i]&lt;=&#x27;9&#x27;) min_base = max(min_base,a[i]-&#x27;0&#x27;+1);</span></span><br><span class="line">        <span class="comment">// else min_base = max(min_base,a[i]-&#x27;a&#x27;+11);</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) min_base = min_base&gt;(a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>) ? min_base : (a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> min_base = min_base&gt;(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>) ? min_base : (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search_base</span><span class="params">(string a,<span class="type">int</span> min_base,<span class="type">int</span> max_base,<span class="type">long</span> <span class="type">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_base&lt;<span class="number">2</span>) min_base = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_base&gt;max_base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll mid_base = min_base + (max_base-min_base)/<span class="number">2</span>;</span><br><span class="line">    ll temp = <span class="built_in">transfer_to_ten</span>(a,mid_base);</span><br><span class="line">    <span class="keyword">if</span>(temp==target) <span class="keyword">return</span> mid_base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target || temp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">search_base</span>(a,min_base,mid_base<span class="number">-1</span>,target);  <span class="comment">//关键 temp可能会溢出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search_base</span>(a,mid_base+<span class="number">1</span>,max_base,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    string cc;</span><br><span class="line">    ll tag,radix;</span><br><span class="line">    ll target;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(a,radix);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;radix;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;target: &quot;&lt;&lt;target&lt;&lt;endl;</span></span><br><span class="line">        cc = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(b,radix);</span><br><span class="line">        cc = a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll min_base = <span class="built_in">find_min_base</span>(cc);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;min_base: &quot;&lt;&lt;min_base&lt;&lt;endl;</span></span><br><span class="line">    ll max_base = target&gt;min_base ? target : min_base;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;max_base: &quot;&lt;&lt;max_base&lt;&lt;endl;</span></span><br><span class="line">    ll mid_base = <span class="built_in">search_base</span>(cc,min_base,max_base,target);</span><br><span class="line">    <span class="keyword">if</span>(mid_base) cout&lt;&lt;mid_base;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410203111819.png" alt="image-20210410203111819"></p>
<p>第10个测试点据说是：10测试点是输入为0<br> 当其中一个输入为0时，base若等于最大数字加1则为1，但我们知道进制的最小值为2，故在搜索前需要进行检查。（不太清楚）</p>
<h3 id="PAT-1011"><a href="#PAT-1011" class="headerlink" title="PAT 1011"></a>PAT 1011</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153118330.png" alt="image-20210422153118330"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153134396.png" alt="image-20210422153134396"></p>
<p>给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大。每一场都选最大的。无脑题，关键在于读懂题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ca</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> pro;</span><br><span class="line">&#125;ca;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ca a,ca b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pro&gt;b.pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>]=&#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"><span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ca&gt;&gt; <span class="built_in">v</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            ca d; </span><br><span class="line">            cin&gt;&gt;d.pro;</span><br><span class="line">            d.a = a[j];</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        res *= v[i][<span class="number">0</span>].pro;</span><br><span class="line">        cout&lt;&lt;v[i][<span class="number">0</span>].a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1012"><a href="#PAT-1012" class="headerlink" title="PAT 1012"></a>PAT 1012</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163238958.png" alt="image-20210422163238958"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163249988.png" alt="image-20210422163249988"></p>
<p>这一题竟然解决了一个小时。</p>
<p>题目大意：输入学生 以及三门课的成绩，然后每输入一个学生的id就打印最高的排名和对应排名的分类。排名分成三门课的单独排名和平均分的排名。排名也有优先级，A&gt;C&gt;M&gt;E。还算模拟题吧。</p>
<p>我的思路是建立一个学生表Map[string , stu]；stu包含学生的信息，包括成绩，排名等等。在第一波输入的时候，我们可以将成绩信息，填入学生表，同时将每科的成绩分门别列进行排序，第二轮遍历学生表Map时我们按照成绩查找对应的排名，本来想用二分查找，（但也必须是改进的二分查找，查找目标&#x3D;&#x3D;target的最小边界）。然后printinfo函数输出每个学生的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    string ID;</span><br><span class="line">    <span class="type">int</span> C,M,E,A;  <span class="comment">//成绩</span></span><br><span class="line">    <span class="type">int</span> rC,rM,rE,rA;  <span class="comment">//排名</span></span><br><span class="line">&#125;stu;</span><br><span class="line">map&lt;string,stu&gt; Map;  <span class="comment">//学生表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; CC;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; MM;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; EE;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AA;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int binary_search(vector&lt;int&gt; A,int target,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">//     if(l&gt;r) return -2;</span></span><br><span class="line"><span class="comment">//     int mid = (l+r)/2;</span></span><br><span class="line"><span class="comment">//     if(A[mid]==target) return mid+1;</span></span><br><span class="line"><span class="comment">//     if(A[mid]&gt;target) return binary_search(A,target,mid+1,r);</span></span><br><span class="line"><span class="comment">//     else return binary_search(A,target,l,mid-1);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]==target) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstu</span><span class="params">(stu S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.rA&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rA&lt;&lt;<span class="string">&quot; A&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rC&lt;=<span class="built_in">min</span>(S.rA,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rC&lt;&lt;<span class="string">&quot; C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rM&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rA)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rM&lt;&lt;<span class="string">&quot; M&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rE&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rA,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rE&lt;&lt;<span class="string">&quot; E&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string a; <span class="type">int</span> b,c,d;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        CC.<span class="built_in">push_back</span>(b);   MM.<span class="built_in">push_back</span>(c);  </span><br><span class="line">        EE.<span class="built_in">push_back</span>(d); </span><br><span class="line">        <span class="type">int</span> aver = (<span class="type">int</span>)((<span class="type">double</span>)(b+c+d)/<span class="number">3.0</span>+<span class="number">0.5</span>);</span><br><span class="line">        AA.<span class="built_in">push_back</span>(aver);</span><br><span class="line">        stu temp; </span><br><span class="line">        temp.ID = a; temp.C=b; temp.M=c; temp.E=d; temp.A=aver;</span><br><span class="line">        Map[a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(CC.<span class="built_in">begin</span>(),CC.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(EE.<span class="built_in">begin</span>(),EE.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(MM.<span class="built_in">begin</span>(),MM.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(AA.<span class="built_in">begin</span>(),AA.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    map&lt;string,stu&gt; :: iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="comment">// int a = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rA = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rC = binary_search(CC,iter-&gt;second.C,0,CC.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rE = binary_search(EE,iter-&gt;second.E,0,EE.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rM = binary_search(MM,iter-&gt;second.M,0,MM.size()-1);</span></span><br><span class="line">        iter-&gt;second.rA = <span class="built_in">search</span>(AA,iter-&gt;second.A);</span><br><span class="line">        iter-&gt;second.rC = <span class="built_in">search</span>(CC,iter-&gt;second.C);</span><br><span class="line">        iter-&gt;second.rE = <span class="built_in">search</span>(EE,iter-&gt;second.E);</span><br><span class="line">        iter-&gt;second.rM = <span class="built_in">search</span>(MM,iter-&gt;second.M);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string s;  cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(s)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printstu</span>(Map[s]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163816564.png" alt="image-20210422163816564"></p>
<h3 id="PAT-1013（连通分量）"><a href="#PAT-1013（连通分量）" class="headerlink" title="PAT 1013（连通分量）"></a>PAT 1013（连通分量）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172221670.png" alt="image-20210422172221670"></p>
<p>题意：给出城市个数为N，连接城市间的道路的条数为M，以及询问次数为K</p>
<p>然后输入这M条道路连接的两个端点城市的编号Ａ和Ｂ</p>
<p>然后是K次询问，每次询问的方法是：给出一个编号为Q城市，然后将这个城市和与其相连的道路从网络中删除，要求让你求出添加多少条道路，才能使得被删除了编号为Q的城市的网络仍然联通</p>
<p>转化成求连通分量个数。即图的遍历，我这里使用广度优先搜索遍历图，求连通分量k。</p>
<p>bfs(int node)；除去node结点的连通分量，从1..N遍历结点，设置一个visited数组表示该结点是否访问过。如果访问过则记作1.k++，然后是用一个栈广度优先搜索该连通分量中可以到达的结点。</p>
<p>最后需要增加的路径&#x3D;连通分量个数-1</p>
<p>注意：每一次考虑新的结点的时候visited必须复位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//1..N 0不用</span></span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">int</span> k;  <span class="comment">//连通分量个数</span></span><br><span class="line"><span class="type">int</span> **Graph;   <span class="comment">//Graph  1..N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;   <span class="comment">//不考虑node结点,求连通分量个数k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==node) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==node) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Graph[top][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                    visited[j]=<span class="number">1</span>;</span><br><span class="line">                    S.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="comment">//visited数组初始化，表示没有访问过</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph初始化</span></span><br><span class="line">    Graph = <span class="keyword">new</span> <span class="type">int</span>*[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Graph[i] = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(Graph[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(Graph[i]));  <span class="comment">//Graph[i][u] = 0代表i,u之间没有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">        Graph[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// memset(visited,0,sizeof(visited));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) visited[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(a);</span><br><span class="line">        cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=K<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 5 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">2 1 3 4 5 6 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172806405.png" alt="image-20210422172806405"></p>
<h3 id="PAT-1014-队列模拟"><a href="#PAT-1014-队列模拟" class="headerlink" title="PAT 1014 (队列模拟)"></a>PAT 1014 (队列模拟)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174327230.png" alt="image-20210422174327230"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174337754.png" alt="image-20210422174337754"></p>
<p><strong>题目大意</strong>：银行有N个窗口，每个窗口划分成两部分，黄线内的和黄线外的</p>
<p>顾客排队有以下几个要求：</p>
<p>1、每个窗口黄线内可以站M个人，第（MN+1)个人得排在黄线外</p>
<p>2、每个顾客选择最短的队伍，（队伍长度相同选择序号小的）</p>
<p>3、顾客i将花费 Ti 的时间处理问题</p>
<p>3、每个窗口的第一位顾客将于8:00被服务</p>
<p>给定每个顾客的处理问题的时间，求每位顾客解决问题的时间点。</p>
<p>输入：第一行 N(窗口）、M（黄线内的人数）、K（顾客人数）、Q（要求的顾客完成时间）  五点之前下班</p>
<p><strong>思路</strong>：用一个vector表示一个窗口，窗口里是一个queue<int>表示窗口队列，首先初始化窗口，之后模拟每一次完成（查找所有窗口剩余时间最少的出队，如果还有人在黄线外等候则加入该窗口的队列，然后更新每个窗口front元素的剩余时间）。持续下去直到所有窗口都为空。 用一个变量nowtime记录当前时间，也即每个顾客的完成时间。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M,K,Q;  <span class="comment">//N 窗口  M 黄线内人数  K 顾客人数  Q 询问时间</span></span><br><span class="line"><span class="type">int</span> Time[<span class="number">1001</span>];   <span class="comment">//表示第i位顾客还剩多少时间完成</span></span><br><span class="line"><span class="type">int</span> process[<span class="number">1001</span>];   <span class="comment">//最多有1001个顾客，time表示第i个顾客的完成时间，单位分钟</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Custom;  <span class="comment">//顾客队列,按照编号进行</span></span><br><span class="line">vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; Window; <span class="comment">//窗口vector，每个窗口维护一个队列，队列长度不超过M</span></span><br><span class="line"><span class="type">int</span> nowtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断所有窗口是否还有人在排队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isemptyWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最早出队的窗口号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mintime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_time = <span class="number">9999</span>; </span><br><span class="line">    <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>() &amp;&amp; Time[Window[i].<span class="built_in">front</span>()]&lt;min_time)&#123;</span><br><span class="line">            min_time = Time[Window[i].<span class="built_in">front</span>()];</span><br><span class="line">            min_i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新每个窗口的出队时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> subtime,<span class="type">int</span> t)</span></span>&#123;  <span class="comment">//subtime减去的时间，t除外</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=t &amp;&amp; !Window[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Time[Window[i].<span class="built_in">front</span>()] -= subtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_to_clock</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour = time/<span class="number">60</span>+<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> minn = time%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;<span class="number">17</span> || (hour==<span class="number">17</span>&amp;&amp;minn&gt;<span class="number">0</span>)) cout&lt;&lt;<span class="string">&quot;Sorry&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>,hour,minn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> pCustom = <span class="number">1</span>;  <span class="comment">//顾客指针，在pCustom之前的都已经安排到Windows黄线内去了</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Time[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//初始化窗口</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;  Window.<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口队列</span></span><br><span class="line">    <span class="keyword">while</span>(pCustom&lt;=N*M &amp;&amp; pCustom&lt;=K)&#123;</span><br><span class="line">        Window[(pCustom+<span class="number">1</span>)%M].<span class="built_in">push</span>(pCustom);  <span class="comment">//按照顺序每个窗口依次安排人</span></span><br><span class="line">        pCustom++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isemptyWindow</span>())&#123;</span><br><span class="line">        <span class="type">int</span> min_i = <span class="built_in">mintime</span>();  <span class="comment">//最早出队的窗口号</span></span><br><span class="line">        <span class="type">int</span> subtime = Time[Window[min_i].<span class="built_in">front</span>()];  <span class="comment">//需要更新的时间</span></span><br><span class="line">        nowtime += subtime;   <span class="comment">//更新当前时间</span></span><br><span class="line">        process[Window[min_i].<span class="built_in">front</span>()] = nowtime;   <span class="comment">//记录该顾客已经完成</span></span><br><span class="line">        Window[min_i].<span class="built_in">pop</span>();  <span class="comment">//当前窗口出队</span></span><br><span class="line">        <span class="keyword">if</span>(pCustom&lt;=K)&#123;</span><br><span class="line">            Window[min_i].<span class="built_in">push</span>(pCustom);   <span class="comment">//加入新元素</span></span><br><span class="line">            pCustom++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(subtime,min_i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">time_to_clock</span>(process[a]);</span><br><span class="line">        <span class="keyword">if</span>(i!=Q<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193023153.png" alt="image-20210422193023153"></p>
<p>看答案发现五点前还没处理完的不可能赶人家走吧，所以修改了一下代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193841669.png" alt="image-20210422193841669"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193858472.png" alt="image-20210422193858472"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193918612.png" alt="image-20210422193918612"></p>
<p>参考了网上的AC代码，还是没看出来自己为什么错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> win_num, win_len, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;win_num, &amp;win_len, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">times</span>(win_num); <span class="comment">//times按顺序记录每个窗口中排队的人的结束时间，用以标示下一个进入的人的开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n)</span>, <span class="title">start_time</span><span class="params">(n)</span></span>; <span class="comment">//data记录每个用户的耗时，start_time记录每个用户的开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i&lt;win_num*win_len; i++)&#123;  <span class="comment">//先把黄线内的人排队排好</span></span><br><span class="line">        <span class="type">int</span> t = i%win_num; <span class="comment">//第t个窗口</span></span><br><span class="line">        start_time[i] = i&lt;win_num?<span class="number">0</span>:times[t][i/win_num<span class="number">-1</span>]; <span class="comment">//第一排的开始时间是0，之后的开始时间是前一排的结束时间，从times中获取</span></span><br><span class="line">        times[t].<span class="built_in">push_back</span>(start_time[i]+data[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=win_num*win_len; i&lt;n; i++)&#123;  <span class="comment">//黄线外的人进入队伍</span></span><br><span class="line">        <span class="type">int</span> mint=<span class="number">540</span>, w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;win_num; j++)&#123;  <span class="comment">//选择队伍，按队伍中size()-win_len个人的最早开始时间选择</span></span><br><span class="line">            <span class="type">int</span> st = times[j][times[j].<span class="built_in">size</span>()-win_len];</span><br><span class="line">            <span class="keyword">if</span>(st&lt;mint)&#123;</span><br><span class="line">                mint = st;</span><br><span class="line">                w = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">-1</span>) start_time[i] = <span class="number">540</span>; <span class="comment">//没窗口选，全都已经超时，按540计</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start_time[i] = times[w][times[w].<span class="built_in">size</span>()<span class="number">-1</span>]; <span class="comment">//计算开始时间</span></span><br><span class="line">            times[w].<span class="built_in">push_back</span>(start_time[i]+data[i]); <span class="comment">//排队进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(start_time[x]&gt;=<span class="number">540</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (start_time[x]+data[x])/<span class="number">60</span>+<span class="number">8</span>, (start_time[x]+data[x])%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PAT-1015"><a href="#PAT-1015" class="headerlink" title="PAT 1015"></a>PAT 1015</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210426090709927.png" alt="image-20210426090709927"></p>
<p>最初这题题目没看懂</p>
<p>题目大意：给出一个素数，判断在d进制下反转后在十进制下是否是素数，如果是，则输出”Yes”，否，则输出”No”。</p>
<p>Sample input:</p>
<p>73 在十进制下反转 37</p>
<p>23(10111) 在2进制下反转(11101) 29 是质数</p>
<p>23在10进制下反转32不是质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//判断n是否是素数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>) <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> zNum = <span class="number">0</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//转换为p进制</span></span><br><span class="line">        z[zNum++] = n % d;</span><br><span class="line">        n /=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zNum; ++i) &#123;<span class="comment">//逆序转为10进制</span></span><br><span class="line">        n = n * d + z[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">true</span>)&#123;<span class="comment">//是素数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;<span class="comment">//是负数，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Check</span>(n, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1016"><a href="#PAT-1016" class="headerlink" title="PAT 1016"></a>PAT 1016</h3><p>题目大意： 打长途电话每分钟要花一定的费用，这取决于一天中打电话的时间。当客户开始连接长途电话时，时间会被记录下来，客户挂断电话的时间也会被记录下来。每个日历月，每一分钟都会向客户发送一张账单（按一天中的时间确定的费率）。你的工作是准备每个月的账单，给你一套电话记录。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210429204459301.png" alt="image-20210429204459301"></p>
<h3 id="PAT-1039"><a href="#PAT-1039" class="headerlink" title="PAT 1039"></a>PAT 1039</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182936179.png" alt="image-20210420182936179"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182949322.png" alt="image-20210420182949322"></p>
<p>题目大意：有一个表保存了学生的选课信息，根据学生姓名来查询信息，输出该名学生选课情况。</p>
<p>样例解释，有11个学生，共5门课，接下来10行表示每门课的选课情况，例如2,3行，第4门课（4是课程号），7个人选，选课名单BOB5…</p>
<p>最后一行按顺序输出学生的名单。结果输出每个学生的名字，选课门数和课程号。</p>
<p>思路比较清楚，我定义的数据结构还算比较复杂</p>
<p>Query_List 代表学生的选课列表（索引就代表学号），Course_List代表课程的学生列表。</p>
<p>我们先把数据读入课程列表中，再用一个Map将学生的名字和学号一一对应。然后遍历Course_List，查到Course_List的学生选的哪门课就往Query_List中添加。最后将Query_List中的list排序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br></pre></td></tr></table></figure>

<p>坑点：最后一个测试数据比较大，据说要用scanf和printf，或者用char</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;Course_List&gt; CList;</span><br><span class="line">    vector&lt;Query_List&gt; QList;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> i1,i2;  </span><br><span class="line">        string i3;  </span><br><span class="line">        cin&gt;&gt;i1&gt;&gt;i2;</span><br><span class="line">        Course_List C; </span><br><span class="line">        C.cno = i1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;i2;i++)&#123;</span><br><span class="line">            cin&gt;&gt;i3;  </span><br><span class="line">            C.name.<span class="built_in">push_back</span>(i3);</span><br><span class="line">        &#125;</span><br><span class="line">        CList.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name;  cin&gt;&gt;name;</span><br><span class="line">        M[name] = i;</span><br><span class="line">        Query_List Q;  Q.name = name;</span><br><span class="line">        QList.<span class="built_in">push_back</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;CList[i].name.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//M[CList[i].name[j]].list.push_back(CList[i].cno);</span></span><br><span class="line">            QList[M[CList[i].name[j]]].list.<span class="built_in">push_back</span>(CList[i].cno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;QList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(QList[i].list.<span class="built_in">begin</span>(),QList[i].list.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;QList[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;QList[i].list.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=QList.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420183645306.png" alt="image-20210420183645306"></p>
<h3 id="PAT-1040（dp"><a href="#PAT-1040（dp" class="headerlink" title="PAT 1040（dp)"></a>PAT 1040（dp)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420235614633.png" alt="image-20210420235614633"></p>
<p>题目大意：查询长度最长的对称串</p>
<p>动态规划，dp[i] [j] 表示从 i 开始到 j 结束的对称串。（ i&lt;&#x3D;j ） </p>
<p>dp[i] [i] &#x3D; 1;</p>
<p>dp [i] [i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</p>
<p>dp[i] [i+k] &#x3D; (s[i] &#x3D;&#x3D; s[i+k] &amp;&amp; dp[i+1] [i+k-1] )</p>
<p>i，j的状态取决于 i+1,j-1是不是对称串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> dp[length][length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="built_in">memset</span>(dp[i],<span class="literal">false</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    <span class="type">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//Initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) &#123;dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>; maxlength=<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;length;k++)&#123;  <span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length &amp;&amp; i+k&lt;length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+k] &amp;&amp; dp[i+<span class="number">1</span>][i+k<span class="number">-1</span>]==<span class="literal">true</span>)&#123; </span><br><span class="line">                dp[i][i+k]=<span class="literal">true</span>;</span><br><span class="line">                maxlength=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="PAT-1041"><a href="#PAT-1041" class="headerlink" title="PAT 1041"></a>PAT 1041</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233542571.png" alt="image-20210420233542571"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233553640.png" alt="image-20210420233553640"></p>
<p>题目大意，找到最近的一个不重复的数，如果找不到输出none。</p>
<p>直接一个map存放出现的次数，之后再从前往后遍历。无脑题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> unicode;</span><br><span class="line">    <span class="type">int</span> Map[<span class="number">50000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">0</span>,<span class="built_in">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a ;cin&gt;&gt;a;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a);</span><br><span class="line">        Map[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(!unique &amp;&amp; j&lt;A.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[A[j]]==<span class="number">1</span>)&#123;</span><br><span class="line">            unique = <span class="literal">true</span>;</span><br><span class="line">            unicode = A[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unique) cout&lt;&lt;unicode;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1081"><a href="#PAT-1081" class="headerlink" title="PAT 1081"></a>PAT 1081</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210423091333960.png" alt="image-20210423091333960"></p>
<p>简单题，模拟分数乘法操作。</p>
<p>注意点：题目准确说明数的范围是Long ing型，第四个测试点出现浮点错误，需要判断一下分母为0的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fenzi[N]; <span class="type">long</span> <span class="type">long</span> fenmu[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,&amp;fenzi[i],&amp;fenmu[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> denominator = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) denominator *= fenmu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) numerator += denominator/fenmu[i]*fenzi[i];</span><br><span class="line">    <span class="keyword">if</span>(denominator==<span class="number">0</span>)&#123;  <span class="comment">//这里一定要判断一下，第四个测试点可能会出现浮点错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> interger = numerator/denominator;</span><br><span class="line">    <span class="keyword">if</span>(interger) cout&lt;&lt;interger;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re_numerator = numerator - interger*denominator;</span><br><span class="line">    <span class="keyword">if</span>(re_numerator)&#123;</span><br><span class="line">        <span class="keyword">if</span>(interger) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(re_numerator,denominator);</span><br><span class="line">        re_numerator /= g;    denominator/= g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,re_numerator,denominator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2021-7-10"><a href="#2021-7-10" class="headerlink" title="2021.7.10"></a>2021.7.10</h2><h3 id="PAT-1152"><a href="#PAT-1152" class="headerlink" title="PAT 1152"></a>PAT 1152</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153004327.png" alt="image-20210710153004327"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153023441.png" alt="image-20210710153023441"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153032898.png" alt="image-20210710153032898"></p>
<p>题目大意：给定一个N位的数，寻找第一次出现的m位素数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(LL t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL s = <span class="number">2</span>; s&lt;<span class="built_in">sqrt</span>(t) ;s++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i++)&#123;</span><br><span class="line">        res = s.<span class="built_in">substr</span>(i,n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issushu</span>(<span class="built_in">stoi</span>(res)))&#123;</span><br><span class="line">            cout&lt;&lt;res;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153216499.png" alt="image-20210710153216499"></p>
<h3 id="PAT-1153"><a href="#PAT-1153" class="headerlink" title="PAT 1153"></a>PAT 1153</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210514325.png" alt="image-20210710210514325"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210537819.png" alt="image-20210710210537819"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210558121.png" alt="image-20210710210558121"></p>
<p>题目大意：给出一组学生的准考证号和成绩，准考证号包含了等级(乙甲顶)，考场号，日期，和个人编号信息，并有三种查询方式<br>查询一：给出考试等级，找出该等级的考生，按照成绩降序，准考证升序排序<br>查询二：给出考场号，统计该考场的考生数量和总得分<br>查询三：给出考试日期，查询改日期下所有考场的考试人数，按照人数降序，考场号升序排序<br><strong>修改前的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;p1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    <span class="keyword">if</span>(M.<span class="built_in">find</span>(cc)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        M[cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        M[cc] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">dic1</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;dic1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;N<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710211717494.png" alt="image-20210710211717494"></p>
<p>改后发现格式不需要那么复杂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1.second==o2.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.first&lt;o2.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; </span><br><span class="line">                    total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    M[cc] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; dic1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : M) dic1.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it.first, it.second));</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一格多一个换行也没关系</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710220609566.png" alt="image-20210710220609566"></p>
<p><strong>修改后的AC代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testees</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;testees;</span><br><span class="line">vector&lt;testees&gt; t;</span><br><span class="line"><span class="type">int</span> N,M,type;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(testees a,testees b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,t[i].id.<span class="built_in">c_str</span>(),t[i].score);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>))&#123;</span><br><span class="line">                sum += t[i].score;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>))&#123;</span><br><span class="line">                mp[t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">vec_mp</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec_mp.<span class="built_in">begin</span>(),vec_mp.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec_mp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,vec_mp[i].first.<span class="built_in">c_str</span>(),vec_mp[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        testees ta;</span><br><span class="line">        cin&gt;&gt;ta.id&gt;&gt;ta.score;</span><br><span class="line">        t.<span class="built_in">push_back</span>(ta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>,i,type,s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">deal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710215520857.png" alt="image-20210710215520857"></p>
<h3 id="PAT-1154"><a href="#PAT-1154" class="headerlink" title="PAT 1154"></a>PAT 1154</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222438518.png" alt="image-20210710222438518"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222450152.png" alt="image-20210710222450152"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222458698.png" alt="image-20210710222458698"></p>
<p>题目大意：</p>
<p>相邻的两边不能同色，不用邻接矩阵，直接用边进行判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Graph</span><span class="params">(V,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> query; cin&gt;&gt;query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;query;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">            Graph[i] = a;</span><br><span class="line">            M[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[Edge[i].first] == Graph[Edge[i].second])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;-coloring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222553175.png" alt="image-20210710222553175"></p>
<h3 id="PAT-1155（回溯）"><a href="#PAT-1155（回溯）" class="headerlink" title="PAT 1155（回溯）"></a>PAT 1155（回溯）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230530365.png" alt="image-20210710230530365"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230546043.png" alt="image-20210710230546043"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230612772.png" alt="image-20210710230612772"></p>
<p>题目大意：给定一个二叉树，判断是不是大顶堆或小顶堆，并且输出路径，从右到左输出，可以利用回溯法解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> MAX_OR_MIN;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&gt;N)&#123;   <span class="comment">//到头了，输出路径</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    V.<span class="built_in">resize</span>(N+<span class="number">1</span>);  <span class="comment">//下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;  <span class="comment">//确定大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&gt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&lt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(V[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">backtrace</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==res[i].<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230634645.png" alt="image-20210710230634645"></p>
<h2 id="2021-7-17"><a href="#2021-7-17" class="headerlink" title="2021.7.17"></a>2021.7.17</h2><h3 id="PAT-1148"><a href="#PAT-1148" class="headerlink" title="PAT 1148"></a>PAT 1148</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174748111.png" alt="image-20210717174748111"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174800947.png" alt="image-20210717174800947"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174812459.png" alt="image-20210717174812459"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174821796.png" alt="image-20210717174821796"></p>
<p>题目大意：狼人杀，给出N个人，其中只有两个是狼人，找出狼人，其中所有人中有两个人说谎，说谎的人里包含一个狼人。</p>
<p>本来是想通过假设说谎的人数 i,j  来找到狼人，后来发现通过假定狼人i,j来验证是否成立来得更加方便。整了一个半小时了都。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Data</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> istrue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;   <span class="comment">//i,j是werewolf,其他是human</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i || k==j) output[k] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> output[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始验证</span></span><br><span class="line">            <span class="type">int</span> fa = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> wefa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[k] * output[<span class="built_in">abs</span>(Data[k])]&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">                     fa++;</span><br><span class="line">                     <span class="keyword">if</span>(k==i || k==j) wefa++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa==<span class="number">2</span> &amp;&amp; wefa==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717175023186.png" alt="image-20210717175023186"></p>
<h3 id="PAT-1149"><a href="#PAT-1149" class="headerlink" title="PAT 1149"></a>PAT 1149</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193857126.png" alt="image-20210717193857126"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193908755.png" alt="image-20210717193908755"></p>
<p>题目大意：集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No～</p>
<p>分析：用map存储每一个货物的所有不兼容货物～在判断给出的一堆货物是否是相容的时候，判断任一货物的不兼容货物是否在这堆货物中～如果存在不兼容的货物，则这堆货物不能相容～如果遍历完所有的货物，都找不到不兼容的两个货物，则这堆货物就是兼容的～</p>
<p>用map存储每一个货物的所有不相容货物，然后逐一进行比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(a)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(b);</span><br><span class="line">            Map[a] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(b)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(a);</span><br><span class="line">            Map[b] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(Q)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;Q;k++)&#123;</span><br><span class="line">            cin&gt;&gt;res[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;res.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jj=<span class="number">0</span>;jj&lt;res.<span class="built_in">size</span>();jj++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ii==jj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Map.<span class="built_in">find</span>(res[ii])== Map.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vector&lt;string&gt; temp = Map[res[ii]];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> zz=<span class="number">0</span>;zz&lt;temp.<span class="built_in">size</span>();zz++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp[zz]==res[jj])&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193955512.png" alt="image-20210717193955512"></p>
<p>修改后，在查找是否兼容这一部分，需要通过map定位到该值所在的结点，然后往节点后的链表顺序查找，这样可能比较浪费时间。</p>
<p>牺牲空间的方法，首先开辟一个大空间res，存放所有可能的物品，每遍历一个物品，就往res中添入不可兼容的物品，之后再查找时，如果在res中，则不可兼容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(res[x]==<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            res[x] = <span class="number">1</span>;   <span class="comment">//表示不兼容  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Map[x].<span class="built_in">size</span>();j++)</span><br><span class="line">                res[Map[x][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717202436733.png" alt="image-20210717202436733"></p>
<h3 id="PAT-1150"><a href="#PAT-1150" class="headerlink" title="PAT 1150"></a>PAT 1150</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210722721.png" alt="image-20210717210722721"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210738857.png" alt="image-20210717210738857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210750029.png" alt="image-20210717210750029"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210800815.png" alt="image-20210717210800815"></p>
<p>题目大意：旅行商问题，给定一个图，并给定路径，判断该路径是否满足一下条件：</p>
<p>Ts a simple cycle 每个城市只访问一次，并且回到远点</p>
<p>Not a TS cycle 没有访问到每个城市，或者没有回到原点</p>
<p>NA not a TS cycle  路径不可达</p>
<p>TS cycle  多次访问每个城市</p>
<p>然后求距离最短的路径。</p>
<p>思路：构建邻接矩阵，一个visited数组判断是否访问过，按照路径一次模拟一遍即可，水题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> shortest = INT_MAX;  <span class="comment">//存放最短路径</span></span><br><span class="line">    <span class="type">int</span> shortestindex = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d1,d2,dist; cin&gt;&gt;d1&gt;&gt;d2&gt;&gt;dist;</span><br><span class="line">        Graph[d1][d2] = dist;</span><br><span class="line">        Graph[d2][d1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T; cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=T;kk++)&#123;</span><br><span class="line">        <span class="type">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//0 可达性  1 是否都访问过  2  是否多次访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> C;  cin&gt;&gt;C;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(C+<span class="number">1</span>)</span></span>;   <span class="comment">//路径也从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visited[path[1]] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[path[i]][path[i+<span class="number">1</span>]]==<span class="number">0</span>) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total_cost += Graph[path[i]][path[i+<span class="number">1</span>]];</span><br><span class="line">                visited[path[i]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;visited.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) flag[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//没有访问过,flag=1 Not a TS cycle</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]&gt;<span class="number">1</span>) flag[<span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//多次访问  TS cycle;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="keyword">if</span>(!flag[<span class="number">0</span>] &amp;&amp; !flag[<span class="number">1</span>] &amp;&amp; !flag[<span class="number">2</span>] &amp;&amp; path[<span class="number">1</span>]==path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>,kk);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">1</span>] || path[<span class="number">1</span>]!=path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest Dist(%d) = %d&quot;</span>,shortestindex,shortest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210659132.png" alt="image-20210717210659132"></p>
<h3 id="PAT-1151"><a href="#PAT-1151" class="headerlink" title="PAT 1151"></a>PAT 1151</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190008683.png" alt="image-20210718190008683"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190019702.png" alt="image-20210718190019702"></p>
<p>题目大意：给出中序序列和先序序列，再给出两个点，求这两个点的最近公共祖先～</p>
<p>柳神题解：不用建树～已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。中序加先序可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点，在此时并入lca算法可以确定两个结点的公共祖先～</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,<span class="type">int</span> node1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> pre_right,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,pre_left+<span class="number">1</span>,mid_position,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,mid_position+<span class="number">1</span>,pre_right,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190202986.png" alt="image-20210718190202986"></p>
<p>问题出在递归过程中变量设置太多，导致递归栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(vector&lt;int&gt; preorder,vector&lt;int&gt; inorder,int node1,</span><br><span class="line">    int node2,int pre_left,int pre_right,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>改成，将preorder,inorder设置成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(int node1,int node2,int pre_left,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,pre_left+<span class="number">1</span>,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,mid_position+<span class="number">1</span>,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(node1,node2,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190952587.png" alt="image-20210718190952587"></p>
<h2 id="2021-7-24"><a href="#2021-7-24" class="headerlink" title="2021.7.24"></a>2021.7.24</h2><h3 id="PAT-1144"><a href="#PAT-1144" class="headerlink" title="PAT 1144"></a>PAT 1144</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103108325.png" alt="image-20210724103108325"></p>
<p>题目大意：给一个数串，找到数串中没有出现的最小正整数</p>
<p>思路：用一个长度为N的哈希表就可以了，因为最小整数不可能超过N，符合条件就放入，不符合条件就跳过，最后从1开始遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(N+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;=<span class="number">1</span> &amp;&amp; L[i]&lt;=N)</span><br><span class="line">            M[L[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103224067.png" alt="image-20210724103224067"></p>
<h3 id="PAT-1145"><a href="#PAT-1145" class="headerlink" title="PAT 1145"></a>PAT 1145</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724143956305.png" alt="image-20210724143956305"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144007126.png" alt="image-20210724144007126"></p>
<p>题目大意：</p>
<p>（quadratic：平方的）</p>
<p><strong>给定一个序列，用平方探测法（只用正数）解决哈希冲突，然后给出m个数字（皆为正数），如果这个数字不能够被插入就输出”X cannot be inserted.”，然后输出这m个数字的平均查找次数</strong></p>
<p>思路：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144235052.png" alt="image-20210724144235052"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//0  1  2  3  4</span></span><br><span class="line"><span class="comment">//10 6  11    4</span></span><br><span class="line"><span class="comment">//11 2次  4 1次  15 6次  2 2次</span></span><br><span class="line"><span class="comment">//11/4 = 2.8</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Msize,N,M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;Msize&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isprime</span>(Msize)) Msize++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Hash</span><span class="params">(Msize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构建哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断插入不成功？</span></span><br><span class="line">            <span class="keyword">if</span>(Hash[(a+j*j)%Msize]==<span class="number">0</span>)&#123;</span><br><span class="line">                Hash[(a+j*j)%Msize] = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==Msize) <span class="built_in">printf</span>(<span class="string">&quot;%d cannot be inserted.\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均查找次数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断找不到?</span></span><br><span class="line">            <span class="type">int</span> t = (b+j*j)%Msize;</span><br><span class="line">            <span class="keyword">if</span>(Hash[t]==b || Hash[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">        sum += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum/M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144253395.png" alt="image-20210724144253395"></p>
<h3 id="PAT-1146"><a href="#PAT-1146" class="headerlink" title="PAT 1146"></a>PAT 1146</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150143550.png" alt="image-20210724150143550"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150158871.png" alt="image-20210724150158871"></p>
<p>题目大意：判断一个序列是不是拓扑序列。</p>
<p>思路：构建邻接矩阵，计算入度，根据给出序列判断入度是否为0，然后将以该顶点为起点的边的终点的入度—1,依次判断下一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  <span class="comment">//N:定点数 M：边数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个顶点的入度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[j][i]==<span class="number">1</span>) in++;</span><br><span class="line">        &#125;</span><br><span class="line">        indegree[i] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为拓扑序列</span></span><br><span class="line">    <span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree1</span><span class="params">(indegree)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree1[seq[j]]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Graph[seq[j]][k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        indegree1[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150354679.png" alt="image-20210724150354679"></p>
<h3 id="PAT-1147"><a href="#PAT-1147" class="headerlink" title="PAT 1147"></a>PAT 1147</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153528563.png" alt="image-20210724153528563"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153541846.png" alt="image-20210724153541846"></p>
<p>题目大意：给定一个完全二叉树，要求判断是否是大顶堆或小顶堆，并给出该二叉树的后序遍历。</p>
<p>判断大顶堆或小顶堆只需要遍历整个序列，判断seq[i] 和 seq[2<em>i] 和 seq[2</em>i+1]的关系即可。</p>
<p>后序遍历采用栈进行模拟，</p>
<p>如果有左节点且左节点没被访问过，左节点入栈，</p>
<p>如果左节点被访问过且右节点没被访问过，右节点入栈</p>
<p>如果是叶子节点，且左右节点都被访问过，则出栈，visited设1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHEAP -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; seq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = seq.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">//第0个结点不用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(size+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node = S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node*<span class="number">2</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>+<span class="number">1</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>&gt;size || (node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>+<span class="number">1</span>])  <span class="comment">//访问该结点的条件 1、没有孩子结点 </span></span><br><span class="line">         || (node*<span class="number">2</span>+<span class="number">1</span>&gt;size &amp;&amp; node*<span class="number">2</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>]))&#123;   <span class="comment">//2、如果有右节点，且被访问过 3、如果没有右结点且左节点被访问过</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            visited[node] = <span class="number">1</span>;  <span class="comment">//标志该结点以访问过</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(seq[node]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)  cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_or_min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(seq[<span class="number">1</span>]&gt;seq[M]) max_or_min = MAX;</span><br><span class="line">        <span class="keyword">else</span> max_or_min = MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_or_min==MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&gt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&gt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&lt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&lt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_or_min==MAX) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN) cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==NOTHEAP) cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="built_in">postorder</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724154312977.png" alt="image-20210724154312977"></p>
<h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021.7.31"></a>2021.7.31</h2><h3 id="PAT-1140"><a href="#PAT-1140" class="headerlink" title="PAT 1140"></a>PAT 1140</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731211941856.png" alt="image-20210731211941856"></p>
<p>题目大意：</p>
<p>题意：后面一个数是前面一个数的描述，一般第一个数是d，代表0-9的任意一个数，第二 数是第一个数的描述，就是将d+d的个数。同样，第三个数是第二个数的描述，依次，例如:1   11(前一个1是第一个数，后一个1是第一个中1的个数)    12（代表前一个数中有2个1）  1121（前面一个数中有1个1，1个2，数放前，个数放后）  122111   112213  12221131  1123123111 。</p>
<p>思路：采用模拟的方法，c表示当前字符，如果遍历到的字符不是c，则输出到temp中，如果是c，则c的个数size++.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731212418772.png" alt="image-20210731212418772"></p>
<p>原因在于<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225304119.png" alt="image-20210731225304119"></p>
<p>使用&#x3D;是深拷贝，需将temp重新拷贝一份再赋值给temp</p>
<p>使用+&#x3D; 是直接在后面append。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225217330.png" alt="image-20210731225217330"></p>
<h3 id="PAT-1141"><a href="#PAT-1141" class="headerlink" title="PAT 1141"></a>PAT 1141</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225429215.png" alt="image-20210731225429215"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225444048.png" alt="image-20210731225444048"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225453525.png" alt="image-20210731225453525"></p>
<p>问题描述：给定每个考生的成绩和学校，统计该学校的总成绩并排序。</p>
<p>思路：用一个Map用于查找学校信息，便于统计学校总成绩，然后扔到vector进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total==b.total &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.total==b.total)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.total&gt;b.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].total),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231308137.png" alt="image-20210731231308137"></p>
<p>sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231840300.png" alt="image-20210731231840300"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231858291.png" alt="image-20210731231858291"></p>
<p>正确代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231804410.png" alt="image-20210731231804410"></p>
<h3 id="PAT-1142"><a href="#PAT-1142" class="headerlink" title="PAT 1142"></a>PAT 1142</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231938095-1677591493747.png" alt="image-20210731231938095"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231950482-1677591493747.png" alt="image-20210731231950482"></p>
<p>题目大意：问题描述：给定一个无向图，和一些顶点，判断这些顶点是否组成了集合（每两个顶点都相连）</p>
<p>Yes 是一个团，每两个顶点都相邻</p>
<p>Not Maximal  是一个团，但是可以再加入一个顶点，使得每两个顶点相连</p>
<p>Not a Clique  不是每两个顶点都相连。</p>
<p>思路：构造邻接矩阵，对给定序列依次判断是否是一个团，然后再尝试加入其他顶点，判断是否是最大团。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232208835-1677591493747.png" alt="image-20210731232208835"></p>
<h3 id="PAT-1143"><a href="#PAT-1143" class="headerlink" title="PAT 1143"></a>PAT 1143</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232235278.png" alt="image-20210731232235278"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232247776.png" alt="image-20210731232247776"></p>
<p>题目大意：用先序遍历的方式给出一棵排序二叉树。让你回答n个询问。<br> 找出每个询问的最近公共祖先。</p>
<p>用TreeMap存树的每个结点，第一步判断是否存在  否则not found</p>
<p>第二部查找最近的公共祖孙，这里利用二叉排序树的特点，如果n1 和 n2 一个大于根节点 一个小于根节点，则根节点必定是公共祖先，否则递归进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLCA</span><span class="params">(vector&lt;<span class="type">int</span>&gt; Tree,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = Tree[left];</span><br><span class="line">    <span class="keyword">if</span>((n1&lt;t &amp;&amp; n2&gt;t) || (n1&gt;t &amp;&amp; n2&lt;t) || (n1==t||n2==t)) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left+<span class="number">1</span>;  <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(Tree[i]&lt;t) i++;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;t &amp;&amp; n2&lt;t) <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,left+<span class="number">1</span>,i<span class="number">-1</span>,n1,n2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,i,right,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Tree</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; TreeMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;Tree[i];</span><br><span class="line">        TreeMap[Tree[i]]++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>() &amp;&amp; TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.&quot;</span>,n1,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> lca = <span class="built_in">searchLCA</span>(Tree,<span class="number">0</span>,N<span class="number">-1</span>,n1,n2);</span><br><span class="line">            <span class="keyword">if</span>(lca==n1)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n1,n2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lca==n2)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n2,n1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.&quot;</span>,n1,n2,lca);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232946850.png" alt="image-20210731232946850"></p>
<p>佬们的代码：他是直接利用先序遍历的特点，按顺序判断是否是祖先</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232910793.png" alt="image-20210731232910793"></p>
<h2 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021.8.7"></a>2021.8.7</h2><h3 id="PAT-1136"><a href="#PAT-1136" class="headerlink" title="PAT 1136"></a>PAT 1136</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112248715.png" alt="image-20210807112248715"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112302487.png" alt="image-20210807112302487"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112313001.png" alt="image-20210807112313001"></p>
<p>题目大意：一个数加它的翻转能否在10次内得到一个回文数</p>
<p>思路：模拟大数加法，并且模拟反转过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> benwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c = a[i]-<span class="string">&#x27;0&#x27;</span> + b[i]-<span class="string">&#x27;0&#x27;</span> + jinwei;</span><br><span class="line">        benwei = c%<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(benwei) + res;</span><br><span class="line">        jinwei = c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jinwei!=<span class="number">0</span>) res = <span class="built_in">to_string</span>(jinwei) + res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispalindromic</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ispalindromic</span>(a) &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s + &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        string c = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        a = <span class="built_in">add</span>(a,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Not found in 10 iterations.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s is a palindromic number.&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112447331.png" alt="image-20210807112447331"></p>
<h3 id="PAT-1137"><a href="#PAT-1137" class="headerlink" title="PAT 1137"></a>PAT 1137</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162201003.png" alt="image-20210807162201003"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162215605.png" alt="image-20210807162215605"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162226330.png" alt="image-20210807162226330"></p>
<p>题目大意：</p>
<p>判断一个学生是否有资格获得整数的条件有2个：1.学生是否能编程&gt;&#x3D;200题 2.学生的总评成绩是否&gt;&#x3D;60</p>
<p>由于题目是分开给出各项成绩，而且Id唯一，所以我们可以使用Map方便查找。最后进行判断，判断完后排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162636845.png" alt="image-20210807162636845"></p>
<p><strong>大坑</strong>：</p>
<p>题目中的-1的意思表示的是没有学生的某一项没有分数（而非分数为0！没有分数代表没来考试，而分数为0代表考试考了0分！）</p>
<p>所以mid的初值应该设为-1 而不应该设为0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162728149.png" alt="image-20210807162728149"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">-1</span>;  <span class="comment">//-1代表没有成绩，不代表0分</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;=<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162753507.png" alt="image-20210807162753507"></p>
<h3 id="PAT-1138"><a href="#PAT-1138" class="headerlink" title="PAT 1138"></a>PAT 1138</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162840383.png" alt="image-20210807162840383"></p>
<p>题目大意：给出数的前序、中序，求后序输出的第一个值</p>
<p>思路：按照前序、中序序列构造树的方法，采用递归，中间需要用到Map来查找中序序列的位置。</p>
<p>如果有左子树，后序遍历的第一个序列在左子树中寻找，否则在右子树中寻找。只有一个节点，则Return；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(preorder,inorder,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807163415544.png" alt="image-20210807163415544"></p>
<p>改进方法：函数传值的时候尽量不要把整个vector都传进去，否则会出现爆内存的情况。需要把vector设置成全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192348410.png" alt="image-20210807192348410"></p>
<h3 id="PAT-1139"><a href="#PAT-1139" class="headerlink" title="PAT 1139"></a>PAT 1139</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192751253.png" alt="image-20210807192751253"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192805065.png" alt="image-20210807192805065"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192815264.png" alt="image-20210807192815264"></p>
<p><strong>题意</strong>：如果一个男孩子A对一个女孩子B有好感，那么他需要跟他的好哥们C说，然后C再去找B的闺蜜，让闺蜜给B带话。</p>
<p>思路就是从A的同性朋友中找出C，再从B的同性朋友中找出D，然后C，D是好朋友的话，这个话就带到了。</p>
<p>但是输出那里规定A，B可以是同性，</p>
<p>If they are of the same gender, then both friends must be in the same gender as theirs.</p>
<p>emmmmmmm，这道题gay里gay气的。</p>
<p><strong>思路</strong>：Person结构体存储自己的Id,还有男朋友，女朋友（其实也可以一起存储），然后用一个Map&lt;id,Person&gt;方便使用Id找到相对应的朋友。</p>
<p>然后给定两个朋友A，朋友B，根据Map找到对应的A的男朋友或女朋友，and 找到B的男朋友或女朋友，最后写一个函数判断这两人之间是否存在关系，然后将存在关系的朋友排好序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; boyfriend;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; girlfriend;</span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfriend</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    Person p = Map[id];</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.boyfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.girlfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(id2&gt;<span class="number">0</span>) Map[id1].boyfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">else</span> Map[id1].girlfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span>) Map[id2].boyfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        <span class="keyword">else</span> Map[id2].girlfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807193412853.png" alt="image-20210807193412853"></p>
<p>参考了以下柳神的代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807200903777.png" alt="image-20210807200903777"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a != y.a ? x.a &lt; y.a : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> asa = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(a)),asb = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(b));</span><br><span class="line">        <span class="comment">// A/B ID 作为下标记录同性边数据，arr记录关系</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v[asa].<span class="built_in">push_back</span>(asb);</span><br><span class="line">            v[asb].<span class="built_in">push_back</span>(asa);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[asa * <span class="number">10000</span> + asb] = arr[asb * <span class="number">10000</span> + asa] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[<span class="built_in">abs</span>(c)].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v[<span class="built_in">abs</span>(d)].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// A在寻找同性朋友时，需要避免找到他想要的伴侣B，所以当前朋友就是B或B的同性朋友就是A时舍弃该结果</span></span><br><span class="line">                <span class="keyword">if</span> (v[<span class="built_in">abs</span>(c)][j] == <span class="built_in">abs</span>(d) || <span class="built_in">abs</span>(c) == v[<span class="built_in">abs</span>(d)][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// A/B，先找A的所有同性朋友C，再找B的所有同性朋友D，当C和D两人是朋友的时候则可以输出C和D</span></span><br><span class="line">                <span class="keyword">if</span> (arr[v[<span class="built_in">abs</span>(c)][j] * <span class="number">10000</span> + v[<span class="built_in">abs</span>(d)][k]] == <span class="literal">true</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node&#123;v[<span class="built_in">abs</span>(c)][j], v[<span class="built_in">abs</span>(d)][k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(ans.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进后</strong>，重新捋一下<strong>思路</strong>：</p>
<p><font color="red">重点!!!</font></p>
<ul>
<li><p>题目简化后为A寻找同性伴侣B，D寻找同性伴侣A，然后A和B是朋友，则添加到结果中。</p>
</li>
<li><p>由于数据错综复杂，所以不适合采用邻接矩阵，我们只需要记录他们之间的关系即可，数据结构可以直接采用 map&lt;pair&lt;int,int&gt;,bool&gt;来存储两者间的关系，其中make_pair&lt;int,int&gt;可以使用哈希映射，比如make_pair&lt;a,b&gt;可以等价为 a*10000+b,同时不会导致哈希冲突。</p>
</li>
<li><p>如何寻找同性朋友呢，可以使用结构体Person, Person下有一个vector用于存储同性朋友，为了快速找到 id 对应的结构体Person，我们可以用map将id直接映射到Person中。</p>
</li>
<li><p>如果用Int接收朋友，会出现+0000和-0000的情况，不能判断是否为同性朋友，题目说we use a negative sign to represent girls. 用一个符号代表女性朋友，我们可以先用string接收，然后stoi(s)转成Int形，用s.length是否相同来判断是否为同性朋友。  (对应2、3个测试点)</p>
</li>
<li><p>输出的数据必须从小到大排序</p>
</li>
<li><p>A在寻找同性朋友时应该避免找到他的同性伴侣D，坑点（对应4、5、6测试点）</p>
</li>
<li><p>输出要保留4位小数  %04d  对应（2、3测试点）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gayfriend;  <span class="comment">//同性朋友</span></span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;pair&lt;int,int&gt;,bool&gt; isfriend;  key不能是pair类型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; isfriend;   <span class="comment">//可以建立Int,Int的哈希映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string sd1,sd2;  cin&gt;&gt;sd1&gt;&gt;sd2;</span><br><span class="line">        <span class="type">int</span> id1 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd1)),id2 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建朋友关系</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id1,id2)]=true;</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id2,id1)]=true;</span></span><br><span class="line">        isfriend[id1*<span class="number">10000</span>+id2]=<span class="literal">true</span>;</span><br><span class="line">        isfriend[id2*<span class="number">10000</span>+id1]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是同性朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(sd1.<span class="built_in">length</span>()==sd2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            Map[id1].gayfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">            Map[id2].gayfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        id1 = <span class="built_in">abs</span>(id1); id2 = <span class="built_in">abs</span>(id2);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        Person p1 = Map[id1];</span><br><span class="line">        Person p2 = Map[id2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p1.gayfriend.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p2.gayfriend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> fri1 = p1.gayfriend[i];</span><br><span class="line">                <span class="type">int</span> fri2 = p2.gayfriend[j];</span><br><span class="line">                <span class="keyword">if</span>(fri1==id2 || fri2==id1) <span class="keyword">continue</span>;  <span class="comment">// A在寻找同性朋友时，需要避免直接找到他想要的伴侣B</span></span><br><span class="line">                <span class="keyword">if</span>(isfriend[fri1*<span class="number">10000</span>+fri2] &amp;&amp; fri1!=fri2)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(fri1,fri2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807205353302.png" alt="image-20210807205353302"></p>
<h2 id="2021-8-14"><a href="#2021-8-14" class="headerlink" title="2021.8.14"></a>2021.8.14</h2><h3 id="PAT-1132"><a href="#PAT-1132" class="headerlink" title="PAT 1132"></a>PAT 1132</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125130500.png" alt="image-20210814125130500"></p>
<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20210814125141745.png" alt="image-20210814125141745" style="zoom:150%;">

<p>题目大意：<strong>一个偶数个位的正整数num，把它从中间分成左右两个整数a、b，问num能不能被a和b的乘积整除，能的话输出yes，不能的话输出no</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125236517.png" alt="image-20210814125236517"></p>
<p>因为没有判断c1*c2能不能是0，正确的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>((c1*c2) &amp;&amp;c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125323306.png" alt="image-20210814125323306"></p>
<h3 id="PAT-1133"><a href="#PAT-1133" class="headerlink" title="PAT 1133"></a>PAT 1133</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125357711.png" alt="image-20210814125357711"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125410450.png" alt="image-20210814125410450"></p>
<p>题目大意：给出一个链表，将链表分为三部分，第一部分小于0的数，第二部分小于&#x3D;K的数，第三部分，大于K的数。</p>
<p>思路：数据结构，一个结构体，存放地址address,数number，下一跳nextaddress，再采用map使得可以方便地根据address查找结点所在的位置，然后获取下一跳，以此类推。最后通过三次查找把合适的部分取出来放到vector中，这样就排好序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string address;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string nextaddress;</span><br><span class="line">    <span class="type">bool</span> isvisited = <span class="literal">false</span>;</span><br><span class="line">&#125;node;</span><br><span class="line">unordered_map&lt;string,node&gt; M;</span><br><span class="line">vector&lt;node&gt; res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string fadd;  cin&gt;&gt;fadd;</span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        node n; </span><br><span class="line">        cin&gt;&gt;n.address&gt;&gt;n.number&gt;&gt;n.nextaddress;</span><br><span class="line">        M[n.address] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    string nextaddress = fadd;</span><br><span class="line">    <span class="comment">//第一遍寻找负数</span></span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一遍寻找小于K的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;=K) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三遍加入剩余的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=res.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number,res[i+<span class="number">1</span>].address.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d -1&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125702974.png" alt="image-20210814125702974"></p>
<h3 id="PAT-1134"><a href="#PAT-1134" class="headerlink" title="PAT 1134"></a>PAT 1134</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125742396.png" alt="image-20210814125742396"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125753908.png" alt="image-20210814125753908"></p>
<p>题目大意：n个顶点和m条边的图，分别给出m条边的两端顶点，然后对其进行k次查询，每次查询输入一个顶点集合，要求判断这个顶点集合是否能完成顶点覆盖，即图中的每一条边都至少有一个顶点在这个集合中。</p>
<p>思路：很简单，将顶点集合用map存，然后遍历边，判断是否有一个顶点在map中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edgeset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        edgeset.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e1,e2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> c;  cin&gt;&gt;c; Map[c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;edgeset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> e1 = edgeset[j].first, e2 = edgeset[j].second;</span><br><span class="line">            <span class="keyword">if</span>(Map.<span class="built_in">find</span>(e1)==Map.<span class="built_in">end</span>() &amp;&amp; Map.<span class="built_in">find</span>(e2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125924885.png" alt="image-20210814125924885"></p>
<h3 id="PAT-1135"><a href="#PAT-1135" class="headerlink" title="PAT 1135"></a>PAT 1135</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145832177.png" alt="image-20210814145832177"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145853993.png" alt="image-20210814145853993"></p>
<p><strong>题目大意</strong>：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</p>
<p>1、非红即黑</p>
<p>2、根结点是否为黑色       </p>
<p>3、将NULL看成1个叶子节点，为黑<code>black</code>色</p>
<p>4、如果1个结点是红色，它的孩子节点是否都为黑色       </p>
<p>5、从任意结点到叶子结点的路径中，黑色结点的个数是否相同       </p>
<p><strong>考场错误思路一</strong>：由于是二叉排序树加上先序序列，可以递归构造二叉树。然后dfs的过程中判断第4个条件，并统计第5个条件（黑色结点个数是否相同）</p>
<p>一开始理解错了，从根节点到叶子结点的路径中，黑色结点个数相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; black_num;   <span class="comment">//统计路径上的黑色结点的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,<span class="type">int</span> black)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&gt;<span class="number">0</span>) black++;   <span class="comment">//黑色结点+1</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        black_num.<span class="built_in">push_back</span>(black);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    black_num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="type">bool</span> dfs = <span class="built_in">DFS</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfs==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;black_num.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(black_num[i]!=black_num[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814150547067.png" alt="image-20210814150547067"></p>
<p>第3个结点段错误，建树过程中存在一些问题。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814154047150.png" alt="image-20210814154047150"></p>
<p><strong>考场错误思路二</strong>：为了使得每一层到叶子结点的黑色结点数相同，我私自认为</p>
<p>&#x2F;&#x2F;判断是否为红黑树</p>
<p>&#x2F;&#x2F;1、红黑树一定是一棵平衡二叉树</p>
<p>&#x2F;&#x2F;2、红黑树一定层次分明,一层黑一层白</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lefthigh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> righhigh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lefthigh,righhigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh-rh&gt;<span class="number">1</span> || rh-lh&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">levelsearch</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> black = <span class="number">1</span>;  <span class="comment">//第一层是black</span></span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> lsize = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsize;i++)&#123;</span><br><span class="line">            TreeNode* p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val*black&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        black*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">levelsearch</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然是错误的，所以红黑树不是平衡二叉树</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155039169.png" alt="image-20210814155039169"></p>
<p><strong>正确思路</strong>：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155458247.png" alt="image-20210814155458247"></p>
<p>这里是判断平衡二叉树的变体，算高度时只统计黑色结点的个数</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155547670.png" alt="image-20210814155547670"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? <span class="built_in">max</span>(l, r) + <span class="number">1</span> : <span class="built_in">max</span>(l, r);</span><br><span class="line">    <span class="comment">// return 1+max(l,r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh!=rh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">DFS</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155614848.png" alt="image-20210814155614848"></p>
<h2 id="2021-8-20"><a href="#2021-8-20" class="headerlink" title="2021.8.20"></a>2021.8.20</h2><h3 id="PAT-1128"><a href="#PAT-1128" class="headerlink" title="PAT 1128"></a>PAT 1128</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184132575.png" alt="image-20210820184132575"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184145438.png" alt="image-20210820184145438"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184157300.png" alt="image-20210820184157300"></p>
<p>判断同一行同一列对角线上有无N皇后，同一列题目已经保证了，同一行用map保证，对角线判断j-i&#x3D;&#x3D;abs(row[j]-row[i] ） O(n*n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> K;   cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//第一个元素不用，下标表示col，数值表示row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;row[i];</span><br><span class="line">            <span class="keyword">if</span>(map[row[i]]==<span class="number">1</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> map[row[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;row.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;row.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="built_in">abs</span>(row[j]-row[i])) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184442560.png" alt="image-20210820184442560"></p>
<h3 id="PAT-1129"><a href="#PAT-1129" class="headerlink" title="PAT 1129"></a>PAT 1129</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184523153.png" alt="image-20210820184523153"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184533785.png" alt="image-20210820184533785"></p>
<p><strong>题目大意</strong>：给定一个序列，求目前出现次数最多的k个数字。如果数字出现次数相同，升序排列。</p>
<p><strong>解题思路</strong>：类似LRU，寻找出现次数最多的三个。</p>
<p>数据结构的设计，一个vector&lt;pair&lt;int,int&gt;&gt; KWindow;   存放出现次数最多的K个数字,pair-&gt;first代表数字，pair-&gt;second代表出现的次数，每加入一个数字，我们就要判断是否要更新KWindow.采用unordered_map存放这个数字在目前出现了几次。</p>
<p>判断是否需要更新KWindow? </p>
<p>情况一：新加入的数字在KWindow中，直接在KWindow中更新就好了，然后排序。</p>
<p>情况二：新加入的数字不在KWindow中，而且KWindow还没满，直接加入，然后排序。</p>
<p>情况三：新加入的数字不在KWindow中，而且KWindow满了，判断是否需要替换，由于之前已经排好序了，只要和最后一个比较，如果次数&lt;最后一个，或者次数相同，数字小于最后一个，则替换掉最后一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;    <span class="comment">//统计在j之前出现的次数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; KWindow;  <span class="comment">//存放出现次数最多的K个数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">finda</span><span class="params">(<span class="type">int</span> target,<span class="type">int</span> fre)</span></span>&#123;  <span class="comment">//查找当前数字是不是在KWindow中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(KWindow[i].first==target)&#123;</span><br><span class="line">            KWindow[i].second = fre;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Min = <span class="number">0</span>;  <span class="comment">//当前最小的次数</span></span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp; cin&gt;&gt;temp;</span><br><span class="line">        input.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Map[input[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">finda</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]))&#123;  <span class="comment">//本来就在窗口里面，不用处理</span></span><br><span class="line">            <span class="keyword">if</span>(KWindow.<span class="built_in">size</span>()&lt;K)&#123;  <span class="comment">//窗口还有容量</span></span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]&gt;Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]==Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].first&gt;input[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                    KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(KWindow.<span class="built_in">begin</span>(),KWindow.<span class="built_in">end</span>(),cmp);  <span class="comment">//将窗口排好序</span></span><br><span class="line">        Min = KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;KWindow[i].first;</span><br><span class="line">            <span class="keyword">if</span>(i!=KWindow.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185242648.png" alt="image-20210820185242648"></p>
<h3 id="PAT-1130"><a href="#PAT-1130" class="headerlink" title="PAT 1130"></a>PAT 1130</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185308171.png" alt="image-20210820185308171"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185322504.png" alt="image-20210820185322504"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185334088.png" alt="image-20210820185334088"></p>
<p><strong>题目大意</strong>：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级</p>
<p><strong>解题思路</strong>：给定的输入建树的过程我感觉比较复杂。在输入的第一遍建立TreeNode，然后将string映射到TreeNode中，但这样会有一个问题，就是string的值可能相同，所以我给每个输入结点设置了一个id，第二遍结点全部都创建好了，我们就可以根据左子树所在的行数，和右子树所在的行数 所 映射到的结点建立连接。  最后就是寻找根节点的过程，用set就可以了，把有父节点的加入set，最后不在set的那个就是根节点。</p>
<p>后面就是中序遍历，很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; Set;  <span class="comment">//用来寻找没有前驱的结点,寻找根节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; MM;  <span class="comment">//建立id到TreeNode的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">input</span></span><br><span class="line">&#123;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">&#125;input;</span><br><span class="line">vector&lt;input&gt; I;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        TreeNode* r = MM[I[i].id];</span><br><span class="line">        <span class="keyword">if</span>(I[i].left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* left = MM[I[I[i].left].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].left].id);</span><br><span class="line">            r-&gt;left = left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(I[i].right!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* right = MM[I[I[i].right].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].right].id);</span><br><span class="line">            r-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(I[i].id)==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> MM[I[i].id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)  <span class="comment">//如果不是叶子结点则加括号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    I.<span class="built_in">push_back</span>(input&#123;&#125;);  <span class="comment">//第一个数不用</span></span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        input ii;  cin&gt;&gt;ii.val&gt;&gt;ii.left&gt;&gt;ii.right;</span><br><span class="line">        ii.id=i;</span><br><span class="line">        I.<span class="built_in">push_back</span>(ii);</span><br><span class="line">        TreeNode* r = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ii.val);</span><br><span class="line">        MM[ii.id] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185818116.png" alt="image-20210820185818116"></p>
<h3 id="PAT-1131"><a href="#PAT-1131" class="headerlink" title="PAT 1131"></a>PAT 1131</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181205412.png" alt="image-20210820181205412"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181223417.png" alt="image-20210820181223417"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181241538.png" alt="image-20210820181241538"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181255465.png" alt="image-20210820181255465"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181307918.png" alt="image-20210820181307918"></p>
<p><strong>题目大意</strong>：</p>
<p>给出各地铁线所经过的站点，构成一张地铁交通图。再给出起点和终点，让你找出最快的一条路径，<strong>如果路径不唯一就选择中转次数最少的那一条</strong>。 </p>
<p><strong>解题思路</strong>：</p>
<p>我没有考虑到这一点，所以2，4测试点没有过。</p>
<p>1、本来想用Floyd算法，但是发线每条边权值都为1，所以用BFS搜索即可。</p>
<p>2、构造邻接矩阵有一个问题，就是要解决0000四位整数映射问题，不然开辟10000*10000个空间未免太大了，我的做法是读入是写到set中，然后遍历set建立string-int的映射，还有int-string的映射。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181854943.png" alt="image-20210820181854943"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181916383.png" alt="image-20210820181916383"></p>
<p>3、建图，采用邻接矩阵，这里存储的是无向图，因此根据线路构造的时候要存储两次，邻接矩阵存储的边值代表线路（几号线）而不是代价。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182051111.png" alt="image-20210820182051111"></p>
<p>4、BFS寻找最短路径，用path来存储路径，path[i] &#x3D; j表示，从j-&gt;i，方便往回寻找</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182130533.png" alt="image-20210820182130533"></p>
<p>5、找到后需要输出路径，顺着path往回寻找，将结果放到path_中。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182243168.png" alt="image-20210820182243168"></p>
<p>6、最后在把path带入到Graph中构造出所要的线路结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182317542.png" alt="image-20210820182317542"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; input;   <span class="comment">//input[i]表示i+1号线的站点</span></span><br><span class="line">unordered_set&lt;string&gt; Set;  <span class="comment">//实现站点映射</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; MapStoI; <span class="comment">//相互映射</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,string&gt; MapItoS; <span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;   <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> kkk=<span class="number">0</span>;  <span class="comment">//结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(string start,string destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> begin = MapStoI[start];</span><br><span class="line">    <span class="type">int</span> end = MapStoI[destination];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(kkk,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(kkk,<span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(begin);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   <span class="comment">//BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kkk;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span> &amp;&amp; Graph[t][i])&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">//访问过</span></span><br><span class="line">                path[i] = t;  <span class="comment">//记录从t-i的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="type">int</span> p = end;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path_;  path_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(p!=begin)&#123;</span><br><span class="line">        <span class="type">int</span> temp = path[p];</span><br><span class="line">        path_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;path_.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(path_.<span class="built_in">begin</span>(),path_.<span class="built_in">end</span>());  <span class="comment">//反转</span></span><br><span class="line">    <span class="type">int</span> bbbb = path_[<span class="number">0</span>];  <span class="type">int</span> eeee = path_[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> xianlu = Graph[path_[<span class="number">0</span>]][path_[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[path_[i]][path_[i<span class="number">-1</span>]]==xianlu) eeee = path_[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[eeee].<span class="built_in">c_str</span>());</span><br><span class="line">            xianlu = Graph[path_[i]][path_[i<span class="number">-1</span>]];</span><br><span class="line">            bbbb = eeee;</span><br><span class="line">            eeee = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[end].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph.<span class="built_in">resize</span>(kkk,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(kkk,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;input[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            Graph[MapStoI[input[i][j<span class="number">-1</span>]]][MapStoI[input[i][j]]] = i+<span class="number">1</span>;  <span class="comment">//后面的数字代表几号线 ,0 表示不连通</span></span><br><span class="line">            Graph[MapStoI[input[i][j]]][MapStoI[input[i][j<span class="number">-1</span>]]] = i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="comment">//1  处理输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">C</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;C[j];</span><br><span class="line">            Set.<span class="built_in">insert</span>(C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        input.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 站点映射</span></span><br><span class="line">    unordered_set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Set.<span class="built_in">begin</span>();iter!=Set.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        MapItoS[kkk] = *iter;</span><br><span class="line">        MapStoI[*iter]=kkk++;</span><br><span class="line">    &#125;<span class="comment">//映射完后共有Kkk个结点，从0..kkk-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 建图</span></span><br><span class="line">    <span class="built_in">BuildGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 广度优先搜索寻找最短路径</span></span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        string start,end; cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182348064.png" alt="image-20210820182348064"></p>
<p><strong>答案正解</strong>：</p>
<p>1、使用邻接表存储     2、使用line的键为a*10000+b,建立边到线路的映射      3、dfs暴力深搜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[<span class="number">10000</span>],minCnt,minTransfer;  <span class="comment">//是否访问过 最小代价  最小中转次数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10000</span>);  <span class="comment">//采用邻接表存储</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path,tempPath;<span class="comment">//路径vector</span></span><br><span class="line"><span class="type">int</span> start,end1;<span class="comment">//起点 终点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; line;  <span class="comment">//结点到路线的映射</span></span><br><span class="line"><span class="comment">/*unordered_map&lt;int,int&gt;line存储两个结点的边所属的路线</span></span><br><span class="line"><span class="comment">假设边两端为a到b，line的键为a*10000+b,值为这条边所属的路线*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transferCnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//传入临时路径，传出中转站个数</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">-1</span>,preLine=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]] != preLine) </span><br><span class="line">			cnt++;<span class="comment">//换乘数cnt+1</span></span><br><span class="line">		preLine=line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;<span class="comment">//输出换乘数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> cnt)</span></span>&#123; <span class="comment">//cnt为换乘数</span></span><br><span class="line">    <span class="comment">//搜索到路径，需要更新</span></span><br><span class="line">	<span class="keyword">if</span>(node==end1 &amp;&amp; (cnt&lt;minCnt || (cnt ==minCnt&amp;&amp;<span class="built_in">transferCnt</span>(tempPath) &lt;minTransfer))) &#123;</span><br><span class="line">		minCnt=cnt;<span class="comment">//更新cnt</span></span><br><span class="line">		minTransfer=<span class="built_in">transferCnt</span>(tempPath);<span class="comment">//更新最小换乘次数</span></span><br><span class="line">		path=tempPath;<span class="comment">//更新路径vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node == end1) <span class="keyword">return</span>;<span class="comment">//搜索到，但不需要更新</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[node].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//dfs寻找路径</span></span><br><span class="line">		<span class="keyword">if</span>(visit[v[node][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">			visit[v[node][i]]=<span class="number">1</span>;<span class="comment">//加锁</span></span><br><span class="line">			tempPath.<span class="built_in">push_back</span>(v[node][i]);</span><br><span class="line">			<span class="built_in">dfs</span>( v[node][i] ,cnt+<span class="number">1</span>); <span class="comment">//cnt+1，进入下一层dfs</span></span><br><span class="line">			visit[v[node][i] ]=<span class="number">0</span>;<span class="comment">//解锁  类似回溯，只对这一层dfs有效</span></span><br><span class="line">			tempPath.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	<span class="type">int</span> n,m,k,pre,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//地铁路线数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;pre);<span class="comment">//pre为m线路的首站</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;<span class="comment">//for循环剩下的m-1个站</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">			v[pre].<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="comment">//首站为pre的线路(vector里)加上temp站</span></span><br><span class="line">			v[temp].<span class="built_in">push_back</span>(pre);</span><br><span class="line">			<span class="comment">//temp站的vector里加入首站(pre)</span></span><br><span class="line">			line[pre*<span class="number">10000</span>+temp]=line[temp*<span class="number">10000</span>+pre]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//pre到temp的线路=temp到pre的线路+1</span></span><br><span class="line">			pre=temp;<span class="comment">//首站为temp</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);<span class="comment">//k次查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;end1);</span><br><span class="line">		<span class="comment">//查询start站到end1站</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//minCnt为最小换乘数，minTransfer为换乘站</span></span><br><span class="line">		minCnt=<span class="number">99999</span>,minTransfer=<span class="number">99999</span>;<span class="comment">//初始化</span></span><br><span class="line">		tempPath.<span class="built_in">clear</span>();</span><br><span class="line">		tempPath.<span class="built_in">push_back</span>(start);<span class="comment">//把start压入临时路径vector</span></span><br><span class="line">		visit[start]=<span class="number">1</span>; <span class="comment">//加锁</span></span><br><span class="line">		<span class="built_in">dfs</span>(start,<span class="number">0</span>); <span class="comment">//递归DFS！！！！！！！！！</span></span><br><span class="line">		visit[start]=<span class="number">0</span>; <span class="comment">//解锁</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//以下为output</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minCnt);<span class="comment">//起点&amp;终点之间的min站数</span></span><br><span class="line">		<span class="type">int</span> preLine=<span class="number">0</span>,preTransfer=start;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;path.<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]] != preLine)&#123;</span><br><span class="line">				<span class="keyword">if</span>(preLine != <span class="number">0</span>) <span class="comment">//每当line和preline不等则输出这句话</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>,</span><br><span class="line">					preLine,preTransfer,path[j<span class="number">-1</span>] );</span><br><span class="line">				preLine=line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]];<span class="comment">//更新上一条线路号</span></span><br><span class="line">				preTransfer = path[j<span class="number">-1</span>];<span class="comment">//更新上一个换乘站</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, </span><br><span class="line">				preLine,preTransfer,end1);<span class="comment">//输出最后一小截线路</span></span><br><span class="line">				<span class="comment">//preLine路线 从preTransfer站到end1站</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820183834493.png" alt="image-20210820183834493"></p>
<h2 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h2><p>1h40min搞定  98分</p>
<h3 id="PAT-1124"><a href="#PAT-1124" class="headerlink" title="PAT 1124"></a>PAT 1124</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105622634.png" alt="image-20210829105622634"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105636286.png" alt="image-20210829105636286"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105648351.png" alt="image-20210829105648351"></p>
<p><strong>题目大意</strong>：明PAT考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔N个人就发出一个红包。请你编写程序帮助他确定中奖名单。注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出“Keep going…”</p>
<p><strong>思路</strong>：只要读懂题目，没有任何头脑的题，一个while循环，加一个set判断重复轻松搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> M,N,S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;S;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">L</span><span class="params">(M+<span class="number">1</span>,<span class="string">&quot;&quot;</span>)</span></span>; </span><br><span class="line">    set&lt;string&gt; Set;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = S;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(L[cur])==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(L[cur]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(L[cur]);</span><br><span class="line">            cur += N;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Keep going...&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105856839.png" alt="image-20210829105856839"></p>
<h3 id="PAT-1125"><a href="#PAT-1125" class="headerlink" title="PAT 1125"></a>PAT 1125</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105926511.png" alt="image-20210829105926511"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105937843.png" alt="image-20210829105937843"></p>
<p>题目大意：　绳子每次打结长度都会减小到原来的一半，那么打结的顺序会影响到最终的长度。求最终长度不超过的数。</p>
<p>刚开始都没太懂题目的意思…最后想想应该是排序+模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = <span class="built_in">double</span>(possible)/<span class="number">2</span> + <span class="built_in">double</span>(Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">    <span class="comment">// printf(&quot;%.0f&quot;,possible);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110128163.png" alt="image-20210829110128163"></p>
<p>注意：只需排序一次，觉得要每次有新绳子就要排序一下，比你小的两个数的平均数肯定也是最小的呀！</p>
<p>测试点1是只有一段绳子，开始的两段绳子要特殊处理，总长度初值应该是最小绳子长度，而不是0</p>
<p>稍加修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = Input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = (possible+Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110627305.png" alt="image-20210829110627305"></p>
<h3 id="PAT-1126"><a href="#PAT-1126" class="headerlink" title="PAT 1126"></a>PAT 1126</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110921087.png" alt="image-20210829110921087"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110935002.png" alt="image-20210829110935002"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110945243.png" alt="image-20210829110945243"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110956289.png" alt="image-20210829110956289"></p>
<p>题目大意：</p>
<p>对于无向图来说：</p>
<ol>
<li>是欧拉图，连通且所有节点的度为偶数</li>
<li>是半欧拉图，连通且只有两个节点的度为奇数</li>
</ol>
<p>转化为统计图的度，然后判断几个节点的度是奇数，如果仅仅只是这样简单处理测试点3过不去，后向仔细看题看到了<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111134310.png" alt="image-20210829111134310"></p>
<p>需要是连通图才可以。</p>
<p>由于懒得构造邻接矩阵再进行遍历，这里使用并查集来判断是不是完全连通图、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *parents;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> total)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;total = total;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="type">int</span>[total+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">find</span>(node1);</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">find</span>(node2);</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;</span><br><span class="line">            parents[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents[node]!=node)&#123;</span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(node1)==<span class="built_in">find</span>(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEurn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isConnected</span>(i,i+<span class="number">1</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    UnionFind* uf = <span class="keyword">new</span> <span class="built_in">UnionFind</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        degree[n1]++; degree[n2]++;</span><br><span class="line">        uf-&gt;<span class="built_in">Union</span>(n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==N) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">if</span>(degree[i]%<span class="number">2</span>) oddnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uf-&gt;<span class="built_in">isEurn</span>()==<span class="literal">false</span>) &#123;cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(oddnum==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oddnum==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Semi-Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111235971.png" alt="image-20210829111235971"></p>
<h3 id="PAT-1127"><a href="#PAT-1127" class="headerlink" title="PAT 1127"></a>PAT 1127</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111310015.png" alt="image-20210829111310015"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111320873.png" alt="image-20210829111320873"></p>
<p><strong>题目大意</strong>：给定中序和后序序列，建立一棵树，然后对这棵树进行Z型层序遍历。</p>
<p><strong>思路</strong>：就是在层序遍历的时候需要把层数分出来，然后设置一个flag，需要的时候把序列翻转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorder;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> inleft,<span class="type">int</span> inright,<span class="type">int</span> postleft,<span class="type">int</span> postright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inleft&gt;inright) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;postright&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> curnode = postorder[postright];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(curnode);</span><br><span class="line">    <span class="type">int</span> mid = M[curnode];</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(inleft,mid<span class="number">-1</span>,postleft,postleft+mid<span class="number">-1</span>-inleft);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(mid+<span class="number">1</span>,inright,postleft+mid<span class="number">-1</span>-inleft+<span class="number">1</span>,postright<span class="number">-1</span>);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> yinzi = <span class="number">-1</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(yinzi==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        yinzi *= <span class="number">-1</span>;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; inorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">        M[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; postorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ZigZag</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111516703.png" alt="image-20210829111516703"></p>
<h2 id="2021-9-5"><a href="#2021-9-5" class="headerlink" title="2021.9.5"></a>2021.9.5</h2><h3 id="PAT-1120"><a href="#PAT-1120" class="headerlink" title="PAT 1120"></a>PAT 1120</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154114163.png" alt="image-20210905154114163"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154125395.png" alt="image-20210905154125395"></p>
<p>题意：统计数的各位数字之和，并升序输出</p>
<p>用set啥的就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:15-8:25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            count += s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[count]++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154408271.png" alt="image-20210905154408271"></p>
<h3 id="PAT-1121"><a href="#PAT-1121" class="headerlink" title="PAT 1121"></a>PAT 1121</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154431389.png" alt="image-20210905154431389"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154440477.png" alt="image-20210905154440477"></p>
<p>题目大意：给N对夫妻编号，再给M个派对里的参与人的编号，输出单身的人的编号（包括夫妻没全部到场的也算单身）</p>
<p>用map统计夫妻配对的情况，再用一个map[10000]统计到场情况，最后一一排除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154613535.png" alt="image-20210905154613535"></p>
<p>改用set存储M个人的信息，就可以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">insert</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=res.<span class="built_in">begin</span>();it!=res.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it!=res.<span class="built_in">begin</span>())<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155315203.png" alt="image-20210905155315203"></p>
<h3 id="PAT-1122"><a href="#PAT-1122" class="headerlink" title="PAT 1122"></a>PAT 1122</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155357857.png" alt="image-20210905155357857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155408391.png" alt="image-20210905155408391"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155419998.png" alt="image-20210905155419998"></p>
<p>判断是否是哈密顿回路，随便写写就AC了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:40-9:00</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E; cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        graph[e1][e2]=<span class="number">1</span>; graph[e2][e1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Input[i];</span><br><span class="line">        <span class="keyword">if</span>(Input.<span class="built_in">size</span>()!=V+<span class="number">1</span> || Input[<span class="number">0</span>]!=Input[V])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[Input[j]][Input[j+<span class="number">1</span>]]==<span class="number">1</span>)&#123;</span><br><span class="line">                Set.<span class="built_in">insert</span>(Input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==V) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155456226.png" alt="image-20210905155456226"></p>
<h3 id="PAT-1123"><a href="#PAT-1123" class="headerlink" title="PAT 1123"></a>PAT 1123</h3>]]></content>
      <tags>
        <tag>算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubAction+Hexo搭建个人博客</title>
    <url>/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="GithubAction-Hexo搭建个人博客"><a href="#GithubAction-Hexo搭建个人博客" class="headerlink" title="GithubAction+Hexo搭建个人博客"></a>GithubAction+Hexo搭建个人博客</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信很多小伙伴们都在使用 Hexo + Github Page 的方式，先在本地生成自己博客的静态页面，然后再推送到 Github Page 来实现页面的更新。Github 近些年推出了 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a>，这是一个非常强大的 Workflow 自动化工作流，它可以帮助我们完成很多自动化部署任务。今天就来利用 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a> 自动化部署 Hexo 到 Github Page。</p>
<p>本来想使用 Travis CI 自动部署 Hexo 博客，一个私人仓库用于备份博客源码，另一个公开仓库用于托管静态页面，但是最近将修改的文章推送到私人仓库时没有触发 Travis CI 的工作流， Travis CI持续集成部署麻烦，而且还需付费，所以考虑了GIthub Action这种简单免费的部署方式。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>Node.JS</li>
<li>Git</li>
</ul>
<h3 id="Hexo本地博客搭建"><a href="#Hexo本地博客搭建" class="headerlink" title="Hexo本地博客搭建"></a>Hexo本地博客搭建</h3><h4 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h4><p>首先全局安装Hexo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Hexo</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，创建一个project文件夹，然后在该文件夹下初始化，（下面所有命令都是在该文件夹里执行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化 Hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>创建文章命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo new &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会发现在source&#x2F;_post文件夹里出现了”文章名字”.md的文件，Hexo采用markdown编辑。</p>
<p>在本地启动文章，就可以在<a href="http://localhost:4000/">http://localhost:4000/</a> 访问该博客了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo s   # 本地服务启动server</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228215744193.png" alt="image-20230228215744193"></p>
<p>Hexo常用的配置以及目录结构</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228220622909.png" alt="image-20230228220622909"></p>
<p>source&#x2F;_post用于存放用户文章 , _config.yml用于存放配置文件</p>
<h4 id="一些配置修改"><a href="#一些配置修改" class="headerlink" title="一些配置修改"></a>一些配置修改</h4><p>主题配置，在Hexo的官方网站上有许多可以选择的样式 <a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p>
<p>选择一个主题，按照主题里面提示的方法进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在Hexo目录下Clone这个主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"># 修改 Hexo 根目錄下的 _config.yml，把主題改為butterfly</span><br><span class="line">theme: butterfly</span><br><span class="line"></span><br><span class="line"># 安裝插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>





<p>在博客搭建完成之后会发现图片无法显示，</p>
<p>安装一个图片显示的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml的配置文件，然后把 _config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。将图片存放在这个文件夹里引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder = true</span><br></pre></td></tr></table></figure>





<h3 id="Hexo博客发布"><a href="#Hexo博客发布" class="headerlink" title="Hexo博客发布"></a>Hexo博客发布</h3><p>在github下创建一个 linli1724647576.github.io 的仓库，目前github采用的令牌代替密码，所以需要在 devoloper setting的设置里new 一个 Tokens，勾上所有的权限。</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228221853162.png" alt="image-20230228221853162"></p>
<p>然后，在_config.yml 的配置文件里做以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: &quot;https://github.com/linli1724647576/linli1724647576.github.io.git&quot;</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>执行上传命令，会提示输入github的用户名和密码，密码用令牌代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo d  #上传博客 deploy</span><br></pre></td></tr></table></figure>

<p>上传成功后就可以在github Pages里访问了。</p>
<h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;  等价于 hexo new &quot;我的第一篇文章&quot;  还等价于</span><br><span class="line">hexo p 等价于 hexo publish</span><br><span class="line">hexo g 等价于 hexo generate  </span><br><span class="line">hexo s等价于 hexo server     </span><br><span class="line">hexo d 等价于 hexo deploy</span><br></pre></td></tr></table></figure>

<p>下次发布时先运行hexo g生成静态网页，然后再hexo d </p>
<p>也可以采用admin模式自动发布,需要安装插件</p>
<p>npm install –save hexo-admin</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/BV1mU4y1j72n/">https://www.bilibili.com/video/BV1mU4y1j72n/</a></p>
<p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/2023/03/01/tags/</url>
    <content><![CDATA[<p>硕士在读，计算机技术专业，分享一些论文和一些技术，强迫自己以更加系统和严谨的态度梳理问题，也希望对他人有所帮助。</p>
]]></content>
  </entry>
  <entry>
    <title>PLUMBER</title>
    <url>/2023/03/04/PLUMBER/</url>
    <content><![CDATA[<h1 id="PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem"><a href="#PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem" class="headerlink" title="PLUMBER: Boosting the Propagation of Vulnerability Fixes in the npm Ecosystem"></a>PLUMBER: Boosting the Propagation of Vulnerability Fixes in the <em>npm</em> Ecosystem</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><ul>
<li>npm是JavaScript编程语言中最大的生态系统，截至2022年1月，它拥有超过180万个第三方软件包。</li>
<li>2017年11月2日的npm快照进行的调查显示，在610,097个包中，其中21.9%直接依赖于易受攻击的包。如果考虑到传递性依赖关系，这种脆弱性对npm生态系统的脆弱性影响可能会显著增加。</li>
<li>我们对npm包的3948个漏洞报告的初步研究发现，在发现漏洞后，60.6%涉及的包及时发布了修复版本。</li>
<li>漏洞修复工具例如 <em>npm</em> audit [6] and Dependabot [7] 来提醒那些直接地或过渡性地依赖于脆弱的软件包版本的项目。</li>
<li>我们对传播漏洞修复的滞后的原因进行了两个观察：大多数包只修复了其最高主要版本中的漏洞，而没有将修复移植到早期的流行版本中。由于缺乏生态系统级依赖图的完整概图，包开发人员几乎没有意识到它们是阻止修复程序传播到其许多下游包的关键因素。</li>
</ul>
<h2 id="2-Motivation-Example"><a href="#2-Motivation-Example" class="headerlink" title="2.Motivation Example"></a>2.Motivation Example</h2><p><img src="/2023/03/04/PLUMBER/image-20230226104613081.png" alt="image-20230226104613081"></p>
<ul>
<li>我们将阻止修复在依赖路径上传播的包称为阻塞包。上图中browser-sync和graphql为阻塞包。</li>
<li>从阻塞包到脆弱包的依赖路径被称为阻塞链。 上图中 browser-sync-&gt;socket.io -&gt;engine.io为一条阻塞链</li>
</ul>
<h2 id="3-Introduction"><a href="#3-Introduction" class="headerlink" title="3.Introduction"></a>3.Introduction</h2><h3 id="3-1-相关工作"><a href="#3-1-相关工作" class="headerlink" title="3.1 相关工作"></a>3.1 相关工作</h3><p>(1)脆弱性对生态系统的影响[2、10、10-16]；</p>
<p>(2)减少报告易受攻击的依赖项[17–22]的误报；</p>
<p>(3)易受攻击的程序包更新中的滞后[1,23-28]</p>
<p>[1] 他们进行了一项实证调查，以确定在脆弱的包发布和固定发布之间可能出现的滞后。为了确保快速采用和传播包含修复程序的版本，他们为开发人员和研究人员提供了可操作的建议：开发者要有更好的意识，以便更快地规划依赖项更新。</p>
<p>然而，现有的工作都没有探索生态系统中阻塞包和阻塞链的特征。如何设计一种技术来加速漏洞的修复仍然是一项主要问题。</p>
<h3 id="3-2-目标和挑战"><a href="#3-2-目标和挑战" class="headerlink" title="3.2 目标和挑战"></a>3.2 目标和挑战</h3><p>为关键软件包提供可行的补救策略，促进脆弱性修复的传播。</p>
<ul>
<li>获取最新的漏洞元数据和npm依赖元数据。</li>
<li>了解阻塞链的演化特征及其对脆弱性修复传播的影响。</li>
</ul>
<h3 id="3-3-方法和结果"><a href="#3-3-方法和结果" class="headerlink" title="3.3 方法和结果"></a>3.3 方法和结果</h3><p><strong>Empirical Study:</strong></p>
<p>（RQ1）含有漏洞的包的规模及其对其他项目的影响；</p>
<p>（RQ2）在连续npm快照上的阻塞链的演化特征；</p>
<p>（RQ3）对传播漏洞修复有更好效果的补救策略。</p>
<p><strong>Technique:</strong></p>
<p>(1)对漏洞和npm依赖元数据进行建模，并逐步更新其演化过程；</p>
<p>(2)识别阻碍漏洞修复通过依赖路径传播的关键阻塞链；</p>
<p>(3)分析阻塞链上的软件包的特性，定制修复方案。</p>
<p><strong>Evaluation:</strong></p>
<p>我们应用PLUMBER为最具影响力的阻塞链生成了268份修复报告。47.4%的补救报告得到了积极的反馈。PLUMBER生成的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个活跃的npm项目中。</p>
<p><strong>Contributions:</strong></p>
<ul>
<li>我们进行了第一个实证研究，以描述软件包在生态系统中阻碍脆弱性修复的传播的情况。</li>
<li>我们开发了PLUMBER工具，通过纠正关键的阻塞链，来促进npm生态系统中脆弱性修复的传播。</li>
<li>一个大规模的漏洞修复传播实验。我们的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个根包中。</li>
</ul>
<h2 id="4-Empirical-Study"><a href="#4-Empirical-Study" class="headerlink" title="4.Empirical Study"></a>4.Empirical Study</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2023/03/04/PLUMBER/image-20230227101417121.png" alt="image-20230227101417121"></p>
<p>搜集漏洞元数据：<em>GitHub Advisory DB</em>, <em>Snyk Vul</em> <em>nerability DB</em> and <em>NPM Security Advisories</em>. </p>
<p>收集npm依赖项元数据：（V，E，C） V版本集合， E依赖边 （最新版本）<em>E</em> &#x3D; <em>{<strong>p</strong>i*@<em>va</em> <em>→</em> <em>pj</em>@<em>v*<em>b</em></em>|<strong>p</strong>i*@<em>v*<em>a</em></em>, pj</em>@<em>vb</em> <em>∈</em></p>
<p><em>V</em> <em>}</em>.   C  依赖关系 <em>c</em>(<em>pi</em>@<em>v*<em>a</em></em>, pj* ) <em>∈</em> <em>C</em></p>
<p>识别易受攻击的路径：通过将漏洞元数据映射到npm依赖元数据G &#x3D;（V，E，C），在集合V中，我们定位了所有带有详细漏洞信息的脆弱包版本。通过可达性分析来识别所有的脆弱路径。</p>
<p>VP模型统计： Table 2</p>
<p><img src="/2023/03/04/PLUMBER/image-20230227102441166.png" alt="image-20230227102441166"></p>
<h3 id="RQ1（阻塞包的规模）："><a href="#RQ1（阻塞包的规模）：" class="headerlink" title="RQ1（阻塞包的规模）："></a>RQ1（阻塞包的规模）：</h3><p>在npm生态系统中阻止漏洞修复传播的包的规模是多少？它们在多大程度上影响了其他项目？</p>
<p>在npm生态系统的356283个活跃根系项目中，有20.0%)中有320个仍然通过1065723个脆弱路径直接或过渡地依赖于这些脆弱包。平均而言，每个根项目都会受到4.4个±7.5漏洞的影响。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228090108772.png" alt="image-20230228090108772"></p>
<p>在npm生态系统的快照中，有45,148个阻塞包和358,422个阻塞链导致983,336个依赖路径的漏洞修复传播滞后。在有影响力的阻塞软件包和阻塞链上都有明显的中心地位。20%的阻塞软件包和阻塞链影响了绝大多数脆弱的路径。</p>
<h3 id="RQ2（阻塞链的进化）："><a href="#RQ2（阻塞链的进化）：" class="headerlink" title="RQ2（阻塞链的进化）："></a>RQ2（阻塞链的进化）：</h3><p>阻断链在npm生态系统中是如何进化的？它们在npm的生态系统中存在了多久了？</p>
<p>方法：每隔两个月爬取一次npm快照，(a)通过比较快照si（1 &lt; i≤7）与s1的统计数据，我们研究了s1中阻塞链、脆弱路径和受影响的根项目的规模，这些项目在一年的进化过程中进行了修复。(b)通过比较两个连续快照si−1和si的统计数据，我们统计了每两个月间隔内修复的阻塞链、脆弱路径和受影响的根项目的数量。此外，我们还关注了与si−1相比，si是否引入了新的案例。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228091129135.png" alt="image-20230228091129135"></p>
<p>在2020年8月1日的npm快照中，经过一年的进化，77.0%的阻断链仍然存在。在此期间，受这些阻塞链影响的脆弱路径和根项目的数量分别下降了37.1%和17.3%。9,904个活动根项目通过17,612条脆弱路径仍然引用了9,808个与更高级漏洞捆绑的阻塞链。</p>
<h3 id="RQ3（补救模式）："><a href="#RQ3（补救模式）：" class="headerlink" title="RQ3（补救模式）："></a>RQ3（补救模式）：</h3><p>阻塞链如何从脆弱路径中去除？是否可以提炼出常见的补救模式，以促进漏洞修复的传播？</p>
<p>我们实证研究了在快照s1-s7（在RQ2中收集）和提炼的常见修复模式中，包更新是如何通过包更新进行修复的。我们关注两种类型的阻塞链，它们通过包更新进行了修复，具有传播漏洞修复的显著效果：</p>
<p><strong>Type A</strong>。阻断链存在于快照s1-si−1（1&lt;i≤7）中，而在快照si中被修复。</p>
<p><strong>Type B</strong>。快照s1-s7中存在的阻塞链，而在进化过程中受其影响的脆弱路径的数量显著减少。</p>
<p><strong>Remediation pattern A.</strong>  阻塞包在其最高主要版本中发布了一个新版本，其中升级了直接依赖以过渡引入漏洞修复。通过最终将直接依赖项升级到安全版本，它们最终修复了其最高可用版本中的漏洞。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093517214.png" alt="image-20230228093517214"></p>
<p><strong>Remediation pattern B</strong> 中间包在其较低的主要版本中发布一个新版本，其中升级直接依赖，使非活动的阻塞包过渡地引入漏洞修复（100%的Type A阻塞链实例）。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093534796.png" alt="image-20230228093534796"></p>
<p><strong>Remediation pattern C</strong> </p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093801859.png" alt="image-20230228093801859"></p>
<p>这三种模式的<strong>补救成本</strong>标记如下：模式A&lt;模式B&lt;模式C</p>
<p>我们提炼了三种常见的修复模式及其传播漏洞修复的先决条件。对于由主动阻塞包引起的阻塞链，这种阻塞包可以纠正其最高可用版本（模式A）中的漏洞。对于由非活动阻塞包引起的阻塞链，中间包可以纠正其较低主要版本序列中的漏洞，使非活动阻塞包能够过渡地引入漏洞修复（模式B）。此外，受阻塞链影响的包也可以不弃用不活动的阻塞包，并迁移到其他维护良好的包，以修复漏洞（模式C）。</p>
<h2 id="5、Approach"><a href="#5、Approach" class="headerlink" title="5、Approach"></a>5、Approach</h2><p><img src="/2023/03/04/PLUMBER/image-20230301174303414.png" alt="image-20230301174303414"></p>
<p>和DTResolver有区别的点：</p>
<p>识别阻塞链：对于每个脆弱路径，PLUMBER从脆弱包pu开始，迭代计算每个包的安全版本µt，直到阻塞包的安全版本为空。最后，PLUMBER根据通过它们的脆弱路径的数量对识别出的阻塞链进行排序。排名最高的阻塞链被认为是关键的阻塞链，应该进行修复，以使漏洞修复能够传播到大量的包中。</p>
<p>我们的实证研究结果表明，三种策略的补救成本通常遵循：策略A&lt;策略B&lt;策略 C. 因此，对于由积极维护的软件包引起的阻塞链，水管工高度建议了补救策略 A. 对于由非活动阻塞包引起的阻塞链，在中间包（即阻塞包和脆弱包之间的包）被开放版本约束指定的情况下，水管工建议补救策略B，如果它们可以返回到较低版本的序列。否则，水管工将采用补救策略C来迁移非活性的阻塞链。</p>
<h2 id="6、Evaluation"><a href="#6、Evaluation" class="headerlink" title="6、Evaluation"></a>6、Evaluation</h2><h3 id="RQ4（PLUMBER的有效性）："><a href="#RQ4（PLUMBER的有效性）：" class="headerlink" title="RQ4（PLUMBER的有效性）："></a>RQ4（PLUMBER的有效性）：</h3><p>水管工制定的补救策略与开发人员是否一致？</p>
<p>方法：选择开发人员已经修复的一些包作为基准，将我们的修复方案和开发人员的修复方案进行比较。</p>
<p>结果：由水管工提出的362种补救策略中，有289种（79.8%）与我们的基准策略一致。对于73种不一致的补救策略，我们的工具通过平衡漏洞修复的补救成本和传播效果来生成建议。</p>
<h3 id="RQ5（补救挑战）："><a href="#RQ5（补救挑战）：" class="headerlink" title="RQ5（补救挑战）："></a>RQ5（补救挑战）：</h3><p>补救npm生态系统中的阻塞链有多具有挑战性？</p>
<p>方法：为了回答RQ5，对于在最近2021年8月1日的npm快照上确定的358,422条阻塞链，我们将它们分为不同的修复难度级别。此外，我们还观察了它们的分布情况，并讨论了补救方面的挑战。</p>
<p>结果：对于影响npm生态系统中大多数脆弱路径的前20%的关键阻断链，其中46.1%的关键阻断链难以修复。它们要么需要迁移非活动的阻塞包，要么需要升级其依赖项的主要版本，以引入漏洞修复，这需要更多的代码更改和测试工作。37.0%的顶级关键阻塞链可以通过所涉及的中间包的反向移植实践进行修复。只有16.9%的顶级关键阻塞链可以通过将主动阻塞包的依赖关系升级到安全的版本来轻松修复。</p>
<h3 id="RQ6（LUMBER的有用性）："><a href="#RQ6（LUMBER的有用性）：" class="headerlink" title="RQ6（LUMBER的有用性）："></a>RQ6（LUMBER的有用性）：</h3><p>水管工能否促进npm生态系统中脆弱性修复程序的传播，并为开发人员提供有用的补救策略？</p>
<p>方法：向开发人员提出Bug  report，挑选了前300个关键的阻塞软件包，并人工验证受影响的下游项目是否可以引入相关的漏洞修复程序</p>
<p>结果：47.4%的补救报告收到了来自许多著名的npm项目的积极反馈。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h2><p>出发点不同，DTResolver是根据root package构造依赖树，并检测依赖树中的漏洞和一些修复策略。 PLUMBER更注重npm生态系统的平衡，检测npm生态系统的Block Chain，并对包开发人员提出修复建议。</p>
<p>和DTResolver一样，都对npm漏洞的影响进行了研究，DTResolver注重于npm3正确依赖树的构造，Plumber更注重实证研究和漏洞的修复。</p>
<p>DTResolver的DTReme的修复有点突兀，没有前因后果，Plumber的修复是基于他的实证研究的结果，根据开发人员的建议制定的策略。</p>
<p>论文的组织模式和Watchman, Nufix很像，都是先实证研究，将问题进行分类，探索开发人员的修复策略； 再根据我们的工具进行分类检测，并提出修复策略，最后让开发人员确认。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</title>
    <url>/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<h1 id="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"><a href="#通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱" class="headerlink" title="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"></a>通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><p><code>本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。</code></p>
<p><a href="https://www.secrss.com/articles/43424">https://www.secrss.com/articles/43424</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/594160921">https://zhuanlan.zhihu.com/p/594160921</a></p>
<p><a href="https://sites.google.com/view/npm-vulnerability-study/">https://sites.google.com/view/npm-vulnerability-study/</a></p>
<p><a href="https://www.youtube.com/watch?v=CErMF3CgSc8">https://www.youtube.com/watch?v=CErMF3CgSc8</a></p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>NPM上发布了170多万个Node.js库，以促进软件开发。正如对比安全所揭示的，第三方库出现在当今软件的大多数（79%）中。然而，任何事物都有两面性。虽然使用库可以减少开发成本和时间，但这些集成库在实践中对软件生态系统构成了新的安全威胁，这些库中的漏洞可能会使依赖它们的软件不断面临安全风险。之前的工作已经调查了整个NPM生态系统的脆弱性影响，而他们的方法要么只是静态地考虑直接依赖性，或者基于依赖关系进行间接依赖的可达性分析，这可能会引入不准确的传递依赖关系，从而导致误报漏洞警告。现存的研究方法还没有提供一个精确的依赖关系。尤其是软件依赖关系之间的内部复杂关系，在很大程度上削弱了其分析的影响，并限制了进一步的解决方案（即精确修复）的提出。尽管一些现有的SCA工具（如Snyk和Blackduck）支持对用户项目进行NPM依赖性分析，但大多数工具都是从实际安装中检索依赖树，而不是从静态推理中检索依赖树。此外，由于语义版本控制的灵活性，依赖关系以及依赖关系中的漏洞实际上会随着时间的推移而发生动态变化。因此，尽管现有工作也调查了漏洞的影响，在没有静态和精确的依赖关系解决方案的情况下，大规模分析依赖关系中存在的漏洞传播的演变仍然是一个挑战，更不用说在防止漏洞动态引入依赖项方面获得实用的解决方案。</p>
<h2 id="2-论文主要成果"><a href="#2-论文主要成果" class="headerlink" title="2. 论文主要成果"></a>2. 论文主要成果</h2><ul>
<li>实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包（超过114万个库和1094万个版本）之间的依赖关系，以及来自NVD的800多个已知CVE（常见漏洞和暴露），进一步的支持对漏洞传播的分析</li>
<li>提出了一种基于DVGraph的新算法（DTResolver），可以静态、精确地解析任意安装时间的依赖树，精度高达90%以上，并通过大约100k个代表性软件包进行了验证</li>
<li>进一步对依赖树中的脆弱性传播进行了实证研究。首先，我们研究了NPM依赖解析带来的依赖树的特征，在此基础上，我们分析了依赖树中漏洞传播的影响和特征，特别是传递依赖的漏洞。此外，我们还将研究扩展到时间维度，以研究依赖树中漏洞传播随时间的演变，揭示依赖树中引入漏洞的原因，以及可能的解决方案</li>
</ul>
<h2 id="3-实验架构"><a href="#3-实验架构" class="headerlink" title="3. 实验架构"></a>3. 实验架构</h2><p>包括依赖漏洞知识图构建、依赖树解析、漏洞路径识别及其验证、大规模实证研究以及对经验教训和解决方案的讨论，以及可能的研究方向</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1ed5572cf3d56e315f7e865590c7f9ac.png" alt="img"></p>
<h2 id="4-DVGraph的构建"><a href="#4-DVGraph的构建" class="headerlink" title="4. DVGraph的构建"></a>4. DVGraph的构建</h2><p>为了支持高精度和高效率的大规模依赖漏洞分析，我们设计并实现了一套数据处理平台，以构建和维护完整而精确的依赖漏洞图DVGraph（基于neo4j）。</p>
<p>下图为改数据处理平台的框架：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/5d6447824371e7607b366407f7aad9fa.png" alt="img"></p>
<p><strong>Metadata Pipeline：</strong>将数据保存在元数据库中</p>
<p><strong>CVE Pipeline：</strong>从NVD数据集收集CVE数据</p>
<p><strong>CVE Triage Pipeline：</strong>手工标记CVE数据的对应的受影响的库和版本</p>
<p><strong>Graph Pipeline：</strong>解析新来的元数据和映射的CVE数据，计算要在DVGraph上执行的操作（即添加、更改和删除节点和边），并最终执行这些操作</p>
<h2 id="5-依赖树解析和脆弱路径识别"><a href="#5-依赖树解析和脆弱路径识别" class="headerlink" title="5. 依赖树解析和脆弱路径识别"></a>5. 依赖树解析和脆弱路径识别</h2><h3 id="5-1-依赖树解析"><a href="#5-1-依赖树解析" class="headerlink" title="5.1 依赖树解析"></a>5.1 依赖树解析</h3><p>目前还没有一个考虑到特定于平台的依赖关系解决规则，可能导致不准确的依赖关系解析。本文目标是实现静态解析与NPM在实际安装过程中动态解析和安装的依赖树一致的依赖树，以便我们能够准确有效地识别依赖树中的漏洞和脆弱路径，而无需实际安装。</p>
<p>为了提高精度，同时保持效率，我们提出了一种基于DVGraph的依赖解析算法（DTResolver），可以在不安装的情况下，对任意数据软件包依赖解析的过程中，识别并找出所有依赖中含有安全漏洞的组件及相应的依赖引入路径</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/0fffc83b26b8297bd142c0061a005fb8.png" alt="img"></p>
<p>Dependency Tree Resolution</p>
<p>此外由于NPM中广泛使用依赖约束条件（版本范围）而不是固定版本进行依赖定义，导致依赖安装结果随着时间可能发生变化</p>
<p>如下图中，在<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#46;&#49;">&#66;&#64;&#49;&#46;&#x30;&#46;&#49;</a>发布后，<a href="mailto:&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>的安装过程中，对B的依赖将解析成新发布的版本而不是原有的<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>, 图中<a href="mailto:&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;">&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;</a>的发布亦是如此。因此我们在DTResolver的基础上进一步增加了时间约束，使其能够支持在给定项目从其发布前到DVGraph更新时间内任意时刻的依赖树模拟解析。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/cb04b86c4aafea8676a467c495666079.jpg" alt="img"></p>
<h3 id="5-2-脆弱路径识别"><a href="#5-2-脆弱路径识别" class="headerlink" title="5.2 脆弱路径识别"></a>5.2 脆弱路径识别</h3><p>给出了脆弱点和路径的示例 通过反向深度优先搜索（DFS）实现了一个脆弱路径提取器，以彻底查找依赖树中从脆弱点到根节点的依赖关系</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/aed9b3b573cfcee4c57b966475f78199.png" alt="img"></p>
<h3 id="5-3-评估验证"><a href="#5-3-评估验证" class="headerlink" title="5.3 评估验证"></a>5.3 评估验证</h3><p>通过比较DTResolver解析的依赖树与实际安装的依赖树来验DTResolver。此外，我们将npm-remote-ls作为比较时的方法，这是一种广泛使用的公共API，在实践中无需实际安装即可获得依赖树，并且它完全遵循依赖范围来派生依赖树。</p>
<p>数据选择我们的验证基于两个标准收集的数据：（1）流行度，对于每个流行度指标（即过去、过去3年和去年下载量最多的明星、分叉、下载量多），我们分别选择了前2000个库。（2）中心性，对于每个中心性度量（即最大出入度），我们还选择了前2000个库和前20K个版本。分别地对于库，我们采用每个次要版本的最高补丁版本。最后，整理了15673个库中的103609个版本。</p>
<p><strong>DTResolver解析器的评估。</strong>根据结果，90.58%的图树在忽略无法计算的情况（例如，具有捆绑的依赖项并且包含没有时间的依赖项）后与安装树完全匹配。而只有53.33%的远程树与安装树完全匹配，这是因为npm远程ls错过了一些官方的解决规则（例如，未弃用版本的优先级选择）。此外，我们进一步确定了不匹配依赖树的两个主要原因：1）在npm ls的输出中消除了依赖，这省略了一些包和依赖关系以简化树视图。2） 由于环境问题，依赖项可能无法完全安装（例如，当缺少所需的操作系统支持时，某些程序包可能无法安装）。此外，缺少库版本（即不在NPM注册表中或爬网失败）也会导致依赖关系树中缺少一些包。</p>
<p><strong>漏洞检测和漏洞路径识别评估。</strong>除了DTResolver的评估，我们还扩展到比较检测到的漏洞和易受攻击的路径。由于从实际安装中检索到的安装树可能不完整（例如，依赖关系中的某些包由于环境问题而未安装），我们通过调用Graph Tree和Remote Tree中已识别的漏洞和漏洞路径来评估漏洞检测的准确性。我们发现DTResolver（98.1%）和npm远程ls（97.7%）在检测易受攻击组件方面具有相似的高覆盖率，但在识别易受攻击路径方面存在差异（92.60%对78.31%）。这可能是因为大多数依赖性约束都被解析为最满意的版本，并且依赖性范围也遵循这一规则，因此，仍然可以识别最脆弱的包。然而，通过依赖关系到达解决依赖关系忽略了NPM特定的解决规则，这会影响识别依赖关系路径的准确性。</p>
<h2 id="6-大规模实证研究"><a href="#6-大规模实证研究" class="headerlink" title="6. 大规模实证研究"></a>6. 大规模实证研究</h2><p>以下两个方面分析NPM中安全漏洞的影响：</p>
<ul>
<li>漏洞如何影响NPM生态系统？漏洞如何通过依赖关系树传播影响根包(root packages)？</li>
<li>漏洞传播如何在依赖树中发展？依赖关系树的变化如何影响漏洞传播的演变？</li>
</ul>
<h3 id="6-1-通过依赖树传播漏洞"><a href="#6-1-通过依赖树传播漏洞" class="headerlink" title="6.1 通过依赖树传播漏洞"></a>6.1 通过依赖树传播漏洞</h3><ul>
<li>据统计证明，漏洞广泛存在于NPM包的依赖关系中（整个生态系统中有19.96%的库的四分之一版本）</li>
<li>第三方库的最新版本（16.17%）仍然存在通过依赖关系受到漏洞影响的潜在风险。</li>
<li>其他用户使用的易受攻击的库中，有相当一部分（超过100个）仍然有易受攻击的最新版本</li>
<li>一些有影响力的已知CVE广泛存在于大部分包的依赖树中</li>
<li>包通常受到多个漏洞的影响，每个漏洞通过多个漏洞路径影响根包（平均一个漏洞引入8个漏洞路径）</li>
<li>漏洞仍然广泛存在于受影响库版本的直接依赖关系中（超过30%），即使是最新版本</li>
<li>在易受攻击的路径上也存在中心性，即大多数易受攻击的路径都会通过有限的直接依赖关系，这可以用来切断易受攻击的路径</li>
</ul>
<h3 id="6-2-依赖树中的漏洞传播演化"><a href="#6-2-依赖树中的漏洞传播演化" class="headerlink" title="6.2 依赖树中的漏洞传播演化"></a>6.2 依赖树中的漏洞传播演化</h3><ul>
<li>随着时间的推移，已知的漏洞正在对NPM生态系统造成更大的影响。它们不仅影响到更多的库版本，而且还影响到依赖树中更脆弱的点</li>
<li>大多数CVE（93%）在被发现之前已经被引入依赖树，这些CVE的固定版本（87%）也大多在CVE发布之前发布</li>
<li>依赖树中只有60%的CVE被DTC自动删除，即使如此，每个CVE删除仍需要一年以上的时间</li>
<li>过时的维护（提供者）和不合适的依赖约束（使用者）是阻碍依赖树中漏洞自动移除的主要原因。应该采取更多的对策和解决方案来避免、监控甚至纠正这些不良做法</li>
</ul>
<p>DTReme</p>
<p>添加了1)<strong>前向漏洞检查</strong>，在解析新的依赖关系的版本时（算法1中的第13行和第17行），只解析每个依赖关系的干净版本；2)<strong>向后安装的包跟踪</strong>，一旦没有干净版本可以解决，回滚到父节点的解析，并找到替代版本，以避免没有干净版本的情况。因此，我们可以彻底遍历所有可能的解决方案，找到可能的干净依赖树，并且可以为整个依赖树生成一个新的package-lock.json文件作为修复解决方案。</p>
<h2 id="7、有限性"><a href="#7、有限性" class="headerlink" title="7、有限性"></a>7、有限性</h2><p>首先，依赖关系中的漏洞可能永远不会影响根包，因为可能永远无法访问这些易受攻击的功能。这只能通过基于依赖树和调用图分析易受攻击的函数调用路径来进一步解决。我们将此作为我们未来的工作。其次，CVE和库版本的映射是手动标记的，这可能会导致数据错误标记，合作的作者已将数据与现有CVE交叉验证，以缓解此类威胁。第三，我们无法区分包含缺失依赖项的安装，这可能会使基本事实不准确，我们只接受依赖项中成功安装的包作为验证中的基本事实。第四，由于计算成本过高，在分析漏洞传播时，我们忽略了具有超过1k条漏洞路径的版本。总的来说，这样的版本只占2.01%，这只能对我们的结果造成有限的偏差。</p>
<h2 id="附录1-Npm依赖解析规则"><a href="#附录1-Npm依赖解析规则" class="headerlink" title="附录1 Npm依赖解析规则"></a>附录1 Npm依赖解析规则</h2><p><a href="https://docs.npmjs.com/cli/v9/commands/npm-install">https://docs.npmjs.com/cli/v9/commands/npm-install</a></p>
<p><a href="https://www.cnblogs.com/penghuwan/p/6970543.html">【npm】详解npm的模块安装机制 - 外婆的 - 博客园 (cnblogs.com)</a></p>
<p><font color="red"><strong>依赖树表面的逻辑结构与依赖树真实的物理结构</strong> </font></p>
<p>这里要先提到两个命令：tree -d（linux）和npm ls（npm）</p>
<p>在一个npm项目下：</p>
<p><strong>tree -d命令</strong>以树状图的方式列出一个项目下所有依赖的物理结构</p>
<p><strong>npm ls命令</strong>以树状图的方式列出一个项目下所有依赖的逻辑结构</p>
<p>以官方文档为例子：</p>
<p>项目example1有两个依赖模块：mod-a模块和mod-c模块；</p>
<p>mod-a模块有一个依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;">&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;</a>模块</p>
<p>mod-c模块有一个依赖模块<a href="mailto:&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;</a>模块</p>
<p>tree -d 和npm ls运行结果如下：（注意npm版本为npm3而非npm2）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092200262-641835535.png" alt="img"></p>
<p>先看看下面那个红框的结果，这应该是“最符合我们理解”的依赖树，首先项目下形成了一级依赖——mod-a模块和mod-b模块，然后以这两个模块为父模块再追加二级依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a>和<a href="mailto:mod-b@2.0.0">mod-b@2.0.0</a></p>
<p>但是！这却并不是物理上真实形成的依赖树的模样，物理上真实形成的依赖树是上面的那个红色框。<strong>mod-a,mod-c和mod-b竟然同为同一级</strong>的依赖。</p>
<p>你可能会问，为什么会形成这样的依赖树呢？下面我就来解释一番</p>
<p>【注意】：下面的图示全部为依赖树的物理结构，而不是逻辑结构</p>
<p><font color="red"><strong>关于npm模块安装机制的一点猜想</strong></font></p>
<p>安装模块时，可能的方式有两种：<strong>平级式</strong>的安装或<strong>嵌套式</strong>的安装（此处仅仅是猜想和假设）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092352262-1548398831.png" alt="img"></p>
<p>能不能完全采取平级的安装方式呢？——不能</p>
<p>我们取和上面相似的一个例子：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块Cv2.0。显然，它们并不能同时存在于同一个node_modules下，当安装的时候，由于npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092426950-802407609.png" alt="img"></p>
<p>但如果我们仅仅只安装一个版本的C依赖模块，将可能会导致A模块和B模块不兼容</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092458231-782438150.png" alt="img"></p>
<p><strong>基于以上原因，npm2选择了嵌套的安装方式——</strong></p>
<p><font color="red"><strong>npm2下的模块安装机制</strong></font></p>
<p>npm2安装多级的依赖模块采用嵌套的安装方式：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092546575-1188239142.png" alt="img"></p>
<p><strong>优点和弊端</strong></p>
<p><strong>优点：</strong>解决了版本单一时存在的存在的不兼容问题，实现多版本兼容</p>
<p><strong>弊端：</strong>可能造成相同模块大量冗余的问题，如下：</p>
<p>以上面例子为例，下面这种情况也是合理存在的：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092618981-1003798029.png" alt="img"></p>
<p>凭感觉也知道，这绝不是什么好现象，那我们如何能在实现依赖间多版本兼容的前提下，减少这种模块冗余呢？于是npm3做了一下改进</p>
<p><font color="red"><strong>npm3下的模块安装机制：</strong></font></p>
<p>npm3和npm2的不同主要体现在二级模块的安装上：</p>
<p>npm3会**”尽量”<strong>把逻辑上某个层级的模块在物理结构上</strong>“全部”**放在项目的第一层级里，具体我概括为以下三种情况：</p>
<p>1.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>还没有相同名称的模块</strong>，便<strong>把这第二层级的模块放在第一层级</strong></p>
<p>2.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，相同版本的模块</strong>，便<strong>直接复用那个模块</strong></p>
<p>3.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，但版本不同的模块</strong>，便<strong>只能嵌套在自身的父模块下方</strong></p>
<p>这一开始可能有些难理解，所以让我们看图说话吧！</p>
<p><strong>先说1：在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</strong></p>
<p>我们先简化一下上面的例子：现在项目APP下只有一个一级依赖模块A，它下面有一个二级依赖模块C，但npm install的时候，项目下安装依赖的</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092737903-1235721353.png" alt="img"></p>
<p>npm3中的二级模块（C v1.0),在项目的一级目录（node_modules）下没有相同名称的模块时，会被安装到一级目录下，从而跟它的父模块A同级。<strong>这就是本文一开始中依赖树的逻辑结构和物理结构不同的起因</strong>。</p>
<p>也就是说：</p>
<p><strong>在npm2中，依赖树的逻辑结构和它的物理结构相同</strong></p>
<p><strong>在npm3中，依赖树的逻辑结构和它的物理结构可能不同</strong></p>
<p><strong>再说2:在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</strong></p>
<p>在1的基础上，我们把1的例子还原回之前的复杂一些的场景：：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块C v1.0（两个C模块版本相同）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092859168-1795479456.png" alt="img"></p>
<p>对npm2,两个C包是相同的，造成模块冗余</p>
<p>在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块</p>
<p><strong>npm3就是用这种方式，部分地解决了npm2的痛点（部分）</strong></p>
<p>【从1，2到3的过渡】我在这一小节的开始说：“npm3会”尽量”把逻辑上某个层级的模块”全部”放在项目的第一层级里”，我想你看完1，2后应该多少有些理解了**<em>“尽量”*<strong>的含义了，但我说了</strong></em>“尽量”***，同时也就意味着npm3存在着不能把二级依赖放在第一层级的情况。对此，请看3:</p>
<p><strong>最后说3:在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方</strong></p>
<p>在2中，A，B所依赖的两个C模块是相同的，<strong>但如果两个C模块的版本不同呢？</strong>，项目npm install情况如下：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093023575-1842293712.png" alt="img"></p>
<p>在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块</p>
<p><strong>（看到这里我想应该能解答你对文章开头那个例子的疑惑了吧，这个例子和那个例子是几乎完全一样的哦）</strong></p>
<p>看到这里，你对npm2和npm3下的模块工作机制，以及npm3针对npm2的优化有个大体的了解了吧，但请思考一个问题：n<strong>pm3是否已经把npm2的模块冗余的缺陷优化到极致了呢？</strong> ———答案是<strong>没有</strong>，请往下看：</p>
<p>实际上：<strong>npm3中仍然可能出现模块冗余的情况</strong>，因为一级目录下已经有v1.0的C模块了，<strong>所以所有的v2.0只能作为二级依赖模块被安装</strong>，这样你就会看到如下的情况</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093147262-345050329.png" alt="img"></p>
<p>并且在上图所示的这种特殊情况里，npm3和npm2表现得似乎并没什么区别</p>
<p>【过渡】那么这有没有什么解决的方式呢？当然是有的，当A模块下的C v1.0模块被更新至C v2.0的前提下，我们可以<strong>通过npm dedupe把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0</strong></p>
<p><font color="red"><strong>利用npm dedupe去除冗余模块</strong></font></p>
<p><strong>npm dedupe做了什么？****它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块</strong></p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093125700-1173491575.png" alt="img"></p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>01-编译Cpython</title>
    <url>/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/</url>
    <content><![CDATA[<h1 id="01-编译CPython"><a href="#01-编译CPython" class="headerlink" title="01-编译CPython"></a>01-编译CPython</h1><h3 id="CPython的目录结构"><a href="#CPython的目录结构" class="headerlink" title="CPython的目录结构"></a>CPython的目录结构</h3><p>源码中文件夹的大致含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpython/</span><br><span class="line">│</span><br><span class="line">├── Doc      ← Source for the documentation</span><br><span class="line">├── Grammar  ← The computer-readable language definition</span><br><span class="line">├── Include  ← The C header files</span><br><span class="line">├── Lib      ← Standard library modules written in Python</span><br><span class="line">├── Mac      ← macOS support files</span><br><span class="line">├── Misc     ← Miscellaneous files</span><br><span class="line">├── Modules  ← Standard Library Modules written in C</span><br><span class="line">├── Objects  ← Core types and the object model</span><br><span class="line">├── Parser   ← The Python parser source code</span><br><span class="line">├── PC       ← Windows build support files</span><br><span class="line">├── PCbuild  ← Windows build support files for older Windows versions</span><br><span class="line">├── Programs ← Source code for the python executable and other binaries</span><br><span class="line">├── Python   ← The CPython interpreter source code</span><br><span class="line">└── Tools    ← Standalone tools useful for building or extending Python</span><br></pre></td></tr></table></figure>

<ul>
<li>Grammar记录了关于python的语法定义，如tokens,grammar，CPython有专门的代码读取这些文件，再生成词法解析和语法解析的代码。</li>
<li>Objects目录里有Python的核心内置类型，与python的对象模型息息相关</li>
<li>Parser里包含了Python语言的前端，即词法解析，语法解析</li>
<li>Programs包含了Python可执行文件的入口和相关实现</li>
<li>Python目录包含了Python解释器的实现</li>
</ul>
<h3 id="编译CPython"><a href="#编译CPython" class="headerlink" title="编译CPython"></a>编译CPython</h3><p>首先在CPython的目录下运行configure脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure CFLAGS=&quot;-g -O0&quot;</span><br></pre></td></tr></table></figure>

<p>继续make指令编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>编译成功后会有一个Python可执行文件。</p>
<h3 id="CPython2-GEF插件让GDB更好用"><a href="#CPython2-GEF插件让GDB更好用" class="headerlink" title="CPython2-GEF插件让GDB更好用"></a>CPython2-GEF插件让GDB更好用</h3><p>gdb .&#x2F;python调试python,想看源码用list指令就可以了，想要看反汇编用disassemble命令就可以了，但是它的风格是AT&amp;T风格的，想要看内存用x，想要看寄存器用info命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -tui ./python</span><br></pre></td></tr></table></figure>

<p>GEF <a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(curl -fsSL https://gef.blah.cat/sh)&quot;</span><br></pre></td></tr></table></figure>

<p>可以使用hexdump命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexdump byte &amp;argc</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/image-20230329102126435.png" alt="image-20230329102126435"></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>02-一切对象皆PyObject</title>
    <url>/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/</url>
    <content><![CDATA[<h2 id="02-一切皆对象PyObject"><a href="#02-一切皆对象PyObject" class="headerlink" title="02-一切皆对象PyObject"></a>02-一切皆对象PyObject</h2><h3 id="一切皆对象PyObject"><a href="#一切皆对象PyObject" class="headerlink" title="一切皆对象PyObject"></a>一切皆对象PyObject</h3><p>Python中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230308194406865.png" alt="image-20230308194406865"></p>
<p>Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自object。因此，object是所有类型对象的”基类”、或者说”父类”。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144138069.png" alt="image-20230310144138069"></p>
<p><strong>我们说可以使用type和__class__查看一个对象的类型，并且还可以通过isinstance来判断该对象是不是某个已知类型的实例对象；那如果想查看一个类型对象都继承了哪些类该怎么做呢？我们目前都是使用issubclass来判断某个类型对象是不是另一个已知类型对象的子类，那么可不可以直接获取某个类型对象都继承了哪些类呢？</strong></p>
<p><strong>答案是可以的，方法有三种，我们分别来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先D继承自B和C, C又继承A, 我们现在要来查看D继承的父类</span></span><br><span class="line"><span class="comment"># 方法一: 使用__base__</span></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 使用__bases__</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三: 使用__mro__</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__base__: 如果继承了多个类, 那么只显示继承的第一个类, 没有显示继承则返回一个&lt;class &#39;object&#39;&gt;;</code></li>
<li><code>__bases__: 返回一个元组, 会显示所有直接继承的父类, 如果没有显示的继承, 则返回(&lt;class &#39;object&#39;&gt;,);</code></li>
<li><code>__mro__: mro表示Method Resolution Order, 表示方法查找顺序, 会从自身除法, 找到最顶层的父类, 因此返回自身、继承的基类、以及基类继承的基类, 一直找到object;</code></li>
</ul>
<p>最后我们来看一下type和object，估计这两个老铁之间的关系会让很多人感到困惑。</p>
<p>我们说type是所有类的元类，而object是所有的基类，这就说明type是要继承自object的，而object的类型是type。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144509108.png" alt="image-20230310144509108"></p>
<p>这就怪了，这难道不是一个先有鸡还是先有蛋的问题吗？其实不是的，这两个对象是共存的，它们之间的定义其实是互相依赖的。至于到底是怎么肥事，我们后面在看解释器源码的时候就会很清晰了。</p>
<p><strong>总之目前记住两点：</strong></p>
<ul>
<li><code>1. type站在类型金字塔的最顶端, 任何的对象按照类型追根溯源, 最终得到的都是type;</code></li>
<li><code>2. object站在继承金字塔的最顶端, 任何的类型对象按照继承追根溯源, 最终得到的都是object;</code></li>
</ul>
<p>我们说type的类型还是type，但是object的基类则不再是object，而是一个None。为什么呢？其实答案很简单，我们说Python在查找属性或方法的时候，会回溯继承链，自身如果没有的话，就会按照__mro__指定的顺序去基类中查找。所以继承链一定会有一个终点，否则就会像没有出口的递归一样出现死循环了。</p>
<p>最后将上面那张关系图再完善一下的话：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144643701.png" alt="image-20230310144643701"></p>
<h3 id="实现对象机制的基石-PyOBject"><a href="#实现对象机制的基石-PyOBject" class="headerlink" title="实现对象机制的基石-PyOBject"></a>实现对象机制的基石-PyOBject</h3><p><strong>根据对象的不同特点还可以进一步分类：</strong></p>
<ul>
<li><code>可变对象：对象创建之后可以本地修改;</code></li>
<li><code>不可变对象：对象创建之后不可以本地修改;</code></li>
<li><code>定长对象：对象所占用的内存大小固定;</code></li>
<li><code>不定长对象：对象所占用的内存大小不固定;</code></li>
</ul>
<p>但是”对象”在Python的底层是如何实现的呢？我们知道标准的Python解释器是C语言实现的CPython，但C并不是一个面向对象的语言，那么它是如何实现Python中的面向对象的呢？</p>
<p>首先对于人的思维来说，对象是一个比较形象的概念，但对于计算机来说，对象却是一个抽象的概念。它并不能理解这是一个整数，那是一个字符串，计算机所知道的一切都是字节。通常的说法是：对象是数据以及基于这些数据的操作的集合。在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的。</p>
<p><strong>而Python中的任何对象在C中都对应一个结构体实例，在Python中创建一个对象，等价于在C中创建一个结构体实例。所以Python中的对象本质上就是C中malloc函数为结构体实例在堆区申请的一块内存。</strong></p>
<p>Python中一切皆对象，而所有的对象都拥有一些共同的信息(也叫头部信息)，这些信息就在PyObject中，PyObject是Python整个对象机制的核心，我们来看看它的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>PyObject_HEAD_EXTRA</strong></font>    </p>
<p>PyObject_HEAD_EXTRA 定义了两个双向链表，用于指向堆上创建的活着的对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_next;           \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_prev;</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>Ob_refcnt</strong></font></p>
<p>ob_refcnt定义了引用计数器</p>
<p>当一个对象被引用时，那么ob_refcnt会自增1；引用解除时，ob_refcnt自减1。而一旦对象的引用计数为0时，那么这个对象就会被回收。</p>
<p>那么在哪些情况下，引用计数会加1呢？哪些情况下，引用计数会减1呢？</p>
<p><strong>导致引用计数加1的情况：</strong></p>
<ul>
<li><code>对象被创建：比如name = &quot;古明地觉&quot;, 此时对象就是&quot;古明地觉&quot;这个字符串, 创建成功时它的引用计数为1</code></li>
<li><code>变量传递使得对象被新的变量引用：比如Name = name</code></li>
<li><code>引用该对象的某个变量作为参数传到一个函数或者类中：比如func(name)</code></li>
<li><code>引用该对象的某个变量作为元组、列表、集合等容器的一个元素：比如lst = [name]</code></li>
</ul>
<p><strong>导致引用计数减1的情况：</strong></p>
<ul>
<li><code>引用该对象的变量被显示的销毁：del name</code></li>
<li><code>对象的引用指向了别的对象：name = &quot;椎名真白&quot;</code></li>
<li><code>引用该对象的变量离开了它的作用域，比如函数的局部变量在函数执行完毕的时候会被销毁</code></li>
<li><code>引用该对象的变量所在的容器被销毁，或者被从容器里面删除</code></li>
</ul>
<p>所以我们使用del删除一个对象，并不是删除这个对象，我们没有这个权力，del只是使对象的引用计数减一，至于到底删不删是解释器判断对象引用计数是否为0决定的。为0就删，不为0就不删，就这么简单。</p>
<p>而ob_refcnt的类型是<strong>Py_ssize_t</strong>，在64位机器上直接把这个类型看成long即可<code>(话说这都2020年了，不会还有人用32位机器吧)</code>，因此一个对象的引用计数不能超过long所表示的最大范围。但是显然，如果不是吃饱了撑的写恶意代码，是不可能超过这个范围的。</p>
<p><font color="red"><strong>ob_type：类型指针</strong></font></p>
<p>我们说一个对象是有类型的，类型对象描述实例对象的数据和行为，而ob_type存储的便是对应类型对象的指针，所以类型对象在底层对应的是struct  _typeobject实例。从这里我们可以看出，所有的类型对象在底层都是由同一个结构体实例化得到的，因为PyObject是所有的对象共有的，它们的ob_type指向的都是struct _typeobject。</p>
<blockquote>
<p><strong>所以不同的实例对象对应不同的结构体，但是类型对象对应的都是同一个结构体。</strong></p>
</blockquote>
<p>因此我们看到PyObject的定义非常简单，就是一个引用计数和一个类型指针，所以Python中的任意对象都必有：引用计数和类型这两个属性。</p>
<h3 id="实现变长对象的基石–PyVarObject"><a href="#实现变长对象的基石–PyVarObject" class="headerlink" title="实现变长对象的基石–PyVarObject"></a>实现变长对象的基石–PyVarObject</h3><p>我们说PyObject是所有对象的核心，它包含了所有对象都共有的信息，但是还有那么一个属性虽然不是每个对象都有，但至少有一大半的对象会有，能猜到是什么吗？</p>
<p>我们说Python中的对象根据所占的内存是否固定可以分为定长对象和变长对象，而变长对象显然有一个长度的概念，比如字符串、列表、元组等等，即便是相同的实例对象，但是长度不同，所占的内存也是不同的。比如：字符串内部有多少个字符、元组、列表内部有多少个元素，显然这里的多少*也是Python中很多对象的共有特征，虽然不像引用计数和类型那样是每个对象都必有的，但也是相当大一部分对象所具有的。</p>
<p><strong>所以针对变长对象，Python底层也提供了一个结构体，因为Python很多都是变长对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>所以我们看到PyVarObject实际上是PyObject的一个扩展，它在PyObject的基础上提供了一个ob_size字段，用于记录内部的元素个数。比如列表，列表<code>(PyListObject实例)</code>中的ob_size维护的就是列表的元素个数，插入一个元素，ob_size会加1，删除一个元素，ob_size会减1。所以我们使用len获取列表的元素个数是一个时间复杂度为O(1)的操作，因为ob_size是时刻都和内部的元素个数保持一致，使用len获取元素个数的时候会直接访问ob_size。</p>
<p><font color="green">因此在Python中，所有的变长对象都拥有PyVarObject，而所有的对象都拥有PyObject，这就使得在Python中，对”对象”的引用变得非常统一，我们只需要一个PyObject  *就可以引用任意一个对象，而不需要管这个对象实际是一个什么对象。所以在Python中，所有的变量、以及容器内部的元素，本质上都是一个PyObject *。</font></p>
<p>由于PyObject和PyVarObject要经常被使用，所以Python提供了两个宏，方便定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD          PyObject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure>

<p><strong>比如定长对象浮点数，在底层对应的结构体为PyFloatObject，只需在头部PyObject的基础上再加上一个double即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>而对于变长对象列表，在底层对应的结构体是PyListObject，所以它需要在PyVarObject的基础上再加上一个指向数组的二级指针和一个容量即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/listobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>这上面的每一个成员都代表什么，我们之前已经分析过了。ob_item就是指向指针数组的二级指针，而allocated表示已经分配的容量，一旦添加元素的时候发现ob_size自增1之后会大于allocated，那么解释器就会对ob_item指向的指针数组进行扩容了。更准确的说，是申请一个容量更大数组，然后将原来指向的指针数组内部的元素按照顺序一个一个地拷贝到新的数组里面去，并让ob_item指向新的数组，这一点在分析PyListObject的时候会细说。所以我们看到列表在添加元素的时候，地址是不会改变的，即使容量不够了也没有关系，直接让ob_item指向新的数组就好了，至于PyListObject对象本身的地址是不会变化的。</strong></p>
<p>最后再来<font color="green">介绍两个宏定义</font>，这个是针对于类型对象的，我们后面在介绍类型对象的时候会经常见到这两个宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Include/object.h</span><br><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>

<p>先看PyObject_HEAD_INIT，里面的_PyObject_EXTRA_INIT是用来实现refchain这个双向链表的，我们目前不需要管。里面的1指的是引用计数，我们看到刚创建的时候默认是设置为1的，至于type就是该类型对象的类型了，这个是作为宏的参数传进来的；而PyVarObject_HEAD_INIT，则是在PyObject_HEAD_INIT的基础之上，增加了一个size，显然我们从名字也能看出来这个size是什么。当然目前只是介绍这两个宏，先有个印象，类型对象的实现我们下面就会说。</p>
<h3 id="实现类型对象的基石–PyTypeObject"><a href="#实现类型对象的基石–PyTypeObject" class="headerlink" title="实现类型对象的基石–PyTypeObject"></a>实现类型对象的基石–PyTypeObject</h3><p>通过PyObject和PyVarObject，我们看到了Python中所有对象的共有信息以及变长对象的共有信息。对于任何一个对象，不管它是什么类型，内部必有引用计数<code>(ob_refcnt)</code>和类型指针<code>(ob_type)</code>；对于任意一个变长对象，不管它是什么类型，除了引用计数和类型指针之外，内部还有一个表示元素个数的ob_size。</p>
<p><strong>然目前是没有什么问题，一切都是符合我们的预期的，但是当我们顺着时间轴回溯的话，就会发现端倪。比如：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</p>
<p>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的PyObject中的ob_type，也就是类型指针。我们通过对象的ob_type成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</p>
<p>下面我们来看看类型对象在底层是怎么定义的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject; <span class="comment">//_typeobject正是PyObject里面的一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/Cpython/object.h</span></span><br><span class="line"><span class="comment">// 类型对象对应的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类型对象在底层对应的是struct _typeobject，当然也是PyTypeObject，它里面的成员非常非常多，我们暂时挑几个重要的说，因为有一部分成员并不是那么重要，我们在后续会慢慢说。</strong></p>
<p><strong>目前我们了解到Python中的类型对象在底层就是一个PyTypeObject实例，它保存了实例对象的元信息，描述对象的类型。</strong></p>
<blockquote>
<p><strong>Python中的实例对象在底层对应不同的结构体实例，而类型对象则是对应同一个结构体实例，换句话说无论是int、str、dict等等等等，它们在C的层面都是由PyTypeObject这个结构体实例化得到的，只不过成员的值不同PyTypeObject这个结构体在实例化之后得到的类型对象也不同。</strong></p>
</blockquote>
<p><font color="green"><strong>我们看一下PyTypeObject内部几个非常关键的成员：</strong></font></p>
<ul>
<li><code>PyObject_VAR_HEAD：我们说这是一个宏，对应一个PyVarObject，所以类型对象是一个变长对象。而且类型对象也有引用计数和类型，这与我们前面分析的是一致的。</code></li>
<li><code>tp_name：类型的名称，而这是一个char *，显然它可以是int、str、dict之类的。</code></li>
<li><code>tp_basicsize, tp_itemsize：创建对应实例对象时所需要的内存信息。</code></li>
<li><code>tp_dealloc：其实例对象执行析构函数时所作的操作。</code></li>
<li><code>tp_print：其实例对象被打印时所作的操作。</code></li>
<li><code>tp_as_number：其实例对象为数值时，所支持的操作。这是一个结构体指针，指向的结构体中的每一个成员都是一个函数指针，其函数就是整型对象可以执行的操作，比如：四则运算、左移、右移、取模等等</code></li>
<li><code>tp_as_sequence：其实例对象为序列时，所支持的操作。同样是一个结构体指针。</code></li>
<li><code>tp_as_mapping：其实例对象为映射时，所支持的操作。也是一个结构体指针。</code></li>
<li><code>tp_base：继承的基类。</code></li>
</ul>
<p><strong>我们暂时就挑这么几个，事实上从名字上你也能看出来这每一个成员代表的含义。而且这里面的成员虽然多，但并非每一个类型对象都具备，比如int类型它就没有tp_as_sequence和tp_as_mapping，所以int类型的这两个成员的值都是0。</strong></p>
<p><strong>具体的我们就在分析具体的类型对象的时候再说吧，然后先来看看Python对象在底层都叫什么名字吧。</strong></p>
<ul>
<li><code>整型 -&gt; PyLongObject结构体实例,  int -&gt; PyLong_Type(PyTypeObject结构体实例)</code></li>
<li><code>字符串 -&gt; PyUnicodeObject结构体实例,  str -&gt; PyUnicode_Type(PyTypeObject结构体实例)</code></li>
<li><code>浮点数 -&gt; PyFloatObject结构体实例,  float -&gt; PyFloat_Type(PyTypeObject结构体实例)</code></li>
<li><code>复数 -&gt; PyComplexObject结构体实例,  complex -&gt; PyComplex_Type(PyTypeObject结构体实例)</code></li>
<li><code>元组 -&gt; PyTupleObject结构体实例,  tuple -&gt; PyTuple_Type(PyTypeObject结构体实例)</code></li>
<li><code>列表 -&gt; PyListObject结构体实例,  list -&gt; PyList_Type(PyTypeObject结构体实例)</code></li>
<li><code>字典 -&gt; PyDictObject结构体实例,  dict -&gt; PyDict_Type(PyTypeObject结构体实例)</code></li>
<li><code>集合 -&gt; PySetObject结构体实例,  set -&gt; PySet_Type(PyTypeObject结构体实例)</code></li>
<li><code>不可变集合 -&gt; PyFrozenSetObject结构体实例,  frozenset -&gt; PyFrozenSet_Type(PyTypeObject结构体实例)</code></li>
<li><code>元类：PyType_Type(PyTypeObject结构体实例)</code></li>
</ul>
<p><strong>所以Python中的对象在底层的名字都遵循一定的标准，包括解释器提供的Python&#x2F;C API也是如此。</strong></p>
<p><font color="green"><strong>下面以浮点数为例，考察一下类型对象和实例对象之间的关系。</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; pi = 3.14</span><br><span class="line">&gt;&gt;&gt; e = 2.71</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; type(pi) is type(e) is float</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312165701421.png" alt="image-20230312165701421"></p>
<p><strong>两个变量均指向了浮点数(PyFloatObject结构体实例)，除了公共头部字段ob_refcnt和ob_type，专有字段ob_fval保存了对应的数值；浮点类型float则对应PyTypeObject结构体实例(PyFloat_Type)，保存了类型名、内存分配信息以及浮点数相关操作。而将这两者关联起来的就是ob_type这个类型指针，它位于PyObject中，是所有对象共有的，而Python便是根据这个ob_type来判断该对象的类型，进而获取该对象的元信息。</strong></p>
<blockquote>
<p><strong>我们说变量只是一个指针，那么int、float、dict这些是不是变量，显然是的，函数和类也是一个变量，所以它们在底层也是一个指针。只不过这些变量是内置的，直接指向了具体的PyTypeObject实例。只是为了方便，有时我们用int、float等等，来代指指向的对象。比如：float指向了底层的PyFloat_Type，所以它其实是PyFloat_Type的指针，但为了表述方便我们会直接用float来代指PyFloat_Type。</strong></p>
<p><strong>而且类型对象在解释器启动的时候就已经是创建好了的，不然的话我们怎么能够直接用呢？类型对象创建完毕之后，直接让float指向相应的类型对象。</strong></p>
</blockquote>
<p><strong>我们来看一下float对应的类型对象在底层是怎么定义的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    .tp_vectorcall = (vectorcallfunc)float_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyFloat_Type在源码中就直接被创建了，这是必须的，否则我们就没有办法直接访问float这个变量了，然后先看结构体中的第4行，我们看到tp_name被初始化成了”float”；第5行表示实例对象所占的字节数，我们看到就是一个PyFloatObject实例所占的内存大小，并且显然这个值是不会变的，说明无论创建多少个实例对象，它们的大小都是不变的，这也符合我们之前的测试结果，都是24字节。</strong></p>
<p><strong>再往下就是一些各种操作对应的函数指针，最后我们来看一下第3行，显然它接收的是一个PyVarObject，PyVarObject_HEAD_INIT这个宏无需赘言，但重点是里面的&amp;PyType_Type，说明了float被设置成了type类型。</strong></p>
<p><strong>而且所有的类型对象(还有元类)在底层都被定义成了静态的全局变量，因为它们的声明周期是伴随着整个解释器的，并且在任意地方都可以访问。</strong></p>
<p><font color="red"><strong>模改CPython如何修改Type的打印信息？</strong></font></p>
<p>例如，修改float的打印信息，进入到floatobject.h中，进入 PyAPI_DATA(PyTypeObject) PyFloat_Type; 中，进入(reprfunc)float_repr</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105008756.png" alt="image-20230309105008756"></p>
<p>重新编译CPython，发现打印的结果为：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105144313.png" alt="image-20230309105144313"></p>
<h3 id="类型对象的类型–PyType-Type"><a href="#类型对象的类型–PyType-Type" class="headerlink" title="类型对象的类型–PyType_Type"></a>类型对象的类型–PyType_Type</h3><p>我们考察了float类型对象，知道它在C的层面是PyFloat_Type这个静态全局变量，它的类型是type，包括我们自定义的类的类型也是type。而type在Python中是一个至关重要的对象，它是所有类型对象的类型，我们称之为元类型<code>(meta class)</code>，或者元类。借助元类型，我们可以实现很多神奇的高级操作。那么type在C的层面又长啥样呢？</p>
<p>在介绍PyFloat_Type的时候我们知道了type在底层对应PyType_Type，而它在”Object&#x2F;typeobject.c”中定义，因为我们说所有的类型对象加上元类都是要预先定义好的，所以要源码中就必须要以静态全局变量的形式出现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们所有的类型对象加上元类都是PyTypeObject这个结构体实例化得到的，所以它们内部的成员都是一样的，只不过传入的值不同，实例化之后的结果也不同，可以是PyLong_Type、可以是PyFloat_Type，也可以是这里的PyType_Type。</p>
<p><strong>PyType_Type的内部成员和PyFloat_Type是一样的，但是我们还是要重点看一下里面的宏PyVarObject_HEAD_INIT，我们看到它传递的是一个&amp;PyType_Type，说明它把自身的类型也设置成了PyType_Type，换句话说，PyType_Type里面的ob_type成员指向的还是PyType_Type。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type.__class__.__class__.__class__.__class__.__class__ is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(type(type(type(type(type))))) is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然不管我们套娃多少次，最终的结果都是True，显然这也是符合我们的预期的。</strong></p>
<h3 id="类型对象的基类–PyBaseObject-Type"><a href="#类型对象的基类–PyBaseObject-Type" class="headerlink" title="类型对象的基类–PyBaseObject_Type"></a>类型对象的基类–PyBaseObject_Type</h3><p>我们说Python中有两个类型对象比较特殊，一个是站在类型金字塔顶端的type，一个是站在继承金字塔顶端的object。说完了type，我们来说说object，我们说类型对象内部的tp_base表示继承的基类，对于PyType_Type来讲，它内部的tp_base肯定是PyBaseObject_Type。</p>
<p><strong>但令我们吃鲸的是，它的tp_base居然是个0，如果为0的话则表示没有这个属性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,                                          /* tp_base */</span><br></pre></td></tr></table></figure>

<p><strong>不是说type的基类是object吗？为啥tp_base是0，事实上如果你去看PyFloat_Type的话，它内部的tp_base也是0。为0的原因就在于我们目前看到的类型对象是一个半成品，因为Python的动态性，显然不可能在定义的时候就将所有成员属性都设置好、然后解释器一启动就会得到我们平时使用的类型对象。目前看到的类型对象是一个半成品，有一部分成员属性是在解释器启动之后再进行动态完善的。</strong></p>
<blockquote>
<p><strong>至于是怎么完善的，都有哪些成员需要解释器启动之后才能完善，我们后续系列会说。</strong></p>
</blockquote>
<p><font color="green">而PyBaseObject_Type位于Object&#x2F;object.c中，我们来一睹其芳容。</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/object.c</span></span><br><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;object&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject),                           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    object_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object_repr,                                <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyBaseObject_Type的类型也被设置成了PyType_Type，而PyType_Type类型在被完善之后，它的tp_base也会指向PyBaseObject_Type。所以之前我们说Python中的type和object是同时出现的，它们的定义是需要依赖彼此的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：解释器在完善PyBaseObject_Type的时候，是不会设置其tp_base的，因为继承链必须有一个终点，否对象沿着继承链进行属性查找的时候就会陷入死循环，而object已经是继承链的顶点了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object -&gt; PyBaseObject_Type</code></li>
<li><code>object() -&gt; PyBaseObject</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312171839520.png" alt="image-20230312171839520"></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>04-浮点数的底层实现</title>
    <url>/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="04-浮点数的底层实现"><a href="#04-浮点数的底层实现" class="headerlink" title="04-浮点数的底层实现"></a>04-浮点数的底层实现</h2><p>从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。</p>
<p>除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p><strong>float实例对象定义在Include&#x2F;floatobject.h中，结构非常简单：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了PyObject这个公共的头部信息之外，只有一个额外的ob_fval，用于存储具体的值，而且直接使用的C中的double。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195351664-171093404.png" alt="img"></p>
<p>​        <strong>那么float类型对象在底层长啥样子呢？</strong>    </p>
<p><strong>与实例对象不同，float类型对象全局唯一，因此可以作为全局变量定义。底层对应PyFloat_Type，位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PyFloat_Type中保存了很多关于浮点数对象的元信息，关键字段包括：</strong></p>
<ul>
<li><code>tp_name字段保存了类型名称，是一个char *，显然是&quot;float&quot;；</code></li>
<li><code>tp_dealloc、tp_init、tp_alloc和 tp_new字段是与对象创建销毁相关的函数；</code></li>
<li><code>tp_repr字段对应__repr__方法，生成语法字符串；</code></li>
<li><code>tp_str字段对应__str__方法，生成普通字符串；</code></li>
<li><code>tp_as_number字段对应数值对象支持的操作簇；</code></li>
<li><code>tp_hash字段是哈希值生成函数；</code></li>
</ul>
<p><strong>PyFloat_Type很重要，作为浮点类型对象，它决定了浮点数的生死和行为。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>在上一篇博客中，我们初步了解到创建实例对象的一般过程。对于内置类型的实例对象，可以使用Python&#x2F;C API创建，也可以通过调用类型对象创建。</strong></p>
<p><strong>调用类型对象float创建实例对象，Python执行的是type类型对象中的tp_call函数。tp_call中会先调用类型对象的tp_new为该对象的实例对象申请一份空间，申请完毕之后该对象就已经被创建了。然后会再调用tp_init，并将实例对象作为参数传递进去，进行初始化，也就是设置属性。</strong></p>
<p><strong>但是对于float来说，它内部的tp_init成员是0，从PyFloat_Type的定义我们也可以看到。说明float没有__init__函数，原因是float是一种很简单的类型对象，初始化操作只需要一个赋值语句，所以在tp_new中就可以完成。</strong></p>
<p>​        <strong>除了通过调用类型对象创建实例对象这种通用型方法之外，CPython还为内置类型对象提供了一些Python&#x2F;C  API来创建对应的实例对象。可以简化调用，提高效率。关于为什么可以提高效率，我们之前已经分析过了，我们说通过Python&#x2F;C  API创建的话，会直接解析成底层对应的数据结构，而通过类型对象调用的话则会有一些额外的开销。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromString</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>以上是底层提供的两个创建浮点数的C API，当然还有其它的。</strong></p>
<ul>
<li><code>PyFloat_FromDouble：通过C中的double创建float对象；</code></li>
<li><code>PyFloat_FromString：通过字符串对象创建float对象；</code></li>
</ul>
<p><strong>以PyFloat_FromDouble为例，我们看看底层是怎么创建的？该函数同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们之前在介绍引用计数的时候，说过引用计数为0了，那么对象会被销毁</span></span><br><span class="line">    <span class="comment">//但是对象所占的内存则不一定回收、或者说还给操作系统，而是会缓存起来</span></span><br><span class="line">    <span class="comment">//所以从这行代码我们就看到了，创建浮点数对象的时候会优先从缓存池里面获取</span></span><br><span class="line">    <span class="comment">//而缓存池是使用链表实现的，free_list(指针)指向的链表的第一个对象</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="comment">//op不是NULL，说明缓存池中有对象，成功获取</span></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//一旦获取了，那么要将free_list指向链表中当前获取的对象的下一个对象</span></span><br><span class="line">        <span class="comment">//但是Py_TYPE不是一个宏吗？它获取的应该是对象的ob_type啊，那么Py_TYPE(op)获取的不是PyFloat_Type指针吗？别急这一点我们后面会说</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        <span class="comment">//并且将缓存池的内部可以使用的浮点数对象的数量减1</span></span><br><span class="line">        <span class="comment">//关于缓存池, 以及为什么要使用缓存池下面也会细说</span></span><br><span class="line">        <span class="comment">//目前先知道Python在分配浮点数对象的时候会先从缓存池里面获取就可以了</span></span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，调用PyObject_MALLOC申请内存，PyObject_MALLOC是基于malloc的一个封装</span></span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="comment">//申请失败的话，证明内存不够了</span></span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//走到这里说明内存分配好了，PyFloatObject也创建了，但是不是还少了点啥呢？显然内部的成员还没有初始化</span></span><br><span class="line">    <span class="comment">//还是那句话内置类型的实例对象该分配多少空间，解释器了如指掌，因为通过PyFloatObject内部的成员一算就出来了。</span></span><br><span class="line">    <span class="comment">//因此虽然对象创建了，但是此时内部的ob_refcnt、ob_type、以及ob_fval三个成员还没有被初始化。</span></span><br><span class="line">    <span class="comment">//所以还要将其ob_refcnt设置为1(因为对于刚创建的对象来说,内部的引用计数显然为1)，将ob_type设置为指向PyFloat_Type的指针</span></span><br><span class="line">    <span class="comment">//而PyObject_INIT是一个宏，它就是专门用来设置ob_type以及ob_refcnt的，我们后面看这个宏的定义就知道了</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line">    <span class="comment">//将内部的ob_fval成员设置为fval，所以此时三个成员都已经初始化完毕</span></span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="comment">//将其转成PyObject *返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以整体流程如下：</strong></p>
<ul>
<li><code>1. 为实例对象分配内存空间，空间分配完了对象也就创建了，不过会优先使用缓存池；</code></li>
<li><code>2. 初始化实例对象内部的引用计数和类型指针；</code></li>
<li><code>3. 初始化ob_fval为指定的浮点值；</code></li>
</ul>
<p><strong>然后我们看一下PyObject_INIT这个宏，它位于Include&#x2F;objimpl.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_INIT(op, typeobj) \</span></span><br><span class="line"><span class="meta">    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</span></span><br><span class="line"><span class="comment">//这个宏接收两个参数，分别是：实例对象的指针和指向的类型对象的指针</span></span><br><span class="line"><span class="comment">//然后Py_TYPE(op)表示获取其内部的ob_type, 将其设置为typeobj, 而typeobj在源码中传入的就是&amp;PyFloat_Type</span></span><br><span class="line"><span class="comment">//然后是_Py_NewReference, 这个宏我们在上一篇博客中已经说过了，它用于将对象的引用计数初始化为1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p><strong>当删除一个变量时，Python会通过宏Py_DECREF或者Py_XDECREF来减少该变量指向的对象的引用计数；当引用计数为0时，就会回收该对象。而回收该对象会调用其类型对象中的tp_dealloc指向的函数。当然啦，CPython依旧为回收对象提供了一个宏，我们上一篇中也说过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">// _Py_Dealloc(op)会调用op指向的对象的类型对象中的析构函数，同时将op自身作为参数传递进去，表示将op指向的对象回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>而PyFloat_Type中的tp_dealloc成员被初始化为float_dealloc，所以析构函数最终执行的是float_dealloc，关于它的源代码我们会在一会儿介绍缓存池的时候细说。</strong></p>
<p><strong>总结一下的话，浮点数对象从创建到销毁整个生命周期所涉及的关键函数、宏、调用关系可以如下图所示：</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195401032-229146894.png" alt="img"></p>
<p><strong>我们看到通过类型对象调用的方式来创建实例对象，最终也是要走Python&#x2F;C API的，肯定没有直接通过Python&#x2F;C API创建的方式快，因为前者多了几个步骤。</strong></p>
<blockquote>
<p><strong>所以如果是float(3.14)，那么最终也会调用PyFloat_FromDouble(3.14)；如果是float(“3.14”)，那么最终会调用PyFloat_FromString(“3.14”)。所以调用类型对象的时候，会先兜个圈子再去使用Python&#x2F;C API，肯定没有直接使用Python&#x2F;C API的效率高。</strong></p>
</blockquote>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p><strong>我们说浮点数这种对象是经常容易被创建和销毁的，如果每创建一个就分配一次内存、每销毁一个就回收一次内存的话，那效率会低到可想而知了。我们知道Python在操作系统之上封装了一个内存池，可以用于小内存对象的快速创建和销毁，这便是Python的内存池机制。但浮点数使用的频率很高，我们有时会创建和销毁大量的临时对象，所以如果每一次对象的创建和销毁都伴随着内存相关的操作的话，这个时候即便是有内存池机制，效率也是不高的。</strong></p>
<p><strong>考虑如下代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi = <span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pi * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">12.56</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个语句首先计算半径r的平方，然后根据结果创建一个临时对象，假设是t；然后再将pi和t进行相乘，得到最终结果并赋值给s；最终销毁临时变量t，所以这背后是隐藏着一个临时对象的创建和删除的。</strong></p>
<p><strong>当然这里一行代码可能感觉不到啥，假设我们要计算很多很多个半径对应的面积呢？显然需要写for循环，如果循环一万次就意味着要创建和销毁临时对象各一万次。</strong></p>
<p>因此，如果每一次创建对象都需要分配内存，销毁对象时需要回收内存的话，那么大量临时对象的创建和销毁就意味着要伴随大量的<font color="red">内存分配以及回收操作</font>，这显然是无法忍受的，更何况Python的for循环本身就已经够慢了。</p>
<p>​        <strong>因此Python在浮点数对象被销毁后，并不急着回收对象所占用的内存，换句话说其实对象还在，只是将该对象放入一个空闲的链表中。因为我们说对象可以理解为就是一片内存空间，对象如果被销毁，那么理论上内存空间要归还给操作系统，或者回到内存池中；但Python考虑到效率，并没有真正的销毁对象，而是将对象放入到链表中，占用的内存还在；后续如果再需要创建新的浮点数对象时，那么从链表中直接取出之前放入的对象(我们认为被回收的对象)，根据新的浮点数对象重新初始化对应的成员即可，这样就避免了内存分配造成的开销。而这个链表就是我们说的缓存池，当然不光浮点数对象有缓存池，Python中的很多其它对象也有对应的缓存池，比如列表。</strong>    </p>
<p><strong>浮点对象的空闲链表同样在 Objects&#x2F;floatobject.c中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyFloat_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST    100  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;  </span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PyFloat_MAXFREELIST：缓存池中能容纳float实例对象的最大数量, 显然不可能将所有要销毁的对象都放入到缓存池中, 这里是100个;</code></li>
<li><code>numfree：表示当前缓存池(链表)中的已经存在的float实例对象的数量, 初始为0;</code></li>
<li><code>free_list: 指向链表头结点的指针, 链表里面存储的都是PyFloatObject, 所以头节点的指针就是PyFloatObject *</code></li>
</ul>
<p><strong>但是问题来了，如果是通过链表来存储的话，那么对象肯定要有一个指针，来指向下一个对象，但是浮点数对象内部似乎没有这样的指针啊。是的，因为Python是使用内部的ob_type来指向下一个对象，本来ob_type指向的应该是PyFloat_Type，但是在链表中指向的是下一个PyFloatObject。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195410257-1986378240.png" alt="img"></p>
<p><strong>所以我们再回过头来看看PyFloat_FromDouble：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然op是缓存池中第一个PyFloatObject的指针</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个时候链表中的第一个对象已经被取出来重新分配了，显然free_list要指向下一个PyFloatObject</span></span><br><span class="line">        <span class="comment">//我们说在链表中，ob_type被用于指向链表中的下一个PyFloatObject，换言之ob_type保存的是下一个PyFloatObject的地址</span></span><br><span class="line">        <span class="comment">//但ob_type虽然保存的是PyFloatObject的地址，但它的类型仍是struct _typeobject *, 或者说PyTypeObject *</span></span><br><span class="line">        <span class="comment">//所以在存储的时候，下一个PyFloatObject *一定是先转成了struct _typeobject *之后，再交给的ob_type,因为对于指针来说，是可以任意转化的</span></span><br><span class="line">        <span class="comment">//所以Py_TYPE(op)获取下一个对象的指针之后，还要再转成PyFloatObject *，然后交给free_list保存</span></span><br><span class="line">        <span class="comment">//如果没有下一个对象了，那么free_list就是NULL</span></span><br><span class="line">        <span class="comment">//因此在下一次分配的时候，上面if (op != NULL)就不成立了，因此会走下面的else，使用PyObject_MALLOC重新分配内存</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说对象创建时，会先从缓存池中获取。既然创建时可以从缓存池获取，那么销毁的时候，肯定要放入到缓存池中。而销毁对象会调用类型对象的析构函数tp_dealloc，对于浮点数而言就是float_dealloc，我们看一下源代码，同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">        <span class="comment">//如果numfree(当前缓存池中float实例对象的数量)达到了缓存池的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            <span class="comment">//那么调用PyObject_FREE回收对象所占内存</span></span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则的话，说明没有达到最大容量限制，显然此时不会真的销毁对象，而是将其放入缓存池中</span></span><br><span class="line">        <span class="comment">//将numfree加1</span></span><br><span class="line">        numfree++;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表的第一个元素，而这里是获取了op的ob_type,让其等于free_list，说明该对象内部的ob_type也指向了链表中的第一个元素</span></span><br><span class="line">        <span class="comment">//那么说明了什么，是不是意味着链表中第一个元素就变成该对象了。因此在将对象放入链表中的时候，是放在链表的头部位置</span></span><br><span class="line">        <span class="comment">//但我们说ob_type的类型是struct _typeobject *，所以还要将free_list进行转化</span></span><br><span class="line">        <span class="comment">//那么显然在获取的时候，还要再转成PyFloatObject *，这在上面的PyFloat_FromDouble中我们已经看到了</span></span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表中的第一个元素，但现在第一个元素变了</span></span><br><span class="line">        <span class="comment">//所以要让free_list = op, 指向新添加的PyFloatObject，因为它被插入到了链表的第一个位置上</span></span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则的话，说明PyFloat_CheckExact(op)为假, PyFloat_CheckExact(op)是用于检测op是不是指向PyFloatObject</span></span><br><span class="line">    <span class="comment">//说明此时op可能指向的其实不是PyFloatObject *，所以通过Py_TYPE(op)-&gt;tp_free直接获取对应的类型对象的tp_free，然后释放掉op指向的对象所占的内存。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>这便是Python的浮点数对象(或者浮点数空闲对象)缓存池的全部秘密，由于对象缓存池在提高对象分配效率方面发挥着至关重要的作用，所以Python中很多其它内置对象的实例对象也都实现了缓存池，我们后续在分析其它对象的时候会经常看到它的身影。</strong>    </p>
<p><strong>看一个思考题：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.414</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.732</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到两个对象的id是一样的，相信你肯定知道原因。因为a在del之后，指向对象被放入到缓存池中，然后创建b的时候会从缓存池中获取，所以a指向的对象被重新利用了，内存还是原来的那一块内存，所以前后地址没有变化。</strong></p>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p><strong>PyFloat_Type中定义了很多的函数指针，比如：type_repr、tp_str、tp_hash等等，这些函数指针将一起决定float实例对象的行为，例如：tp_hash决定float实例对象的哈希值是如何计算的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(e)</span><br><span class="line"><span class="number">1637148536541722626</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>tp_hash指向的是float_hash，还是那句话Python底层的函数命名以及API都是很有规律的，相信你能慢慢发现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_hash_t</span><br><span class="line"><span class="title function_">float_hash</span><span class="params">(PyFloatObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到调用了_Py_HashDouble，计算的就是ob_fval成员哈希值</span></span><br><span class="line">    <span class="keyword">return</span> _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>由于加减乘除等数值操作很常见， Python 将其抽象成数值操作簇 PyNumberMethods，并让内部成员tp_as_number指向。数值操作集 PyNumberMethods 在头文件 Include&#x2F;object.h 中定义：</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">    arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">    in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p><strong>PyNumberMethods定义了各种数学算子的处理函数，数值计算最终由这些函数执行。 处理函数根据参数个数可以分为： 一元函数(unaryfunc) 、 二元函数(binaryfunc) 和 三元函数(ternaryfunc )。</strong></p>
<p><strong>然后我们回到Objects&#x2F;floatobject.c中观察一下PyFloat_Type是如何初始化的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    (unaryfunc)float_neg, <span class="comment">/* nb_negative */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>以加法为例，显然最终执行float_add，源码位于Objects&#x2F;floatobject.c中，显然它是一个二元函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">float_add</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然两个Python对象相加，一定是先将其转成C的对象相加，加完之后再根据结果创建新的Python对象</span></span><br><span class="line">    <span class="comment">//所以声明了两个double</span></span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="comment">//CONVERT_TO_DOUBLE是一个宏，不用想，功能肯定是将PyFloatObject里面的ob_fval抽出来给double变量，从名字上也能看出来</span></span><br><span class="line">    <span class="comment">//这个宏有兴趣可以去源码中看一下，也在当前文件中</span></span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);  <span class="comment">// 将ob_fval赋值给a</span></span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);  <span class="comment">// 将ob_fval赋值给b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PyFPE_START_PROTECT和下面的PyFPE_END_PROTECT也都是宏，作用我们一会儿说。</span></span><br><span class="line">    PyFPE_START_PROTECT(<span class="string">&quot;add&quot;</span>, <span class="keyword">return</span> <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//将a和b相加赋值给a</span></span><br><span class="line">    a = a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line">    <span class="comment">//根据相加后的结果创建新的PyFloatObject对象，当然返回的是泛型指针PyObject *</span></span><br><span class="line">    <span class="keyword">return</span> PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以上就是float实例对象的运算，核心就是：</strong></p>
<ul>
<li><code>1. 定义两个double变量：a、b</code></li>
<li><code>2. 将用来相加的两个float实例对象中ob_fval维护的值抽出来赋值给a和b</code></li>
<li><code>3. 让a和b相加，将相加结果传入PyFloat_FromDouble中创建新的PyFloatObject，然后返回其PyObject *</code></li>
</ul>
<p><strong>所以如果是C中的两个浮点数相加，直接a +  b就可以了，编译之后就是一条简单的机器指令，然而Python则需要额外做很多其它工作。并且在介绍整型的时候，你会发现Python中的整型的相加会更麻烦，但对于C而言同样是一条简单的机器码就可以搞定。当然啦，因为Python3中的整型是不会溢出的，所以需要额外的一些处理，等介绍整型的时候再说吧。所以这里我们也知道Python为什么会比C慢几十倍了，从一个简单的加法上面就可以看出来。</strong></p>
<blockquote>
<p><strong>最后我们再说一下PyFPE_START_PROTECT和PyFPE_END_PROTECT这两个宏，其实它们对于我们了解浮点数在底层的计算没有什么意义。首先浮点数计算一般都遵循IEEE-754标准，如果计算时出现了错误，那么需要将IEEE-754异常转换成Python中的异常，而这两个宏就是用来干这件事情的。</strong></p>
<p><strong>所以我们不需要管它，这两个宏定义在Include&#x2F;pyfpe.h中，并且Python3.9的时候会被删除掉。</strong></p>
</blockquote>
<p>​        <strong>最后我们说一下Python解释器源代码的结构吧，因为我们每一次介绍函数的时候，都会说该函数定义在哪个文件里。所以突然想起来，介绍一下源代码的组织结构也是有必要的。</strong>    </p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195419135-1770620855.png" alt="img"></p>
<p><strong>我们从官网上将源代码下载下来之后，大概长这样，里面有几个目录是我们需要关注的。</strong></p>
<ul>
<li><code>Include：该目录包含了Python所提供的所有头文件，主要包含了一些实例对象在底层的定义，比如listobject.h、dictobject.h等等。如果用户需要自己使用C或者C++来编写自定义模块扩展Python，那么也需要用到这里的头文件。</code></li>
<li><code>Lib：这个无需多说，该目录包含了python自带的所有标准库，Lib中的库基本上都是使用python编写的。</code></li>
<li><code>Modules：该目录中包含了所有用C语言编写的模块，比如_random、_io等，而且gc也在里面。Modules中的模块是那些对速度要求非常严格的模块，而有一些对速度没有太严格要求的模块，比如os，就是用Python编写，并且是放在Lib目录下的。</code></li>
<li><code>Parser：该目录中包含了python解释器中的Scanner和Parser部分，即对python源代码进行词法分析和语法分析的部分。除了这些，Parser还包含了一些有用的工具，这些工具能够根据Python语言的语法自动生成Python语言的词法和语法分析器，与YACC非常类似。</code></li>
<li><code>Objects：该目录包含了所有Python的内置类型对象的实现，以及其实例对象相关操作的实现，比如浮点数相关操作就位于文件floatobject.c中、列表相关操作就位于文件listobject.c中，文件名也很有规律。同时，该目录还包含了Python在运行时需要的所有内部使用对象的实现，因为有很多对象比如&lt;class &#39;function&#39;&gt;是没有暴露给Python的，但是在底层它们是实现了的。</code></li>
<li><code>Python：虚拟机的实现相关，是python运行的核心所在。</code></li>
</ul>
<h3 id="PyFloatObjectに侵入し"><a href="#PyFloatObjectに侵入し" class="headerlink" title="PyFloatObjectに侵入し"></a>PyFloatObjectに侵入し</h3><p><strong>最后我们修改一下源码：当对象放入到缓冲池中，我们打印一下放入的浮点数对象的地址；当对象从缓存池中取出时，我们打印一下取出的浮点数对象的地址。</strong></p>
<p>对象从内存池中取出的时候加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line">    op = state-&gt;free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">        <span class="comment">// PyFloat_FromDouble() must not be called after _PyFloat_Fini()</span></span><br><span class="line">        assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        state-&gt;free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        state-&gt;numfree--;</span><br><span class="line">        OBJECT_STAT_INC(from_freelist);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Object gets from the memory pool,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        op = PyObject_Malloc(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _PyObject_Init((PyObject*)op, &amp;PyFloat_Type);</span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象放入内存池中加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyFloat_ExactDealloc(PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(PyFloat_CheckExact(obj));</span><br><span class="line">    PyFloatObject *op = (PyFloatObject *)obj;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">    <span class="comment">// float_dealloc() must not be called after _PyFloat_Fini()</span></span><br><span class="line">    assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">        PyObject_Free(op);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;numfree++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Objects are put back into the memory poo,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    Py_SET_TYPE(op, (PyTypeObject *)state-&gt;free_list);</span><br><span class="line">    state-&gt;free_list = op;</span><br><span class="line">    OBJECT_STAT_INC(to_freelist);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PyObject_Free(op);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195427317-1430841014.png" alt="img"></p>
<p><strong>我们看到在解释器刚启动的时候，内部就已经创建出很多对象了，然后我们自己来创建一个对象吧。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195432078-602851272.png" alt="img"></p>
<p><strong>我们第一次创建对象的时候，居然是从缓存池里面获取的，说明在解释器启动的时候那个链表中就已经有空闲对象了。然后我们使用Python获取其id，由于得到的是十进制整型，所以转成16进制，发现地址是一样的。然后放入到缓存池中，放入的对象的地址也是相同的，这和我们得到结论是一致的。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195437415-553253163.png" alt="img"></p>
<p><strong>我们再创建新的变量a、b并打印地址，然后删除a、b变量，再重新创建a、b变量、打印地址，结果发现它们存储的对象的地址在删除前后正好是相反的。至于原因，如果思考一下将对象放入缓存池、以及从缓存池获取对象的时候所采取的策略，那么很容易就明白了。</strong></p>
<p><strong>因为del a,  b的时候会先删除a，再删除b。删除a的时候，会将a指向的对象作为链表中的第一个元素，然后删除b的时候，会将b指向的对象作为链表中的第一个元素，所以之前a指向的对象就变成了链表中的第二个元素。而获取的时候，也会从链表的头部开始获取，所以当重新创建变量a的时候，其指向的对象实际上使用的是之前变量b指向的对象所占的内存，而一旦获取，那么free_list指针会向后移动；因此创建变量b的时候，其指向的对象显然使用的是之前变量a指向的对象所占的内存。因此前后打印的地址是相反的，所以我们算是通过实践从另一个角度印证了之前分析的结论。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        <strong>这一篇我们分析了Python中的浮点数在底层的实现方式，之所以选择浮点数是因为浮点数是最简单的了。至于整数，其实并没有那么简单，因为它的值底层是通过数组存储的，而浮点型底层是用一个double存储对应的值，所以更简单一些，我们就先拿浮点数”开刀了”。</strong>    </p>
<p>​        <strong>然后我们还介绍浮点数的创建和销毁，会调用类型对象内部的tp_dealloc，浮点数的话就是float_dealloc。当然为了保证效率，避免内存的创建和回收，Python底层为浮点数引入了缓存池机制，我们也分析了它的机制。当然浮点数还支持相关的数值型操作，PyFloat_Type中的tp_as_number指向了PyNumberMethods结构体，里面有大量的函数指针，每个指针指向了具体的函数，专门用于浮点数的运算。当然整型也有，只不过指针指向的函数是用于整型运算的。比如相加：对于浮点数来说，PyNumberMethods结构体成员nb_add指向了函数float_add；对于整数来说，nb_add则是指向了long_add。然后我们也以相加为例，看了float_add函数的实现，核心就是将Python中对象的值抽出来，转成C的类型，然后运算，最后再根据运算的结果，创建Python中的对象、返回。当然除了加法，它的减法、乘法、除法都是类似的，有兴趣可以”杀入”floatobject.c中，大肆探索一番。</strong>    </p>
<p>​        <strong>最后我们修改了PyFloatObject的部分源码，其实就是加上了两个printf语句，对float实例对象的缓存池机制进行了实践，并用之前的结论对结果进行了合理的解释。</strong>    </p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Bytes对象的底层操作</title>
    <url>/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="06-Bytes对象的底层操作"><a href="#06-Bytes对象的底层操作" class="headerlink" title="06-Bytes对象的底层操作"></a>06-Bytes对象的底层操作</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p>不少编程语言中的”字符串”都是使用字符数组(或者称字符序列)来表示，比如C语言和go语言就是这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;komeiji satori&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>一个字节最多能表示256个字符，所以对于英文来说足够了，因此一个英文字符占一个字节即可，然而对于那些非英文字符便力不从心了。因此为了表示这些非英文编码，于是多字节编码应运而生—-通过多个字节来表示一个字符。但由于原始字节序列不维护编码信息，因此操作不慎便导致各种乱码现象。</p>
<p>而Python提供的解决方案是使用unicode<code>(在Python3中等价于str)</code>表示字符串，因为unicode可以表示各种字符，不需要关心编码的问题。但在存储或网络通讯时，字符串不可避免地要序列化成字节序列。为此，Python除了提供字符串对象之外，还额外提供了字节序列对象—-bytes。</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223900719-724141880.png" alt="img"></p>
<p><strong>如上图，str对象统一表示一个字符串，不需要关心编码；计算机通过字节序列和存储介质、网络介质打交道，字节序列由bytes对象表示；在存储和传输str对象的时候，需要将其序列化成字节序列，序列化也是编码的过程。</strong></p>
<p><strong>下面我们就来看看bytes对象在底层的数据结构。</strong></p>
<h3 id="PyBytesObject"><a href="#PyBytesObject" class="headerlink" title="PyBytesObject"></a>PyBytesObject</h3><p><strong>我们说bytes对象是由若干个字节组成的，显然这是一个变长对象，有多少个字节说明其长度是多少。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/bytesobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyBytesObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下里面的成员对象：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD：变长对象的公共头部</code></li>
<li><code>ob_shash：保存该字节序列的哈希值，之所以选择保存是因为在很多场景都需要bytes对象的哈希值。而Python在计算字节序列的哈希值的时候，需要遍历每一个字节，因此开销比较大。所以会提前计算一次并保存起来，这样以后就不需要算了，可以直接拿来用，并且bytes对象是不可变的，所以哈希值是不变的。</code></li>
<li><code>ob_sval：这个和PyLongObject中的ob_digit的声明方式是类似的，虽然声明的时候长度是1,  但具体是多少则取决于bytes对象的字节数量。这是C语言中定义&quot;变长数组&quot;的技巧, 虽然写的长度是1, 但是你可以当成n来用,  n可取任意值。显然这个ob_sval存储的是所有的字节，因此Python中的bytes的值，底层是通过字符数组存储的。而且通过注释，我们发现会多申请一个空间，用于存储\0，因为C中是通过\0来表示一个字符数组的结束，但是计算ob_size的时候不包括\0。</code></li>
</ul>
<p>​        <strong>我们创建几个不同的bytes对象，然后通过画图感受一下：</strong>    </p>
<p><strong>val &#x3D; b””</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223908475-1596108760.png" alt="img"></p>
<p><strong>我们看到一个空的字节序列，底层的ob_savl也是需要一个’\0’的，那么这个结构体实例占多大内存呢？我们说上面ob_sval之外的四个成员，显然每个都是8字节，而ob_savl每个成员都是一个char、也就是占1字节，所以Python中bytes对象占的内存等于32 +  ob_sval的长度。而ob_sval里面至少有一个’\0’，因此对于一个空的字节序列，显然占33个字节。注意：ob_size统计的是ob_sval中有效字节的个数，不包括’\0’，但是计算占用内存的时候，显然是需要考虑在内的，因为它确实多占用了一个字节的空间。或者说bytes对象占的内存等于33 + ob_size也是可以的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>val &#x3D; b”abc”</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223922037-1082582124.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">36</span>  <span class="comment"># 32 + 4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="bytes对象的行为"><a href="#bytes对象的行为" class="headerlink" title="bytes对象的行为"></a>bytes对象的行为</h3><p><strong>介绍bytes对象在底层的数据结构之后，我们要考察bytes对象的行为。我们说实例对象的行为由其类型对象决定，所以bytes对象具有哪些行为，就看bytes类型对象本身定义了哪些操作。bytes类型对象，显然对应PyBytes_Type，根据我们之前介绍的规律，也可以猜出来，它定义在Object&#x2F;bytesobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/bytesobject.c</span></span><br><span class="line">PyTypeObject PyBytes_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &amp;bytes_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;bytes_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;bytes_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)bytes_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>到了现在，相信你对类型对象的结构肯定非常熟悉了，因为类型对象都是由PyTypeObject结构体实例化得到的。我们看到tp_as_number，它居然不是0，而是传递了一个指针，说明确实指向了一个PyNumberMethods结构体实例。难道bytes支持数值运算，这显然是不可能的啊，所以我们需要进入bytes_as_number中一探究竟。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods bytes_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    bytes_mod,      <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到它只定义了一个取模操作，也就是%</span></span><br><span class="line"><span class="comment">//看到%估计有人已经明白了，这是格式化</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">bytes_mod(PyObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyBytes_Check(self)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，bytes对象只是借用了%运算实现了格式化，谈不上数值运算，虚惊一场。不过由此也看到了Python的动态特性，即使是相同的操作，但如果是不同类型的对象执行的话，也会有不同的表现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>info = <span class="string">b&quot;name: %s, age: %d&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>info % (<span class="string">b&quot;satori&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;name: satori, age: 16&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>​        <strong>除了tp_as_number，PyBytes_Type还给tp_as_sequence成员传递了bytes_as_sequence指针，说明bytes对象支持序列操作。显然这是肯定的，而且bytes对象显然是序列型对象，所以序列型操作才是我们的研究的重点，下面看看bytes_as_sequence的定义。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>根据定义我们看到，bytes对象支持的序列型操作一共有5个：</strong></p>
<ul>
<li><code>sq_length：查看序列的长度</code></li>
<li><code>sq_concat：将两个序列合并为一个</code></li>
<li><code>sq_repeat：将序列重复多次</code></li>
<li><code>sq_item：根据索引获取指定的下表, 得到一个整型;如果是切片，那么还会得到一个bytes对象</code></li>
<li><code>sq_contains：判断某个序列是不是在该序列中，显然它等价于Python中的in操作</code></li>
</ul>
<p><strong>查看序列长度：</strong></p>
<p><strong>显然这是最简单的，直接获取ob_size即可，比如：val &#x3D; b”abcde”，那么长度就是5。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">bytes_length</span><span class="params">(PyBytesObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将两个序列合并为一个：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&quot;def&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line"><span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而且我们看到这里相当于是加法运算，我们很容易想到会是PyNumberMethods中的nb_add，比如：PyLongObject对应的long_add、PyFloatObject对应的float_add，但对于bytes对象而言，加法操作对应PySequenceMethods的sq_concat。所以我们看到Python中的同一个操作符，在底层会对应不同的函数，比如：long_add和float_add、以及这里的bytes_concat，在Python的层面都是+这个操作符。然后我们看看底层是怎么对两个字节序列进行相加的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_concat</span><span class="params">(PyObject *a, PyObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//两个局部变量，用于维护缓冲区</span></span><br><span class="line">    Py_buffer va, vb;</span><br><span class="line">    <span class="comment">//result用于保存结果</span></span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将缓冲区的长度设置为-1, 可以认为此时缓冲区啥也没有</span></span><br><span class="line">    va.len = <span class="number">-1</span>;</span><br><span class="line">    vb.len = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将a、b中ob_sval拷贝到缓冲区中，拷贝成功返回0，拷贝失败返回非0</span></span><br><span class="line">    <span class="comment">//如果下面的条件不成功, 就意味着拷贝失败了, 说明至少有一个老铁不是bytes类型</span></span><br><span class="line">    <span class="keyword">if</span> (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) != <span class="number">0</span> ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//然后设置异常，PyExc_TypeError表示TypeError(类型错误)，专门用来指对一个对象执行了它所不支持的操作</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;can&#x27;t concat %.100s to %.100s&quot;</span>,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//比如：&quot;123&quot; + 123, 会得到: TypeError: can&#x27;t concat int to bytes, 和这里设置的异常信息是一样的</span></span><br><span class="line">        <span class="comment">//这里直接跳转到done</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是判断是否有一方长度为0, 如果a长度为0，那么相加之后结果就是b</span></span><br><span class="line">    <span class="keyword">if</span> (va.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(b)) &#123;</span><br><span class="line">        <span class="comment">//将b拷贝给result</span></span><br><span class="line">        result = b;</span><br><span class="line">        <span class="comment">//增加result的引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和上面同理，如果b长度为0，那么相加之后的结果就是a</span></span><br><span class="line">    <span class="keyword">if</span> (vb.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//将a拷贝给result</span></span><br><span class="line">        result = a;</span><br><span class="line">        <span class="comment">//增加引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是判断两个字节序列合并之后，长度是否超过限制，因为不允许超过PY_SSIZE_T_MAX</span></span><br><span class="line">    <span class="comment">//所以更直观的写法应该是 if (va.len + vb.len &gt; PY_SSIZE_T_MAX), 但是这个条件基本不可能满足，除非你写恶意代码</span></span><br><span class="line">    <span class="keyword">if</span> (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话，声明指定容量PyBytesObject</span></span><br><span class="line">    result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, va.len + vb.len);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//将缓冲区va里面内容拷贝到result的ob_sval中，拷贝的长度为va.len</span></span><br><span class="line">        <span class="comment">//PyBytes_AS_STRING是一个宏，用于获取PyBytesObject中的ob_sval</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        <span class="comment">//然后将缓冲区vb里面的内容拷贝到result的ob_sval中，拷贝的长度为vb.len，但是从va.len的位置开始拷贝, 不然会把内容覆盖掉</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="comment">//如果长度不会-1，那么要将缓冲区里面的内容释放掉，否则可能导致内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (va.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    <span class="keyword">if</span> (vb.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    <span class="comment">//返回result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虽然代码很长，但是不难理解。不过可能有人认为为什么非要先将a、b的内容拷贝到Py_buffer里面，再通过Py_buffer拷贝到result里面去呢？直接拷贝不可以吗？答案是Py_buffer提供了一套操作对象缓冲区的统一接口，屏蔽不同类型对象的内部差异。</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223933085-875268687.png" alt="img"></p>
<p><strong>将序列重复多次：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * <span class="number">3</span></span><br><span class="line"><span class="string">b&#x27;abcabcabc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * -<span class="number">1</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span>  <span class="comment"># 如果乘上一个负数，等于乘上0，那么会得到一个空的字节序列</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_repeat</span><span class="params">(PyBytesObject *a, Py_ssize_t n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    Py_ssize_t j;</span><br><span class="line">    Py_ssize_t size;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="type">size_t</span> nbytes;</span><br><span class="line">    <span class="comment">//如果n小于0, 那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里条件写成Py_SIZE(a) * n &gt; PY_SSIZE_T_MAX更容易理解</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; Py_SIZE(a) &gt; PY_SSIZE_T_MAX / n) &#123;</span><br><span class="line">        <span class="comment">//先计算相乘之后字节序列的长度是否超过最大限制，如果超过了，直接报错</span></span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算Py_SIZE(a) * n得到size</span></span><br><span class="line">    size = Py_SIZE(a) * n;</span><br><span class="line">    <span class="keyword">if</span> (size == Py_SIZE(a) &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//如果两者相等，那么证明n = 1，直接增加引用计数，然后返回a即可</span></span><br><span class="line">        Py_INCREF(a);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型转化，此时是size_t类型，相当于无符号64位整型</span></span><br><span class="line">    nbytes = (<span class="type">size_t</span>)size;</span><br><span class="line">    <span class="comment">//PyBytesObject_SIZE是一个宏，表示PyBytesObject的基本大小</span></span><br><span class="line">    <span class="comment">//它是一个宏，等价于(offsetof(PyBytesObject, ob_sval) + 1), 显然是33</span></span><br><span class="line">    <span class="comment">//所以nbytes + PyBytesObject_SIZE就是bytes对象所需要的空间</span></span><br><span class="line">    <span class="comment">//如果nbytes + PyBytesObject_SIZE还小于等于nbytes, 所以相加之后size_t类型存不下了</span></span><br><span class="line">    <span class="comment">//说明超过所占内存的极限了</span></span><br><span class="line">    <span class="keyword">if</span> (nbytes + PyBytesObject_SIZE &lt;= nbytes) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请空间，大小为PyBytesObject_SIZE + nbytes</span></span><br><span class="line">    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + nbytes);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//返回NULL，表示申请失败</span></span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//PyObject_INIT_VAR是一个宏，设置ob_type和ob_size</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size);</span><br><span class="line">    <span class="comment">//设置ob_shash为-1</span></span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将ob_sval最后一位设置为&#x27;\0&#x27;</span></span><br><span class="line">    op-&gt;ob_sval[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然这里是在a对应的bytes对象长度为1时，所走的逻辑</span></span><br><span class="line">        <span class="comment">//直接将op-&gt;ob_sval里面元素设置a-&gt;ob_sval[0], 设置n个</span></span><br><span class="line">        <span class="built_in">memset</span>(op-&gt;ob_sval, a-&gt;ob_sval[<span class="number">0</span>] , n);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则将a -&gt; ob_sval拷贝到op -&gt; ob_sval中, 拷贝n次, 因为size = Py_SIZE(a) * n;</span></span><br><span class="line">    <span class="comment">//这里是先拷贝了一次</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval, a-&gt;ob_sval, Py_SIZE(a));</span><br><span class="line">        i = Py_SIZE(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后拷贝n - 1次</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">        j = (i &lt;= size-i)  ?  i  :  size-i;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval+i, op-&gt;ob_sval, j);</span><br><span class="line">        i += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据索引获取指定元素：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>], <span class="built_in">type</span>(val[<span class="number">1</span>])</span><br><span class="line">(<span class="number">98</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>: <span class="number">4</span>], <span class="built_in">type</span>(val[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">(<span class="string">b&#x27;bcd&#x27;</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_item</span><span class="params">(PyBytesObject *a, Py_ssize_t i)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果i &lt; 0或者 i &gt;= a的ob_size，那么会报错:索引越界</span></span><br><span class="line">    <span class="comment">//但是我们记得Python支持负数索引的啊，是的，只不过会手动帮你变成正的</span></span><br><span class="line">    <span class="comment">//因为C是不支持负数索引的，所以通过C的索引获取，那么索引一定是正的</span></span><br><span class="line">    <span class="comment">//因此我们填上的负数，Python会帮你加上长度。比如：长度为5，但是我们写的索引为-1, 那么Python会帮你变成4之后再获取</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= Py_SIZE(a)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们看到获取第i个元素之后直接转成了PyLongObject，然后返回指针</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)a-&gt;ob_sval[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那切片呢？切片的话对应bytes_subscript，但它不是在PySequenceMethods tp_as_sequence里面，而是在PyMappingMethods bytes_as_mapping里面，它是一个映射操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到映射操作，bytes对象中只有两个，一个bytes_length获取长度，这个在bytes_as_sequence中已经实现了，还有一个就是bytes_subscript进行切片操作</span></span><br><span class="line"><span class="type">static</span> PyMappingMethods bytes_as_mapping = &#123;</span><br><span class="line">    (lenfunc)bytes_length,</span><br><span class="line">    (binaryfunc)bytes_subscript,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>因为映射操作只有两个，一个是重复的，还有一个是必须要在这里说的，所以映射操作我们就放在这里介绍了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject*</span><br><span class="line"><span class="title function_">bytes_subscript</span><span class="params">(PyBytesObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//参数是self和item，那么在Python的层面上就类似于self[item]</span></span><br><span class="line">    <span class="comment">//检测item，看它是不是一个整型</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//如果是转成Ssize_t</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果i小于0，那么将i加上序列的长度，得到正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyBytes_GET_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= PyBytes_GET_SIZE(self)) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                            <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到整型</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)self-&gt;ob_sval[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测是否是一个切片</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//起始、终止、步长、拷贝的字节个数、循环变量</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, i;</span><br><span class="line">        <span class="type">size_t</span> cur; <span class="comment">//拷贝的字节所在的位置</span></span><br><span class="line">        <span class="comment">//两个缓存</span></span><br><span class="line">        <span class="type">char</span>* source_buf;</span><br><span class="line">        <span class="type">char</span>* result_buf;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        <span class="comment">//这里是会将item解包</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到拷贝的字节个数比如：ob_sval长度为9, 但是未必拷贝9个，所以这个slicelength是计算的拷贝的字节个数</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(PyBytes_GET_SIZE(self), &amp;start,</span><br><span class="line">                                            &amp;stop, step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//slicelength小于等于0的话，直接返回空的字节序列，比如val[3: 2]，显然此时是不循环的，因为start对应的位置在end之后，而且步长为正</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果起始位置为0，步长为1，且拷贝的字节个数等于字节序列的长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start == <span class="number">0</span> &amp;&amp; step == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                 slicelength == PyBytes_GET_SIZE(self) &amp;&amp;</span><br><span class="line">                 PyBytes_CheckExact(self)) &#123;</span><br><span class="line">            <span class="comment">//那么增加引用计数，直接返回</span></span><br><span class="line">            Py_INCREF(self);</span><br><span class="line">            <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果步长是1，那么从start开始拷贝，拷贝slicelength个字字节</span></span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(</span><br><span class="line">                PyBytes_AS_STRING(self) + start,</span><br><span class="line">                slicelength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里，说明步长不是1，只能一个一个拷贝了</span></span><br><span class="line">            source_buf = PyBytes_AS_STRING(self);</span><br><span class="line">            <span class="comment">//创建PyBytesObject对象，空间为slicelength</span></span><br><span class="line">            result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, slicelength);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//拿到内部的ob_sval</span></span><br><span class="line">            result_buf = PyBytes_AS_STRING(result);</span><br><span class="line">            <span class="comment">//从start开始然后一个字节一个字节的拷贝过去</span></span><br><span class="line">            <span class="comment">//start开始拷贝，依旧循环slicelength，通过cur记录拷贝的位置，然后每次循环都加上步长step</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += step, i++) &#123;</span><br><span class="line">                result_buf[i] = source_buf[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//item要么是整数、要么是切片，走到这里说明不满足条件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//比如：item我们传递了一个字符串，显然此时在通过这种方式获取的话，这属于字典的操作</span></span><br><span class="line">        <span class="comment">//所以抛出TypeError异常</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;byte indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     Py_TYPE(item)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以从底层我们可以看到，Python为我们做的事情是真的不少，我们通过一个简单的切片，在底层要这么多行代码。不过在我们分析完逻辑之后，会发现其实也不过如此，毕竟逻辑很好理解。</strong></p>
<p><strong>但是在Python中，索引操作和切片操作，我们都可以通过__getitem__实现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">123</span>])  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])  <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>])  <span class="comment"># slice(1, 5, None)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>: <span class="number">2</span>])  <span class="comment"># slice(1, 5, 2)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;yo&quot;</span>: <span class="string">&quot;ha&quot;</span>: <span class="string">&quot;哼哼&quot;</span>])  <span class="comment"># slice(&#x27;yo&#x27;, &#x27;ha&#x27;, &#x27;哼哼&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过__getitem__，我们可以同时实现切片、索引获取，但是当item为字符串时，我们还可以实现字典操作</span></span><br><span class="line"><span class="comment"># 当然这部分内容，我们会在后面系列中分析类的时候介绍。</span></span><br></pre></td></tr></table></figure>

<p><strong>判断一个序列是否在指定的序列中：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;abc&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;cbd&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果让你来实现的话，显然是两层for循环，那么Python是怎么做的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bytes_contains</span><span class="params">(PyObject *self, PyObject *arg)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//比如: b&quot;abc&quot; in b&quot;abcde&quot;会调用这里的bytes_contains</span></span><br><span class="line">    <span class="comment">//self就是b&quot;abcde&quot;对应的PyBytesObject的指针,arg是b&quot;abc&quot;对应的PyBytesObject的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显然这里调用了_Py_bytes_contains, 传入了self -&gt; ob_sval, self -&gt; ob_size, arg</span></span><br><span class="line">    <span class="keyword">return</span> _Py_bytes_contains(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的源码没有说明，显然是在bytesobject.c中</span></span><br><span class="line"><span class="comment">//但是_Py_bytes_contains位于bytes_methods.c中</span></span><br><span class="line">_Py_bytes_contains(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t len, PyObject *arg)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//将arg转成整型, 但是显然只有当arg -&gt; ob_savl的有效字节为1时才可以这么做</span></span><br><span class="line">    Py_ssize_t ival = PyNumber_AsSsize_t(arg, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ival == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="comment">//所以如果ival == -1 &amp;&amp; PyErr_Occurred()，说明arg -&gt; ob_sval的有效字节数大于1</span></span><br><span class="line">        Py_buffer varg;<span class="comment">//缓冲区</span></span><br><span class="line">        Py_ssize_t pos;<span class="comment">//遍历位置</span></span><br><span class="line">        PyErr_Clear();<span class="comment">//这里将异常清空</span></span><br><span class="line">        <span class="comment">//将arg -&gt; ob_sval设置到缓存区中</span></span><br><span class="line">        <span class="keyword">if</span> (PyObject_GetBuffer(arg, &amp;varg, PyBUF_SIMPLE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//调用stringlib_find找到其位置，里面也是使用了循环</span></span><br><span class="line">        pos = stringlib_find(str, len,</span><br><span class="line">                             varg.buf, varg.len, <span class="number">0</span>);</span><br><span class="line">        PyBuffer_Release(&amp;varg); <span class="comment">//释放缓冲区</span></span><br><span class="line">        <span class="comment">//如果pos大于0确实找到了，否则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> pos &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明字节不合法</span></span><br><span class="line">    <span class="keyword">if</span> (ival &lt; <span class="number">0</span> || ival &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;byte must be in range(0, 256)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明是单个字节，直接调用C中memchr去寻找即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memchr</span>(str, (<span class="type">int</span>) ival, len) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p><strong>我们知道Python中对于不可变对象运算的处理方式就是，再创建一个新的。所以三个bytes对象a、b、c相加时，那么会先根据a + b创建新的临时对象，然后再根据”临时对象+c”创建新的对象，返回指针。所以：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> bytes_list:</span><br><span class="line">    result += _</span><br></pre></td></tr></table></figure>

<p><strong>这是一种效率非常低下的做法，因为涉及大量临时对象的创建和销毁，不仅是这里bytes，后面即将分析的字符串也是同样的道理。官方推荐的做法是，使用join，字符串和字节序列都可以对一个列表进行join，将列表里面的多个字符串或者字节序列join在一起。</strong></p>
<p><strong>举个Python中的例子，我们以字符串为例，字节序列同样如此：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad</span>():</span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        s += <span class="built_in">str</span>(_)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">good</span>():</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        l.append(<span class="built_in">str</span>(_))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">better</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">best</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<p>+号在拼接字符串的时候，会先开辟一块空间，把+号左边的字符串和+号右边的字符串合起来放在新开辟的空间内，这样有几个+号，就会开辟几次空间。<br>加号操作符</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210306369.png" alt="image-20230315210306369"></p>
<p>join拼接字符串也需要开辟空间，但是会提前算好总共需要开辟多大的空间，一次性把内存申请好，然后把所有的字符串合起来放在这个新的空间中，这样就不用频繁申请空间了。节约空间又节约时间。<br>join连接</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210318179.png" alt="image-20230315210318179"></p>
<p>从上面的例子中，可以看到join比+少申请了一块a+b的空间。</p>
<h3 id="字节序列缓冲池"><a href="#字节序列缓冲池" class="headerlink" title="字节序列缓冲池"></a>字节序列缓冲池</h3><p><strong>为了优化单字节bytes对象的创建效率，Python底层内部维护了一个缓冲池。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyBytesObject *characters[UCHAR_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>Python内部创建单字节bytes对象时，先检查目标对象是否已在缓冲池中。PyBytes_FromStringAndSize函数是负责创建bytes对象的通用接口，同样位于 Objects&#x2F;bytesobject.c 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyBytesObject对象的指针</span></span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然size不可以小于0</span></span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;Negative size passed to PyBytes_FromStringAndSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size为1表名创建的是单字节对象，当然str不可以为NULL, 而且获取到的字节必须要在characters里面</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        _Py_one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	</span></span><br><span class="line">        <span class="comment">//增加引用计数，返回指针</span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话创建新的PyBytesObject，此时是个空</span></span><br><span class="line">    op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//不管size是多少，都直接拷贝即可</span></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line">    <span class="comment">//但是size是1的话，除了拷贝还会放到缓存池characters中</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回其指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，当 Python 程序开始运行时，字符缓冲池是空的。随着单字节 bytes*对象的创建，缓冲池中的对象慢慢多了起来。</strong></p>
<p><strong>这样一来，字符对象首次创建后便在缓冲池中缓存起来；后续再次使用时，  Python 直接从缓冲池中取，避免重复创建和销毁。与前面章节介绍的小整数对象池一样，字符对象只有为数不多的 256  个，但使用频率非常高。缓冲池技术作为一种以时间换空间的优化手段，只需较小的内存为代价，便可明显提升执行效率。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然此时不需要我解释了，单字节bytes对象会缓存起来，不是单字节则不会缓存。</strong></p>
<h3 id="bytearray对象"><a href="#bytearray对象" class="headerlink" title="bytearray对象"></a>bytearray对象</h3><p><strong>除了bytes对象之外，Python中还有一个bytearray对象，它和bytes对象类似，只不过bytes对象是不可变的，而bytearray对象是可变的。所以就不单独分析了，这里简单提一嘴。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入一个整型组成的列表创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>([<span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;cde&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个bytes对象创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个字符串，同时指定encoding编码创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">&quot;古明地觉&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们对s进行decode会直接得到字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：bytearray对象是可以变的</span></span><br><span class="line"><span class="comment"># 如果是中文，为了防止出现乱码，所以一次要改变3个字节</span></span><br><span class="line">s[-<span class="number">3</span>:] = <span class="string">&quot;恋&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe6\x81\x8b&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地恋</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们同样可以根据索引、切片获取</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="comment"># 获取单个元素也会得到整型，这一点和bytes对象是一样的</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>])  <span class="comment"># 97 98 99</span></span><br><span class="line"><span class="comment"># 通过切片得到bytearray</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">2</span>])  <span class="comment"># bytearray(b&#x27;ab&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对多个bytearray对象进行join, 会得到一个bytes对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;--&quot;</span>.join([<span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>), <span class="built_in">bytearray</span>(<span class="string">b&quot;def&quot;</span>)]))  <span class="comment"># b&#x27;abc--def&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此把bytearray对象想象成可变的bytes对象即可，它的使用和bytes对象非常类似，一些操作的行为也是一样的，所以就不单独分析了，下一篇将会分析Python中的字符串。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们分析了bytes对象的底层实现，我们说：</strong></p>
<ul>
<li><code>bytes对象是一个变长、不可变对象，内部的值是通过一个C的字符数组来维护的;</code></li>
<li><code>bytes也是序列型操作，它支持的操作在bytes_as_sequence中;</code></li>
<li><code>Python内部维护字符缓冲池来优化单字节bytes对象的创建和销毁操作;</code></li>
<li><code>缓冲池是一种常用的以空间换时间的优化技术;</code></li>
</ul>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Python引用计数器和底层对象管理</title>
    <url>/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="03-Python引用计数器以及底层对象管理"><a href="#03-Python引用计数器以及底层对象管理" class="headerlink" title="03-Python引用计数器以及底层对象管理"></a>03-Python引用计数器以及底层对象管理</h2><p>在上一篇中我们说到了Python中的对象在底层的数据结构，我们知道Python底层通过<strong>PyObject</strong>和<strong>PyTypeObject</strong>完成了C++所提供的对象的多态特性。在Python中创建一个对象，会分配内存并进行初始化，然后Python会用一个PyObject *来保存和维护这个对象，当然所有对象都是如此。因为指针是可以相互转化的，所以变量在保存一个对象的指针时，会将该指针转成PyObject *之后再交给变量保存。因此在Python中，变量的传递<code>(包括函数的参数传递)</code>实际上传递的都是一个泛型指针：PyObject *。这个指针具体是指向的什么类型我们并不知道，只能通过其内部的ob_type成员进行动态判断，而正是因为这个ob_type，Python实现了多态机制。</p>
<p>比如：a.pop()，我们不知道这个a指向的对象到底是什么类型，但只要a可以调用pop方法即可，因此a可以是一个列表、也可以是一个字典、或者是我们实现了pop方法的类的实例对象。所以如果a的ob_type是一个PyList_Type  *，那么就调用PyList_Type中定义的pop操作；如果a的ob_type是一个PyDict_Type，那么就调用PyDict_Type中定义的pop操作。</p>
<blockquote>
<p><strong>所以变量a在不同的情况下，会表现出不同的行为，这正是Python多态的核心所在。</strong></p>
</blockquote>
<p>再比如列表，其内部的元素都是PyObject *，当我们通过索引获取到该指针进行操作的时候，会先通过ob_type获取其类型指针，然后再获取该操作对应的C一级的函数、进行执行，如果不支持相应的操作便会报错。</p>
<p><strong>从这里我们也能看出来Python为什么慢了，因为有相当一部分时间浪费在类型和属性的查找上面。</strong></p>
<blockquote>
<p><strong>以变量a +  b为例，这个a和b指向的对象可以是整型、浮点型、字符串、列表、元组、甚至是我们自己实现了某个魔法方法的类的实例对象，因为我们说Python中的变量都是一个PyObject *，所以它可以指向任意的对象，因此Python它就无法做基于类型方面的优化。</strong></p>
<p><strong>首先Python要通过ob_type判断变量到底指向的是什么类型，这在C级至少需要一次属性查找。然后Python将每一个操作都抽象成了一个魔法方法，所以实例相加时要在对应的类型对象中找到该方法对应的函数指针，这又是一次属性查找。找到了之后将a、b作为参数传递进去，这会发生一次函数调用，会将a和b中维护的值拿出来进行运算，然后根据相加结果创建一个新的对象，再返回其对应的PyObject *指针。</strong></p>
<p><strong>而对于C来讲，由于已经规定好了类型，所以a + b在编译之后就是一条简单的机器指令，所以两者在效率上差别很大。</strong></p>
</blockquote>
<p><strong>当然我们不是来吐槽Python效率的问题的，因为任何语言都擅长的一面和不擅长的一面，只是通过回顾前面的知识来解释为什么Python效率慢。</strong></p>
<blockquote>
<p><strong>因此当别人问你Python为什么效率低的时候，希望你能从这个角度来回答它。不要动不动就GIL，那是在多线程情况下才需要考虑的问题，所以有时真的很反感那些在没涉及到多线程的时候还提Python GIL的人。</strong></p>
</blockquote>
<p><strong>简单回顾了一下前面的内容，下面我们说一说Python中的对象从创建到销毁的过程，了解一下Python中对象的生命周期。</strong></p>
<h3 id="Python-x2F-C-API"><a href="#Python-x2F-C-API" class="headerlink" title="Python&#x2F;C API"></a>Python&#x2F;C API</h3><p>当我们在控制台敲下这个语句的时候，Python内部是如何从无到有创建一个浮点数对象的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; e = 2.71</span><br></pre></td></tr></table></figure>

<p>另外Python又是怎么知道该如何将它打印到屏幕上面呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(e)</span><br><span class="line">2.71</span><br></pre></td></tr></table></figure>

<p>对象使用完毕时，Python还要将其销毁，那么销毁的时机又该如何确定呢？带着这些问题，我们来探寻一个对象从创建到销毁整个生命周期中的行为表现，然后从中寻找答案。</p>
<p>不过在探寻对象的创建之前，先介绍Python提供的C API，也叫Python&#x2F;C API。</p>
<p>Python对外提供了C API，让用户可以从C环境中与其交互。实际上，由于Python解释器是用C写成的，所以Python内部本身也在大量使用这些C API。为了更好的研读源码，系统地了解这些API的组成结构是很有必要的，而C API分为两类：<font color="red">泛型API和特型API</font></p>
<p><font color="red"><strong>泛型API</strong></font></p>
<p>“泛型API”与类型无关，属于”抽象对象层(Abstract Object Layer，AOL)”，这类API的第一个参数是PyObject  *，可以处理任意类型的对象，API内部会根据对象的类型进行区别处理。而且泛型API名称也是有规律的，具有PyObject_xxx这种形式。</p>
<p>以对象打印函数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PyObject_Print</span><span class="params">(PyObject *op, FILE *fp, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<p>接口的第一个参数为待打印的对象的指针，可以是任意类型的对象的指针，因此参数类型是PyObject *。而我们说PyObject  *是Python底层的一个泛型指针，通过这个泛型指针来实现多态的机制。第二个参数是文件句柄，表示输出的位置，默认是stdout、即控制台；而flags表示是要以<code>__str__</code>打印还是要以<code>__repr__</code>打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有两个PyObject *, fo和lo</span></span><br><span class="line"><span class="comment">// fo指向PyFloatObject, lo指向PyLongObject, 但是它们在打印的时候都可以调用这个相同的打印方法</span></span><br><span class="line">PyObject_Print(fo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">PyObject_Print(lo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PyObject_Print接口内部会根据对象类型，决定如何输出对象。</strong></p>
<p><font color="red"><strong>特型API</strong></font></p>
<p>特型API与类型相关，属于”具体对象层(Concrete Object Layer，COL)”。这类API只能作用于某种具体类型的对象，比如：浮点数PyFloatObject，而Python内部为每一种内置对象的实例对象都提供了很多的特型API。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过C的中double创建PyFloatObject</span></span><br><span class="line">PyObject* <span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过C中的long创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromLong</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="comment">// 通过C中的char *来创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **pend, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure>

<p><strong>特型API也是有规律的，尤其是关于C类型和Python类型互转的时候，会用到以下两种特型API：</strong></p>
<ul>
<li><code>Py###_From@@@: 根据C的对象创建Python的对象，###表示Python的类型， @@@表示C的类型，比如PyFloat_FromDouble表示根据C中的double创建Python的float。</code></li>
<li><code>Py###_As@@@: 根据Python的对象创建C的对象,  ###表示Python的类型，@@@表示C的类型，比如PyFloat_AsDouble表示根据Python的float创建C的double;  PyLong_AsLong表示根据Python中的int创建C中的long，因为Python中的int是没有长度限制的，所以在底层使用的是PyLongObject，而不是PyIntObject。</code></li>
</ul>
<p><strong>了解了Python&#x2F;C API之后，我们看对象是如何创建的。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>经过前面的理论学习，我们知道对象的 ** <font color="red">元数据</font>保存在对应的<font color="red">类型对象</font>，元数据当然也包括对象如何创建等信息。</strong></p>
<blockquote>
<p><strong>比如执行pi &#x3D; 3.14，那么这个过程都发生了什么呢？首先解释器会根据3.14推断出要创建的对象是浮点数，所以会创建出维护的值为3.14的PyFloatObject，并将其指针转化成PyObject *交给变量pi。</strong></p>
<p><strong>另外需要注意的是，我们说对象的元数据保存在对应的类型对象中，这就意味着对象想要被创建是需要借助对应的类型对象的，但是这是针对于创建我们自定义的类的实例对象而言。创建内置类型的实例对象是直接创建的，至于为什么，我们下面会说。</strong></p>
</blockquote>
<p><strong>而创建对象的方式有两种，一种是通过”泛型API”创建，另一种是通过”特型API”创建。比如创建一个浮点数：</strong></p>
<p><font color="cornflowerblue"><strong>使用泛型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyObject_New(PyObject, &amp;PyFloat_Type);</span><br></pre></td></tr></table></figure>

<p><font color="cornflowerblue"><strong>使用特型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyFloat_FromDouble(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyTupleObject</span></span><br><span class="line">PyObject* tpl = PyTuple_New(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyListObject, 当然了这是初始容量, 列表可以扩容的</span></span><br><span class="line">PyObject* tpl = PyList_New(<span class="number">5</span>);    </span><br></pre></td></tr></table></figure>

<p>但不管采用哪种方式创建，最终的关键步骤都是分配内存，而创建内置类型的实例对象，Python是可以直接分配内存的。因为它们有哪些成员在底层都是写死的，而Python对它们了如指掌，因此可以通过Python&#x2F;C  API直接分配内存并初始化。以PyFloat_FromDouble为例，直接在接口内部为PyFloatObject结构体实例分配内存，并初始化相关字段即可。</p>
<blockquote>
<p><strong>比如：pi &#x3D; 3.14，解释器通过3.14知道要创建的对象是PyFloatObject，那么直接根据PyFloatObject里面的成员算一下就可以了，一个引用计数<code>(ob_refcnt)</code> + 一个指针<code>(ob_type)</code> + 一个double<code>(ob_fval)</code> 显然是24个字节，所以直接就分配了。然后将ob_refcnt始化为1，ob_type设置为&amp;PyFloat_Type，ob_fval设置为3.14即可。</strong></p>
<p><strong>同理可变对象也是一样，因为成员都是固定的，类型、以及内部容纳的元素有多少个也可以根据赋的值得到，所以内部的所有元素<code>(PyObject \*)</code>占用了多少内存也是可以算出来的，因此也是可以直接分配内存的。</strong></p>
</blockquote>
<p>但对于我们自定义的类型就不行了，假设我们通过class Girl:定义了一个类，显然实例化的时候不可能通过<code>PyGirl_New</code>、或者<code>PyObject_New(PyObject, &amp;PyGirl_Type)</code>这样的API去创建，因为根本就没有PyGirl_New这样的API，也没有PyGirl_Type这个类型对象。这种情况下，创建Girl的实例对象就需要Girl这个类型对象来创建了。因此自定义类的实例对象如何分配内存、如何进行初始化，答案是需要在对应的类型对象里面寻找的。</p>
<p><strong>总的来说：Python内部创建一个对象的方法有两种：</strong></p>
<ul>
<li><code>通过Python/C API，可以是泛型API、也可以是特型API，用于内置类型；</code></li>
<li><code>通过对应的类型对象去创建，多用于自定义类型；</code></li>
</ul>
<p>​        抛出个问题: e &#x3D; 2.71 和 e &#x3D; float(2.71)得到的结果都是2.71，但它们之间有什么不同呢。或者说列表: lst &#x3D; [] 和 lst &#x3D; list()得到的lst也都是一个空列表，但这两种方式有什么区别呢？    </p>
<p>我们说创建实例对象可以通过Python&#x2F;C API，用于内置类型；也可以通过对应的类型对象去创建，多用于自定义类型。但是通过对应类型对象去创建实例对象其实是一个更加通用的流程，因为它除了支持自定义类型之外、还支持内置类型。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst = []  # 通过Python/C API创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; lst = list()  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; e = 2.71  # 通过Python/C API创建 </span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt; e = float(2.71)  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到了对象的两种创建方式，我们写上2.71、或者[]，Python会直接解析成底层对应的数据结构；而float(2.71)、或者list()，虽然结果是一样的，但是我们看到这是一个调用，因此要进行参数解析、类型检测、创建栈帧、销毁栈帧等等，所以开销会大一些。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = []</span><br><span class="line">t2 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t2 - t1)  <span class="comment"># 0.5595989</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t3 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = <span class="built_in">list</span>()</span><br><span class="line">t4 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t4 - t3)  <span class="comment"># 1.1722419999999998</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>通过[]的方式创建一千万次空列表需要0.56秒，但是通过list()的方式创建一千万次空列表需要1.17秒，主要就在于list()是一个调用，而[]直接会被解析成底层对应的PyListObject，因此[]的速度会更快一些。同理3.14和float(3.14)也是如此。</strong></p>
</blockquote>
<p><strong>虽说使用Python&#x2F;C API的方式创建的速度会更快一些，但这是针对内置类型而言。以我们上面那个自定义了Girl为例，如果想创建一个Girl的实例对象，除了通过Girl这个类型对象去创建，你还能想到其它方式吗？</strong></p>
<blockquote>
<p><strong>列表的话：可以list()、也可以[]；元组：可以tuple()、也可以()；字典：可以dict()、也可以{}，前者是通过类型对象去创建的，后者是通过Python&#x2F;C API创建，会直接解析为对应的C一级数据结构。因为这些结构在底层都是已经实现好了的，是可以直接用的，无需通过调用的方式。</strong></p>
<p><strong>但是显然自定义类型就没有这个待遇了，它的实例对象只能通过它自己去创建，比如：Girl这个类，Python不可能在底层定义一个PyGirlObject、然后把API提供给我们。所以，我们只能通过Girl()这种方式去创建Girl的实例对象。</strong></p>
</blockquote>
<p><strong>所以我们需要通过Girl这个类来创建它的实例对象，也就是调用Girl这个类，而一个对象可以是可调用的，也可以是不可调用的。如果一个对象可以被调用，那么这个对象就是callable，否则就不是callable。</strong></p>
<p><strong>而决定一个对象是不是callable，就取决于其对应的类型对象中是否定义了某个方法。如果从Python的角度看的话，这个方法就是<code>__call__</code>，从解释器角度看的话，这个方法就是tp_call。</strong></p>
<p><font color="red"><strong>1. 从Python的角度来看对象的调用：</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int可以调用, 那么它的类型对象(type)内部一定有__call__方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(<span class="built_in">type</span>, <span class="string">&quot;__call__&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 因为我们自定义的类A里面没有__call__, 所以a是不可以被调用的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 告诉我们A的实例对象不可以被调用</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;A&#x27; object is not callable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们给A设置了一个__call__</span></span><br><span class="line"><span class="built_in">type</span>.__setattr__(A, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="comment"># 发现可以调用了</span></span><br><span class="line"><span class="built_in">print</span>(a())  <span class="comment"># 这是__call__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这就是动态语言的特性, 即便在类创建完毕之后, 依旧可以通过type进行动态设置</span></span><br><span class="line"><span class="comment"># 而这在静态语言中是不支持的, 所以type是所有类的元类, 它控制了我们自定义类的生成过程</span></span><br><span class="line"><span class="comment"># type这个古老而又强大的类可以让我们玩出很多新花样</span></span><br><span class="line"><span class="comment"># 但是对于内置的类type是不可以对其动态增加、删除或者修改的，因为内置的类在底层是静态定义好的</span></span><br><span class="line"><span class="comment"># 因为从源码中我们看到, 这些内置的类、包括元类，它们都是PyTypeObject对象, 在底层已经被声明为全局变量了</span></span><br><span class="line"><span class="comment"># 所以type虽然是所有类型对象的元类，但是只有在面对我们自定义的类的时候，type具有增删改的能力</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">type</span>.__setattr__(<span class="built_in">dict</span>, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;dict&#x27;</span></span><br><span class="line"><span class="comment"># 我们看到抛异常了, 提示我们&quot;不可以给内置/扩展类型dict设置属性&quot;</span></span><br><span class="line"><span class="comment"># 而dict属于内置类型，至于扩展类型是我们在编写扩展模块中定义的类</span></span><br><span class="line"><span class="comment"># 内置类和扩展类是等价的，它们直接就指向了C一级的数据结构, 不需要经历被解释器解释这一步</span></span><br><span class="line"><span class="comment"># 而动态特性是解释器在解释执行字节码(翻译成C级代码执行)的时候动态赋予的</span></span><br><span class="line"><span class="comment"># 而内置类/扩展类它们本身就已经是指向C一级的数据结构了，绕过了解释器解释执行这一步, 所以它们的属性不能被动态设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__dict__[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 它们的属性字典也是不可以设置的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>: </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line">g.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="comment"># 实例对象我们也可以手动设置属性</span></span><br><span class="line"><span class="built_in">print</span>(g.a)  <span class="comment"># xx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 但是内置类型的实例对象是不可以的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;list&#x27; object has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># 可能有人奇怪了，为什么不行呢？</span></span><br><span class="line"><span class="comment"># 答案是内置类型的实例对象没有__dict__属性字典, 有多少属性或方法底层已经定义好了，不可以动态添加</span></span><br><span class="line"><span class="comment"># 如果我们自定义类的时候，设置了__slots__, 那么效果和内置的类是相同的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(lst, <span class="string">&quot;__dict__&quot;</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>2. 从解释器的角度来看对象的调用：</strong></font></p>
<p><strong>我们以内置类型float为例，我们说创建一个PyFloatObject，可以通过3.14或者float(3.14)的方式。前者使用Python&#x2F;C  API创建，3.14直接被解析为C一级数据结构PyFloatObject的对象；后者使用类型对象创建，通过对float进行一个调用、将3.14作为参数，最终也得到指向C一级数据结构PyFloatObject的对象。Python&#x2F;C API的创建方式我们已经很清晰了，就是根据值来推断在底层应该对应哪一种数据结构，然后直接创建即可。我们重点看一下通过调用来创建实例对象的方式。</strong></p>
<p><strong>如果一个对象可以被调用，我们说它的类型对象中一定要有tp_call<code>(更准确的说成员tp_call的值一定一个是函数指针, 不可以是0)</code>，而PyFloat_Type是可以调用的，这就说明PyType_Type内部的tp_call是一个函数指针，这在Python的层面是上我们已经验证过了，下面我们就来看看。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="comment">//...                                          /* tp_hash */</span></span><br><span class="line">    (ternaryfunc)type_call,                     <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="green"><strong>我们看到在实例化PyType_Type的时候PyTypeObject内部的成员tp_call被设置成了type_call，这是一个函数指针，当我们调用PyFloat_Type的时候，会触发这个type_call指向的函数。</strong></font></p>
<p>因此float(3.14)在C层面上等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFloat_Type.ob_type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">//即：</span></span><br><span class="line">PyType_Type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">// 而在创建PyType_Type的时候，给tp_call成员传递的是type_call, 因此最终相当于</span></span><br><span class="line">type_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>

<p><strong>调用参数通过args和kwargs两个对象传递，关于参数传递暂时先不展开，留到函数机制中再详细介绍。</strong></p>
<p><strong>然后我们围观一下type_call函数，它位于Object&#x2F;typeobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 如果我们调用的是float，那么显然这里的type就是&amp;PyFloat_Type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是声明一个PyObject *，显然这是要返回的实例对象的指针</span></span><br><span class="line">    PyObject *obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里的tp_new是什么估计有人已经猜到了，我们说__call__对应底层的tp_call</span></span><br><span class="line">    <span class="comment">//那么这里tp_new呢？然后对应Python中的__new__方法，这里是为实例对象分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;cannot create &#x27;%.100s&#x27; instances&quot;</span>,</span><br><span class="line">                     type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过tp_new分配空间，此时实例对象就已经创建完毕了，这里会返回其指针</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line">    <span class="comment">//类型检测，暂时不用管</span></span><br><span class="line">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断参数的，我们说这里的参数type是类型对象，但也可以是元类，元类也是由PyTypeObject结构体实例化得到的</span></span><br><span class="line">    <span class="comment">//元类在调用的时候执行的依旧是type_call，所以这里是检测type指向的是不是PyType_Type</span></span><br><span class="line">    <span class="comment">//如果是的话，那么实例化得到的obj就不是实例对象了，而是类型对象，要单独检测一下</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span><br><span class="line">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (kwds == <span class="literal">NULL</span> ||</span><br><span class="line">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="number">0</span>)))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，后面为了方便在Python层面就不提指针了，直接用实例对象代替了</span></span><br><span class="line">    <span class="comment">//但如果返回的不是，那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//拿到obj的类型</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//执行tp_init，显然这个tp_init就是__init__函数，这与Python中类的实例化过程是一致的。</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//执行tp_init, 设置参数</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//执行失败，将引入计数减1，然后将obj设置为NULL</span></span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回obj</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此从上面我们可以看到关键的部分有两个：</strong></p>
<ul>
<li><code>调用类型对象的tp_new函数指针指向的函数为实例对象申请内存。</code></li>
<li><code>调用tp_init函数指针指向的函数为实例对象进行初始化，也就是设置属性。</code></li>
</ul>
<p><strong>所以这对应Python中的<code>__new__</code>和<code>__init__</code>，我们说<code>__new__</code>是为实例对象开辟一份内存，然后返回指向这片内存<code>(对象)</code>的指针，会自动传递给<code>__init__</code>中的self。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        <span class="comment"># 写法非常固定，调用object.__new__(cls)就会创建Girl的实例对象</span></span><br><span class="line">        <span class="comment"># 因此这里的cls指的就是这里的Girl, 但是一定要返回, 因为__new__会将自己的返回值交给__init__中的self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl(<span class="string">&quot;古明地觉&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(g.name, g.age)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">__init__方法执行啦</span></span><br><span class="line"><span class="string">古明地觉 16</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>*<em>但是注意：__new__里面的参数要和__init__里面的参数保持一致，因为我们会先执行__new__，然后解释器会将__new__的返回值和我们传递的参数组合起来一起传递给self。因此__new__里面的参数位置除了cls之外，一般都会写*args和*<em>kwargs。</em></em></p>
<p><strong>然后再回过头来看一下type_call中的这几行代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，但如果返回的不是</span></span><br><span class="line">    <span class="comment">//那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说tp_new应该返回该类型对象的实例对象指针，而且一般情况下我们是不写__new__的，会默认执行。但是我们一旦重写了，那么必须要手动返回object.<strong>new</strong>(cls)，那么如果我们不返回，或者返回其它的话，会怎么样呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="comment"># 打印看看instance到底是个什么东东</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;instance:&quot;</span>, instance)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;type(instance):&quot;</span>, <span class="built_in">type</span>(instance))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正确做法是将instance返回, 但是我们不返回, 而是返回个123</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">instance: &lt;__main__.Girl object at 0x000002C0F16FA1F0&gt;</span></span><br><span class="line"><span class="string">type(instance): &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里面有很多可以说的点，首先就是__init__里面需要两个参数，但是我们没有传，却还不报错。原因就在于这个__init__压根就没有执行，因为__new__返回的不是Girl的实例对象。</strong></p>
<p><strong>通过打印instance，我们知道了object.<strong>new</strong>(cls)返回的就是cls的实例对象，而这里的cls就是Girl这个类本身，我们必须要返回instance，才会执行对应的__init__，否则__new__直接就返回了。我们来打印一下其返回值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g, <span class="built_in">type</span>(g))  <span class="comment"># 123 &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到直接打印的就是123，所以再次总结一些tp_new和tp_init之间的区别，当然也对应__new__和__init__的区别：</strong></p>
<ul>
<li><code>tp_new：为该类型对象的实例对象申请内存，在Python的__new__方法中通过object.__new__(cls)的方式申请，然后将其返回。</code></li>
<li><code>tp_init：tp_new的返回值会自动传递给self，然后为self绑定相应的属性，也就是执行构造函数进行初始化。</code></li>
</ul>
<blockquote>
<p><strong>但如果tp_new返回的不是对应类型的实例对象指针，比如type_call中第一个参数接收的&amp;PyFloat_Type，但是tp_new中返回的却是PyLongObject类型的指针，所以此时就不会执行tp_init。</strong></p>
<p><strong>以Python为例，我们Girl中的__new__应该返回Girl的实例对象才对，但实际上返回了整型，因此类型不一致，所以不会执行__init__。</strong></p>
</blockquote>
<p><strong>所以通过类型对象去创建实例对象的整体流程如下：</strong></p>
<ul>
<li><code>1. 获取类型对象的类型对象，说白了就是元类，执行元类中的type_call指向的函数；</code></li>
<li><code>2.  tp_call会调用该类型对象的tp_new指向的函数，如果tp_new为NULL(实际上肯定不会NULL，但是我们假设为NULL)，那么会到tp_base指定的父类里面去寻找tp_new。在新式类当中，所有的类都继承自object，因此最终会找到一个不为NULL的tp_new。然后通过tp_new会访问对应类型对象中的tp_basicsize信息，继而完成申请内存的操作。这个信息记录着一个该对象的实例对象需要占用多大内存。在为实例对象分配空间之后，会将指向这片空间的指针交给tp_init；</code></li>
<li><code>3. 在调用type_new完成创建对象之后，流程就会转向PyLong_Type的tp_init，完成初始化对象的工作。当然这个tp_init也可能不被调用，原因我们上面已经分析过了；</code></li>
</ul>
<p><strong>所以我们说Python中__new__调用完了会自动调用__init__，而且还会将其返回值传递给__init__中的第一个参数。那是因为在type_call中先调用的tp_new，然后再调用的tp_init，同时将tp_new的返回值传进去了。从源码的角度再分析一遍：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//当我们创建一个类的实例对象的时候，会去调用元类的__call__方法，所以是这里的tp_call</span></span><br><span class="line">    <span class="comment">//比如Girl(&quot;古明地觉&quot;, 16) 等价于 type.__call__(Girl, &quot;古明地觉&quot;, 16)</span></span><br><span class="line">    <span class="comment">//所以走到了这一步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用__new__方法， 拿到其返回值</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用__init__，将返回值obj传递给__init__中的self，并在里面设置属性</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此底层所表现出来的和我们在Python中看到的，是一样的。</strong></p>
<h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><p>​        我们说Python创建一个对象，比如PyFloatObject，会分配内存并进行初始化。然后Python内部会统一使用一个叫做PyObject*的泛型指针来保存和维护这个对象，而不是PyFloatObject *。    </p>
<p>​    	通过PyObject *保存和维护对象，可以实现更加抽象的上层逻辑，而不用关心对象的实际类型和实现细节。比如：哈希计算 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数可以计算任意对象的哈希值，而不用关心对象的类型是啥，它们都可以使用这个函数。</p>
<p><strong>但是不同类型的对象，其行为也千差万别，哈希值计算的方式也是如此，那么PyObject_Hash函数是如何解决这个问题的呢？不用想，因为元信息存储在对应的类型对象之中，所以肯定会通过其ob_type拿到指向的类型对象。而类型对象中有一个成员叫做tp_hash，它是一个函数指针，指向的函数专门用来计算其实例对象的哈希值，我们看一下PyObject_Hash的函数定义吧，它位于Object&#x2F;Object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//Py_TYPE是一个宏，用来获取一个PyObject *内部的ob_type，不过从名字也能看出来</span></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(v);</span><br><span class="line">    <span class="comment">//获取对应的类型对象内部的tp_hash方法，tp_hash是一个函数指针</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果tp_hash不为空,证明确实指向了具体的hash函数，那么拿到拿到函数指针之后，通过*获取对应的函数</span></span><br><span class="line">        <span class="comment">//然后将PyObject *传进去计算哈希值，返回。</span></span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果tp_hash为空，那么有两种可能。1. 说明该类型对象可能还未初始化, 导致tp_hash暂时为空; 2. 说明该类型本身就不支持其&quot;实例对象&quot;被哈希</span></span><br><span class="line">    <span class="comment">// 如果是第1种情况，那么它的tp_dict、也就是属性字典一定为空，tp_dict是动态设置的，因此它若为空，是该类型对象没有初始化的重要特征</span></span><br><span class="line">    <span class="comment">//如果它不为空，说明类型对象一定已经被初始化了，所以此时tp_hash为空，就真的说明该类型不支持实例对象被哈希</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，那么先进行类型的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后再看是否tp_hash是否为空，为空的话，说明不支持哈希</span></span><br><span class="line">        <span class="comment">//不为空则调用对应的哈希函数</span></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里代表以上条件都不满足，说明该对象不可以被hash</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数先通过ob_type指针找到对象的类型，然后通过类型对象的tp_hash函数指针调用对应的哈希计算函数。所以PyObject_Hash根据对象的类型，调用不同的哈希函数，这不正是实现了多态吗？</strong></p>
<blockquote>
<p><strong>通过ob_type字段，Python在C语言的层面实现了对象的多态特性，思路跟C++中的”虚表指针”有着异曲同工之妙。</strong></p>
</blockquote>
<p><strong>另外可能有人觉得这个函数的源码写的不是很精简，比如一开始已经判断过内部的tp_hash是否为NULL，然后在下面又判断了一次。那么可不可以先判断tp_dict是否为NULL，为NULL进行初始化，然后再判断tp_hash是否NULL，不为NULL的话执行tp_hash。这样的话，代码会变得精简很多。</strong></p>
<blockquote>
<p><strong>答案是可以的，而且这种方式似乎更直观，但是效率上不如源码。因为我们这种方式的话，无论是什么对象，都需要判断其类型对象中tp_dict和tp_hash是否为NULL。而源码中先判断tp_hash是否为NULL，不为NULL的话就不需要再判断tp_dict了；如果tp_hash为NULL，再判断是否tp_dict也为NULL，如果tp_dict为NULL则初始化，再进一步再判断tp_hash是否还是NULL。所以对于已经初始化<code>(tp_hash不为NULL)</code>的类型对象，源码中少了一次对tp_dict是否为NULL的判断，所以效率会更高。</strong></p>
<p><strong>当然这并不是重点，我想说的重点是类似于<code>先判断tp_hash是否为空、如果不为空则直接调用</code>这种方式，叫做CPython中的快分支。而且CPython中还有很多其它的快分支，快分支的特点就是命中率极高，可以尽早做出判断、尽早处理。回到当前这个场景，只有当类型未被初始化的时候，才会不走快分支，而其余情况都走快分支。也就是说快分支只有在第一次调用的时候才可能不会命中，其余情况都是命中，因此没有必要每次都对tp_dict进行判断。所以源码的设计是非常合理的，我们在后面分析函数调用的时候，也会看到很多类似于这样的快分支。</strong></p>
<p><strong>再举个生活中的栗子解释一下快分支：好比你去见心上人，但是心上人说你今天没有打扮，于是你又跑回去打扮一番之后再去见心上人。所以既然如此，那为什么不能先打扮完再去见心上人呢？答案是在绝大部分情况下，即使你不打扮，心上人也不会介意，只有在极少数情况下，比如心情不好，才会让你回去打扮之后再过来。所以不打扮直接去见心上人就能牵手便属于快分支，它的特点就是命中率极高，绝大部分都会走这个情况，所以没必要每次都因为打扮耽误时间，只有在极少数情况下快分支才不会命中。</strong></p>
</blockquote>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p>这里说一句，关于对象我们知道Python中的类型对象和实例对象都属于对象，但是我们更关注的是实例对象的行为。</p>
<p>而不同对象的行为不同，比如hash值的计算方法就不同，由类型对象中tp_hash字段决定。但除了tp_hash，PyTypeObject中还定义了很多函数指针，这些指针最终都会指向某个函数，或者为空表示不支持该操作。这些函数指针可以看做是”类型对象”中定义的操作，这些操作决定了其”实例对象”在运行时的”行为”。虽然所有类型对象在底层都是由同一个结构体PyTypeObject实例化得到的，但内部成员接收的值不同，得到的类型对象就不同；类型对象不同，导致其实例对象的行为就不同，这也正是一种对象区别于另一种对象的关键所在。</p>
<blockquote>
<p><strong>比如列表支持append，这说明在PyList_Type中肯定有某个函数指针，能够找到用于列表append操作的函数。</strong></p>
<p><strong>整型支持除法操作，说明PyLong_Type中也有对应除法操作的函数指针。</strong></p>
<p><strong>整型、浮点型、字符串、元组、列表都支持加法操作，说明它们也都有对应加法操作的函数指针，并且类型不同，也会执行不同的加法操作。比如：1 + 1 &#x3D; 2，”xx” + “yy” &#x3D;  “xxyy”，不可能对字符串使用整型的加法操作。而字典不支持加法操作，说明创建PyDict_Type的时候，没有给相应的结构体成员设置函数指针，可能传了一个空。</strong></p>
</blockquote>
<p><strong>而根据支持的操作不同，Python中可以将对象进行以下分类：</strong></p>
<ul>
<li><code>数值型操作：比如整型、浮点型的加减乘除；</code></li>
<li><code>序列型操作：比如字符串、列表、元组的通过索引、切片取值行为；</code></li>
<li><code>映射型操作：比如字典的通过key映射出value，相当于y = f(x)，将x传进去映射出y；另外有一本专门讲Python解释器的书，基于Python2.5，书中的这里不叫映射型，而是叫关联型。但我个人喜欢叫映射型，所以差不多都是一个东西，理解就可以。</code></li>
</ul>
<p>​        <strong>而这三种操作，PyTypeObject中分别定义了三个指针。每个指针指向一个结构体实例，这个结构体实例中有大量的成员，成员也是函数指针，指向了具体的函数。</strong>    </p>
<p><strong>我们看一下定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    PyNumberMethods *tp_as_number;  <span class="comment">// 数值型相关操作</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;   <span class="comment">// 序列型相关操作</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;  <span class="comment">// 映射型相关操作</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下tp_as_number，它是PyNumberMethods类型的结构体指针：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">       arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">       in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="type">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p>​        <strong>你看到了什么，是的，这不就是python里面的魔法方法嘛。在PyNumberMethods里面定义了作为一个数值应该支持的操作。如果一个对象能被视为数值对象，比如整数，那么在其对应的类型对象PyLong_Type中，tp_as_number -&gt;  nb_add就指定了对该对象进行加法操作时的具体行为。同样，PySequenceMethods和PyMappingMethods中分别定义了作为一个序列对象和映射对象应该支持的行为，这两种对象的典型例子就是list和dict。所以，只要 类型对象 提供相关 操作 ， 实例对象 便具备对应的 行为 。</strong>    </p>
<p><strong>然而对于一种类型来说，它完全可以同时定义三个函数中的所有操作。换句话说，一个对象既可以表现出数值对象的特征，也可以表现出映射对象的特征。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Int(<span class="number">1</span>)</span><br><span class="line">b = Int(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;(嘎~嘎~嘎~)&quot;</span>])  <span class="comment"># (嘎~嘎~嘎~)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看上去a[“”]这种操作是一个类似于dict这样的对象才支持的操作。从int继承出来的Int自然是一个数值对象，但是通过重写__getitem__这个魔法函数，可以视为指定了Int在python内部对应的PyTypeObject对象的tp_as_mapping -&gt;  mp_subscript操作。最终Int实例对象表现的像一个map一样。归根结底就在于PyTypeObject中允许一种类型对象同时指定多种不同的行为特征。  默认使用PyTypeObject结构体实例化出来的PyLong_Type对象所生成的实例对象是不具备list和dict的属性特征的，但是我们继承PyLong_Type，同时指定__getitem__，使得我们自己构建出来的类型对象所生成的实例对象，同时具备int、list(部分)、dict(部分)的属性特征，就是因为python支持同时指定多种行为特征。</strong>     </p>
<p><strong>我们以浮点型为例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到了该类型对象在创建时，给成员tp_as_number，传入了一个float_as_number指针</span></span><br><span class="line"><span class="comment">//那么这个float_as_number指针就应该指向一个PyNumberMethods结构体实例</span></span><br><span class="line"><span class="comment">//而指向的结构体实例中也应该有大量和浮点数运算相关的函数指针，每个函数指针指向了浮点数运算相关的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//里面的float_add、float_sub、float_mul等等显然都是已经定义好的函数的指针</span></span><br><span class="line"><span class="comment">//然后创建PyNumberMethods结构体实例float_as_number的时候，分别赋值给了成员nb_add、nb_substract、nb_multiply等等等等</span></span><br><span class="line"><span class="comment">//创建完浮点数相关操作的PyNumberMethods结构体实例float_as_number之后，将其指针交给PyFloat_Type中的tp_as_number成员</span></span><br><span class="line"><span class="comment">//所以浮点数相加的时候，会执行object -&gt; ob_type -&gt; tp_as_number -&gt; nb_add, 而浮点类型对象的tp_as_number就是&amp;float_as_number</span></span><br><span class="line"><span class="comment">//所以再获取其成员nb_add的时候，拿到的就是float_add指针，然后调用float_add函数</span></span><br></pre></td></tr></table></figure>

<p><strong>所以PyFloat_Type是支持数值型操作的，但是我们看到tp_as_sequence和tp_as_mapping这两个成员接收到的值则不是一个函数指针，而是0，相当于空。因此float对象、即浮点数不支持序列型操作和映射型操作，比如：pi &#x3D;  3.14，我们无法使用len计算长度、无法通过索引或者切片获取指定位置的值、无法通过key获取value，这和我们使用Python时候的表现是一致的。</strong></p>
<blockquote>
<p><strong>我们看到PyFloat_Type中tp_as_number指向的结构体中的nb_add成员对应的函数指针是float_add，但如果是PyLong_Type的话，那么nb_add对应的函数指针则是long_add。</strong></p>
<p><strong>不同对象，使用的操作是不同的。整型相加，使用的肯定是long_add，浮点型相加使用的是float_add。</strong></p>
</blockquote>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在c和c++中，程序员被赋予了极大的自由，可以任意的申请内存。但是权利的另一面对应着责任，程序员最后不使用的时候，必须负责将申请的内存释放，并释放无效指针。可以说，这一点是万恶之源，大量内存泄漏、悬空指针、越界访问的bug由此产生。</p>
<p>现代的开发语言当中都有垃圾回收机制，语言本身负责内存的管理和维护，比如C#和golang。垃圾回收机制将开发人员从维护内存分配和清理的繁重工作中解放出来，但同时也剥夺了程序员和内存亲密接触的机会，并牺牲了一定的运行效率。但好处就是提高了开发效率，并降低了bug发生的几率。Python里面同样具有垃圾回收机制，代替程序员进行繁重的内存管理工作，而引用计数正是垃圾收集机制的一部分。</p>
<p>python通过对一个对象的引用计数的管理来维护对象在内存中的存在与否。我们知道Python中每一个东西都是一个对象，都有一个ob_refcnt成员。这个成员维护这该对象的引用计数，从而也最终决定着该对象的创建与消亡。</p>
<p>​        在python中，主要是通过Py_INCREF(op)和Py_DECREF(op)两个宏，来增加和减少一个对象的引用计数，当一个对象的引用计数减少到0后，Py_DECREF将调用该对象的析构函数来释放该对象所占有的内存和系统资源。这个析构函数就是对象的类型对象(Py***_Type)中定义的函数指针来指定的，也就是tp_dealloc。    </p>
<p>​        如果熟悉设计模式中的Observer模式，就可以看到，这里隐隐约约透着Observer模式的影子。在ob_refcnt减少到0时，将触发对象的销毁事件。从python的对象体系来看，各个对象提供了不同事件处理函数，而事件的注册动作正是在各个对象对应的类型对象中完成的。    </p>
<p><strong>我们在研究对象的行为的时候，说了比起类型对象，我们更关注实例对象的行为。那么对于引用计数也是一样的，只有实例对象，我们探讨引用计数才是有意义的。类型对象<code>(内置)</code>是超越引用计数规则的，永远都不会被析构，或者销毁，因为它们在底层是被静态定义好的。同理，我们自定义的类，虽然可以被回收，但是探讨它的引用计数也是没有价值的。我们以内置类型对象int为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># del关键字只能作用于变量, 不可以作用于对象</span></span><br><span class="line"><span class="comment"># 比如：pi = 3.14, 你可以del pi, 但是不可以del 3.14, 这是不符合语法规则的</span></span><br><span class="line"><span class="comment"># 而int虽然我们说它是整型的类型对象, 但这是从Python的层面</span></span><br><span class="line"><span class="comment"># 如果从底层来讲, int它也是一个变量, 指向了对应的数据结构(PyLong_Type)</span></span><br><span class="line"><span class="comment"># 既然是变量, 那么就可以删除, 但是这个删除并不是直接删除对象，而是将变量指向的对象的引用计数减去1，然后将这个变量也给删掉。</span></span><br><span class="line"><span class="comment"># Python中的对象是否被删除是通过其引用计数是否为0决定的, &quot;del 变量&quot;只是删除了这个变量，让这个变量不再指向该对象罢了</span></span><br><span class="line"><span class="comment"># 所以&quot;del 变量&quot;得到的结果就是我们没办法再使用这个变量了，这个变量就没了，但是变量之前指向的对象是不是也没了就看还有没有其它的引用也指向它。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;int&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 神奇的事情发生了, 告诉我们int这个变量没有被定义</span></span><br><span class="line"><span class="comment"># 原因就在于del关键字不会删除内置作用域里面的变量</span></span><br><span class="line"><span class="comment"># 我们看一下int的引用计数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(<span class="built_in">int</span>))  <span class="comment"># 138</span></span><br></pre></td></tr></table></figure>

<p><strong>惊了，居然有130多个变量在指向int，这130多个变量分别都是谁我们就无需关注了，找出这130多个变量显然是一件很恐怖的事情。</strong></p>
<blockquote>
<p><strong>总之，我们探讨类型对象的引用计数是没有太大意义的，而且内置类型对象是超越了引用计数的规则的，所以我们没必要太关注，我们重心是在实例对象上。我们真正的操作也都是依赖实例对象进行操作的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span>  <span class="comment"># 创建一个新对象，显然此时的引用计数为1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 估计有人好奇了，为啥引用计数是2, 难道不是1吗？因为e这个变量作为参数传到了sys.getrefcount这个函数里面</span></span><br><span class="line">   <span class="comment"># 所以函数里面的参数也指向2.71这个PyFloatObject，所以引用计数加1。当函数结束后，局部变量被销毁，再将引用计数减1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e1 = e  <span class="comment"># 变量间的传递会传递指针，所以e1也会指向2.71这个浮点数，因此它的引用计数加1。</span></span><br><span class="line">		   <span class="comment"># 注意：我们说变量只是个符号，引用计数是针对变量指向的对象而言的，变量本身没有所谓的引用计数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  <span class="comment"># 此时变量指向的对象的引用计数为3(sys.getrefcount函数参数对&quot;对象&quot;的引用也算在内)</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e1)  <span class="comment"># 我们说操作变量相当于操作变量指向的对象,e和e1都指向同一个对象，所以获取也是同一个对象的引用计数</span></span><br><span class="line"><span class="number">3</span>  <span class="comment"># 因此结果是一样的,都是3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [e, e1]  <span class="comment"># 放在容器里面，显然列表l中多了两个指针，这两个指针也指向这里的PyFloatObject对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">5</span>  <span class="comment"># 因此结果为5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l  <span class="comment"># 将列表删除、或者将列表清空，那么里面的变量也就没了，因此在删除变量的时候，会先将变量指向的对象的引用计数减去1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">3</span>  <span class="comment"># 所以又变成了3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e1  <span class="comment"># 再删除一个变量，引用计数再减1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 结果为2，说明外部还有一个变量在引用它，因为这个浮点数不会被回收。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e  <span class="comment"># 再次del，此时引用计数为0，这个浮点数就真的没了。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>另外，引用计数什么时候会加1，什么时候会减1，我们在上一篇博客中也说的很详细了，可以去看一下。</strong></p>
<p>​        <strong>关于引用计数，Python底层也提供了几个宏。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_NewReference(op) (                          \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span></span><br><span class="line"><span class="meta">    Py_REFCNT(op) = 1)<span class="comment">//对于新创建的对象，引用计数为1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">//引用计数为0时执行析构函数, Py_TYPE(op)-&gt;tp_dealloc获取析构函数对应的函数指针，再通过*获取指向的函数</span></span><br><span class="line"><span class="comment">//将传入PyObject *指针，将其回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++) <span class="comment">//引用计数自增1</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                             \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">            <span class="comment">//引用计数减1，如果减完1变成了0，则执行析构函数</span></span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//注意：Py_INCREF和Py_DECREF不可以处理NULL指针的，会报错</span></span><br><span class="line"><span class="comment">//所以又有两个宏，做了一层检测，会判断对象指针为NULL的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XINCREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xincref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xincref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_INCREF(_py_xincref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XDECREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xdecref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xdecref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_DECREF(_py_xdecref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然减少引用计数，除了Py_DECREF和Py_XDECREF之外，还有一个Py_CLEAR，也可以处理空指针的情况</span></span><br></pre></td></tr></table></figure>

<p><strong>因此这几个宏作用如下：</strong></p>
<ul>
<li><code>_Py_NewReference:  接收一个对象，将其引用计数设置为1，用于新创建的对象。此外我们在定义里面还看到了一个宏Py_REFCNT，这是用来获取对象引用计数的，当然除了Py_REFCNT之外，我们之前还见到了一个宏叫Py_TYPE，这是专门获取对象的类型的。</code></li>
<li><code>_Py_Dealloc: 接收一个对象, 执行该对象的类型对象里面的析构函数, 来对该对象进行回收。</code></li>
<li><code>Py_INCREF: 接收一个对象, 将该对象引用计数自增1。</code></li>
<li><code>Py_DECREF: 接收一个对象, 将该对象引用计数自减1。</code></li>
<li><code>Py_XINCREF: 和Py_INCREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_XDECREF: 和Py_DECREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_CLEAR: 和Py_XDECREF类似，也可以处理空指针。</code></li>
</ul>
<p>​        在一个对象的引用计数为0时，与该对象对应的析构函数就会被调用，但是要特别注意的是，我们刚才一致调用析构函数，会回收对象、销毁对象或者删除对象等等，意思都是将这个对象从内存中抹去，但是这并不意味着最终一定调用free释放空间，<strong>换句话说就是对象没了，但是对象占用的内存却有可能还在。</strong>如果对象没了，占用的内存也要释放的话，那么频繁申请、释放内存空间会使Python的执行效率大打折扣(更何况Python已经背负了人们对其执行效率的不满这么多年)。一般来说，Python中大量采用了<strong>内存对象池</strong>的技术，使用这种技术可以避免频繁地申请和释放内存空间。因此在析构的时候，只是将对象占用的空间归还到内存池中。Python在操作系统之上提供了一个内存池，说白了就是对malloc进行了一层封装，事先申请一部分内存，然后用于对象(占用内存低)的创建，这样就不必频繁地向操作系统请求空间了，从而大大的节省时间。<strong>这一点，在后面的Python内置类型对象(PyLongObject，PyListObject等等)的实现中，将会看得一清二楚。</strong>当然内存比较大的对象，还是需要向操作系统申请的，内存池只是用于那些内存占用比较小的对象的创建，因为这种对象显然没必要每次都和操作系统内核打交道。关于内存池，我们在后续系列中也会详细说。     </p>
<h3 id="python对象的分类"><a href="#python对象的分类" class="headerlink" title="python对象的分类"></a>python对象的分类</h3><p><strong>我们之前根据支持的操作，将Python对象分成了数值型、序列型、映射型，但其实我们是可以分为5类的：</strong></p>
<ul>
<li><code>Fundamental对象：类型对象，如int、float、bool</code></li>
<li><code>Numeric对象：数值对象，如int实例、float实例、bool实例</code></li>
<li><code>Sequence对象：序列对象，如str实例、list实例、tuple实例</code></li>
<li><code>Mapping对象：关联对象(映射对象)，如dict实例</code></li>
<li><code>Internal对象：python虚拟机在运行时内部使用的对象，如function实例(函数)、code实例(字节码)、frame实例(栈帧)、module实例(模块)、method实例(方法)，没错，函数、字节码、栈帧、模块、方法等等它们在底层一个一个类的实例对象。比如：函数的类型是&lt;class &#39;function&#39;&gt;，在底层对应PyFunctionObject，那么&lt;class  &#39;function&#39;&gt;的类型对象是什么呢？显然就是&lt;class &#39;type&#39;&gt;啦。</code></li>
</ul>
<p><strong>关于Internal对象，我们在后续系列中会细说。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一次我们说了Python中创建对象的两种方式，可以通过Python&#x2F;C  API创建，也可以通过类型对象创建。以及分析了对象的多态性，Python底层是如何通过C来实现多态，答案是通过ob_type。还说了对象的行为，对象进行某个操作的时候在底层发生了什么。最后说了引用计数，Python是通过引用计数来决定一个对象是否被回收的，但是有人知道它无法解决循环引用的问题。是的，所以Python中的gc就是为了解决这一点的，不过这也要等到介绍垃圾回收的时候再细说了。</p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Python整数的底层实现</title>
    <url>/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="05-Python整数的底层实现"><a href="#05-Python整数的底层实现" class="headerlink" title="05-Python整数的底层实现"></a>05-Python整数的底层实现</h2><p>这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？</p>
<p>既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。</p>
<h3 id="int实例对象的底层实现"><a href="#int实例对象的底层实现" class="headerlink" title="int实例对象的底层实现"></a>int实例对象的底层实现</h3><p><strong>Python中的整数底层对应的结构体是PyLongObject，它位于longobject.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合起来可以看成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125; PyLongObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把这个PyLongObject更细致的展开一下就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">//维护的元素个数</span></span><br><span class="line">    digit ob_digit[<span class="number">1</span>]; <span class="comment">//digit类型的数组,长度为1</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>别的先不说，就冲里面的ob_size我们就可以思考一番。首先Python中的整数有大小、但应该没有长度的概念吧，那为什么会有一个ob_size呢？从结构体成员来看，这个ob_size指的应该就是ob_digit数组的长度，而这个ob_digit数组显然只能是用来维护具体的值了。而数组的长度不同，那么对应的整数占用的内存也不同。所以答案出来了，整数虽然没有我们生活中的那种长度的概念，但它是个变长对象，因为不同的整数占用的内存可能是不一样的。</strong></p>
<p><strong>因此这个ob_size它指的是底层数组的长度，因为Python中整数对应的值在底层是使用数组来存储的。尽管它没有字符串、列表那种长度的概念，或者说无法对整型使用len方法，但它是个变长对象。</strong></p>
<p>​        <strong>那么下面的重点就在这个ob_digit数组了，我们要从它的身上挖掘信息，看看Python中整数对应的值(比如123)，是怎么放在这个数组里面的。不过首先我们要看看这个digit是个什么类型，它同样定义在longintrepr.h中</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PYLONG_BITS_IN_DIGIT是一个宏，如果你的机器是64位的，那么它会被定义为30，32位机器则会被定义为15</span></span><br><span class="line"><span class="comment">//至于这个宏是做什么的我们先不管</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而我们的机器现在基本上都是64位的，所以PYLONG_BITS_IN_DIGIT会等于30，因为digit等价于uint32_t<code>(unsigned int)</code>，所以它是一个无符号32位整型。</strong></p>
<p><strong>所以ob_digit这个数组是一个无符号32位整型数组，长度为1。当然这个数组具体多长则取决于你要存储的Python整数有多大，因为C中数组的长度不属于类型信息，你可以看成是长度n，而这个n是多少要取决于你的整数大小。显然整数越大，这个数组就越长，那么占用空间就越大。</strong></p>
<p>​        <strong>搞清楚了PyLongObject里面的所有成员，那么下面我们就来分析ob_digit是怎么存储Python中的整数，以及Python中的整数为什么不会溢出。</strong>    </p>
<p>​        <strong>不过说实话，关于Python的整数不会溢出这个问题，其实相信很多人已经有答案了，因为底层是使用数组存储的嘛，而数组的长度又没有限制，所以当然不会溢出啦。</strong>    </p>
<p>​        <strong>另外，还存在一个问题，那就是digit是一个无符号32位整型，那负数怎么存储？别着急，我们会举栗说明，将上面的疑问一一解答。</strong>    </p>
<p><strong>首先如果你是Python的设计者，要保证整数不会溢出，你会怎么办？我们把问题简化一下，假设有一个8位的无符号整数类型，我们知道它能表示的最大数字是255，但这时候如果我想表示256，要怎么办？</strong></p>
<p><strong>可能有人会想，那用两个数来存储不就好了。一个存储255，一个存储1，将这两个数放在数组里面。这个答案的话，虽然有些接近，但其实还有很大偏差：那就是我们并不能简单地按照大小拆分的，256拆分为255和1，要是265就拆分成255和10，而是要通过二进制的方式，我们来简单看一下。</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">我们知道<span class="number">8</span>位整数最大就是 <span class="number">2</span> ^ <span class="number">8</span> <span class="selector-tag">-</span> <span class="number">1</span>,也就是它的八位全部都是<span class="number">1</span>,结果是<span class="number">255</span></span><br><span class="line">所以<span class="number">255</span>对应的数组就是: <span class="selector-attr">[255]</span>, 因为此时一个<span class="number">8</span>位整数就能存下</span><br><span class="line"></span><br><span class="line">但如果是<span class="number">256</span>,那么<span class="number">8</span>位显然存不下了,此时就还需要一个位</span><br><span class="line">所以这个时候会使用两个<span class="number">8</span>位整数, 但并不是简单的相加, 而是使用一个新的<span class="number">8</span>位整数来模拟更高的位</span><br></pre></td></tr></table></figure>

<p>​        <strong>而Python底层也是类似这种做法，但是考虑的会更加全面。下面就以Python中的整数为例，看看底层数组的存储方式。</strong>    </p>
<p><strong>整数0：</strong></p>
<p><strong>注意：当要表示的整数为0时，ob_digit这个数组为空，不存储任何值，ob_size为0，表示这个整数的值为0，这是一种特殊情况。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002206919-1398161118.png" alt="img"></p>
<p><strong>整数1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002212476-1473281999.png" alt="img"></p>
<p><strong>当然存储的值为1时，ob_size的值就是1，此时ob_digit数组就是[1]。</strong></p>
<p><strong>整数-1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002220242-1580767637.png" alt="img"></p>
<p><strong>我们看到ob_digit数组没有变化，但是ob_size变成了-1，没错，整数的正负号是通过这里的ob_size决定的。ob_digit存储的其实是绝对值，无论n取多少，<code>-n</code>和<code>n</code>对应的ob_digit是完全一致的，但是ob_size则互为相反数。所以ob_size除了表示数组的长度之外，还可以表示对应整数的正负。</strong></p>
<p><strong>所以我们之前说整数越大，底层的数组就越长。更准确的说是绝对值越大，底层数组就越长。所以Python在比较两个整型的大小时，会先比较ob_size，如果ob_size不一样则可以直接比较出大小来。显然ob_size越大，对应的整数越大，不管ob_size是正是负，都符合这个结论，可以想一下。</strong></p>
<p><strong>整数2 ^ 30 -1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002228080-1963789840.png" alt="img"></p>
<p><strong>如果想表示2 ^30 - 1<code>(^这里代指幂运算,当然对于Python程序猿来说两个星号也是幂运算,表达的意义是一样的)</code>，那么也可以使用一个digit表示。虽然如此，但为什么突然举2 ^ 30 - 1这个数字呢？答案是，虽然digit是4字节、32位，但是Python只用30个位。</strong></p>
<blockquote>
<p><strong>之所以这么做是和加法进位有关系，如果32个位全部用来存储其绝对值，那么相加产生进位的时候，可能会溢出，比如有一个将32个位全部占满的整数<code>(2 ^ 32 - 1)</code>，即便它只加上1，也会溢出。这个时候为了解决这个问题，就需要先强制转换为64位再进行运算。</strong></p>
<p><strong>但如果只用30个位的话，那么加法是不会溢出的，或者说相加之后依旧可以用32位整数保存。因为30个位最大就是2 ^ 30 - 1，即便两个这样的值相加，结果也是(2 ^ 30 - 1) * 2，即：2 ^ 31 - 2。而32个位的话最大是2 ^ 32 - 1，所以肯定不会溢出的；如果一开始30个位就存不下，那么数组中会有两个digit。</strong></p>
</blockquote>
<p><strong>所以虽然将32位全部用完，可以只用一个digit表示更多、更大的整数，但是可能面临相加之后一个digit存不下的情况，于是只用30个位，如果数值大到30个位存不下的话，那么就会多使用一个digit。可能有人发现了，如果是用31个位的话，那么相加产生的最大值就是2 ^ 32 - 2，结果依旧可以使用一个32位整型存储啊，那Python为啥要牺牲两个位呢？答案是为了乘法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还记得这个宏吗？PYLONG_BITS_IN_DIGIT指的就是Python使用digit的位数</span></span><br><span class="line"><span class="comment">// 我们看到在32位机器上，digit相当于2字节、16位的整型，而它用了15位，只牺牲了一个位</span></span><br><span class="line"><span class="comment">// 64 位机器上则牺牲两个位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>整数2 ^ 30：</strong></p>
<p><strong>问题来了，我们说digit只用30位，所以2 ^ 30 - 1是一个digit能存储的最大值，那么现在是2 ^ 30，所以数组中就要有两个digit了。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002236296-672861305.png" alt="img"></p>
<p><em><em>我们看到此时就用两个digit来存储了，此时的数组里面的元素就是0和1，而且充当高位的放在后面，因为我们说了使用新的digit来模拟更高的位。由于一个digit只用30位，那么数组中第一个digit的最低位就是1，第二个digit的最低位就是31，第三个digit的最低位就是61，以此类推，所以如果ob_digit为[a, b, c]，那么对应的整数就为: a * 2 *</em> 0 + b * 2 *</em> 30 + c  * 2 ** 60，如果ob_digit不止3个，那么就按照30个位往上加，比如ob_digit还有第四个元素d，那么就再加上d * 2  ** 90即可。**</p>
<p><strong>再比如我们反推一下，如果a &#x3D; 88888888888，那么底层数组ob_digit中的值是多少？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="number">88888888888</span></span><br><span class="line"><span class="comment"># 我们说1个digit用30个位, 那么n个digit所能表示的最大整数就是2 ** (30 * n) - 1, 至于原因的话其实很好理解，但我们还是可以严格推导一下</span></span><br><span class="line"><span class="comment"># 我们以n = 2为例, 显然两个digit最高能表示 (2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30,</span></span><br><span class="line"><span class="comment"># 它等于 (2 ** 30 - 1) + (2 ** 60 - 2 ** 30) = 2 ** 60 - 1, 因此两个digit最大可以表示 2 ** 60 - 1</span></span><br><span class="line"><span class="comment"># 同理你可以n取3, 看看(2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30 + (2 ** 30 - 1) * 2 ** 60是不是等于2 ** 90 - 1</span></span><br><span class="line"><span class="comment"># 或者试试更大的数, 结论都是成立的</span></span><br><span class="line"><span class="built_in">print</span>(np.log2(a))  <span class="comment"># 36.37128404230425</span></span><br><span class="line"><span class="comment"># 36超过了30个位、但小于90个位, 因此需要两个digit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说 &quot;整数 = ob_digit[0] + ob_digit[1] * 2 ** 30 + ob_digit[2] * 2 ** 60 + ...&quot;</span></span><br><span class="line"><span class="comment"># 但是对于ob_digit长度为2的情况下, 这里的a = ob_digit[0] + ob_digit[1] * 2 ** 30</span></span><br><span class="line"><span class="built_in">print</span>(a // <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 82</span></span><br><span class="line"><span class="built_in">print</span>(a - <span class="number">82</span> * <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 842059320</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明此时底层对应的ob_digit数组就是[842059320, 82]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002245710-535862489.png" alt="img"></p>
<p><strong>我们修改解释器源代码重新编译，通过在创建整数的时候打印ob_digit里面的元素的值，也印证了这个结论。</strong></p>
<p>​        <strong>这个时候，我们可以分析整数所占的字节了。相信所有人都知道可以使用sys.getsizeof计算大小，但是这大小到底是怎么来的，估计会一头雾水。因为Python中对象的大小，是根据底层的结构体计算出来的。</strong>    </p>
<p>​        <strong>我们说ob_refcnt、ob_type、ob_size这三个是整数所必备的，它们都是8字节，加起来24字节。所以任何一个整数所占内存都至少24字节，至于具体占多少，则取决于ob_digit里面的元素都多少个。</strong>    </p>
<p>​        <strong>因此Python中整数所占内存 &#x3D; 24 + 4 * ob_digit数组长度</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是0的话, ob_digit数组为空, 所以此时就是24字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">0</span>))  <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是1的话, ob_digit数组有一个元素, 所以此时是24 + 4 = 28字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个digit只用30位, 所以最大能表示2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 如果是2 ** 30, 那么就需要两个元素, 所以是24 + 4 * 2 = 32字节</span></span><br><span class="line"><span class="comment"># 如果是两个digit, 那么能表示的最大整数就是2 ** 60 - 1</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span>))  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">60</span> - <span class="number">1</span>))  <span class="comment"># 32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">相信下面的不需要解释了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">60</span>))  <span class="comment"># 36</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof((<span class="number">1</span> &lt;&lt; <span class="number">90</span>) - <span class="number">1</span>))  <span class="comment"># 36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">90</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<h3 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h3><p><strong>由于分析过了浮点数以及浮点类型对象，因此int类型对象的实现以及int实例对象的创建啥的就不说了，可以自己去源码中查看，我们后面会着重介绍它的一些操作。还是那句话，Python中的API设计的很优美，都非常的相似，比如创建浮点数可以使用PyFloat_FromDouble、PyFloat_FromString等等，那么创建整数也可以使用PyLong_FromLong、PyLong_FromDouble、PyLong_FromString等等，直接去Objects中对应的源文件中查看即可。</strong></p>
<p><strong>这里说一下Python中的小整数对象池，我们知道Python中的整数属于不可变对象，运算之后会创建新的对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274354736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355024</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以这种做法就势必会有性能缺陷，因为程序运行时会有大量对象的创建和销毁。根据浮点数的经验，我们猜测Python应该也对整数使用了缓存池吧。答案是差不多，只不过不是缓存池，而是</strong><font color="red"><strong>小整数对象池</strong></font></p>
<p><strong>Python将那些使用频率高的整数预先创建好，而且都是单例模式，这些预先创建好的整数会放在一个静态数组里面，我们称为小整数对象池。如果需要使用的话会直接拿来用，而不用重新创建。注意：这些整数在Python解释器启动的时候，就已经创建了。</strong></p>
<p><strong>小整数对象池的实现位于longobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NSMALLPOSINTS宏规定了对象池中正数的个数 (从 0 开始，包括 0 )，默认 257 个；</code></li>
<li><code>NSMALLNEGINTS宏规定了对象池中负数的个数，默认5个；</code></li>
<li><code>small_ints是一个整数对象数组，保存预先创建好的小整数对象；</code></li>
</ul>
<p><strong>以默认配置为例，Python解释器在启动的时候就会预先创建一个可以容纳262个整数的数组，并会依次初始化 -5 到 256<code>(包括两端)</code>之间的262个PyLongObject。所以小整数对象池的结构如下：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002308727-1460169599.png" alt="img"></p>
<p><strong>但是为什么要实现缓存从-5到256之间的整数呢？因为Python认为这个范围内的整数使用频率最高，而缓存这些整数的内存相对可控。因此这只是某种权衡，很多程序的开发场景都没有固定的正确答案，需要根据实际情况来权衡利弊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140714000246400</span>, <span class="number">140714000246400</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>256位于小整数对象池内，所以全局唯一，需要使用的话直接去取即可，因此它们的地址是一样的。但是257不再小整数对象池内，所以它们的地址不一样。</strong></p>
<p><strong>我们上面是在交互式下演示的，但如果有小伙伴不是通过交互式的话，那么会得到出乎意料的结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>可能有人会好奇，为什么地址又是一样的了，257明明不在小整数对象池中啊。虽然涉及到了后面的内容，但是提前解释一下也是可以的。主要区别就在于一个是在交互式下执行的，另一个是通过 python3 xxx.py的方式执行的。</strong></p>
<blockquote>
<p><strong>首先Python的编译单元是函数，每个函数都有自己的作用域，在这个作用域中出现的所有常量都是唯一的，并且都位于常量池中，由co_consts指向。虽然我们上面的不是函数，而是在全局作用域中，但是全局你也可以看成是一个函数，它也是一个独立的编译单元。同一个编译单元中，常量只会出现一次。</strong></p>
<p><strong>当a &#x3D; 257的时候，会创建257这个整数、并放入常量池中；所以b &#x3D; 257的时候就不会再创建了，因为常量池中已经有了，所以会直接从常量池中获取，因此它们的地址是一样的，因为是同一个PyLongObject。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3.6下执行, 该系列的所有代码都是基于Python3.8, 但是这里先使用Python3.6, 至于原因, 后面会说</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140042202371968, 140042204149712)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140042202371968, 140042204255024)</span></span><br></pre></td></tr></table></figure>

<p><strong>此时f1和f2显然是两个独立的编译单元，256属于小整数对象池中的整数、全局唯一，因此即便不在同一个编译单元的常量池中，它的地址也是唯一的，因为它是预先定义好的，所以直接拿来用。但是257显然不是小整数对象池中的整数，而且不在同一个编译单元的常量池中，所以地址是不一样的。</strong></p>
<p><strong>而对于交互式环境来说，因为我们输入一行代码就会立即执行一行，所以任何一行可独立执行的代码都是一个独立的编译单元。注意：是可独立执行的代码，比如变量赋值、函数、方法调用等等；但如果是if、for、while、def等等需要多行表示的话，比如：<code>if 2 &gt; 1:</code>，显然这就不是一行可独立执行的代码，它还依赖你输入的下面的内容。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span>:  <span class="comment"># 此时按下回车，我们看到不再是&gt;&gt;&gt;, 而是..., 代表还没有结束, 还需要你下面的内容</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;2 &gt; 1&quot;</span>)</span><br><span class="line"><span class="meta">... </span> <span class="comment"># 此时这个if语句整体才是一个独立的编译单元</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是像a &#x3D; 1、foo()、lst.appned(123)这些显然它们是一行可独立执行的代码，因此在交互式中它们是独立的编译单元。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>  <span class="comment"># 此时这行代码已经执行了，它是一个独立的编译单元</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span>  <span class="comment"># 这行代码也是独立的编译单元，所以它里面的常量池为空，因此要重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)  <span class="comment"># 由于它们是不同常量池内的整数，所以id是不一样的。</span></span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，看看下面的代码，a和b的地址为啥又一样了呢？666和777明显也不在常量池中啊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span>;b=<span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354896</span>, <span class="number">2431274354896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">777</span>, <span class="number">777</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354800</span>, <span class="number">2431274354800</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>显然此时应该已经猜到原因了，因为上面两种方式无论哪一种，都是在同一行，因此整体会作为一个编译单元，所以地址是一样的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在Python3.8中，如果是通过 python xxx.py的方式执行的话，即便是大整数、并且不再同一个编译单元的常量池中，它们的地址也是一样的，说明Python在3.8版本的时候做了优化。</strong></p>
<blockquote>
<p><strong>另外，如果没有特殊说明，那么我们这个系列的所有代码都是在Python3.8下执行的。说实话，我就是因为发现在Python3.8中，打印的地址都是一样的，才在上面试了一下Python3.6。但是Python3.8中具体是怎么优化的，这里就暂时不讨论了<code>(明明是你没有仔细研究)</code>。</strong></p>
</blockquote>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p><strong>整数溢出是程序开发中一大难题，由此引发的 BUG  不计其数，而且相当隐蔽。之前使用golang刷LeetCode的时候，怎么也通不过，最后发现是因为LeetCode后台有一个测试用例比较特殊，导致整数太大，golang中的int64存不下。而Python 选择从语言层面彻底解决这个痛点，殚心竭虑地设计了整数对象。而我们也探索了整数对象，并初步掌握了整数对象的内部结构。</strong></p>
<p><strong>Python中的整数是串联了多个C中的digit<code>(uint32_t)</code>，通过一个C数组的形式来实现整数的表示。这么做的好处就是Python中的整数没有长度限制了，因此不会溢出<code>(而浮点数使用C的double，所以它会溢出)</code>。之所以不会溢出，是因为数组是没有长度限制的，所以只要你的内存足够，就可以算任意大的数。所以Python表示：存不下？会溢出？这都不是事儿，直接继续往数组里面塞digit就ok了。</strong></p>
<blockquote>
<p><strong>这里再重温一下PyLongObject的数据结构，我们说它是一个变长对象。ob_size指的是数组的长度，并且它除了表示长度还能体现出整数的正负，而ob_digit这个数组只用来存储其绝对值。</strong></p>
<p><strong>但是说实话，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<p><strong>所以我们在分析浮点数的时候，一直说整数要比浮点数复杂，原因就在于此。浮点数相加的话直接两个double相加即可，但是整数相加可就没有那么简单了。</strong></p>
</blockquote>
<p><strong>整数支持的操作定义在什么地方相信不用我说了，直接去longobject.c中查看就可以了，根据浮点数的经验我们知道PyLong_Type中的tp_as_number成员也指向了PyNumberMethods结构体实例，里面的成员都是指向与整型运算相关的函数的指针。</strong></p>
<p><strong>注意：图中有一个箭头画错了，应该是 ob_type 指向 PyLong_Type，但图中不小心变成了 ob_size。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002525586-1003237779.png" alt="img"></p>
<h4 id="整数的大小比较"><a href="#整数的大小比较" class="headerlink" title="整数的大小比较"></a>整数的大小比较</h4><p><strong>先来看看Python中的整数在底层是如何比较的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">long_compare</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//sign是一个8字节的long, 用来表示a和b之间的比较结果</span></span><br><span class="line">    <span class="comment">//如果a == b, 那么sign = 0; 如果a &gt; b, 那么sign &gt; 0; 如果a &lt; b, 那么sign &lt; 0</span></span><br><span class="line">    Py_ssize_t sign;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Py_SIZE是一个宏:获取对象的ob_size,除此之外我们之前还见到了Py_REFCNT和Py_TYPE, 用来获取对象的引用计数和类型指针</span></span><br><span class="line">    <span class="comment">//如果两个整数的ob_size不一样, 我们说a和b一定不相等, 所以可以直接比较出大小</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) != Py_SIZE(b)) &#123;</span><br><span class="line">        <span class="comment">//如果一正一负, 那么肯定正的大, 因为ob_size还体现整数的正负, 所以正的ob_size对应的整数也会更大</span></span><br><span class="line">        <span class="comment">//如果都为正, 那么ob_size越大, 对应数组元素就越多, 显然整数就越大</span></span><br><span class="line">        <span class="comment">//如果都为负, 那么ob_size越大, 其绝对值就越小, 因为越接近0,所以对应的整数的绝对值也越小</span></span><br><span class="line">          <span class="comment">//但因为是负数,所以乘上-1之后,所以整数值反而会越大。比如: 1 &lt; 100, 但是乘上-1之后, 小于号就要变成大于号</span></span><br><span class="line">        <span class="comment">//因此无论是哪种情况，如果两个整数的ob_size不一样，是可以直接比较出大小的。</span></span><br><span class="line">        sign = Py_SIZE(a) - Py_SIZE(b);</span><br><span class="line">        <span class="comment">//所以sign &gt; 0的话a &gt; b, sign &lt; 0的话a &lt; b, 因为ob_size不一样, 所以sign不可能等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果相等, 那么说明a和b的符号相同, 数组中使用的digit也是一样的</span></span><br><span class="line">        <span class="comment">//那么接下来就只能挨个比较数组中的digit了</span></span><br><span class="line">        <span class="comment">//这里是获取数组的长度, 赋值给变量i</span></span><br><span class="line">        Py_ssize_t i = Py_ABS(Py_SIZE(a));</span><br><span class="line">        <span class="comment">//我们之前说，一个digit存不下，那么会使用两个digit, 以此类推</span></span><br><span class="line">        <span class="comment">//并且代表整数高位的digit会放在后面, 而比较两个数的大小显然是从高位开始比</span></span><br><span class="line">        <span class="comment">//因此遍历数组是从后往前遍历的, 先比较a -&gt; ob_digit[n]和 b -&gt; ob_digit[n]</span></span><br><span class="line">        <span class="comment">//如果一样就比较a -&gt; ob_digit[n-1]和a -&gt; ob_digit[n-1],直到将数组的元素全部比完,显然只要有一个不一样,就可以直接决定绝对值的大小</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            <span class="comment">//进行while循环, i是数组的长度, 因此数组的最大索引是i - 1, 所以这里的--i会先将i自减1,再判断自减1之后的i是否&gt;=0</span></span><br><span class="line">            <span class="comment">//然后比较a-&gt;ob_digit[i]和b-&gt;ob_digit[i], 如果数组内元素全部一样, 那么循环结束之后i肯定是-1,只要有一个不一样, 那么i一定&gt;=0</span></span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以如果i &lt; 0,说明两个整数的数组全部一样, 因此两个整数是一样的</span></span><br><span class="line">            <span class="comment">//所以sign = 0</span></span><br><span class="line">            sign = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话, 说明数组中索引为i的元素不一样, 那么直接相减就可以了</span></span><br><span class="line">            <span class="comment">//如果sign大于0, 显然a对应的绝对值比大, 否则a对应的绝对值比b小</span></span><br><span class="line">            sign = (sdigit)a-&gt;ob_digit[i] - (sdigit)b-&gt;ob_digit[i];</span><br><span class="line">            <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//但是我们说计算的是绝对值，如果ob_size小于0，绝对值越大其值反而越小，那么sign还要乘上-1</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因此最终: a &gt; b则sign &gt; 0, a &lt; b则sign &lt; 0, a == b则sign == 0</span></span><br><span class="line">    <span class="comment">//然后这里是一个嵌套的三元表达式, sign大于0则直接返回1表示a &gt; b, 小于0返回-1表示a &lt; b, 等于0则返回0表示a == b</span></span><br><span class="line">    <span class="keyword">return</span> sign &lt; <span class="number">0</span> ? <span class="number">-1</span> : sign &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到Python中的整数就是按照上面这种方式比较的，总的来说就是先比较ob_size，ob_size不一样则可以直接比较。如果ob_size一样的话，那么会从后往前挨个比较数组中的元素，最终确定大小关系。</strong></p>
<h4 id="整数的相加"><a href="#整数的相加" class="headerlink" title="整数的相加"></a>整数的相加</h4><p><strong>再来看看Python中的整数在底层是如何相加的，加法的实现显然是long_add，我们看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//a和b是两个PyLongObject *</span></span><br><span class="line">    <span class="comment">//z显然是指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//CHECK_BINOP是一个宏, 接收两个指针, 检测它们是不是都指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断a和b的ob_size的绝对值是不是都小于等于1, 如果是的话, 那么说明数组中最多只有一个元素</span></span><br><span class="line">    <span class="comment">//数组没有元素,说明整数是0;有一个元素,那么直接取出来、再判断正负号即可,然后直接相加。</span></span><br><span class="line">    <span class="comment">//所以显然这里走的是快分支,因为绝对值超过2 ** 30 - 1的整数还是比较少的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//MEDIUM_VALUE是一个宏, 接收一个abs(ob_size) &lt;= 1的PyLongObject的指针</span></span><br><span class="line">        <span class="comment">//如果ob_size是0, 那么结果为0; 如果ob_size绝对值为1, 那么结果为 ob_digit[0] 或者 -ob_digit[0]</span></span><br><span class="line">        <span class="comment">//所以直接将MEDIUM_VALUE(a) + MEDIUM_VALUE(b)之后的结果转成PyLongObject,然后返回其指针即可</span></span><br><span class="line">        <span class="comment">//因此如果数组中元素不超过1个的话, 那么显然是可以直接相加的</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里, 说明至少有一方的ob_size大于1</span></span><br><span class="line">    <span class="comment">//如果a &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果a &lt; 0并且b &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明两者符号相同, 那么通过x_add直接将两个整数相加即可</span></span><br><span class="line">            <span class="comment">//这个x_add专门用于整数的绝对值相加,并且会返回PyLongObject *,它的实现我们后面会说</span></span><br><span class="line">            <span class="comment">//所以z指向的PyLongObject的内部成员是已经设置好了的</span></span><br><span class="line">            <span class="comment">//只不过x_add加的是两者的绝对值, z指向的PyLongObject内部ob_type的符号我们还需要再度判断一下</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//因为a和b指向的整数都是负数, 所以将相加之后还要将ob_size乘上-1</span></span><br><span class="line">                Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//走到这里说明a &lt; 0并且b &gt; 0, 那么直接让b - a即可, 此时得到的结果一定是正</span></span><br><span class="line">            <span class="comment">//因此不需要考虑ob_size的符号问题</span></span><br><span class="line">            z = x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明a &gt; 0并且b &lt; 0, 所以让a - b即可</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两个整数均为正, 直接相加</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回z的指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以long_add这个函数并不长，但是调用了辅助函数x_add和x_sub，显然核心逻辑是在这两个函数里面。至于long_add函数，它的逻辑如下：</strong></p>
<ul>
<li><code>1. 定义一个变量z, 用于保存计算结果;</code></li>
<li><code>2. 判断两个整数底层对应的数组是不是都不超过1, 如果是的话那么通过宏MEDIUM_VALUE直接将其转成C中的一个digit, 然后直接相加、返回即可。显然这里走的是快分支,或者快速通道;</code></li>
<li><code>3. 但如果有一方ob_size绝对值不小于1, 那么判断两者的符号。如果都为负,那么通过x_add计算两者绝对值之和、再将ob_size乘上-1即可;</code></li>
<li><code>4. 如果a的ob_size小于0, b的ob_size大于0, 那么通过x_sub计算b和a绝对值之差即可;</code></li>
<li><code>5. 如果a的ob_size大于0, b的ob_size小于0, 那么通过x_sub计算a和b绝对值之差即可;</code></li>
<li><code>6. 如果a的ob_size大于0, b的ob_size大于0, 那么通过x_add计算让b和a绝对值之和即可;</code></li>
</ul>
<p><strong>所以Python中整数的设计非常的巧妙，ob_digit虽然是用来维护具体数值，但是它并没有考虑正负，而是通过ob_size来表示整数的正负号。这样运算的时候，计算的都是整数的绝对值，因此实现起来会方便很多。将绝对值计算出来之后，再通过ob_size来判断正负号。</strong></p>
<p><strong>因此long_add将整数加法转成了 “绝对值加法(x_add)”和”绝对值减法(x_sub)”：</strong></p>
<ul>
<li><code>x_add(a, b), 计算两者的绝对值之和, 即:|a| + |b|;</code></li>
<li><code>x_sub(a, b), 计算两者的绝对值之差, 即:|a| - |b|;</code></li>
</ul>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002538412-969820254.png" alt="img"></p>
<p><strong>由于绝对值加、减法不用考虑符号对计算结果的影响，实现更为简单，这是Python将整数运算转化成绝对值运算的缘由。虽然我们还没看到x_add和x_sub是如何对整数的绝对值进行相加和相减运算的，但也能从中体会到程序设计中逻辑的 划分 与 组合 的艺术，优秀的代码真的很美。</strong></p>
<blockquote>
<p><strong>那么下面我们的重心就在x_add和x_sub中了，看看它们是如何对大整数绝对值进行运算的。但是你可能会有疑问，大整数运算肯定很复杂，效率会差吧。显然这是必然的，整数数值越大，整数对象底层数组越长，运算开销也就越大。好在运算处理函数均以快速通道对小整数运算进行优化，将额外开销降到最低。</strong></p>
<p><strong>比如上面的long_add，如果a和b对应的整数的绝对值都小于等于2 ^  30 - 1，那么会直接转成C中的整型进行运算，性能损耗极小。并且走快速通道的整数的范围是：-(2 ^ 30 - 1) ~ 2 ^ 30 -  1，即：-1073741823 ~ 1073741823，显然它可以满足我们绝大部分的运算场景。</strong></p>
</blockquote>
<p>​        <strong>绝对值加法x_add：</strong>    </p>
<p><strong>在介绍绝对值加法之前，先来看看几个宏，先不管它们是干什么的，会在x_add中有体现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_SHIFT    30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_MASK     ((digit)(PyLong_BASE - 1))</span></span><br><span class="line"><span class="comment">//所以PyLong_MASK等于(1 &lt;&lt; 30) - 1, 就等于2 ** 30 - 1, 说明32个位, 前两个位为0, 后面三十个位则都是1</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，再想象一下我们平时算加法的时候是怎么算的：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002550125-674752602.png" alt="img"></p>
<p><strong>而x_add在逻辑和上面是类似的，下面分析x_add的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然a和b指向了两个要想加的整数对象</span></span><br><span class="line">    <span class="comment">//这里获取a和b的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//根据a和b的相加结果所创建的新的PyLongObject的指针</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//重点也是最难理解的地方: carry用于每个部分的运算结果(可不是大神带你carry哦)</span></span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size_a小于size_b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么将a和b进行交换, 以及size_a和size_b也进行交换, 为什么这么做呢?因为方便</span></span><br><span class="line">        <span class="comment">//我们小时候计算两个整数相加时候, 如果一个位数多,一个位数少, 也会习惯将位数多的放在左边</span></span><br><span class="line">        <span class="comment">//最终从右往左, 也就是从低位往高位逐个相加, 大于10则进1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//如果size_a和size_b相等, 或者size_a大于size_b, 那么该if就无需执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是创建一个ob_size为size_a + 1的PyLongObject, 然后返回其指针</span></span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//但为什么是size_a + 1呢?</span></span><br><span class="line">    <span class="comment">//因为此时size_a 一定不小于 size_b, 那么a和b相加之后的z的ob_size一定不小于size_a</span></span><br><span class="line">    <span class="comment">//但是也可以也可能比size_a多1, 比如: a = 2 ** 60 - 1, b = 1</span></span><br><span class="line">    <span class="comment">//所以相加之后结果为2 ** 60次方, 所以ob_size就变成了3, 因此在创建z的时候，ob_digit的容量会等于size_a + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正常情况下, z是一个PyLongObject *, 但如果z == NULL, 表示分配失败(解释器也会异常退出)</span></span><br><span class="line">    <span class="comment">//但说实话, 除非你内存不够了, 否则这种情况不会发生</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, 如果a和b的ob_size不一样, 那么size_a会大于size_b</span></span><br><span class="line">    <span class="comment">//所以显然是先以size_b为准, 两者从低位向高位依次对应相加; 当b到头了, 再单独算a的剩余部分;</span></span><br><span class="line">    <span class="comment">//假设size_a == 4, size_b == 2, 对应到ob_digit的话</span></span><br><span class="line">    <span class="comment">//就是a -&gt; ob_digit[0] + b -&gt; ob_digit[0], 作为z -&gt; ob_digit[0], 当然还需要考虑进位, 下面说</span></span><br><span class="line">    <span class="comment">//然后a -&gt; ob_digit[1] + b -&gt; ob_digit[1], 作为z -&gt; ob_digit[1], 此时b到头了</span></span><br><span class="line">    <span class="comment">//继续a -&gt; ob_digit[2]作为z -&gt; ob_digit[2], a -&gt; ob_digit[3]作为z -&gt; ob_digit[3]</span></span><br><span class="line">    <span class="comment">//此时a和b相加就结束了, 如果不考虑相加进位的话, 那么整体流程就是这个样子。然后我们继续往下看</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从索引为0开始遍历, 以i &lt; size_b为条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]作为carry, 显然carry如果没有超过2 ** 30 - 1的话</span></span><br><span class="line">        <span class="comment">//显然它就是z -&gt; ob_digit[i]</span></span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//但是carry是可能溢出的, 所以z -&gt; ob_digit[i] = carry &amp; PyLong_MASK</span></span><br><span class="line">        <span class="comment">//这个PyLong_MASK就是我们在介绍x_add之前先介绍的几个宏之一, 它表示的是2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//我们说它的前两个位为0, 后面三十个位全是1, 因此对于后面三十个位来说, 在和carry进行&quot;与运算&quot;之后,对应的位还和carry保持一致</span></span><br><span class="line">        <span class="comment">//所以在carry小于等于2 ** 30 - 1的时候carry &amp; PyLong_MASK就等于carry</span></span><br><span class="line">        <span class="comment">//但如果carry大于2 ** 30 - 1, 由于PyLong_MASK的前两位为0, 所以这一步可以确保carry不会超过2 ** 30 - 1</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//但是carry的前两位显然不可以丢, 所以它们要作用在数组中下一个元素相加的结果上</span></span><br><span class="line">        <span class="comment">//比如a -&gt; ob_digit[0] + b -&gt; ob_digit[0]得到结果正好是2 ** 32 - 1, 那么carry的前两位也是1</span></span><br><span class="line">        <span class="comment">//而数组中下一元素相加之后, 其结果对应的位要比本次循环高出30</span></span><br><span class="line">        <span class="comment">//所以这里将carry右移30位, 然后作用到下一次循环中</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果当b到头了, 那么继续从当前的i开始, 直到i == size_a, 逻辑还是和上面一样的</span></span><br><span class="line">        <span class="comment">//只不过将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]换成了a-&gt;ob_digit[i], 因为b到头了</span></span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//这里也要&quot;与上&quot;PyLong_MASK, 因为也可能存在进位的情况, 拿生活中的99999 + 1为例</span></span><br><span class="line">        <span class="comment">//此时a = 99999, b = 1, 显然第一次循环b就到头了, 但后面单独循环a的时候, 依旧是要加进位的</span></span><br><span class="line">        <span class="comment">//所以这里也是同理</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//carry右移30位</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个循环结束之后, 其实还差一步, 还拿99999 + 1举例子, 按照顺序相加最后得到的是00000</span></span><br><span class="line">    <span class="comment">//因为最后还进了一个1, 所以这里的carry也是同理, 因此z的ob_size要比size_a多1, 目的就在于此</span></span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="comment">//但如果最后的carry没有进位的话, 显然其结果就是0, 所以最后没有直接返回z, 而是返回了long_normalize(z)</span></span><br><span class="line">    <span class="comment">//这个long_normalize函数作用就是从后往前依次检查ob_digit的元素, 如果为0, 那么就将其ob_size减去1, 直到出现一个不为0的元素</span></span><br><span class="line">    <span class="comment">//当然对于我们当前来说, 显然最多只会检查一次</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python中的整数在底层实现的很巧妙，不理解的话可以多看几遍，然后我们在Python的层面上再反推一下，进一步感受底层运算的过程。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有a和b两个整数, 当然这里是使用列表直接模拟的底层数组ob_digit</span></span><br><span class="line">a = [<span class="number">1073741744</span>, <span class="number">999</span>, <span class="number">765</span>, <span class="number">123341</span>]</span><br><span class="line">b = [<span class="number">841</span>, <span class="number">1073741633</span>, <span class="number">2332</span>]</span><br><span class="line"><span class="comment"># 然后创建z, 表示a和b的相加结果</span></span><br><span class="line">z = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更直观, 我们一步步手动相加</span></span><br><span class="line"><span class="comment"># 首先是将a[0] + b[0], 得到carry</span></span><br><span class="line">carry = a[<span class="number">0</span>] + b[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1), 我们看到结果是761</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 761</span></span><br><span class="line"><span class="comment"># 因为如果carry小于等于 2 ** 30 - 1, 那么结果就是carry, 而这里是761, 显然carry肯定大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 因为carry &amp; (2 ** 30 - 1) == 761, 所以z的第一个元素就是761</span></span><br><span class="line">z.append(<span class="number">761</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算a[1] + b[1]得到新的carry, 但是之前的carry大于 2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还要再加上之前的右移30位的carry</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">1</span>] + b[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1)得到809</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 809</span></span><br><span class="line"><span class="comment"># 说明carry依旧大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 然后z的第二个元素就是809</span></span><br><span class="line">z.append(<span class="number">809</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算a[2] + b[2]的时候也是同理</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">2</span>] + b[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 但是显然此时的carry已经不大于 2 ** 30 - 1了</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 所以carry和carry &amp; (2 ** 30 - 1)的结果都是carry本身</span></span><br><span class="line"><span class="built_in">print</span>(carry, carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 3098 3098</span></span><br><span class="line"><span class="comment"># 说明z的第三个元素是3098</span></span><br><span class="line">z.append(<span class="number">3098</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时b到头了, 所以直接将a[3]作为carry, 当然我们不知道carry是否大于2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还是右移30位即可, 不过carry不大于2 ** 30 - 1的话, 那么 carry &gt;&gt; 30 就是0罢了</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(carry)  <span class="comment"># 123341</span></span><br><span class="line"><span class="comment"># 说明z的最后一个元素是123341, 当然理论上我们还要在对carry和 2 ** 30 - 1进行一次判断</span></span><br><span class="line"><span class="comment"># 当然由于我们知道carry肯定不会超过2 ** 30 - 1, 所以就不判断了</span></span><br><span class="line">z.append(<span class="number">123341</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时z为[761, 809, 3098, 123341]</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># [761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以ob_digit为[1073741744, 999, 765, 123341]和[841, 1073741633, 2332]的两个PyLongObject相加</span></span><br><span class="line"><span class="comment"># 得到的新的PyLongObject的ob_digit为[761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们根据ob_digit按照规则转成整数, 那么a + b的结果要和z是相等的</span></span><br><span class="line">a = <span class="number">1073741744</span> + <span class="number">999</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">765</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line">b = <span class="number">841</span> + <span class="number">1073741633</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">2332</span> * <span class="number">2</span> ** <span class="number">60</span></span><br><span class="line">z = <span class="number">761</span> + <span class="number">809</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">3098</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 152688762386380073438430860672944</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 2689765870042689307465</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># 152688762389069839308473549980409</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然结果为True, 由此证明我们之前的结论是成立的。</span></span><br><span class="line"><span class="built_in">print</span>(a + b == z)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看完绝对值加法x_add之后，再来看看绝对值减法x_sub，显然有了加法的经验之后再看减法会简单很多。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//依旧是获取两者的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//z指向相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//如果size_a 小于 size_b, 那么sign就是-1, 否则就是1</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//之前carry保存的相加的结果, borrow保存相减的结果</span></span><br><span class="line">    <span class="comment">//名字很形象, 相加要进位叫carry、相减要结尾叫borrow</span></span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果size_a比size_b小, 说明a的绝对值比b小</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么令sign = -1, 相减之后再乘上sign</span></span><br><span class="line">        <span class="comment">//因为计算的是绝对值之差, 符号是在绝对值之差计算完毕之后通过sign判断的</span></span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后依旧交换两者的位置, 相减的时候也确保大的一方在左边</span></span><br><span class="line">        <span class="comment">//相加的时候其实大的一方在左边还是在右边没有太大影响, 但是相减的时候大的一方在左边显然会省事很多</span></span><br><span class="line">        <span class="comment">//但是交换之后再相减, 肯定要变符号, 因此将sign设置为-1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//可能有人会有疑问了，那如果a的ob_size是1, b的ob_size是-3，一正一负,此时起到的效果是相加才对啊</span></span><br><span class="line">        <span class="comment">//是的, 所以此时会将a和b传到x_add里面，而不是这里, 后面我们会总结</span></span><br><span class="line">        <span class="comment">//由于ob_digit里面的元素都为正, 所以x_add计算的是绝对值之和，x_sub计算的绝对值之差, 总之在理解逻辑的时候把a和b都想象成正数即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">//这一个条件语句可能有人会觉得费解，我们分析一下</span></span><br><span class="line">        <span class="comment">//如果两者相等, 那么两个ob_digit里面对应的元素也是有几率都相等的</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="comment">//所以从ob_digit的尾巴开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">//如果都相等, 那么i会等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以直接返回0即可</span></span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//下面下面是为了计算相减之后的PyLongObject的ob_size</span></span><br><span class="line">        <span class="comment">//如果对应元素不相等, 假设a的ob_digit里面的元素是[2, 3, 4, 5], b的ob_digit是[1, 2, 3, 5]</span></span><br><span class="line">        <span class="comment">//因此上面的while循环结束之后, i会等于2, 显然只需要计算[2, 3, 4]和[1, 2, 3]之间的差即可, 因为最高位的5是一样的</span></span><br><span class="line">        <span class="comment">//然后判断索引为i时, 对应的值谁大谁小</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            <span class="comment">//如果a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i], 那么同样说明a小于b, 因此将sign设置为-1, 然后交换a和b的位置</span></span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为做减法, 所以size_a和size_b直接设置成i + 1即可, 因为高位在减法的时候会被抵消掉, 所以它们完全可以忽略</span></span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里依旧是申请空间</span></span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="comment">//申请失败返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后下面的逻辑和x_add是类似的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//让a-&gt;ob_digit[i] - b-&gt;ob_digit[i], 但如果存在借位, 那么还要减掉</span></span><br><span class="line">        <span class="comment">//但是问题来了, 我们说digit貌似是无符号的吧, 但是对于低位来说a-&gt;ob_digit[i] 是完全可以小于 b-&gt;ob_digit[i]的</span></span><br><span class="line">        <span class="comment">//但是这样减出来不成负数了, 所以C语言中有这么个特点, 比如：这里相减得到的是-100</span></span><br><span class="line">        <span class="comment">//那么结果就是2 ** 32 - 100, 因为digit是无符号32位, 所以存储的负数会变成 2 ** 32 + 该负数, 或者2 ** 32 - 负数的绝对值</span></span><br><span class="line">        <span class="comment">//以我们平时做的减法为例：32 - 19, 我们知道结果是13, 但是低位的2减去低位的9结果是-7, 如果是负数</span></span><br><span class="line">        <span class="comment">//那么要像高位借个1, 从而得到10,因此最后一位是10 - 7 = 3</span></span><br><span class="line">        <span class="comment">//以此为例, a -&gt; ob_digit[i] - b -&gt; ob_digit[i], 如果小于0, 那么肯定要像数组中i + 1的元素进行借位, 但我们说它会比当前高30个位</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        <span class="comment">//因此这里借个1, 借的就不是10了, 而是2 ** 30次方</span></span><br><span class="line">        <span class="comment">//所以borrow为负, 那么结果显然加上2 ** 30才对, 但是当前borrow加的是2 ** 32次方</span></span><br><span class="line">        <span class="comment">//所以将borrow 还要 与上 PyLong_MASK，然后其结果才是z-&gt;ob_digit[i]的值</span></span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//如果真的借了个1, 那么ob_digit中下一个元素肯定是要减去1的, 所以borrow右移30位</span></span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        <span class="comment">//和1进行与运算, 如果a -&gt; ob_digit[i] - b -&gt; ob_digit[i]为负, 那么就必须要借位</span></span><br><span class="line">        <span class="comment">//但由于digit只用30个位, 因此再加上2 ** 32次方之后，其结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以borrow右移30位之后, 再和1进行与运算之后结果肯定是1, 由此可以判断这次相减一定是借位了</span></span><br><span class="line">        <span class="comment">//如果为0代表结果为正、没有加上2 ** 32次方,那么结果borrow &amp; 1的结果就是0</span></span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//所以Python底层的整数只用了30个位真的非常巧妙, 尤其是在减法的时候</span></span><br><span class="line">        <span class="comment">//因为借位一次借2 ** 30, 可由于C的特性会加上2 ** 32次方, 但是它们的结果只有前两个高位不一样, 后面30个位是一样的</span></span><br><span class="line">        <span class="comment">//所以再与上PyLong_MASK, 所以就等价于加上了2 ** 30次方，从而得到正确的结果</span></span><br><span class="line">        <span class="comment">//但如果一旦借位, 那么数组下一个元素要减去1。但问题是怎么判断它有没有借位呢？判断有没有借位就是判断两个元素相减之后是否为负</span></span><br><span class="line">        <span class="comment">//如果为负数,那么C会将这个负数加上2 ** 32次方, 而两个不超过2 ** 30 - 1的数相减得到的负数的绝对值显然也不会超过2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//换句话说其结果对应的第31位一定是0, 那么再和32个位全部是1的2 ** 32次方相加, 得到的结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以再让borrow右移30位、并和1进行与运算。如果结果为1, 证明相减为负数, 确实像下一个元素借了1, 因此下一次循环的会减去1</span></span><br><span class="line">        <span class="comment">//如果borrow为0, 那么就证明a-&gt;ob_digit[i] - b-&gt;ob_digit[i]得到的结果为正,根本不需要借位, 所以下一次循环等于减了一个0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size_a和size_b一样, 那么这里的for循环是不会满足条件的, 但不一样的话, 肯定会走这里</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//我们看到这里的逻辑和之前分析x_add是类似的</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只不过由于不会产生进位, 因此不需要对borrow再做额外判断, x_add中最后还要判断carry有没有进位</span></span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sign &lt; 0, 那么证明是负数</span></span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后同样从后往前将z -&gt; ob_digit中为0的元素删掉, 直到遇见一个不为0的元素, 比如: 10000 - 9999, 虽然位数多, 但是结果是1</span></span><br><span class="line">    <span class="comment">//而z -&gt; ob_digit在申请空间的时候只是根据长度申请的, 所以最后还需要这样的一次判断</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以Python整数在底层的设计确实很精妙，尤其是在减法的时候，强烈建议多看几遍回味一下。</strong></p>
<h4 id="整数的相减"><a href="#整数的相减" class="headerlink" title="整数的相减"></a>整数的相减</h4><p><strong>整数的相减调用的是long_sub函数，显然long_sub和long_add的思路都是一样的，核心还是在x_add和x_sub上面，所以long_sub就没有什么可细说的了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//z指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//判断a和b是否均指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里依旧是快分支</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//直接相减，然后转成PyLongObject返回其指针</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) - MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a小于0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//a小于0，b小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用绝对值减法, 因为两者符号一样</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两者符号不一样，那么相加起到的是相加的效果</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//但是x_add和x_sub运算的是绝对值, x_sub中考虑的sign是基于绝对值而言的</span></span><br><span class="line">            <span class="comment">//比如：x_sub接收的a和b的ob_size分别是-5和-3, 那么得到的结果肯定是正的, 因为会用绝对值大的减去绝对值小的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是负数, 所以还要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果x_sub接收的a和b的ob_size分别是-3和-5, 由于还是用绝对值大的减去绝对值小的,所以会交换、从而变号，得到的结果是负的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是正数, 所以也要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//至于x_add就更不用说了, 当a为负、b为正的时候, a - b，就等于a和b的绝对值相加乘上-1</span></span><br><span class="line">            assert(Py_SIZE(z) == <span class="number">0</span> || Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">            Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//a大于0, b小于0, 所以a - b等于a和b的绝对值相加</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//a大于0, b大于0, 所以直接绝对值相减即可</span></span><br><span class="line">            <span class="comment">//而正数等于其绝对值, 所以x_sub里面考虑的符号就是真正的结果的符号</span></span><br><span class="line">            <span class="comment">//如果是上面的负数, 那么还要乘上-1</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以关于什么时候调用x_add、什么时候调用x_sub，我们总结一下，总之核心就在于它们都是对绝对值进行运算的，掌握好这一点就不难了：</strong></p>
<p><strong>a + b</strong></p>
<ul>
<li><code>如果a是正、b是正，调用x_add(a, b)，直接对绝对值相加返回结果</code></li>
<li><code>如果a是负、b是负，调用x_add(a, b)，但相加的是绝对值，所以long_add中在接收到结果之后还要对ob_size乘上-1</code></li>
<li><code>如果a是正、b是负，调用x_sub(a,  b)，此时等价于a的绝对值减去b的绝对值。并且x_sub是使用绝对值大的减去绝对值小的，如果a的绝对值大，那么显然正常；如果a的绝对值小，x_sub中会交换，但同时也会自动变号，因此结果也是正常的。举个普通减法的例子：5 + -3, 那么在x_sub中就是5 - 3; 如果是3 + -5, 那么在x_sub中就是-(5 - 3),  因为发生了交换。但不管那种情况，符号都是一样的</code></li>
<li><code>如果a是负、b是正，调用x_sub(b, a)，此时等价于b的绝对值减去a的绝对值。所以这个和上面a是正、b是负是等价的。</code></li>
</ul>
<p><strong>所以符号相同，会调用x_add、符号不同会调用x_sub。</strong></p>
<p><strong>a - b</strong></p>
<ul>
<li><code>如果a是正、b是负，调用x_add(a, b)直接对a和b的绝对值相加即可</code></li>
<li><code>如果a是正、b是正，调用x_sub(a, b)直接对a和b的绝对值相减即可，会根据绝对值自动处理符号，而a、b为正，所以针对绝对值处理的符号，也是a - b的符号</code></li>
<li><code>如果a是负、b是正，调用x_add(a, b)对绝对值进行相加, 但是结果显然为负，因此在long_sub中还要对结果的ob_size成员乘上-1</code></li>
<li><code>如果a是负、b是负，调用x_sub(a, b)对绝对值进行相减, 会根据绝对值自动处理符号,  但是在为负的情况下绝对值越大，其值反而越小, 因此针对绝对值处理的符号，和a -  b的符号是相反的。所以最终在long_sub中，也要对结果的ob_size成员乘上-1。举个普通减法的例子：-5 - -3,  那么在x_sub中就类似于5 - 3; 如果是-3 - -5, 那么在x_sub中就类似于-(5 - 3),  因为发生了交换。但不管那种情况得到的值的正负号都是相反的，所以要再乘上-1</code></li>
</ul>
<p><strong>所以符号相同，会调用x_sub、符号不同会调用x_add。</strong></p>
<p>​        <strong>所以可以仔细回味一下Python中整数的设计思想，以及运算方式。为什么只使用digit的30个位, 以及在相加、相减的时候是怎么做的。</strong>    </p>
<p>​        <strong>当然还有乘法和除法，乘法Python内部采用的是效率更高的karatsuba算法，相当来说比较复杂，有兴趣可以自己查看一下。重点还是了解Python中的整数在底层是怎么存储的，以及为什么要这么存储。</strong>    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>这一节我们介绍了整数的底层实现，并分析了Python中的整数为什么不会溢出，以及Python如何计算一个整数所占的字节。当然我们还说了小整数对象池，以及通过分析源码中的long_add和long_sub来了解底层是如何对整数进行运算的。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>10-PyCodeObject对象和pyc文件</title>
    <url>/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="10-Python中的PyCodeObject对象与pyc文件"><a href="#10-Python中的PyCodeObject对象与pyc文件" class="headerlink" title="10-Python中的PyCodeObject对象与pyc文件"></a>10-Python中的PyCodeObject对象与pyc文件</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>当我们想要执行一个py文件的时候，只需要python  xxx.py即可，但是你有没有想过这背后的流程是怎么样的呢？从这里开始我们就开始进入到Python虚拟机的环节了，之前都是在介绍Python中的一些内置对象，不过虚拟机的执行流程、以及背后的原理却更是值得我们关注的。</strong></p>
<p><strong>这里我们先来说一下Python执行py文件的流程：</strong></p>
<ul>
<li><code>1. 首先将文件里面的内容读取出来, 所以从这个角度上讲, 文件名不一定非要是.py结尾, .txt也是可以的, 只要文件里面的内容符合Python代码规范即可</code></li>
<li><code>2. 读取文件里面的内容之后会对其进行分词, 将源代码切分成一个一个的token</code></li>
<li><code>3. 然后Python编译器会对token进行语法解析, 建立抽象语法树(AST, abstract syntax tree)</code></li>
<li><code>4. 编译器再将得到AST编译成字节码</code></li>
<li><code>5. 最终由Python虚拟机来执行字节码</code></li>
</ul>
<p><strong>首先我们从中看到了Python编译器、Python虚拟机，而且我们平常还会说Python解释器，那么三者之间有什么区别呢？</strong></p>
<blockquote>
<p><strong>实际上Python解释器 &#x3D; Python编译器 + Python虚拟机，Python编译器负责将Python源代码编译成字节码<code>(包括文件读取、分词、建立AST、编译成字节码)</code>，Python虚拟机负责执行这些字节码。</strong></p>
</blockquote>
<p><strong>那么Python编译器和Python虚拟机都在什么地方呢？如果打开Python的安装目录，会发现有一个python.exe，点击的时候会通过它来启动一个终端。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202008/1229382-20200815023105176-468360562.png" alt="img"></p>
<p><strong>但问题是这个文件大小还不到100K，不可能容纳一个解释器加一个虚拟机，所以下面还有一个python38.dll，没错，编译器、虚拟机都藏身于python38.dll当中。</strong></p>
<p><strong>因此Python代码并不是直接就一步到胃、变成机器码，而是先被Python编译器编译成字节码，中间存在一个编译的过程。而之所以要存在编译，是为了能够让虚拟机更快速的执行，而且还可以尽早的检测出语法上的错误。</strong></p>
<p><strong>那么下面我们就来看看Python中的字节码长什么样子。</strong></p>
<h3 id="Python编译器的编译结果–PyCodeObject对象"><a href="#Python编译器的编译结果–PyCodeObject对象" class="headerlink" title="Python编译器的编译结果–PyCodeObject对象"></a>Python编译器的编译结果–PyCodeObject对象</h3><p><strong>我们知道Python代码的编译结果是字节码，里面必然隐藏了Python运行的秘密，因此不管是深入理解虚拟机还是调优Python的运行效率，字节码都是绕不过去的一个坎。</strong></p>
<blockquote>
<p><strong>注意：我们这里会研究字节码，但是不会研究Python是怎么编译得到字节码。因为Python编译器的工作原理和其它语言基本类似，很多关于编译原理的书籍都有介绍，编译这个过程不是Python特有的。并且研究Python的编译过程，对于我们开发帮助不是很大。</strong></p>
<p><strong>所以我们只需要知道Python解释器的背后有一个编译器会通过”读取文件”、”对源代码分词”、”分词之后会语法解析建立AST”、”对AST编译”得到字节码即可，至于这一列步骤是怎么做的、是怎么将源代码变成的字节码不是我们需要关心的，我们的重点是研究字节码本身以及虚拟机。</strong></p>
</blockquote>
<h4 id="PyCodeObject对象和pyc文件"><a href="#PyCodeObject对象和pyc文件" class="headerlink" title="PyCodeObject对象和pyc文件"></a>PyCodeObject对象和pyc文件</h4><p><strong>首先做Python开发的肯定都见过这个pyc文件，它一般位于<code>__pycache__</code>目录中，那么这个pyc文件和字节码之间有什么关系呢？</strong></p>
<p><strong>首先我们知道，Python执行这个文件首先要进行的动作就是编译，编译会得到字节码。然而除了字节码之外，还应该包含一些其它的信息，这些信息也是Python运行的时候所必须的。</strong></p>
<p><strong>在编译过程中，像常量值、字符串这些源代码当中的静态信息都会被Python编译器收集起来，并且这些静态信息也都会体现在编译之后的结果里面。在Python运行期间，这些源文件提供的静态信息都会被存储在一个运行时的对象当中，当Python运行结束时，这个运行时对象中所包含的信息还会被存储在一种文件中。这个对象和文件就是我们接下来要探讨的重点：PyCodeObject对象和pyc文件。</strong></p>
<blockquote>
<p><strong>Python中的字节码只是一个PyBytesObject对象、或者说一段字节序列，PyCodeObject对象中有一个成员co_code，它是一个指针，指向了这段字节序列。但是这个对象除了有co_code指向字节码之外，还有很多其它成员，负责保存代码涉及到的常量、变量<code>(名字、符号)</code>等等</strong></p>
<p><strong>所以我们知道了，pyc文件里面的内容是PyCodeObject对象。对于Python编译器来说，PyCodeObject对象才是其真正的编译结果，而pyc文件是这个对象在硬盘上表现形式。</strong></p>
</blockquote>
<p><strong>在程序运行期间，编译结果存在于内存的PyCodeObject对象当中，而Python结束运行之后，编译结果又被保存到了pyc文件当中。当下一次运行的时候，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不需要再度重新编译了。</strong></p>
<h4 id="python源码中的PyCodeObject对象"><a href="#python源码中的PyCodeObject对象" class="headerlink" title="python源码中的PyCodeObject对象"></a>python源码中的PyCodeObject对象</h4><p><strong>我们说Python编译器会将Python源代码编译成字节码，虚拟机执行的也是字节码，所以要理解虚拟机的运行时<code>(runtime)</code>行为，就必须要先掌握字节码。而我们说字节码是被底层结构体PyCodeObject的成员co_code指向，那么我们就必须来看看这个结构体了，它的定义位于 *Include&#x2F;code.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD		<span class="comment">/* 头部信息, 我们看到真的一切皆对象, 字节码也是个对象 */</span>	</span><br><span class="line">    <span class="type">int</span> co_argcount;            <span class="comment">/* 可以通过位置参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_posonlyargcount;     <span class="comment">/* 只能通过位置参数传递的参数个数,  Python3.8新增 */</span></span><br><span class="line">    <span class="type">int</span> co_kwonlyargcount;      <span class="comment">/* 只能通过关键字参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;             <span class="comment">/* 代码块中局部变量的个数，也包括参数 */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;           <span class="comment">/* 执行该段代码块需要的栈空间 */</span></span><br><span class="line">    <span class="type">int</span> co_flags;               <span class="comment">/* 参数类型标识 */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;         <span class="comment">/* 代码块在对应文件的行号 */</span></span><br><span class="line">    PyObject *co_code;          <span class="comment">/* 指令集, 也就是字节码, 它是一个bytes对象 */</span></span><br><span class="line">    PyObject *co_consts;        <span class="comment">/* 常量池, 一个元组，保存代码块中的所有常量。 */</span></span><br><span class="line">    PyObject *co_names;         <span class="comment">/* 一个元组,保存代码块中引用的其它作用域的变量 */</span></span><br><span class="line">    PyObject *co_varnames;      <span class="comment">/* 一个元组,保存当前作用域中的变量 */</span></span><br><span class="line">    PyObject *co_freevars;      <span class="comment">/* 内层函数引用的外层函数的作用域中的变量 */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* 外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的 */</span></span><br><span class="line"></span><br><span class="line">    Py_ssize_t *co_cell2arg;    <span class="comment">/* 无需关注 */</span></span><br><span class="line">    PyObject *co_filename;      <span class="comment">/* 代码块所在的文件名 */</span></span><br><span class="line">    PyObject *co_name;          <span class="comment">/* 代码块的名字，通常是函数名或者类名 */</span></span><br><span class="line">    PyObject *co_lnotab;        <span class="comment">/* 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的无需关注了</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;       <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="type">void</span> *co_extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *co_opcache_map;</span><br><span class="line">    _PyOpcache *co_opcache;</span><br><span class="line">    <span class="type">int</span> co_opcache_flag; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> co_opcache_size; </span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里面的每一个成员，我们后面都会逐一演示进行说明。总之Python编译器在对Python源代码进行编译的时候，对于代码中的每一个block，都会创建一个PyCodeObject与之对应。但是多少代码才算得上是一个block呢？事实上，Python有一个简单而清晰的规则：当进入一个新的名字空间，或者说作用域时，我们就算是进入了一个新的block了。这里又引出了名字空间，别急，我们后面会一点一点说，总之先举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = []</span><br></pre></td></tr></table></figure>

<p><strong>我们仔细观察一下上面这个文件，它在编译完之后会有三个PyCodeObject对象，一个是对应整个py文件的，一个是对应class A的，一个是对应def foo的。因为这是三个不同的作用域，所以会有三个PyCodeObject对象。</strong></p>
<p><strong>在这里，我们开始提及Python中一个至关重要的概念–名字空间(name  space)、也叫命名空间、名称空间，都是一个东西。名字空间是符号的上下文环境，符号的含义取决于名字空间。更具体的说，一个变量名对应的变量值什么，在Python中是不确定的，需要命名空间来决定。</strong></p>
<p>对于某个符号、或者名字<code>(我们在前面系列中说过Python的变量只是一个名字)</code>，比如说上面代码中的a，在某个名字空间中，它可能指向一个PyLongObject对象；而在另一个名字空间中，它可能指向一个PyListObject对象。但是在一个名字空间中，一个符号只能有一种含义。而且名字空间可以一层套一层的形成一条<code>名字空间链</code>，Python虚拟机在执行的时候，会有很大一部分时间消耗在从<code>名字空间链</code>中确定一个符号所对应的对象是什么。这也侧面说明了，Python为什么比较慢。</p>
<p><strong>如果你现在名字空间还不是很了解，不要紧，随着剖析的深入，你一定会对名字空间和Python在名字空间链上的行为有着越来越深刻的理解。总之现在需要记住的是：一个code block对应一个名字空间<code>(或者说作用域)</code>、同时也对应一个PyCodeObject对象。在Python中，类、函数、module都对应着一个独自的名字空间，因此都会有一个PyCodeObject与之对应。</strong></p>
<h4 id="如何在Python中访问PyCodeObject对象"><a href="#如何在Python中访问PyCodeObject对象" class="headerlink" title="如何在Python中访问PyCodeObject对象"></a>如何在Python中访问PyCodeObject对象</h4><p><strong>那么我们如何才能在Python中获取到PyCodeObject对象呢？PyCodeObject对象在Python中也是一个对象，它的类型对象是<code>&lt;class &#39;code&#39;&gt;</code>。但是这个类，底层没有暴露给我们，所以code对于Python来说只是一个没有定义的变量罢了。</strong></p>
<p><strong>但是我们可以通过其它的方式进行获取，首先来看看如何通过函数来获取该函数对应的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(func.__code__))  <span class="comment"># &lt;class &#x27;code&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过函数的<code>__code__</code>拿到底层对应的PyCodeObject对象，当然也可以获取里面的属性，我们来演示一下。</strong></p>
<p>​        <strong>co_argcount：可以通过位置参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, *args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_argcount)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *args, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_argcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>foo中的参数a、b、c都可以通过位置参数传递，所以结果是3；对于bar，显然是两个，这里不包括<code>\*args</code>；而函数func，显然是两个，因为参数c只能通过关键字参数传递。</strong></p>
<p>​        <strong>co_posonlyargcount：只能通过位置参数传递的参数个数，python3.8新增</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_posonlyargcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, /, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_posonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：这里是只能通过位置参数传递的参数个数。</strong></p>
<p>​        <strong>co_kwonlyargcount：只能通过关键字参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=<span class="number">1</span>, c=<span class="number">2</span>, *, d, e</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_kwonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>这里是d和e，它们必须通过关键字参数传递。</strong></p>
<p>​        <strong>co_nlocals：代码块中局部变量的个数，也包括参数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量：a、b、c、name、age、gender，所以我们看到在编译成字节码的时候函数内局部变量的个数就已经确定了，因为它是静态存储的。</strong></p>
<p>​        <strong>co_stacksize：执行该段代码块需要的栈空间</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_stacksize)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>这个不需要关注</strong></p>
<p>​        <strong>co_firstlineno：代码块在对应文件的起始行</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然是文件的第一行</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_firstlineno)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>如果函数出现了调用呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_firstlineno)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>如果执行foo，那么会返回函数bar，调用的就是bar函数的字节码，那么得到就是<code>def bar():</code>所在的行数。因为每个函数都有自己独自的命名空间，以及PyCodeObject对象。</strong></p>
<p>​        <strong>co_names：一个元组，保存代码块中不在当前作用域的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_names)  <span class="comment"># (&#x27;print&#x27;, &#x27;c&#x27;, &#x27;list&#x27;, &#x27;int&#x27;, &#x27;str&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到print、c、list、int、str都是全局或者内置变量，函数、类也可以看成是变量，它们都不在当前foo函数的作用域中。</strong></p>
<p>​        <strong>co_varnames：一个元组，保存在当前作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>a、b、d是位于当前foo函数的作用域当中的，所以编译阶段便确定了局部变量是什么。</strong></p>
<p>​        <strong>co_consts：常量池，一个元组对象，保存代码块中的所有常量。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>, <span class="literal">False</span>, <span class="built_in">list</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># list不属于常量</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_consts)  <span class="comment"># (None, &#x27;abc&#x27;, True, False, 1, 2, 3, &#x27;a&#x27;, &#x27;&gt;&gt;&gt;&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>co_consts里面出现的都是常量，而<code>[1, 2, 3]</code>和<code>&#123;&quot;a&quot;: 1&#125;</code>，则是将里面元素单独拿出来了。不过可能有人好奇里面的None是从哪里来的。首先a和b是不是函数的参数啊，所以co_consts里面还要有两个常量，但是我们还没传参呢，所以使用None来代替。</strong></p>
<p>​        <strong>co_freevars：内层函数引用的外层函数的作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里调用的是f2的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1().__code__.co_freevars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_cellvars：外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():    </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但这里调用的是f1的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_cellvars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_filename：代码块所在的文件名</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_filename)  <span class="comment"># D:/satori/1.py</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_name：代码块的名字，通常是函数名或者类名</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_code：字节码</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, /, c, *, d, e</span>):</span><br><span class="line">    f = <span class="number">123</span></span><br><span class="line">    g = <span class="built_in">list</span>()</span><br><span class="line">    g.extend([<span class="built_in">tuple</span>, <span class="built_in">getattr</span>, <span class="built_in">print</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_code)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;d\x01&#125;\x05t\x00\x83\x00&#125;\x06|\x06\xa0\x01t\x02t\x03t\x04g\x03\xa1\x01\x01\x00d\x00S\x00&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 这便是字节码, 当然单单是这些字节码肯定不够的, 所以还需要其它的静态信息</span></span><br><span class="line"><span class="comment"># 其它的信息显然连同字节码一样, 都位于PyCodeObject中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># co_lnotab: 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_lnotab)  <span class="comment"># b&#x27;\x00\x01\x04\x01\x06\x01&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">然而事实上，Python不会直接记录这些信息，而是会记录增量值。比如说：</span></span><br><span class="line"><span class="string">字节码在co_code中的偏移量            .py文件中源代码的行号</span></span><br><span class="line"><span class="string">0                                  1  </span></span><br><span class="line"><span class="string">6                                  2</span></span><br><span class="line"><span class="string">50                                 7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么co_lnotab就应该是: 0 1 6 1 44 5</span></span><br><span class="line"><span class="string">0和1很好理解, 就是co_code和.py文件的起始位置</span></span><br><span class="line"><span class="string">而6和1表示字节码的偏移量是6, .py文件的行号增加了1</span></span><br><span class="line"><span class="string">而44和5表示字节码的偏移量是44, .py文件的行号增加了5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h4><p><strong>每一个PyCodeObject对象中都包含了一个co_code指针，指向code block中所有代码经过编译后得到的byte  code序列。前面我们说到，Python会将字节码序列和PyCodeObject对象一起存储在pyc文件中。但不幸的是，事实并不总是这样。有时，当我们运行一个简单的程序时并没有产生pyc文件，因此我们猜测：有些python程序只是临时完成一些琐碎的工作，这样的程序仅仅只会运行一次，然后就不会再使用了，因此也就没有保存至pyc文件的必要。</strong></p>
<p><strong>如果我们在代码中加上了一个import  abc这样语句，再执行你就会发现Python为其生成了pyc文件，这就说明import会触发pyc的生成。实际上，在运行过程中，如果碰到import  abc这样的语句，那么Python会在设定好的path中寻找abc.pyc或者abc.dll文件，如果没有这些文件，而是只发现了abc.py，那么Python会先将abc.py编译成PyCodeObject，然后创建pyc文件，并将PyCodeObject写到pyc文件里面去。接下来，再对abc.pyc进行import动作，对，并不是编译成PyCodeObject对象之后直接使用，而是先写到pyc里面去，然后将pyc文件的PyCodeObject对象重新在内存中复制出来。</strong></p>
<p><font color="red"><strong>关于python的import机制，我们后面章节会剖析，这里只是用来完成pyc文件的触发。当然得到pyc文件有很多方法，比如使用py_compile模块。</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>执行b.py的时候，会发现创建了a.cpython-38.pyc。另外关于pyc文件的创建位置，会在当前文件的同级目录下的<code>__pycache__</code>目录中创建，名字就叫做：py文件名.cpython-版本号.pyc</strong></p>
<h4 id="通过compile获取PyCodeObject对象"><a href="#通过compile获取PyCodeObject对象" class="headerlink" title="通过compile获取PyCodeObject对象"></a>通过compile获取PyCodeObject对象</h4><p><strong>事实上我们已经介绍了一种方法去获取相应的PyCodeObject对象，但是还有没有其他的方法呢？答案是通过内置函数compile，但是在介绍compile之前，先介绍一下eval和exec。</strong></p>
<p>​        <strong>eval：传入一个字符串，然后把字符串里面的内容拿出来。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 所以eval(&quot;a&quot;)就等价于a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1 + 1&quot;</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：eval是有返回值的，返回值就是字符串里面内容。</span></span><br><span class="line"><span class="comment"># 或者说eval是可以作为右值的，比如a = eval(&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment"># 所以eval里面绝不可以出现诸如赋值之类的，比如 print(eval(&quot;a = 3&quot;))，那么这个语句等价于print(a = 3)，这样显然会出现语法错误的</span></span><br><span class="line"><span class="comment"># 因此eval里面把字符串剥掉之后就是一个普通的值，不可以出现诸如if、def等语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;xxx&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>exec：传入一个字符串，把字符串里面的内容当成语句来执行，这个是没有返回值，或者说返回值是None。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1&quot;</span>)  <span class="comment"># 等价于把a = 1这个字符串里面的内容当成语句来执行</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;&quot;&quot;a = 123</span></span><br><span class="line"><span class="string">if a == 123:</span></span><br><span class="line"><span class="string">    print(&quot;a等于123&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;a不等于123&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(statement)  <span class="comment"># a等于123</span></span><br><span class="line"><span class="comment"># 注意：&#x27;a等于123&#x27;并不是exec返回的，而是把上面那坨字符串当成普通代码执行的时候print出来的</span></span><br><span class="line"><span class="comment"># 这便是exec的作用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么它和eval的区别就显而易见的，eval是要求字符串里面的内容能够当成一个值来打印，返回值就是里面的值</span></span><br><span class="line"><span class="comment"># 而exec则是直接执行里面的内容</span></span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">exec</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># invalid syntax (&lt;string&gt;, line 1)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>compile：关键来了，它执行后返回的就是一个code对象</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">statement = <span class="string">&quot;a, b = 1, 2&quot;</span></span><br><span class="line"><span class="comment"># 参数一：代码</span></span><br><span class="line"><span class="comment"># 参数二：可以为这些代码起一个文件名</span></span><br><span class="line"><span class="comment"># 参数三：执行方式,可以选择三种方式。exec: 将源码当做一个模块来编译;single: 用于编译一个单独d的Python语句(交互式下);eval:用于编译一个eval表达式</span></span><br><span class="line"><span class="comment"># 这里显然是exec</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_firstlineno)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(co.co_filename)  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(co.co_argcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是一个元组，因为我们是a, b = 1, 2这种方式赋值的，所以加载的是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># ((1, 2), None)</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;a = 1;b = 2&quot;</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># (1, 2, None)</span></span><br><span class="line"><span class="built_in">print</span>(co.co_names)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们后面在分析PyCodeObject的时候，会经常使用compile的方式。</strong></p>
<h3 id="pyc文件的生成"><a href="#pyc文件的生成" class="headerlink" title="pyc文件的生成"></a>pyc文件的生成</h3><h4 id="创建pyc文件的具体过程"><a href="#创建pyc文件的具体过程" class="headerlink" title="创建pyc文件的具体过程"></a>创建pyc文件的具体过程</h4><p><strong>前面我们提到，Python通过import  module进行加载时，如果没有找到相应的pyc或者dll文件，就会在py文件的基础上自动创建pyc文件。所以想要了解pyc文件是怎么创建的，只需要了解PyCodeObject是如何写入的即可。关于写入pyc文件，主要写入三个内容：</strong></p>
<p>​        <strong>1. magic number</strong>    </p>
<p><strong>这是Python定义的一个整数值，不同版本的Python会定义不同的magic  number，这个值是为了保证Python能够加载正确的pyc。比如Python3.7不会加载3.6版本的pyc，因为Python在加载这个pyc文件的时候会首先检测该pyc的magic number，如果和自身的magic number不一致，则拒绝加载。</strong></p>
<p>​        <strong>2. pyc的创建时间</strong>    </p>
<p><strong>这个很好理解，因为编译完之后要是把源代码修改了怎么办呢？因此会判断源代码的最后修改时间和pyc文件的创建时间，如果pyc文件的创建时间比源代码修改时间要早，说明在生成pyc之后，源代码被修改了，那么会重新编译新的pyc，而反之则会直接加载pyc。</strong></p>
<p>​        <strong>3.PyCodeObject对象</strong>    </p>
<p><strong>这个不用说了，肯定是要存储的。当然还有字节码，不过PyCodeObject里面的co_code指向了这个字节码，所以我们就直接说PyCodeObject对象了。</strong></p>
<h4 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h4><p><strong>既然要写入，那么肯定要有文件句柄，我们来看看：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：Python/marshal.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FILE是一个文件句柄，可以把WFILE看成是FILE的包装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FILE *fp;  <span class="comment">//文件句柄</span></span><br><span class="line">    <span class="comment">//下面的字段在写入信息的时候会看到</span></span><br><span class="line">    <span class="type">int</span> error;  </span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">char</span> *end;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    _Py_hashtable_t *hashtable;</span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line">&#125; WFILE;</span><br></pre></td></tr></table></figure>

<p><strong>写入magic number和时间：</strong></p>
<p><strong>写入magic number和时间都是调用了<code>PyMarshal_WriteLongToFile</code>，我们来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteLongToFile</span><span class="params">(<span class="type">long</span> x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明char型的数组，元素个数为4个</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//声明一个WFILE类型变量wf</span></span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="comment">//内存初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    <span class="comment">//设置fp，文件句柄</span></span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    <span class="comment">//将buf数组的指针赋值给wf.ptr和wf.buf</span></span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    <span class="comment">//相当于buf的最后一个元素的指针</span></span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">//写错误</span></span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    <span class="comment">//写入版本信息</span></span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="comment">//调用w_long将x也就是版本信息或者时间写到wf里面去</span></span><br><span class="line">    w_long(x, &amp;wf);</span><br><span class="line">    <span class="comment">//刷到磁盘上</span></span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到这一步只是初始化一个WFILE对象，真正写入则是调用w_long</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_long</span><span class="params">(<span class="type">long</span> x, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    w_byte((<span class="type">char</span>)( x      &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//w_long则是将要写入的x一个字节一个字节写到文件里面去。</span></span><br></pre></td></tr></table></figure>

<p><strong>写入PyCodeObject对象：</strong></p>
<p><strong>写入PyCodeObject对象则是调用了<code>PyMarshal_WriteObjectToFile</code>，我们也来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteObjectToFile</span><span class="params">(PyObject *x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="keyword">if</span> (w_init_refs(&amp;wf, version))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* caller mush check PyErr_Occurred() */</span></span><br><span class="line">    w_object(x, &amp;wf);</span><br><span class="line">    w_clear_refs(&amp;wf);</span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看到，和PyMarshal_WriteLongToFile基本是类似的</span></span><br><span class="line"><span class="comment">//只不过PyMarshal_WriteLongToFile调用的是w_long，而PyMarshal_WriteObjectToFile调用的是w_object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_object</span><span class="params">(PyObject *v, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> flag = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;depth &gt; MAX_MARSHAL_STACK_DEPTH) &#123;</span><br><span class="line">        p-&gt;error = WFERR_NESTEDTOODEEP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        w_byte(TYPE_NULL, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_None) &#123;</span><br><span class="line">        w_byte(TYPE_NONE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == PyExc_StopIteration) &#123;</span><br><span class="line">        w_byte(TYPE_STOPITER, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_Ellipsis) &#123;</span><br><span class="line">        w_byte(TYPE_ELLIPSIS, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_False) &#123;</span><br><span class="line">        w_byte(TYPE_FALSE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_True) &#123;</span><br><span class="line">        w_byte(TYPE_TRUE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!w_ref(v, &amp;flag, p))</span><br><span class="line">        w_complex_object(v, flag, p);</span><br><span class="line"></span><br><span class="line">    p-&gt;depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到本质上还是调用了w_byte，但是在这里面我们并没有看到诸如：列表、元组之类的数据的存储过程，注意最后的w_complex_object，关键来了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源代码很长, 具体逻辑就不贴了</span></span><br><span class="line"><span class="comment">//我们后面会单独截取一部分	进行分析</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_complex_object</span><span class="params">(PyObject *v, <span class="type">char</span> flag, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyLong_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyFloat_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyComplex_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyBytes_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyUnicode_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; PyUnicode_IS_ASCII(v)) &#123;</span><br><span class="line">            	<span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyAnySet_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyCode_Check(v)) &#123;</span><br><span class="line">        PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyObject_CheckBuffer(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        W_TYPE(TYPE_UNKNOWN, p);</span><br><span class="line">        p-&gt;error = WFERR_UNMARSHALLABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><font color="red"><strong>源代码很长，这里就不一一分析了，可以自行查看。不过虽然长，但是逻辑很简单，就是对不同的对象、执行不同的写动作。然而其最终目的都是通过w_byte写到pyc文件中。换句话说，Python在往pyc写入list对象时，只是将list中包含的数值或者字符串等对象写到了pyc文件中。同时这也意味着，Python在加载pyc文件时，必须基于这些数值或字符串重新构造出list对象。</strong></font></p>
<p><strong>对于PyCodeObject对象，很显然，w_object会遍历PyCodeObject中的所有域，将这些域依次写入。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br></pre></td></tr></table></figure>

<p><strong>但是当面对一个PyListObject对象时，会有什么变化呢？没错，会和PyCodeObject一样，w_object还是会遍历，然后将PyListObject对象中的每一个元素依次写入到pyc文件中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以看到PyTupleObject、PyListObject、PyDictObject都是采用了相同的姿势</span></span><br><span class="line"><span class="comment">//注意里面的W_TYPE</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">        n = PyTuple_Size(v);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; n &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            W_TYPE(TYPE_SMALL_TUPLE, p);</span><br><span class="line">            w_byte((<span class="type">unsigned</span> <span class="type">char</span>)n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            W_TYPE(TYPE_TUPLE, p);</span><br><span class="line">            W_SIZE(n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyTuple_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        W_TYPE(TYPE_LIST, p);</span><br><span class="line">        n = PyList_GET_SIZE(v);</span><br><span class="line">        W_SIZE(n, p);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyList_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        Py_ssize_t pos;</span><br><span class="line">        PyObject *key, *value;</span><br><span class="line">        W_TYPE(TYPE_DICT, p);</span><br><span class="line">        <span class="comment">/* This one is NULL object terminated! */</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(v, &amp;pos, &amp;key, &amp;value)) &#123;</span><br><span class="line">            w_object(key, p);</span><br><span class="line">            w_object(value, p);</span><br><span class="line">        &#125;</span><br><span class="line">        w_object((PyObject *)<span class="literal">NULL</span>, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到无论对于哪一个对象，在写入之前，都会先调用W_TYPE写一个类似于类型的东西，是的，诸如TYPE_LIST、TYPE_TUPLE、TYPE_DICT这样的标识，对于pyc文件的加载起着至关重要的作用。</strong></p>
<p><strong>之前说过，Python仅仅将容器里面的数值和字符串写入到pyc文件。当PyCodeObject写入到pyc之后，所有的数据就变成了字节流，类型信息就丢失了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从当前来看，常量池中没有任何关于列表的信息</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_consts)  <span class="comment"># (None, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<p><strong>然鹅如果没有类型信息，那么当python再次加载pyc文件的时候，就没办法知道字节流中隐藏的结构和蕴含的信息，所以Python必须往pyc文件写入一个标识，这些标识正是Python定义的类型信息。如果Python在pyc中发现了这样的标识，则预示着上一个对象结束，新的对象开始，并且也知道新对象是什么样的对象，从而也知道该执行什么样的加载动作，这些标识也是可以看到的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//marshal.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NULL               <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NONE               <span class="string">&#x27;N&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FALSE              <span class="string">&#x27;F&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TRUE               <span class="string">&#x27;T&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STOPITER           <span class="string">&#x27;S&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ELLIPSIS           <span class="string">&#x27;.&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT                <span class="string">&#x27;i&#x27;</span></span></span><br><span class="line"><span class="comment">/* TYPE_INT64 is not generated anymore.</span></span><br><span class="line"><span class="comment">   Supported for backward compatibility only. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT64              <span class="string">&#x27;I&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FLOAT              <span class="string">&#x27;f&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_FLOAT       <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_COMPLEX            <span class="string">&#x27;x&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_COMPLEX     <span class="string">&#x27;y&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LONG               <span class="string">&#x27;l&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STRING             <span class="string">&#x27;s&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INTERNED           <span class="string">&#x27;t&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_REF                <span class="string">&#x27;r&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TUPLE              <span class="string">&#x27;(&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LIST               <span class="string">&#x27;[&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_DICT               <span class="string">&#x27;&#123;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_CODE               <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNICODE            <span class="string">&#x27;u&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNKNOWN            <span class="string">&#x27;?&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_SET                <span class="string">&#x27;&lt;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FROZENSET          <span class="string">&#x27;&gt;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>到了这里可以看到，其实Python对于PyCodeObject对象的导出实际上是不复杂的，因为不管什么对象，最后都为归结为两种简单的形式，一种是数值写入，一种是字符串写入。上面都是对数值的写入，比较简单，仅仅需要按照字节一次写入pyc即可。然而在写入字符串的时候，Python设计了一种比较复杂的机制，有兴趣可以自己阅读源码，这里不再介绍。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前说对于这样的一个py文件，会创建三个PyCodeObject对象，但是写到pyc文件里面的只有一个PyCodeObject对象，这难道不就意味着有两个PyCodeObject丢失了吗？其实很明显，有两个PyCodeObject对象是位于另一个PyCodeObject对象当中的。因此foo和A对应的PyCodeObject对象位于a.py这个PyCodeObject对象当中，准确的说是位于co_consts指向的常量池当中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_consts)</span><br><span class="line"><span class="comment"># (None, &lt;code object f2 at 0x000001BC5DF3D450, file &quot;D:/satori/1.py&quot;, line 2&gt;, &#x27;f1.&lt;locals&gt;.f2&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到f2对应的PyCodeObject确实位于f1的常量池当中，但其实说白了不过f1的常量池当中有一个指针在指向f2对应PyCodeObject罢了。只不过在写入的时候，也会把指针的内容一块写进去，所以也可以理解就是写了3个PyCodeObject对象。不过这都不是重点，重点是PyCodeObject对象是可以嵌套的，当在一个作用域内部发现了一个新的作用域，那么新的作用域对应的PyCodeObject对象会位于外层作用域的PyCodeObject对象的常量池中，或者说被常量池中的一个指针指向。</strong></p>
<p><strong>而在写入pyc的时候会从最外层、也就是模块的PyCodeObject对象开始写入，如果碰到了包含的另一个PyCodeObject对象，那么就会递归地执行写入新的PyCodeObject对象的操作。如此下去，最终所有的PyCodeObject对象都会写入到pyc文件当中，因此pyc文件当中的PyCodeObject对象也是以一种嵌套的关系联系在一起的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>这里问一下，上面那段代码中创建了几个PyCodeObject对象呢？</strong></p>
<blockquote>
<p><strong>答案是6个，首先全局是一个，foo函数一个，bar函数一个，类A一个，类A里面的foo函数一个，类A里面的bar函数一个，所以一共是6个。</strong></p>
<p><strong>而且这里的PyCodeObject对象是层层嵌套的，一开始是对整个全局创建PyCodeObject对象，然后遇到了函数foo，那么再为函数foo创建一个PyCodeObject对象，依次往下。所以如果是常量值、字符串等等，则相当于是静态信息，直接存储起来便可；可如果是函数、类，那么会为其创建新的PyCodeObject对象，然后收集起来，所以A里面的foo函数对应的PyCodeObject对象是存在A对应PyCodeObject对象里面的；而A对应的PyCodeObject对象则是存在全局对应的PyCodeObject对象里面，当然此时还有外层的foo、bar函数。。</strong></p>
</blockquote>
<h3 id="Python的字节码与反编译"><a href="#Python的字节码与反编译" class="headerlink" title="Python的字节码与反编译"></a>Python的字节码与反编译</h3><p><strong>关于Python的字节码，是后面章节剖析虚拟机的重点，现在先来看一下。我们知道Python执行源代码之前会对其进行编译得到PyCodeObject对象，里面的co_code指向了字节码序列，Python虚拟机会根据这些字节码序列来进行一系列的操作<code>(当然也依赖其它的静态信息)</code>，从而完成对程序的执行。</strong></p>
<p><strong>当然每一个操作在python中都对应一个操作指令、或者操作数，总共一共定义了121个。其实说白了每个指令不过是一个整数罢了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POP_TOP                   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_TWO                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_THREE                 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP                   4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP_TWO               5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP                       9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_POSITIVE           10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NEGATIVE           11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NOT                12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_INVERT             15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MATRIX_MULTIPLY   16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_MATRIX_MULTIPLY  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_POWER             19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MULTIPLY          20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MODULO            22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_ADD               23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBTRACT          24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBSCR            25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_FLOOR_DIVIDE      26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TRUE_DIVIDE       27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_FLOOR_DIVIDE     28</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>然后我们可以通过反编译的方式查看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的dis模块是专门干这件事情</span></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 里面可以接收一个字节码对象, 当然函数也是可以的, 会自动获取co_code</span></span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  5           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              2 LOAD_FAST                1 (b)</span></span><br><span class="line"><span class="string">              4 BINARY_ADD</span></span><br><span class="line"><span class="string">              6 STORE_FAST               2 (c)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  6           8 LOAD_FAST                2 (c)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>字节码反编译后的结果多么像汇编语言！其中，第一列是源代码行号，第二列是字节码偏移量，第三列是操作数。</strong></p>
<p><strong>关于反编译的内容，我们会在剖析函数的时候，深入介绍。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>12-剖析字节码指令</title>
    <url>/2023/03/29/12-%E5%89%96%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程"><a href="#12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程" class="headerlink" title="12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程"></a>12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程</h2><p><strong>上一章中，我们通过_PyEval_EvalFrameDefault看到了Python虚拟机的整体框架，那么这一章我们将深入到_PyEval_EvalFrameDefault的各个细节当中，深入剖析Python的虚拟机，在本章中我们将剖析Python虚拟机是如何完成对一般表达式的执行的。这里的一般表达式包括最基本的对象创建语句、打印语句等等。至于if、while等表达式，我们将其归类于控制流语句，对于Python中控制流的剖析，我们将留到下一章。</strong></p>
<h3 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h3><p><strong>这里我们通过问与答的方式，简单回顾一下前面的内容。</strong></p>
<p>​        <strong>请问 Python 程序是怎么运行的？是编译成机器码后在执行的吗？</strong>    </p>
<p><strong>不少初学者对 *Python* 存在误解，以为它是类似 *Shell* 的解释性脚本语言，其实并不是。虽然执行 *Python* 程序的 称为 *Python* 解释器，但它其实包含一个 “编译器” 和一个 “虚拟机”。</strong></p>
<p><strong>当我们在命令行敲下 <code>python xxxx.py</code> 时，*python* 解释器中的编译器首先登场，将 *Python* 代码编译成 *PyCodeObject* 对象。*PyCodeObject* 对象包含 字节码 以及执行字节码所需的 名字 以及 常量。</strong></p>
<p><strong>当编译器完成编译动作后，接力棒便传给 虚拟机。虚拟机 维护执行上下文，逐行执行 字节码 指令。执行上下文中最核心的 名字空间，便是由 虚拟机 维护的。</strong></p>
<p><strong>因此，*Python* 程序的执行原理其实更像 *Java*，可以用两个词来概括—— 虚拟机和字节码。不同的是，*Java* 编译器 *javac* 与 虚拟机 *java* 是分离的，而 *Python* 将两者整合成一个 *python* 命令。</strong></p>
<p>​        <strong>pyc 文件保存什么东西，有什么作用？</strong>    </p>
<p><strong>Python 程序执行时需要先由 编译器 编译成 *PyCodeObject* 对象，然后再交由 虚拟机 来执行。不管程序执行多少次，只要源码没有变化，编译后得到的 *PyCodeObject* 对象就肯定是一样的。因此，*Python* 将 *PyCodeObject* 对象序列化并保存到 *pyc* 文件中。当程序再次执行时，*Python* 直接从 *pyc* 文件中加载代码对象，省去编译环节。当然了，当 *py* 源码文件改动后，*pyc* 文件便失效了，这时 *Python* 必须重新编译 *py* 文件。</strong></p>
<p>​        <strong>如何查看 Python 程序的字节码？</strong>    </p>
<p><strong>Python 标准库中的 *dis* 模块，可以对 *PyCodeObject* 对象 以及 函数进行反编译，并显示其中的 字节码。</strong></p>
<blockquote>
<p><strong>其实dis.dis最终反编译的就是字节码，只不过我们可以传入一个函数，会自动获取其字节码。比如：函数foo，我们可以dis.dis(foo)、dis.dis(foo.<strong>code</strong>)、dis.dis(foo.<strong>code</strong>.co_code)，最终都是对字节码进行反编译的。</strong></p>
</blockquote>
<p><strong>在这里我们说几个常见的字节码指令，因为它太常见了以至于我们这里必须要提一下，然后再举例说明。</strong></p>
<ul>
<li><code>LOAD_CONST: 加载一个常量</code></li>
<li><code>LOAD_FAST: 在局部作用域中(比如函数)加载一个当前作用域的局部变量</code></li>
<li><code>LOAD_GLOBAL: 在局部作用域(比如函数)中加载一个全局变量或者内置变量</code></li>
<li><code>LOAD_NAME: 在全局作用域中加载一个全局变量或者内置变量</code></li>
<li><code>STORE_FAST: 在局部作用域中定义一个局部变量, 来建立和某个对象之间的映射关系</code></li>
<li><code>STORE_GLOBAL: 在局部作用域中定义一个global关键字声明的全局变量, 来建立和某个对象之间的映射关系</code></li>
<li><code>STORE_NAME: 在全局作用域中定义一个全局变量, 来建立和某个对象之间的映射关系</code></li>
</ul>
<p><strong>然后下面的我们就来看看这些指令：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(gender)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line">  <span class="number">9</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (gender)</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>           <span class="number">4</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">0</span> (gender)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">11</span>          <span class="number">12</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">14</span> LOAD_GLOBAL              <span class="number">1</span> (name)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_CONST 1 (&#39;female&#39;):  加载常量&quot;female&quot;, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_FAST 0 (gender): 在局部作用域中定义一个局部变量gender, 所以是STORE_FAST</code></li>
<li><code>4 LOAD_GLOBAL 0 (print): 在局部作用域中加载一个内置变量print, 所以是LOAD_GLOBAL</code></li>
<li><code>6 LOAD_FAST 0 (gender): 在局部作用域中加载一个局部变量gender, 所以是LOAD_FAST</code></li>
<li><code>14 LOAD_GLOBAL 1 (name): 在局部作用域中加载一个全局变量name, 所以是LOAD_GLOBAL</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    name = <span class="string">&quot;马自立三舅&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"> <span class="number">10</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;马自立三舅&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_GLOBAL             <span class="number">0</span> (name)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_CONST 1 (&#39;马自立三舅&#39;): 加载一个字符串常量, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_GLOBAL 0 (name): 在局部作用域中定义一个被global关键字声明的全局变量, 所以是STORE_GLOBAL</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">print(name)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_NAME                <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_NAME                <span class="number">0</span> (name)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code> 0 LOAD_CONST 0 (&#39;夏色祭&#39;): 加载一个字符串常量, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_NAME 0 (name): 在全局作用域中定义一个全局变量name, 所以是STORE_NAME</code></li>
<li><code>4 LOAD_NAME 1 (print): 在全局作用域中加载一个内置变量print, 所以是LOAD_NAME</code></li>
<li><code>6 LOAD_NAME 0 (name): 在全局作用域中加载一个全局变量name, 所以是LOAD_NAME</code></li>
</ul>
<p><strong>因此LOAD_CONST、LOAD_FAST、LOAD_GLOBAL、LOAD_NAME、STORE_FAST、STORE_GLOBAL、STORE_NAME它们是和加载常量、变量和定义变量之间有关的，可以说常见的不能再常见了，你写的任何代码在反编译之后都少不了它们的身影，至少会出现一个。因此有必要提前解释一下，它们分别代表的含义是什么。</strong></p>
<p>​        <strong>Python 中变量交换有两种不同的写法，示例如下。这两种写法有什么区别吗？那种写法更好？</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>

<p><strong>这两种写法都能实现变量交换，表面上看第一种写法更加简洁明了，似乎更优。那么，在优雅的外表下是否隐藏着不为人知的性能缺陷呢？想要找到答案，唯一的途径是研究字节码：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"># 写法一</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (b)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> ROT_TWO</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (b)</span><br><span class="line">              </span><br><span class="line"># 写法二</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (tmp)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (tmp)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">2</span> (b)              </span><br></pre></td></tr></table></figure>

<p><strong>从字节码上看，第一种写法需要的指令条目要少一些：先将两个变量依次加载到栈，然后一条 *ROT_TWO* 指令将栈中的两个变量交换，最后再将变量依次写回去。注意到，变量加载的顺序与 *&#x3D;* 右边一致，写回顺序与 *&#x3D;* 左边一致。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(ROT_TWO)</span>: &#123;</span><br><span class="line">    <span class="comment">//从栈顶弹出元素, 因为栈是先入后出的</span></span><br><span class="line">    <span class="comment">//由于b先入栈、a后入栈, 所以这里获取的栈顶元素就是a</span></span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    <span class="comment">//运行时栈的第二个元素就是b</span></span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    <span class="comment">//当然栈里面的元素是谁在这里并不重要, 重点是我们看到栈顶元素被设置成了栈的第二个元素</span></span><br><span class="line">    <span class="comment">//栈的第二个元素被设置成了栈顶元素, 所以两个元素确实实现了交换</span></span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>而且，*ROT_TWO* 指令只是将栈顶两个元素交换位置，执行起来比 *LOAD_NAME* 和 *STORE_NAME* 都要快。</strong></p>
<p><strong>至此，我们可以得到结论了——第一种变量交换写法更优：</strong></p>
<ul>
<li><code>代码简洁明了, 不拖泥带水</code></li>
<li><code>不需要辅助变量 tmp, 节约内存</code></li>
<li><code>ROT_TWO 指令比 LOAD_NAME 和 STORE_NAME 组成的指令对更有优势，执行效率更高</code></li>
</ul>
<p>​        <strong>请解释 is 和 &#x3D;&#x3D; 这两个操作的区别。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">is</span> b</span><br><span class="line">a == b</span><br></pre></td></tr></table></figure>

<p><strong>我们知道 *is* 是 对象标识符 ( *object identity* )，判断两个引用是不是引用的同一个对象，等价于 *id(a) &#x3D;&#x3D; id(b)* ；而 *&#x3D;&#x3D;* 操作符判断两个引用所引用的对象是不是相等，等价于调用魔法方法 *a.<strong>eq</strong>(b)* 。因此，*&#x3D;&#x3D;* 操作符可以通过 *<strong>eq</strong>* 魔法方法进行覆写( *overriding* )，而 *is* 操作符无法覆写。</strong></p>
<p><strong>从字节码上看，这两个语句也很接近，区别仅在比较指令 *COMPARE_OP* 的操作数上：</strong></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"> # a is b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="name">a</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (<span class="name">b</span>)</span><br><span class="line">              <span class="number">4</span> COMPARE_OP               <span class="number">8</span> (<span class="name">is</span>)</span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              </span><br><span class="line"># a == b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="name">a</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (<span class="name">b</span>)</span><br><span class="line">              <span class="number">4</span> COMPARE_OP               <span class="number">2</span> (<span class="name">==</span>)</span><br><span class="line">              <span class="number">6</span> POP_TOP              </span><br></pre></td></tr></table></figure>

<p>*<strong>COMPARE_OP* 指令处理逻辑在 *Python&#x2F;ceval.c* 源文件中实现，关键函数是 *cmp_outcome*：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">cmp_outcome</span><span class="params">(<span class="type">int</span> op, PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们说Python中的变量在C的层面上是一个指针, 因此Python中两个变量是否指向同一个对象 等价于 在C中两个指针是否相等</span></span><br><span class="line">    <span class="comment">//而Python中的==, 则需要调用PyObject_RichCompare(指针1, 指针2, 操作符)来看它们指向的对象所维护的值是否相等</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">        <span class="comment">//is操作符的话, 在C的层面直接一个==判断即可</span></span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//而PyObject_RichCompare是一个函数调用, 将进一步调用对象的魔法方法进行判断。</span></span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);</span><br><span class="line">    &#125;</span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># a 和 b 均引用同一个对象, is 和 == 操作均返回 True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">int</span>(<span class="string">&#x27;1024&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 显然, 由于背后对象是不同的, is 操作结果是 False; 而对象值相同, == 操作结果是 True </span></span><br></pre></td></tr></table></figure>

<p><strong>用一张图看一下它们之间的区别：</strong></p>
<p><img src="/2023/03/29/12-%E5%89%96%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/1229382-20200818171117232-708867799.png" alt="img"></p>
<p><strong>一般而言如果a is b成立，那么a &#x3D;&#x3D; b多半成立，可能有人好奇，a is b成立说明a和b指向的是同一个对象了，那么a &#x3D;&#x3D; b表示该对象和自己进行比较，结果为啥不相等呢？以下面两种情况为例：</strong></p>
<ul>
<li><code>重写了__eq__的类的实例对象</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g <span class="keyword">is</span> g)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(g == g)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>浮点数nan</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">float</span>(<span class="string">&quot;nan&quot;</span>)</span><br><span class="line">b = math.nan</span><br><span class="line">c = np.nan</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> a, a == a)  <span class="comment"># True False</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> b, b == b)  <span class="comment"># True False</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">is</span> c, c == c)  <span class="comment"># True False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nan 是一个特殊的 浮点数, 意思是not a number, 表示不是一个数字, 用于表示 异常值, 即不存在或者非法的值</span></span><br><span class="line"><span class="comment"># 不管 nan 跟任何浮点(包括自身)做何种数学比较, 结果均为 False </span></span><br></pre></td></tr></table></figure>

<p>​        <strong>在 Python 中与 None 比较时，为什么要用 is None 而不是 &#x3D;&#x3D; None ？</strong>    </p>
<p><strong>None 是一种特殊的内建对象，它是单例对象，整个运行的程序中只有一个。因此，如果一个变量等于 *None*，那么*is None*一定成立，内存地址是相同的。</strong></p>
<p>*<strong>Python* 中的 *&#x3D;&#x3D;* 操作符对两个对象进行相等性比较，背后调用 *<strong>eq</strong>* 魔法方法。在自定义类中，<strong>eq</strong> 方法可以被覆写：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(g == <span class="literal">None</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>而且最重要的一点，我们在介绍is和 &#x3D;&#x3D;  之间区别的时候说过，Python的is在底层是比较地址是否相等，所以对于C而言只是判断两个变量间是否相等、一个 &#x3D;&#x3D;  操作符即可；但是对于Python的&#x3D;&#x3D;，在底层则是需要调用PyObject_RichCompare函数，然后进一步取出所维护的值进行比较。所以通过is None来判断会在性能上更有优势一些，再加上None是单例对象，使用is判断是最合适的。我们使用jupyter  notebook测试一下两者的性能吧：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%timeit name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="number">31.6</span> ns ± <span class="number">1.62</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000000</span> loops each)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%timeit name == <span class="literal">None</span></span><br><span class="line"><span class="number">36.6</span> ns ± <span class="number">2.8</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000000</span> loops each)</span><br></pre></td></tr></table></figure>

<h3 id="复杂内建对象的创建"><a href="#复杂内建对象的创建" class="headerlink" title="复杂内建对象的创建"></a>复杂内建对象的创建</h3><p><strong>像整数对象、字符串对象在创建时的字节码，相信都已经理解了。总共两条指令：直接先LOAD常量，然后STORE<code>(两者组成entry放在local名字空间中)</code>。</strong></p>
<p><strong>但是问题来了，像列表、字典这样的对象，底层是怎么创建的呢？显然它们的创建要更复杂一些，两条指令是不够的。下面我们就来看看列表、字典在创建时对应的字节码是怎样的吧。</strong></p>
<p><strong>不过在此之前我们需要看一些宏，这是PyFrame_EvalFrameEx<code>(调用了_PyEval_EvalFrameDefault)</code>在遍历指令序列co_code时所需要的宏，里面包括了对栈的各种操作，以及对PyTupleObject对象的元素的访问操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取PyTupleObject对象中指定索引对应的元素</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETITEM(v, i) PyTuple_GetItem((v), (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//调整栈顶指针, 这个stack_pointer指向运行时栈的顶端</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_STACKADJ(n) (stack_pointer += n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKADJ(n)     &#123; (void)(BASIC_STACKADJ(n), \</span></span><br><span class="line"><span class="meta">                          lltrace &amp;&amp; prtrace(TOP(), <span class="string">&quot;stackadj&quot;</span>)); \</span></span><br><span class="line"><span class="meta">                          assert(STACK_LEVEL() <span class="string">&lt;= co-&gt;</span>co_stacksize); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PUSH(v)     (*stack_pointer++ = (v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH(v)                BASIC_PUSH(v)</span></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_POP()       (*--stack_pointer)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP()           ((void)(lltrace &amp;&amp; prtrace(TOP(), <span class="string">&quot;pop&quot;</span>)), \</span></span><br><span class="line"><span class="meta">                         BASIC_POP())</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们随便创建一个列表和字典吧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">lst = [1, 2, &quot;3&quot;, &quot;xxx&quot;]</span></span><br><span class="line"><span class="string">d = &#123;&quot;name&quot;: &quot;夏色祭&quot;, &quot;age&quot;: -1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> BUILD_LIST               <span class="number">4</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">0</span> (lst)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          <span class="number">12</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">5</span> (-<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">6</span> ((<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>))</span><br><span class="line">             <span class="number">18</span> BUILD_CONST_KEY_MAP      <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> STORE_NAME               <span class="number">1</span> (d)</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">7</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先对于列表来说，它是先将列表中的常量加载进来了，从上面的4个LOAD_CONST也能看出来。然后重点来了，我们看到有一行指令 BUILD_LIST 4，从名字上也能看出来这是要根据load进行来的4个常量创建一个列表，后面的4表示这个列表有4个元素。</strong></p>
<p><strong>但是问题来了，Python怎么知道这构建的是一个列表呢？元组难道不可以吗？答案是因为我们创建的是列表，不是元组，而且这个信息也体现在了字节码中。然后我们看看BUILD_LIST都干了些什么吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BUILD_LIST)</span>: &#123;</span><br><span class="line">   <span class="comment">//这里的oparg显然指的就是BUILD_LIST后面的4</span></span><br><span class="line">      <span class="comment">//因此可以看到这个oparg的含义取决于字节码指令, 比如:LOAD_CONST就是代表索引, 这里的就是列表元素个数	</span></span><br><span class="line">      <span class="comment">//PyList_New表示创建一个能容纳4个元素的的PyListObject对象</span></span><br><span class="line">      PyObject *<span class="built_in">list</span> =  PyList_New(oparg);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line"><span class="comment">//从运行时栈里面将元素一个一个的弹出来, 注意它的索引, load元素的时候是按照1、2、&quot;3&quot;、&quot;xxx&quot;的顺序load</span></span><br><span class="line">      <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//但是栈是先入后出结构, 索引栈顶的元素是&quot;xxx&quot;, 栈底的元素是1</span></span><br><span class="line">          <span class="comment">//所以这里弹出元素的顺序就变成了&quot;xxx&quot;、&quot;3&quot;、2、1</span></span><br><span class="line">          PyObject *item = POP();</span><br><span class="line">          <span class="comment">//所以这里的oparg是从后往前遍历的, 即3、2、1、0</span></span><br><span class="line">          <span class="comment">//所以最终将&quot;xxx&quot;设置在索引为3的位置、将&quot;3&quot;设置在索引2位的位置, 将2设置在索引为1的位置, 将1设置在索引为0的位置</span></span><br><span class="line">          <span class="comment">//这显然是符合我们的预期的</span></span><br><span class="line">          PyList_SET_ITEM(<span class="built_in">list</span>, oparg, item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//构建完毕之后, 将其压入运行时栈, 此时栈中只有一个PyListObject对象, 因为先load进来的4个常量在构建列表的时候已经被逐个弹出来了</span></span><br><span class="line">      PUSH(<span class="built_in">list</span>);</span><br><span class="line">      DISPATCH();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>但BUILD_LIST之后，只改变了运行时栈，没有改变local空间。所以后面的STORE_NAME 0 (lst)表示将在local空间中建立一个 “符号lst” 到 “BUILD_LIST构建的PyListObject对象”  之间的映射，也就是组合成一个entry放在local空间中，这样我们后面才可以通过符号lst找到对应的列表。</strong></p>
<blockquote>
<p><strong>STORE_NAME我们已经见过了，这里就不说了。其实STORE_XXX和LOAD_XXX都是非常简单的，像LOAD_GLOBAL、LOAD_FAST、STORE_FAST等等可以自己去看一下，没有任何难度，当然我们下面也会说。</strong></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (&#x27;<span class="number">3</span>&#x27;)</span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (&#x27;xxx&#x27;)</span><br><span class="line">            <span class="number">8</span> BUILD_LIST               <span class="number">4</span></span><br><span class="line">           <span class="number">10</span> STORE_NAME               <span class="number">0</span> (<span class="name">lst</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>          <span class="number">12</span> LOAD_CONST               <span class="number">4</span> (&#x27;夏色祭&#x27;)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">5</span> (<span class="name">-1</span>)</span><br><span class="line">           <span class="number">16</span> LOAD_CONST               <span class="number">6</span> ((&#x27;name&#x27;, &#x27;age&#x27;))</span><br><span class="line">           <span class="number">18</span> BUILD_CONST_KEY_MAP      <span class="number">2</span></span><br><span class="line">           <span class="number">20</span> STORE_NAME               <span class="number">1</span> (<span class="name">d</span>)</span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">7</span> (<span class="name">None</span>)</span><br><span class="line">           <span class="number">24</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>然后我们再看看字典的构建方式，首先依旧是加载两个常量，显然这个字典是value。然后注意：我们看到key是作为一个元组加载进来的。而且如果我们创建了一个元组，那么这个元组也会整体被LOAD_CONST，所以从这里我们也能看到列表和元组之间的区别，列表的元素是一个一个加载的，元组是整体加载的，只需要LOAD_CONST一次即可。BUILD_CONST_KEY_MAP      2毋庸置疑就是构建一个字典了，后面的oparg是2，表示这个字典有两个entry，我们看一下源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BUILD_CONST_KEY_MAP)</span>: &#123;</span><br><span class="line">      Py_ssize_t i; <span class="comment">//循环变量</span></span><br><span class="line">      PyObject *<span class="built_in">map</span>;<span class="comment">//一个PyDictObject对象指针</span></span><br><span class="line">      PyObject *keys = TOP();<span class="comment">//从栈顶获取所有的key, 一个元组</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//如果keys不是一个元组或者这个元组的ob_size不等于oparg, 那么表示字典构建失败</span></span><br><span class="line">      <span class="keyword">if</span> (!PyTuple_CheckExact(keys) ||</span><br><span class="line">          PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) &#123;</span><br><span class="line">          _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                           <span class="string">&quot;bad BUILD_CONST_KEY_MAP keys argument&quot;</span>);</span><br><span class="line">          <span class="comment">//显然这是属于Python内部做的处理, 至少我们在使用层面没有遇到过这个问题</span></span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//申请一个字典, 表示至少要容纳oparg个键值对, 但是具体的容量肯定是要大于oparg的</span></span><br><span class="line">      <span class="comment">//至于到底是多少, 则取决于oparg, 总之这一步就是申请合适容量的字典</span></span><br><span class="line">      <span class="built_in">map</span> = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//很明显, 这里开始循环了, 要依次设置键值对了</span></span><br><span class="line">      <span class="comment">//还记得在BUILD_CONST_KEY_MAP之前, 常量是怎么加载的吗?是按照&quot;夏色祭&quot;、-1、(&#x27;name&#x27;, &#x27;age&#x27;)的顺序加载的</span></span><br><span class="line">      <span class="comment">//所以栈里面的元素, 从栈顶到栈底就应该是(&#x27;name&#x27;, &#x27;age&#x27;)、-1、&quot;夏色祭&quot;</span></span><br><span class="line">      <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="type">int</span> err;</span><br><span class="line">          <span class="comment">//这里是获取元组里面的元素, 也就是key, 注意: 索引是oparg - i, 而i是从oparg开始自减的</span></span><br><span class="line">          <span class="comment">//以当前为例, 循环结束时, oparg - i分别是0、1，那么获取的元素显然就分别是: &quot;name&quot;、&quot;age&quot;</span></span><br><span class="line">          PyObject *key = PyTuple_GET_ITEM(keys, oparg - i);</span><br><span class="line">          <span class="comment">//然后这里的PEEK和TOP类似, 都是获取元素但是不从栈里面删除, TOP是专门获取栈顶元素, PEEK还可以获取栈的其它位置的元素</span></span><br><span class="line">          <span class="comment">//而这里获取也是按照&quot;夏色祭&quot;、-1的顺序获取, 和&quot;name&quot;、&quot;age&quot;之间是正好对应的</span></span><br><span class="line">          PyObject *value = PEEK(i + <span class="number">1</span>);</span><br><span class="line">          <span class="comment">//然后将entry设置在map里面</span></span><br><span class="line">          err = PyDict_SetItem(<span class="built_in">map</span>, key, value);</span><br><span class="line">          <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">              Py_DECREF(<span class="built_in">map</span>);</span><br><span class="line">              <span class="keyword">goto</span> error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">//依次清空运行时栈, 将栈里面的元素挨个弹出来</span></span><br><span class="line">      Py_DECREF(POP());</span><br><span class="line">      <span class="keyword">while</span> (oparg--) &#123;</span><br><span class="line">          Py_DECREF(POP());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将构建的PyDictObject对象压入运行时栈</span></span><br><span class="line">      PUSH(<span class="built_in">map</span>);</span><br><span class="line">      DISPATCH();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后STORE_NAME               1 (d)，显然是再将运行时栈中的字典弹出来，将符号d和弹出来的字典建立一个entry放在local空间中。</strong></p>
<p><strong>在所有的字节码指令都执行完毕之后，运行时栈会是空的，但是所有的信息都存储在了local名字空间中。</strong></p>
<h3 id="函数中的变量"><a href="#函数中的变量" class="headerlink" title="函数中的变量"></a>函数中的变量</h3><p><strong>我们之前定义的变量是在模块级别的作用域中，但如果我们在函数中定义呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    s = <span class="string">&quot;python&quot;</span></span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (i)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (s)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到大致一样，但是有一点发生了变化，  那就是在将变量名和变量值映射的时候，使用的不再是STORE_NAME，而是STORE_FAST，显然STORE_FAST会更快一些。为什么这么说，这是因为函数中的局部变量总是固定不变的，在编译的时候就能确定局部变量使用的内存空间的位置，也能确定局部变量字节码指令应该如何访问内存，就能使用静态的方法来实现局部变量。其实局部变量的读写都在<code>fastlocals = f -&gt; f_localsplus</code>上面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_FAST)</span> &#123;</span><br><span class="line">            PyObject *value = POP();</span><br><span class="line">            SETLOCAL(oparg, value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETLOCAL(i, value)      do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line"><span class="meta">                                     GETLOCAL(i) = value; \</span></span><br><span class="line"><span class="meta">                                     Py_XDECREF(tmp); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETLOCAL(i)     (fastlocals[i])</span></span><br></pre></td></tr></table></figure>

<h3 id="一般表达式"><a href="#一般表达式" class="headerlink" title="一般表达式"></a>一般表达式</h3><h4 id="符号搜索"><a href="#符号搜索" class="headerlink" title="符号搜索"></a>符号搜索</h4><p><strong>我们还是举个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先源代码第一行对应的字节码指令无需介绍，但是第二行对应的指令变了，我们看到不再是LOAD_CONST，而是LOAD_NAME。其实也很好理解，第一行a &#x3D; 5，而5是一个常量所以是LOAD_CONST，但是b &#x3D; a，这里的a是一个变量名，所以是LOAD_NAME。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里显然要从几个名字空间里面去寻找指定的变量名对应的值</span></span><br><span class="line"><span class="comment">//找不到就会出现NameError</span></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_NAME)</span> &#123;</span><br><span class="line">           <span class="comment">//从符号表里面获取变量名</span></span><br><span class="line">           PyObject *name = GETITEM(names, oparg);</span><br><span class="line">           <span class="comment">//获取local命名空间, 一个PyDictObject对象</span></span><br><span class="line">           PyObject *locals = f-&gt;f_locals;</span><br><span class="line">           PyObject *v; <span class="comment">//value</span></span><br><span class="line">           <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               PyErr_Format(PyExc_SystemError,</span><br><span class="line">                            <span class="string">&quot;no locals when loading %R&quot;</span>, name);</span><br><span class="line">               <span class="keyword">goto</span> error;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//根据变量名从locals里面获取对应的value</span></span><br><span class="line">           <span class="keyword">if</span> (PyDict_CheckExact(locals)) &#123;</span><br><span class="line">               v = PyDict_GetItem(locals, name);</span><br><span class="line">               Py_XINCREF(v);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               v = PyObject_GetItem(locals, name);</span><br><span class="line">               <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                       <span class="keyword">goto</span> error;</span><br><span class="line">                   PyErr_Clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果v是NULL，说明local名字空间里面没有</span></span><br><span class="line">           <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="comment">//于是从global名字空间里面找</span></span><br><span class="line">               v = PyDict_GetItem(f-&gt;f_globals, name);</span><br><span class="line">               Py_XINCREF(v);</span><br><span class="line">               <span class="comment">//如果v是NULL说明global里面也没有</span></span><br><span class="line">               <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="comment">//下面的if和else里面的逻辑基本一致，只不过对builtin做了检测</span></span><br><span class="line">                   <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">                       <span class="comment">//local、global都没有，于是从builtin里面找</span></span><br><span class="line">                       v = PyDict_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                       <span class="comment">//还没有，NameError</span></span><br><span class="line">                       <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                           format_exc_check_arg(</span><br><span class="line">                                       PyExc_NameError,</span><br><span class="line">                                       NAME_ERROR_MSG, name);</span><br><span class="line">                           <span class="keyword">goto</span> error;</span><br><span class="line">                       &#125;</span><br><span class="line">                       Py_INCREF(v);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//从builtin里面找</span></span><br><span class="line">                       v = PyObject_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                       <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                           <span class="comment">//还没有，NameError</span></span><br><span class="line">                           <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                               format_exc_check_arg(</span><br><span class="line">                                           PyExc_NameError,</span><br><span class="line">                                           NAME_ERROR_MSG, name);</span><br><span class="line">                           <span class="keyword">goto</span> error;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到了，把v给push进去，相当于压栈</span></span><br><span class="line">           PUSH(v);</span><br><span class="line">           DISPATCH();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外如果是在函数里面，那么b &#x3D;  a就既不是LOAD_CONST、也不是LOAD_NAME，而是LOAD_FAST。这是因为函数中的变量在编译的时候就已经确定，因此是LOAD_FAST。那么如果b &#x3D; a在函数里面，而a &#x3D; 5定义在函数外面呢？那么结果是LOAD_GLOBAL，因为知道这个a到底是定义在什么地方。</strong></p>
<h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">c = a + b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然这里我们直接从 8 LOAD_NAME开始看即可，首先是加在两个变量，然后通过BINARY_ADD进行加法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_ADD)</span> &#123;</span><br><span class="line">    <span class="comment">//获取两个值，也就是我们a和b对应的值, a是栈底、b是栈顶</span></span><br><span class="line">    PyObject *right = POP(); <span class="comment">//从栈顶弹出b</span></span><br><span class="line">    PyObject *left = TOP();  <span class="comment">//弹出b之后, 此时a就成为了栈顶, 直接通过TOP获取, 但是不弹出</span></span><br><span class="line">    PyObject *sum;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//这里检测是否是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(left) &amp;&amp;</span><br><span class="line">             PyUnicode_CheckExact(right)) &#123;</span><br><span class="line">        <span class="comment">//是的话直接拼接</span></span><br><span class="line">        sum = unicode_concatenate(left, right, f, next_instr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是的话相加</span></span><br><span class="line">        sum = PyNumber_Add(left, right);</span><br><span class="line">        Py_DECREF(left);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    <span class="comment">//设置sum, 将栈顶的元素(之前的a)给顶掉</span></span><br><span class="line">    SET_TOP(sum);</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信息输出"><a href="#信息输出" class="headerlink" title="信息输出"></a>信息输出</h4><p><strong>最后看看信息是如何输出的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (c)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">3</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">22</span> POP_TOP</span><br><span class="line">             <span class="number">24</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">26</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们直接从16 LOAD_NAME开始看，首先从builtins中加载变量print<code>(本质上加载和变量绑定的对象)</code>，然后加载变量c，将两者压入运行时栈。</strong></p>
<p><strong>CALL_FUNCTION，表示函数调用，执行刚才的print，后面的1则是参数的个数。另外，当调用print的时候，实际上又创建了一个栈帧，因为只要是函数调用都会创建栈帧的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_FUNCTION)</span> &#123;</span><br><span class="line">     PyObject **sp, *res;</span><br><span class="line">     sp = stack_pointer;</span><br><span class="line">     res = call_function(&amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">     stack_pointer = sp;</span><br><span class="line">     PUSH(res);</span><br><span class="line">     <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">goto</span> error;</span><br><span class="line">     &#125;</span><br><span class="line">     DISPATCH();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后POP_TOP表示从栈的顶端弹出函数的返回值，因为POP_TOP的上一步是一个call_function，也就是函数调用。而函数是有返回值的，在函数调用(call_function指令)执行完毕之后会自动将返回值设置在栈顶，而POP_TOP就是负责将上一步函数调用的返回值从栈顶弹出来。只不过我们这里是print函数返回的是None、我们不需要这个返回值，或者说我们没有使用变量接收，所以直接将其从栈顶弹出去即可。但如果我们是res &#x3D;  print(c)，那么你会发现指令POP_TOP就变成了STORE_NAME，因为要将符号和返回值绑定起来放在local空间中。最后LOAD_CONST、RETURN_VALUE，无需解释了，就是返回值，不光是函数，类代码块、模块代码块在执行完毕之后也会返回一个值给调用者，只不过这个值通常是None。最后再来看看print是如何打印的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/bltinmodule.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin_print</span><span class="params">(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs, PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Python里面print支持的参数, 这里是解析我们在调用print所传递的位置参数和关键字参数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> _keywords[] = &#123;<span class="string">&quot;sep&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;file&quot;</span>, <span class="string">&quot;flush&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PyArg_Parser</span> _<span class="title">parser</span> =</span> &#123;<span class="string">&quot;|OOOO:print&quot;</span>, _keywords, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化全部为NULL</span></span><br><span class="line">    PyObject *sep = <span class="literal">NULL</span>, *end = <span class="literal">NULL</span>, *file = <span class="literal">NULL</span>, *flush = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kwnames != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            !_PyArg_ParseStackAndKeywords(args + nargs, <span class="number">0</span>, kwnames, &amp;_parser,</span><br><span class="line">                                          &amp;sep, &amp;end, &amp;file, &amp;flush)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//file参数</span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span> || file == Py_None) &#123;</span><br><span class="line">        file = _PySys_GetObjectId(&amp;PyId_stdout);</span><br><span class="line">        <span class="comment">//默认输出到sys.stdout也就是控制台</span></span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_RuntimeError, <span class="string">&quot;lost sys.stdout&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sys.stdout may be None when FILE* stdout isn&#x27;t connected */</span></span><br><span class="line">        <span class="keyword">if</span> (file == Py_None)</span><br><span class="line">            Py_RETURN_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//sep分隔符, 默认是空格</span></span><br><span class="line">    <span class="keyword">if</span> (sep == Py_None) &#123;</span><br><span class="line">        sep = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sep &amp;&amp; !PyUnicode_Check(sep)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;sep must be None or a string, not %.200s&quot;</span>,</span><br><span class="line">                     sep-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//end, 默认是换行</span></span><br><span class="line">    <span class="keyword">if</span> (end == Py_None) &#123;</span><br><span class="line">        end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (end &amp;&amp; !PyUnicode_Check(end)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;end must be None or a string, not %.200s&quot;</span>,</span><br><span class="line">                     end-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将里面的元素逐个打印到file中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sep == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="comment">//设置sep为空格</span></span><br><span class="line">                err = PyFile_WriteString(<span class="string">&quot; &quot;</span>, file);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//否则说明用户了sep</span></span><br><span class="line">                err = PyFile_WriteObject(sep, file,</span><br><span class="line">                                         Py_PRINT_RAW);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//end同理，不指定的话默认是打印换行</span></span><br><span class="line">    <span class="keyword">if</span> (end == <span class="literal">NULL</span>)</span><br><span class="line">        err = PyFile_WriteString(<span class="string">&quot;\n&quot;</span>, file);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//flush表示是否强制刷新控制台</span></span><br><span class="line">    <span class="keyword">if</span> (flush != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *tmp;</span><br><span class="line">        <span class="type">int</span> do_flush = PyObject_IsTrue(flush);</span><br><span class="line">        <span class="keyword">if</span> (do_flush == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (do_flush) &#123;</span><br><span class="line">            tmp = _PyObject_CallMethodId(file, &amp;PyId_flush, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Py_DECREF(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们就简单分析了一下字节码指令，介绍了一些常见的指令。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>11-探索Python虚拟机和字节码的奥秘</title>
    <url>/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    <content><![CDATA[<h2 id="11-探索Python虚拟机执行字节码的奥秘"><a href="#11-探索Python虚拟机执行字节码的奥秘" class="headerlink" title="11-探索Python虚拟机执行字节码的奥秘"></a>11-探索Python虚拟机执行字节码的奥秘</h2><p><strong>这一次我们就来剖析Python运行字节码的原理，我们知道Python虚拟机是Python的核心，在源代码被编译成PyCodeObject对象时，就将由Python虚拟机接手整个工作。Python虚拟机会从PyCodeObject中读取字节码，并在当前的上下文中执行，直到所有的字节码都被执行完毕。</strong></p>
<h3 id="Python虚拟机的执行环境"><a href="#Python虚拟机的执行环境" class="headerlink" title="Python虚拟机的执行环境"></a>Python虚拟机的执行环境</h3><p><strong>Python的虚拟机实际上是在模拟操作系统运行可执行文件的过程，我们先来看看在一台普通的x86的机器上，可执行文件是以什么方式运行的。在这里主要关注运行时栈的栈帧，如图所示：</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192050931-2050285817.png" alt="img"></p>
<p><strong>x86体系处理器通过栈维护调用关系，每次函数调用时就在栈上分配一个帧用于保存调用上下文以及临时存储。CPU中有两个关键寄存器，rsp指向当前栈顶，rbp指向当前栈帧。每次调用函数时，调用者(Caller)负责准备参数、保存返回地址，并跳转到被调用函数中执行代码；作为被调用者(Callee)，函数先将当前rbp寄存器压入栈（保存调用者栈帧位置），并将rbp设为当前栈顶(保存当前新栈帧的位置)。由此，rbp寄存器与每个栈帧中保存调用者栈帧地址一起完美地维护了函数调用关系链。</strong></p>
<p><strong>我们以Python中的代码为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"></span><br><span class="line">g()</span><br></pre></td></tr></table></figure>

<p><strong>当程序进入到函数 f 中执行时，那么显然调用者的帧就是函数 g 的栈帧，而当前帧则是 f 的栈帧。</strong></p>
<blockquote>
<p><strong>解释一下：栈是先入后出的数据结构，从栈顶到栈底地址是增大的。对于一个函数而言，其所有对局部变量的操作都在自己的栈帧中完成，而调用函数的时候则会为调用的函数创建新的栈帧。</strong></p>
</blockquote>
<p><strong>在上图中，我们看到运行时栈的地址是从高地址向低地址延伸的。当在函数 g  中调用函数 f 的时候，系统就会在地址空间中，于 g 的栈帧之后创建 f  的栈帧。当然在函数调用的时候，系统会保存上一个栈帧的栈指针(rsp)和帧指针(rbp)。当函数的调用完成时，系统就又会把rsp和rbp的值恢复为创建 f 栈帧之前的值，这样程序的流程就又回到了 g  函数中，当然程序的运行空间则也又回到了函数g的栈帧中，这就是可执行文件在x86机器上的运行原理。</strong></p>
<p><strong>而上一章我们说Python源代码经过编译之后，所有字节码指令以及其他静态信息都存储在PyCodeObject当中，那么是不是意味着Python虚拟机就在PyCodeObject对象上进行所有的动作呢？其实不能给出唯一的答案，因为尽管<font color="green">PyCodeObject包含了关键的字节码指令以及静态信息</font>，</strong><font color="red"><strong>但是有一个东西，是没有包含、也不可能包含的，就是程序运行的动态信息–执行环境</strong>。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var = <span class="string">&quot;satori&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    var = <span class="number">666</span></span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure>

<p><strong>首先代码当中出现了两个print(var)，它们的字节码指令是相同的，但是执行的效果却显然是不同的，这样的结果正是执行环境的不同所产生的。因为环境的不同，var的值也是不同的。因此同一个符号在不同环境中对应不同的类型、不同的值，必须在运行时进行动态地捕捉和维护，这些信息是不可能在PyCodeObject对象中被静态的存储的。</strong></p>
<p><strong>所以我们还需要执行环境，这里的执行环境和我们下面将要说的名字空间比较类似<code>(名字空间暂时就简单地理解为作用域即可)</code>。但是名字空间仅仅是执行环境的一部分，除了名字空间，在执行环境中，还包含了其他的一些信息。</strong></p>
<p>​        <strong>因此对于上面代码，我们可以大致描述一下流程：</strong>    </p>
<ul>
<li><code>当python在执行第一条语句时，已经创建了一个执行环境，假设叫做A</code></li>
<li><code>所有的字节码都会在这个环境中执行，Python可以从这个环境中获取变量的值，也可以修改。</code></li>
<li><code>当发生函数调用的时候，Python会在执行环境A中调用函数f的字节码指令，会在执行环境A之外重新创建一个执行环境B</code></li>
<li><code>在环境B中也有一个名字为var的对象，但是由于环境的不同，var也不同。两个人都叫小明，但一个是北京的、一个是上海的，所以这两者没什么关系</code></li>
<li><code>一旦当函数f的字节码指令执行完毕，会将当前f的栈帧销毁(也可以保留下来)，再回到调用者的栈帧中来。就像是递归一样，每当调用函数就会创建一个栈帧，一层一层创建，一层一层返回。</code></li>
</ul>
<p><strong>所以Python在运行时的时候，并不是在PyCodeObject对象上执行操作的，而是我们一直在说的栈帧对象(PyFrameObject)，从名字也能看出来，这个栈帧也是一个对象。</strong></p>
<h4 id="Python源码中的PyFrameObject"><a href="#Python源码中的PyFrameObject" class="headerlink" title="Python源码中的PyFrameObject"></a>Python源码中的PyFrameObject</h4><p><strong>对于Python而言，PyFrameObject可不仅仅只是类似于x86机器上看到的那个简简单单的栈帧，Python中的PyFrameObject实际上包含了更多的信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD  		<span class="comment">/* 可变对象的头部信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* 上一级栈帧, 也就是调用者的栈帧 */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* PyCodeObject对象, 通过栈帧对象的f_code可以获取对应的PyCodeObject对象 */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin命名空间，一个PyDictObject对象 */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global命名空间，一个PyDictObject对象 */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local命名空间，一个PyDictObject对象  */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* 运行时的栈底位置 */</span></span><br><span class="line"></span><br><span class="line">    PyObject **f_stacktop;      <span class="comment">/* 运行时的栈顶位置 */</span></span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* 回溯函数，打印异常栈 */</span></span><br><span class="line">    <span class="type">char</span> f_trace_lines;         <span class="comment">/* 是否触发每一行的回溯事件 */</span></span><br><span class="line">    <span class="type">char</span> f_trace_opcodes;       <span class="comment">/* 是否触发每一个操作码的回溯事件 */</span></span><br><span class="line"></span><br><span class="line">    PyObject *f_gen;            <span class="comment">/* 是否是生成器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f_lasti;                <span class="comment">/* 上一条指令在f_code中的偏移量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f_lineno;               <span class="comment">/* 当前字节码对应的源代码行 */</span></span><br><span class="line">    <span class="type">int</span> f_iblock;               <span class="comment">/* 当前指令在栈f_blockstack中的索引 */</span></span><br><span class="line">    <span class="type">char</span> f_executing;           <span class="comment">/* 当前栈帧是否仍在执行 */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* 用于try和loop代码块 */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* 动态内存，维护局部变量+cell对象集合+free对象集合+运行时栈所需要的空间 */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到，Python会根据PyCodeObject对象来创建一个栈帧对象<code>(或者直接说栈帧也行)</code>，也就是PyFrameObject对象，虚拟机实际上是在PyFrameObject对象上执行操作的。每一个PyFrameObject都会维护一个PyCodeObject，换句话说，每一个PyCodeObject都会隶属于一个PyFrameObject。并且从f_back中可以看出，在Python的实际执行过程中，会产生很多PyFrameObject对象，而这些对象会被链接起来，形成一条执行环境链表，这正是x86机器上栈帧之间关系的模拟。在x86机器上，栈帧间通过rsp和rbp指针建立了联系，使得新栈帧在结束之后能够顺利的返回到旧栈帧中，而Python则是利用f_back来完成这个动作。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192059369-802300135.png" alt="img"></p>
<p><strong>里面f_code成员是一个指针，指向相应的PyCodeObject对象，而接下来的f_builtins、f_globals、f_locals是三个独立的名字空间，在这里我们看到了名字空间和执行环境(即栈帧)之间的关系。名字空间实际上是维护这变量名和变量值的PyDictObject对象，所以在这三个PyDictObject对象中分别维护了各自name和value的对应关系。</strong></p>
<p><strong>在PyFrameObject的开头，有一个PyObject_VAR_HEAD，表示栈帧是一个变长对象，即每一次创建PyFrameObject对象大小可能是不一样的，那么变动在什么地方呢？首先每一个PyFrameObject对象都维护了一个PyCodeObject对象，而每一个PyCodeObject对象都会对应一个代码块(code  block)。在编译一段代码块的时候，会计算这段代码块执行时所需要的栈空间的大小，这个栈空间大小存储在PyCodeObject对象的co_stacksize中。而不同的代码块所需要的栈空间是不同的，因此PyFrameObject的开头要有一个PyObject_VAR_HEAD对象。最后其实PyFrameObject里面的内存空间分为两部分，一部分是编译代码块需要的空间，另一部分是计算所需要的空间，我们也称之为”运行时栈”。</strong></p>
<blockquote>
<p><strong>注意：x86机器上执行时的运行时栈不止包含了计算<code>(还有别的)</code>所需要的内存空间，但PyFrameObject对象的运行时栈则只包含计算所需要的内存空间，这一点务必注意。</strong></p>
</blockquote>
<h4 id="在python中访问PyFrameObject对象"><a href="#在python中访问PyFrameObject对象" class="headerlink" title="在python中访问PyFrameObject对象"></a>在python中访问PyFrameObject对象</h4><p><strong>在Python中获取栈帧，我们可以使用inspect模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="comment"># 返回当前所在的栈帧, 这个函数实际上是调用了sys._getframe(1)</span></span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frame = f()</span><br><span class="line"><span class="built_in">print</span>(frame)  <span class="comment"># &lt;frame at 0x000001FE3D6E69F0, file &#x27;D:/satori/1.py&#x27;, line 6, code f&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(frame))  <span class="comment"># &lt;class &#x27;frame&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到栈帧的类型是<code>&lt;class &#39;frame&#39;&gt;</code>，正如PyCodeObject对象的类型是<code>&lt;class &#39;code&#39;&gt;</code>一样。还是那句话，这两个类Python解释器没有暴露给我们，所以不可以直接使用。同理，还有Python的函数，类型是<code>&lt;class &#39;function&#39;&gt;</code>；模块，类型是<code>&lt;class &#39;module&#39;&gt;</code>，这些Python解释器都没有给我们提供，如果直接使用的话，那么frame、code、function、module只是几个没有定义的变量罢了，这些类我们只能通过这种间接的方式获取。</strong></p>
<p>​        <strong>下面我们就来获取一下栈帧的成员属性</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用函数g的时候, 也会触发函数f的调用</span></span><br><span class="line"><span class="comment"># 而一旦f执行完毕, 那么f对应的栈帧就被全局变量frame保存起来了</span></span><br><span class="line">frame = g()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(frame)  <span class="comment"># &lt;frame at 0x00000194046863C0, file &#x27;D:/satori/1.py&#x27;, line 8, code f&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一级栈帧, 即调用者的栈帧, 显然是g的栈帧</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back)  <span class="comment"># &lt;frame at 0x00000161C79169F0, file &#x27;D:/satori/1.py&#x27;, line 14, code g&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块也是有栈帧的, 我们后面会单独说</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_back)  <span class="comment"># &lt;frame at 0x00000174CE997840, file &#x27;D:/satori/1.py&#x27;, line 25, code &lt;module&gt;&gt;</span></span><br><span class="line"><span class="comment"># 显然最外层就是模块了, 模块对应的上一级栈帧是None</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_back.f_back)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取PyCodeObject对象</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_code)  <span class="comment"># &lt;code object f at 0x00000215D560D450, file &quot;D:/satori/1.py&quot;, line 4&gt;</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_code.co_name)  <span class="comment"># f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取f_locals, 即栈帧内部的local名字空间</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;神乐mea&#x27;, &#x27;age&#x27;: 38&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">另外我们看到函数运行完毕之后里面的局部变量居然还能获取</span></span><br><span class="line"><span class="string">原因就是栈帧没被销毁, 因为它被返回了, 而且被外部变量接收了</span></span><br><span class="line"><span class="string">同理：该栈帧的上一级栈帧也不能被销毁, 因为当前栈帧的f_back指向它了, 引用计数不为0, 所以要保留</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈帧对应的行号</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_lineno)  <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_lineno)  <span class="comment"># 14</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">行号为8的位置是: return inspect.currentframe()</span></span><br><span class="line"><span class="string">行号为14的位置是: return f()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过栈帧我们可以获取很多的属性，我们后面还会慢慢说。</strong></p>
<p><strong>此外，异常处理也可以获取到栈帧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="comment"># exc_info返回一个三元组,分别是异常的类型、值、以及traceback</span></span><br><span class="line">        exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">        <span class="built_in">print</span>(exc_type)  <span class="comment"># &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line">        <span class="built_in">print</span>(exc_value)  <span class="comment"># division by zer</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb)  <span class="comment"># &lt;traceback object at 0x00000135CEFDF6C0&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用exc_tb.tb_frame即可拿到异常对应的栈帧</span></span><br><span class="line">        <span class="comment"># 另外这个exc_tb也可以通过except ZeroDivisionError as e; e.__traceback__的方式获取</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb.tb_frame.f_back)  <span class="comment"># &lt;frame at 0x00000260C1297840, file &#x27;D:/satori/1.py&#x27;, line 17, code &lt;module&gt;&gt;</span></span><br><span class="line">        <span class="comment"># 因为foo是在模块级别、也就是最外层调用的,所以tb_frame是当前函数的栈帧、那么tb_frame.f_back就是整个模块对应的栈帧</span></span><br><span class="line">        <span class="comment"># 那么再上一级的话, 栈帧就是None了</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb.tb_frame.f_back.f_back)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="名字、作用域、名字空间"><a href="#名字、作用域、名字空间" class="headerlink" title="名字、作用域、名字空间"></a>名字、作用域、名字空间</h3><p><strong>我们在PyFrameObject里面看到了3个独立的名字空间：f_locals、f_globals、f_builtins。名字空间对于Python来说是一个非常重要的概念，整个Python虚拟机运行的机制和名字空间有着非常紧密的联系。并且在Python中，与命名空间这个概念紧密联系着的还有”名字”、”作用域”这些概念，下面就来剖析这些概念是如何实现的。</strong></p>
<h4 id="Python中的变量只是一个名字"><a href="#Python中的变量只是一个名字" class="headerlink" title="Python中的变量只是一个名字"></a>Python中的变量只是一个名字</h4><p><strong>很早的时候我们就说过，Python中的变量在底层一个泛型指针PyObject *，而在Python的层面上来说，变量只是一个名字、或者说符号，用于和对象进行绑定的。变量的定义本质上就是建立名字和对象之间的约束关系，所以a &#x3D; 1这个赋值语句本质上就是将符号a和1对应的PyLongObject绑定起来，让我们通过a可以找到对应的PyLongObject。</strong></p>
<p><strong>除了变量赋值，函数定义、类定义也相当于定义变量，或者说完成名字和对象之间的绑定。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>定义一个函数也相当于定义一个变量，会先根据函数体创建一个函数对象，然后将名字<code>foo</code>和函数对象绑定起来，所以函数名和函数体之间是分离的，同理类也是如此。</strong></p>
<p><strong>再有导入一个模块，也相当于定义一个变量。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<p><strong>import os，相当于将名字<code>os</code>和模块对象绑定起来，通过os可以访问模块里面的属性。或者import numpy as np当中的as语句也相当于定义一个变量，将名字<code>np</code>和对应的模块对象绑定起来，以后就可以通过np这个名字去访问模块内部的属性了。</strong></p>
<blockquote>
<p><strong>另外，当我们导入一个模块的时候，解释器是这么做的。比如：import os等价于os &#x3D; <strong>import</strong>(“os”)，可以看到本质上还是一个赋值语句。</strong></p>
</blockquote>
<h4 id="作用域和名字空间"><a href="#作用域和名字空间" class="headerlink" title="作用域和名字空间"></a>作用域和名字空间</h4><p><strong>我们说赋值语句、函数定义、类定义、模块导入，本质上只是完成了名字和对象之间的绑定。而从概念上讲，我们实际上得到了一个<code>name</code>和<code>obj</code>这样的映射关系，通过name获取对应的obj，而它们的容身之所就是名字空间。而名字空间是通过PyDictObject对象实现的，这对于映射来说简直再适合不过了，所以字典在Python底层也是被大量使用的，因此是经过高度优化的。</strong></p>
<p><strong>但是一个模块内部，名字还存在可见性的问题，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到同一个变量名，打印的确实不同的值，说明指向了不同的对象。换句话说这两个变量是在不同的名字空间中被创建的，我们知道名字空间本质上是一个字典，如果两者是在同一个名字空间，那么由于字典的key的不重复性，那么当我进行a&#x3D;2的时候，会把字典里面key为’a’的value给更新掉，但是在外面还是打印为1，这说明，两者所在的不是同一个名字空间。在不同的名字空间，打印的也就自然不是同一个a。</strong></p>
<p><strong>因此对于一个模块而言，内部是可能存在多个名字空间的，每一个名字空间都与一个作用域相对应。作用域就可以理解为一段程序的正文区域，在这个区域里面定义的变量是有作用的，然而一旦出了这个区域，就无效了。</strong></p>
<p><strong>对于作用域这个概念，至关重要的是要记住它仅仅是由源程序的文本所决定的。在Python中，一个变量在某个位置是否起作用，是由其在文本位置是否唯一决定的。因此，Python是具有静态作用域<code>(词法作用域)</code>的，而名字空间则是作用域的动态体现。一个由程序文本定义的作用域在Python运行时就会转化为一个名字空间、即一个PyDictObject对象。也就是说，在函数执行时，会为创建一个名字空间，这一点在以后剖析函数时会详细介绍。</strong></p>
<blockquote>
<p><strong>我们之前说Python在对Python源代码进行编译的时候，对于代码中的每一个block，都会创建一个PyCodeObject与之对应。而当进入一个新的名字空间、或者说作用域时，我们就算是进入了一个新的block了。相信此刻你已经明白了，而且根据我们使用Python的经验，显然函数、类都是一个新的block，当Python运行的时候会它们创建各自的名字空间。</strong></p>
<p><strong>所以名字空间是名字、或者变量的上下文环境，名字的含义取决于命名空间。更具体的说，一个变量名对应的变量值什么，在Python中是不确定的，需要名字空间来决定。</strong></p>
</blockquote>
<p><strong>位于同一个作用域中的代码可以直接访问作用域中出现的名字，即所谓的”直接访问”，也就是不需要通过属性引用的访问修饰符:<code>.</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(A.a)  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(b)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>比如：B里面想访问A里面的内容，比如通过<code>A.属性</code>的方式，表示通过A来获取A里面的属性。但是访问B的内容就不需要了，因为都是在同一个作用域，所以直接访问即可。</strong></p>
<p><strong>访问名字这样的行为被称为<code>名字引用</code>，名字引用的规则决定了Python程序的行为。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>还是对于上面的代码，如果我们把函数里面的a&#x3D;2给删掉，那么显然作用域里面已经没有a这个变量的，那么再执行程序会有什么后果呢？从Python层面来看，显然是会寻找外部的a。因此我们可以得到如下结论：</strong></p>
<ul>
<li><code>作用域是层层嵌套的,显然是这样,毕竟python虚拟机操作的是PyFrameObject对象,而PyFrameObject对象也是嵌套的,当然还有PyCodeObject</code></li>
<li><code>内层的作用域是可以访问外层作用域的</code></li>
<li><code>外层作用域无法访问内层作用域,尽管我们没有试,但是想都不用想,如果把外层的a=1给去掉,那么最后面的print(a)铁定报错。因为外部的作用域算是属于顶层了(先不考虑builtin)</code></li>
<li><code>查找元素会依次从当前作用域向外查找,也就是查找元素对应的作用域是按照从小往大、从里往外的方向前进的,到了最外层还没有,就真没有了(先不考虑builtin)</code></li>
</ul>
<h4 id="LGB规则"><a href="#LGB规则" class="headerlink" title="LGB规则"></a>LGB规则</h4><p><strong>我们说函数、类是有自己的作用域的，但是模块对应的源文件本身也有相应的作用域。比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>由于这个文件本身也有自己的作用域<code>(显然是global作用域)</code>，所以Python解释器在运行a.py这个文件的时候，也会为其创建一个名字空间，而显然这个名字空间就是global名字空间。它里面的变量是全局的，或者说是模块级别的，在当前的文件内可以直接访问。</strong></p>
<p><strong>而函数也会有一个作用域，这个作用域称为local作用域(对应local名字空间)；同时Python自身还定义了一个最顶层的作用域，也就是builtin作用域(比如：dir、range、open都是builtin里面的)。这三个作用域在python2.2之前就存在了，所以那时候Python的作用域规则被称之为LGB规则：名字引用动作沿着local作用域<code>(local名字空间)</code>、global作用域<code>(global名字空间)</code>、builtin作用域<code>(builtin名字空间)</code>来查找对应的变量。</strong></p>
<p><strong>而获取名字空间，Python也提供了相应的内置函数：</strong></p>
<ul>
<li><code>locals函数: 获取当前作用域的local名字空间, local名字空间也称为局部名字空间</code></li>
<li><code>globals函数: 获取当前作用域的global名字空间, global名字空间也称为全局名字空间</code></li>
</ul>
<p><strong>对于global名字空间来说，它对应一个字典，并且这个字典是全局唯一的，全局变量都存储在这里面。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())  <span class="comment"># &#123;..., &#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1, &#x27;foo&#x27;: &lt;function foo at 0x0000020BF60851F0&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>里面的…表示省略了一部分输出，我们看到创建的全局变量都在里面了。而且foo也是一个变量，它指向一个函数对象，我们说foo也对应一个PyCodeObject。但是在解释到def  foo的时候，便会根据这个PyCodeObject对象创建一个PyFunctionObject对象，然后将foo和这个函数对象绑定起来。当我们调用foo的时候，会根据PyFunctionObject对象再创建PyFrameObject对象、然后执行，这些留在介绍函数的时候再细说。总之，我们看到foo也是一个全局变量，全局变量都在global名字空间中。</strong></p>
<blockquote>
<p><strong>global名字空间全局唯一，它是程序运行时全局变量和与之绑定的对象的容身之所，你在任何一个地方都可以访问到global名字空间。正如，你在任何一个地方都可以访问相应的全局变量一样。</strong></p>
<p><strong>此外，我们说名字空间是一个字典，变量和变量指向的值会以键值对的形式存在里面。那么换句话说，如果我手动的往这个global名字空间里面添加一个键值对，是不是也等价于定义一个全局变量呢？</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">globals</span>()[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">            <span class="built_in">globals</span>()[<span class="string">&quot;age&quot;</span>] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f3</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()()()</span><br><span class="line"><span class="built_in">print</span>(age)  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到确实如此，通过往global名字空间里面插入一个键值对完全等价于定义一个全局变量。并且我们看到global名字空间是全局唯一的，你在任何地方调用globals()得到的都是global名字空间，正如你在任意地方都可以访问到全局变量一样。所以即使是在函数中向global名字空间中插入一个键值对，也等价于定义一个全局变量、并和对象绑定起来。</strong></p>
<ul>
<li><code>name = &quot;夏色祭&quot;等价于 globals[&quot;name&quot;] = &quot;夏色祭&quot;</code></li>
<li><code>print(name)等价于print(globals[&quot;name&quot;])</code></li>
</ul>
<p><strong>对于local名字空间来说，它也对应一个字典，显然这个字典是就不是全局唯一的了，每一个作用域都会对应自身的local名字空间。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>() == <span class="built_in">globals</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="built_in">print</span>(g())  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;神乐mea&#x27;, &#x27;age&#x27;: 38&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>显然对于模块来讲，它的local名字空间和global名字空间是一样的，也就是说模块对应的PyFrameObject对象里面的f_locals和f_globals指向的是同一个PyDictObject对象。</strong></p>
<p><strong>但是对于函数而言，局部名字空间和全局名字空间就不一样了。而调用locals也是获取自身的局部名字空间，因此不同的函数的local名字空间是不同的，而调用locals函数返回结果显然取决于调用它的位置。但是globals函数的调用结果是一样的，获取的都是global名字空间，这也符合”函数内找不到某个变量的时候会去找全局变量”这一结论。</strong></p>
<p><strong>所以我们说在函数里面查找一个变量，查找不到的话会找全局变量，全局变量再没有会查找内置变量。本质上就是按照自身的local空间、外层的global空间、内置的builtin空间的顺序进行查找。因此local空间会有很多个，因为每一个函数或者类都有自己的局部作用域，这个局部作用域就可以称之为该函数的local空间；但是global空间则全局唯一，因为该字典存储的是全局变量，无论你在什么地方，通过globals拿到的永远全局变量对应的名字空间，向该空间中添加键值对，等价于创建全局变量。</strong></p>
<p><strong>对于builtin命名空间，它也是一个字典。当local空间、global空间都没有的时候，会去builtin空间查找。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    <span class="comment"># local空间有&quot;name&quot;这个key, 直接从局部名字空间获取</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="comment"># 但是当前的local空间没有&quot;age&quot;这个key, 所以会从global空间查找</span></span><br><span class="line">    <span class="comment"># 从这里也能看出为什么函数也能访问到global空间了</span></span><br><span class="line">    <span class="comment"># 如果函数内访问不到的话, 那么它怎么能够在局部变量找不到的时候去找全局变量呢</span></span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但是local空间、global空间都没有&quot;int&quot;这个key, 所以要去builtin空间查找了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;xxx&quot;的话, 三个空间都没有, 那么结果只能是NameError了</span></span><br><span class="line">    <span class="built_in">print</span>(xxx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">神乐mea</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">File &quot;D:/satori/1.py&quot;, line 18, in f1</span></span><br><span class="line"><span class="string">    print(xxx)</span></span><br><span class="line"><span class="string">NameError: name &#x27;xxx&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题来了，builtin名字空间如何获取呢？答案是通过builtins模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们调用int、str、list显然是从内置作用域、也就是builtin命名空间中查找的</span></span><br><span class="line"><span class="comment"># 即使我们只通过list也是可以的, 因为local空间、global空间没有的话, 最终会从builtin空间中查找,</span></span><br><span class="line"><span class="comment"># 但如果是builtins.list, 那么就不兜圈子了, 表示: &quot;builtin空间,就从你这获取了&quot;</span></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">list</span> <span class="keyword">is</span> <span class="built_in">list</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">builtins.<span class="built_in">dict</span> = <span class="number">123</span></span><br><span class="line"><span class="comment"># 将builtin空间的dict改成123，那么此时获取的dict就是123，因为是从内置作用域中获取的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span> + <span class="number">456</span>)  <span class="comment"># 579</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="number">123</span></span><br><span class="line"><span class="comment"># 如果是str = 123，等价于创建全局变量str = 123，显然影响的是global空间，而查找显然也会先从global空间查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  <span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 但是此时不影响内置作用域</span></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">str</span>)  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>这里提一下Python2当中，while 1比while True要快，为什么？</strong>    </p>
<p><strong>因为True在Python2中不是关键字，所以它是可以作为变量名的，那么python在执行的时候就要先看local空间和global空间中有没有True这个变量，有的话使用我们定义的，没有的话再使用内置的True，而1是一个常量直接加载就可以。所以while True它多了符号查找这一过程，但是在Python3中两者就等价了，因为True在python3中是一个关键字，所以会直接作为一个常量来加载。</strong></p>
<p>​        <strong>这里再提一下函数的local空间</strong>    </p>
<p><strong>我们说：globals[“name”] &#x3D; “夏色祭”等价于定义一个全局变量name &#x3D; “夏色祭”，那么如果是在函数里面执行了locals[“name”] &#x3D; “夏色祭”，是不是等价于创建局部变量name &#x3D; “夏色祭”呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;name &quot;</span>] = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">f1()  <span class="comment"># name &#x27;name&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>我们说对于全局变量来讲，变量的创建是通过向字典添加键值对的方式实现的。因为全局变量会一直在变，需要使用字典来动态维护。但是对于函数来讲，内部的变量是通过静态方式访问的，因为其局部作用域中存在哪些变量在编译的时候就已经确定了，我们通过PyCodeObject的co_varnames即可获取内部都有哪些变量。</strong></p>
<p><strong>所以虽然我们说查找是按照LGB的方式查找，但是访问函数内部的变量其实是静态访问的，不过完全可以按照LGB的方式理解。</strong></p>
<blockquote>
<p><strong>所以名字空间可以说是Python的灵魂，因为它规定了Python变量的作用域，使得Python对变量的查找变得非常清晰。</strong></p>
</blockquote>
<h4 id="LEGB规则"><a href="#LEGB规则" class="headerlink" title="LEGB规则"></a>LEGB规则</h4><p><strong>我们上面说的LGB是针对Python2.2之前的，那么Python2.2开始，由于引入了嵌套函数，显然最好的方式应该是内层函数找不到应该首先去外层函数找，而不是直接就跑到global空间、也就是全局里面找，那么此时的规则就是LEGB。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>调用f，实际上调用的是bar函数，最终输出的结果是2。如果按照LGB的规则来查找的话。bar函数的作用域没有a、那么应该到全局里面找，打印的应该是1才对。但是我们之前说了，作用域仅仅是由文本决定的，函数bar位于函数foo之内，所以bar函数定义的作用域内嵌与函数foo的作用域之内。换句话说，函数foo的作用域是函数bar的作用域的直接外围作用域，所以首先是从foo作用域里面找，如果没有那么再去全局里面找。而作用域和名字空间是对应的，所以最终打印了2。</strong></p>
<blockquote>
<p><strong>因此在执行f &#x3D; foo()的时候，会执行函数foo中的def bar():语句，这个时候Python会将a&#x3D;2与函数bar对应的函数对象捆绑在一起，将捆绑之后的结果返回，这个捆绑起来的整体称之为闭包。</strong></p>
<p><strong>所以：闭包 &#x3D; 内层函数 + 引用的外层作用域</strong></p>
</blockquote>
<p><strong>这里显示的规则就是LEGB，其中E成为enclosing，代表<code>直接外围作用域</code>这个概念。</strong></p>
<h4 id="global表达式"><a href="#global表达式" class="headerlink" title="global表达式"></a>global表达式</h4><p><strong>有一个很奇怪的问题，最开始学习python的时候，笔者也为此困惑了一段时间，下面我们来看一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先这段代码打印1，这显然是没有问题的，但是下面问题来了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:/Users/satori/Desktop/love_minami/a.py&quot;, line 8, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    foo()</span></span><br><span class="line"><span class="string">  File &quot;C:/Users/satori/Desktop/love_minami/a.py&quot;, line 5, in foo</span></span><br><span class="line"><span class="string">    print(a)</span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;a&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我仅仅是在print下面，在当前作用域又新建了一个变量a，结果就告诉我<code>局部变量a在赋值之前就被引用了</code>，这是怎么一回事，相信肯定有人为此困惑。</strong></p>
<p><strong>弄明白这个错误的根本就在于要深刻理解两点：</strong></p>
<ul>
<li><code>一个赋值语句所定义的变量在这个赋值语句所在的作用域里都是可见的</code></li>
<li><code>函数中的变量是静态存储、静态访问的, 内部有哪些变量在编译的时候就已经确定</code></li>
</ul>
<p><strong>在编译的时候，因为存在a &#x3D;  2这条语句，所以知道函数中存在一个局部变量a，那么查找的时候就会在局部空间中查找。但是还没来得及赋值，就print(a)了，所以报错：局部变量a在赋值之前就被引用了。但如果没有a &#x3D; 2这条语句则不会报错，因为知道局部作用域中不存在a这个变量，所以会找全局变量a，从而打印1。</strong></p>
<p><strong>更有趣的东西隐藏在字节码当中，我们可以通过反汇编来查看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">dis.dis(g)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  7           0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line"><span class="string">              2 LOAD_GLOBAL              1 (a)</span></span><br><span class="line"><span class="string">              4 CALL_FUNCTION            1</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dis.dis(f)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 12           0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line"><span class="string">              2 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              4 CALL_FUNCTION            1</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 13           8 LOAD_CONST               1 (2)</span></span><br><span class="line"><span class="string">             10 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="string">             12 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             14 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>中间的序号代表字节码的偏移量，我们看第二条，g的字节码是<code>LOAD_GLOBAL</code>，意思是在global名字空间中查找，而f的字节码是<code>LOAD_FAST</code>，表示在local名字空间中查找名字。这说明Python采用了静态作用域策略，在编译的时候就已经知道了名字藏身于何处。</strong></p>
<p><strong>因此上面的例子表明，一旦作用域有了对某个名字的赋值操作，这个名字就会在作用域中可见，就会出现在local名字空间中，换句话说，就遮蔽了外层作用域中相同的名字。</strong></p>
<p><strong>但有时我们想要在函数里面修改全局变量呢？当然Python也为我们精心准备了global关键字，比如函数内部出现了<code>global a</code>，就表示我后面的a是全局的，你要到global名字空间里面找，不要在local空间里面找了</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">        <span class="keyword">global</span> a</span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line">bar()()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>但是如果外层函数里面也出现了a，我们想找外层函数里面的a而不是全局的a，该怎么办呢？Python同样为我们准备了关键字: <code>nonlocal</code>，但是nonlocal的时候，必须确保自己是内层函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line">bar()()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 外界依旧是1</span></span><br></pre></td></tr></table></figure>

<h4 id="属性引用与名称引用"><a href="#属性引用与名称引用" class="headerlink" title="属性引用与名称引用"></a>属性引用与名称引用</h4><p><strong>属性引用实质上也是一种名称引用，其本质都是到名称空间中去查找一个名称所引用的对象。这个就比较简单了，比如a.xxx，就是到a里面去找xxx，这个规则是不受LEGB作用域限制的，就是到a里面查找，有就是有、没有就是没有。</strong></p>
<p><strong>这个比较简单，但是有一点我们需要注意，那就是我们说属性查找会按照LEGB的规则，但是仅仅限制在自身所在的模块内。举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>关于模块的导入我们后面系列中会详细说，总之目前在b.py里面执行的import a，你可以简单认为就是把a.py里面的内容拿过来执行一遍即可，所以这里相当于print(name)。</strong></p>
<p><strong>但是执行b.py的时候会提示变量name没有被定义，可是把a导进来的话，就相当于print(name)，而我们上面也定义name这个变量了呀。显然，即使我们把a导入了进来，但是a.py里面的内容依旧是处于一个模块里面。而我们也说了，名称引用虽然是LEGB规则，但是无论如何都无法越过自身的模块的，print(name)是在a.py里面的，而变量name被定义在b.py中，所以是不可能跨过模块a的作用域去访问模块b里面的内容的。</strong></p>
<blockquote>
<p><strong>所以模块整体也有一个作用域，就是该模块的全局作用域，每个模块是相互独立的。所以我们发现每个模块之间作用域还是划分的很清晰的，都是相互独立的。</strong></p>
</blockquote>
<p><strong>关于模块，我们后续会详细说。总之通过<code>.</code>的方式本质上都是去指定的命名空间中查找对应的属性。</strong></p>
<h4 id="属性空间"><a href="#属性空间" class="headerlink" title="属性空间"></a>属性空间</h4><p><strong>我们知道，自定义的类中如果没有__slots__，那么这个类的实例对象都会有一个属性字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">        self.age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g.__dict__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于查找属性而言, 也是去属性字典中查找</span></span><br><span class="line"><span class="built_in">print</span>(g.name, g.__dict__[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理设置属性, 也是更改对应的属性字典</span></span><br><span class="line">g.__dict__[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;female&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gender)  <span class="comment"># female</span></span><br></pre></td></tr></table></figure>

<p><strong>当然模块也有属性字典，属性查找方面，本质上和上面的类的实例对象是一致的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">str</span>)  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(builtins.__dict__[<span class="string">&quot;str&quot;</span>])  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>另外global空间里面是保存了builtin空间的指针的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># globals()[&quot;__builtins__&quot;]直接等价于import builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(builtins)  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但我们说globals函数是在什么地方呢? 显然是在builtin空间中</span></span><br><span class="line"><span class="comment"># 所以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>在 *Python* 中，一个名字(变量)可见范围由 “作用域” 决定，而作用域由语法静态划分，划分规则提炼如下：</strong></p>
<ul>
<li><code>.py文件(模块)最外层为全局作用域</code></li>
<li><code>遇到函数定义，函数体形成子作用域</code></li>
<li><code>遇到类定义，类定义体形成子作用域</code></li>
<li><code>名字仅在其作用域以内可见</code></li>
<li><code>全局作用域对其他所有作用域可见</code></li>
<li><code>函数作用域对其直接子作用域可见，并且可以传递(闭包)</code></li>
</ul>
<p><strong>与”作用域”相对应， *Python* 在运行时借助 *PyDictObject* 对象保存作用域中的名字，构成动态的”名字空间” 。这样的名字空间总共有 *4* 个：</strong></p>
<ul>
<li><code>局部名字空间(local): 不同的函数,局部名字空间不同</code></li>
<li><code>全局名字空间(global): 全局唯一</code></li>
<li><code>闭包名字空间(enclosing)</code></li>
<li><code>内建名字空间(builtin)</code></li>
<li><code>在查找名字时会按照LEGB规则查找, 但是注意: 无法跨越文件本身。就是按照自身文件的LEGB, 如果属性查找都找到builtin空间了, 那么证明这已经是最后的倔强。如果builtin空间再找不到, 那么就只能报错了, 不可能跑到其它文件中找</code></li>
</ul>
<h3 id="python虚拟机的运行框架"><a href="#python虚拟机的运行框架" class="headerlink" title="python虚拟机的运行框架"></a>python虚拟机的运行框架</h3><p><strong>当Python启动后，首先会进行运行时环境的初始化。注意这里的<code>运行时环境</code>，它和上面说的<code>执行环境</code>是不同的概念。运行时环境是一个全局的概念，而执行时环境是一个栈帧，是一个与某个code  block相对应的概念。现在不清楚两者的区别不要紧，后面会详细介绍。关于运行时环境的初始化是一个非常复杂的过程，我们后面将用单独的一章进行剖析，这里就假设初始化动作已经完成，我们已经站在了Python虚拟机的门槛外面，只需要轻轻推动一下第一张骨牌，整个执行过程就像多米诺骨牌一样，一环扣一环地展开。</strong></p>
<p><strong>首先Python虚拟机执行PyCodeObject对象中字节码的代码为*Python&#x2F;ceval.c*中，主要函数有两个：*PyEval_EvalCodeEx* 是通用接口，一般用于函数这样带参数的执行场景； PyEval_EvalCode 是更高层封装，用于模块等无参数的执行场景。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCode</span><span class="params">(PyObject *co, PyObject *globals, PyObject *locals)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCodeEx</span><span class="params">(PyObject *_co, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *args, <span class="type">int</span> argcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *kws, <span class="type">int</span> kwcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *defs, <span class="type">int</span> defcount,</span></span><br><span class="line"><span class="params">                  PyObject *kwdefs, PyObject *closure)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这两个函数最终调用 *_PyEval_EvalCodeWithName* 函数，初始化栈帧对象并调用*PyEval_EvalFrame* 和*PyEval_EvalFrameEx*函数进行处理。栈帧对象将贯穿代码对象执行的始终，负责维护执行时所需的一切上下文信息。而*PyEval_EvalFrame* 和*PyEval_EvalFrameEx*函数最终调用 *_PyEval_EvalFrameDefault* 函数，虚拟机执行的秘密就藏在这里。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrame</span><span class="params">(PyFrameObject *f)</span>;</span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrameEx</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span></span><br><span class="line"></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_<span class="title function_">PyEval_EvalFrameDefault</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192108147-1756306627.png" alt="img"></p>
<p>***_PyEval_EvalFrameDefault*函数是虚拟机运行的核心，这一个函数加上注释大概在3100行左右。可以说代码量非常大，但是逻辑并不难理解。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    该函数首先会初始化一些变量，PyFrameObject对象中的PyCodeObject对象包含的信息不用说，还有一个重要的动作就是初始化堆栈的栈顶指针，使其指向f-&gt;f_stacktop</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    co = f-&gt;f_code;</span><br><span class="line">    names = co-&gt;co_names;</span><br><span class="line">    consts = co-&gt;co_consts;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">    next_instr = first_instr;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_lasti &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        assert(f-&gt;f_lasti % <span class="keyword">sizeof</span>(_Py_CODEUNIT) == <span class="number">0</span>);</span><br><span class="line">        next_instr += f-&gt;f_lasti / <span class="keyword">sizeof</span>(_Py_CODEUNIT) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack_pointer = f-&gt;f_stacktop;</span><br><span class="line">    assert(stack_pointer != <span class="literal">NULL</span>);</span><br><span class="line">    f-&gt;f_stacktop = <span class="literal">NULL</span>;       </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PyFrameObject对象中的f_code就是PyCodeObject对象,而PyCodeObject对象里面的co_code域则保存着字节码指令和字节码指令参数</span></span><br><span class="line"><span class="comment">    python执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。在Python的虚拟机中，利用三个变量来完成整个遍历过程。</span></span><br><span class="line"><span class="comment">    首先co_code本质上是一个PyBytesObject对象，而其中的字符数组才是真正有意义的东西。也就是说整个字节码指令序列就是c中一个普普通通的数组。</span></span><br><span class="line"><span class="comment">    因此遍历的过程使用的3个变量都是char *类型的变量</span></span><br><span class="line"><span class="comment">    1.first_instr：永远指向字节码指令序列的开始位置</span></span><br><span class="line"><span class="comment">    2.next_instr：永远指向下一条待执行的字节码指令的位置</span></span><br><span class="line"><span class="comment">    3.f_lasti：指向上一条已经执行过的字节码指令的位置</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<p><strong>那么这个一步一步的动作是如何完成的呢？其实就是一个for循环加上一个巨大的switch case结构。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//......   </span></span><br><span class="line">    co = f-&gt;f_code;</span><br><span class="line">    names = co-&gt;co_names;</span><br><span class="line">    consts = co-&gt;co_consts;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 逐条取出字节码来执行</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Py_atomic_load_relaxed(eval_breaker)) &#123;</span><br><span class="line">            <span class="comment">// 读取下条字节码</span></span><br><span class="line">            <span class="comment">// 字节码位于： f-&gt;f_code-&gt;co_code, 偏移量由 f-&gt;f_lasti 决定</span></span><br><span class="line">            opcode = _Py_OPCODE(*next_instr);</span><br><span class="line">            <span class="comment">//opcode是指令，我们说Python在Include/opcode.h中定义了121个指令</span></span><br><span class="line">            <span class="keyword">if</span> (opcode == SETUP_FINALLY ||</span><br><span class="line">                opcode == SETUP_WITH ||</span><br><span class="line">                opcode == BEFORE_ASYNC_WITH ||</span><br><span class="line">                opcode == YIELD_FROM) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fast_next_opcode; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        fast_next_opcode:</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">//判断该指令属于什么操作，然后执行相应的逻辑</span></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="comment">// 加载常量</span></span><br><span class="line">                <span class="keyword">case</span> LOAD_CONST:</span><br><span class="line">                    <span class="comment">// ....</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 加载名字</span></span><br><span class="line">                <span class="keyword">case</span> LOAD_NAME:</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在这个执行架构中，对字节码一步一步的遍历是通过几个宏来实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INSTR_OFFSET()  \</span></span><br><span class="line"><span class="meta">    (sizeof(_Py_CODEUNIT) * (int)(next_instr - first_instr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTOPARG()  do &#123; \</span></span><br><span class="line"><span class="meta">        _Py_CODEUNIT word = *next_instr; \</span></span><br><span class="line"><span class="meta">        opcode = _Py_OPCODE(word); \</span></span><br><span class="line"><span class="meta">        oparg = _Py_OPARG(word); \</span></span><br><span class="line"><span class="meta">        next_instr++; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><strong>Python的字节码有的是带有参数的，有的是没有参数的，而判断字节码是否带有参数是通过HAS_AGR这个宏来实现的。注意：对于不同的字节码指令，由于存在是否需要指令参数的区别，所以next_instr的位移可以是不同的，但无论如何，next_instr总是指向python下一条要执行的字节码。</strong></p>
<p><strong>Python在获得了一条字节码指令和其需要的参数指令之后，会对字节码利用switch进行判断，根据判断的结果选择不同的case语句，每一条指令都会对应一个case语句。在case语句中，就是Python对字节码指令的实现。所以这个switch语句非常的长，函数总共3000行左右，这个switch就占了2400行，因为指令有121个，比如：LOAD_CONST、LOAD_NAME、YIELD_FROM等等，而每一个指令都要对应一个case语句。</strong></p>
<p><strong>在成功执行完一条字节码指令和其需要的指令参数之后，Python的执行流程会跳转到fast_next_opcode处，或者for循环处。不管如何，Python接下来的动作就是获取下一条字节码指令和指令参数，完成对下一条指令的执行。通过for循环一条一条地遍历co_code中包含的所有字节码指令，然后交给for循环里面的switch语句，如此周而复始，最终完成了对Python程序的执行。</strong></p>
<p><strong>尽管只是简单的分析，但是相信大家也能了解Python执行引擎的大体框架，在Python的执行流程进入了那个巨大的for循环，取出第一条字节码交给里面的switch语句之后，第一张多米诺骨牌就已经被推倒，命运不可阻挡的降临了。一条接一条的字节码像潮水一样涌来，浩浩荡荡，横无际涯。</strong></p>
<p>​        <strong>我们这里通过反编译的方式演示一下</strong>    </p>
<p><strong>指令分为很多种，我们这里就以简单的顺序执行为例，不涉及任何的跳转指令，看看Python是如何执行字节码的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">r = <span class="number">3</span></span><br><span class="line">area = pi * r ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>对它们反编译之后，得到的字节码指令如下：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">3.14</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (pi)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="number">3</span>)</span><br><span class="line">            <span class="number">6</span> STORE_NAME               <span class="number">1</span> (r)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (pi)</span><br><span class="line">           <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (r)</span><br><span class="line">           <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">           <span class="number">14</span> BINARY_POWER</span><br><span class="line">           <span class="number">16</span> BINARY_MULTIPLY</span><br><span class="line">           <span class="number">18</span> STORE_NAME               <span class="number">2</span> (area)</span><br><span class="line">           <span class="number">20</span> LOAD_CONST               <span class="number">3</span> (None)</span><br><span class="line">           <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>第一列是源代码的行号，第二列是指令的偏移量<code>(或者说指令对应的索引)</code>，第三列是指令<code>(或者操作码, 它们在宏定义中代表整数)</code>，第四列表示指令参数<code>(或者操作数)</code>。</strong></p>
<ul>
<li><strong>0 LOAD_CONST: 表示加载一个常量<code>(压入&quot;运行时栈&quot;)</code>，后面的0 (3.14)表示从常量池中加载索引为0的对象，3.14表示加载的对象是3.14(所以最后面的括号里面的内容实际上起到的是一个提示作用，告诉你加载的对象是什么)。</strong></li>
<li><strong>2 STORE_NAME: 表示将LOAD_CONST得到的对象用一个名字存储、或者绑定起来。0 (pi)表示使用符号表<code>(co_varnames)</code>中索引为0的名字<code>(符号)</code>，且名字为”pi”。</strong></li>
<li><strong>4 LOAD_CONST和6 STORE_NAME显然和上面是一样的，只不过后面的索引变成了1，表示加载常量池中索引为1的对象、符号表中索引为1的符号<code>(名字)</code>。另外从这里我们也能看出，一行赋值语句实际上对应两条字节码<code>(加载常量、与名字绑定)</code>。</strong></li>
<li><strong>8 LOAD_NAME表示加载符号表中pi对应的值，10 LOAD_NAME表示加载符号表中r对应的值，12 LOAD_CONST表示加载2这个常量<code>2 (2)表示常量池中索引为2的对象是2</code>。</strong></li>
<li><strong>14 BINARY_POWER表示进行幂运算，16 BINARY_MULTIPLY表示进行乘法运算，18 STORE_NAME表示用符号表中索引为2的符号<code>(area)</code>存储上一步计算的结果，20 LOAD_CONST表示将None加载进来，22 RETURN_VALUE将None返回。虽然它不是在函数里面，但也是有这一步的。</strong></li>
</ul>
<p>​        <strong>我们通过几张图展示一下上面的过程：</strong>    </p>
<p>*<strong>Python* 虚拟机刚开始执行时，准备好栈帧对象用于保存执行上下文，关系如下<code>(省略部分信息)</code>。另外，图中有地方画错了，图中的co_varnames应该改成co_names。我们说对于函数来说是通过co_varnames获取符号表(local空间里面局部变量的存储位置，一个静态数组)，因为函数有哪些局部变量在编译时已经确定，会静态存储在符号表co_varnames中。但我们这里是对模块进行反编译、不是函数，而模块的符号是全局的，local空间和global空间是同一个，使用字典来维护，所以它的co_varnames是一个空元组。但co_names是可以获取到所有的符号的，因此这里把co_names理解为符号表即可，但我们知道全局变量是存在字典里面的。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192115796-1415510203.png" alt="img"></p>
<p><strong>由于 *next_instr* 初始状态指向字节码开头，虚拟机开始加载第一条字节码指令： <code>0 LOAD_CONST 0 (3.14)</code> 。字节码分为两部分，分别是 操作码 ( *opcode* )和 操作数 ( *oparg* ) 。<code>LOAD_CONST</code> 指令表示将常量加载进运行时栈，常量下标由操作数给出。<code>LOAD_CONST</code> 指令在 *_PyEval_EvalFrameDefault* 函数 *switch* 结构的一个 *case* 分支中实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(LOAD_CONST) &#123;</span><br><span class="line">    <span class="comment">//通过GETITEM从consts(常量池)中加载索引为oparg的对象(常量)</span></span><br><span class="line">    <span class="comment">//所以0 LOAD_CONST 0 (3.14)分别表示: </span></span><br><span class="line">    <span class="comment">//字节码指令的偏移量、操作码、对象在常量池中的索引(即这里的oparg)、对象的值(对象的值、或者说常量的值其实是dis模块帮你解析出来的)</span></span><br><span class="line">    PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">    <span class="comment">//增加引用计数</span></span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="comment">//压入运行时栈, 这个运行时栈是位于栈帧对象尾部, 我们一会儿会说</span></span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192124938-1897728358.png" alt="img"></p>
<p><strong>接着虚拟机接着执行 <code>2 STORE_NAME 0 (pi)</code> 指令，从符号表中获取索引为0的符号、即pi，然后将栈顶元素<code>3.14</code>弹出，再把符号”pi”和整数对象3.14绑定起来保存到local名字空间</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192130184-726653805.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_NAME)</span>: &#123;</span><br><span class="line">    	    <span class="comment">//从符号表中加载索引为oparg的符号	</span></span><br><span class="line">            PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    	    <span class="comment">//从栈顶弹出元素	</span></span><br><span class="line">            PyObject *v = POP();</span><br><span class="line">            <span class="comment">//获取名字空间namespace</span></span><br><span class="line">            PyObject *ns = f-&gt;f_locals;</span><br><span class="line">            <span class="type">int</span> err;</span><br><span class="line">            <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有名字空间则报错, 这个tstate是和线程密切相关的, 我们后面会说</span></span><br><span class="line">                _PyErr_Format(tstate, PyExc_SystemError,</span><br><span class="line">                              <span class="string">&quot;no locals found when storing %R&quot;</span>, name);</span><br><span class="line">                Py_DECREF(v);</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//将符号和对象绑定起来放在ns中</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_CheckExact(ns))</span><br><span class="line">                err = PyDict_SetItem(ns, name, v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                err = PyObject_SetItem(ns, name, v);</span><br><span class="line">            Py_DECREF(v);</span><br><span class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>你可能会问，变量赋值为啥不直接通过名字空间，而是到临时栈绕一圈？主要原因在于： *Python* 字节码只有一个操作数，另一个操作数只能通过临时栈给出。 *Python* 字节码设计思想跟 *CPU*精简指令集类似，指令尽量简化，复杂指令由多条指令组合完成。</strong></p>
<p><strong>同理，r &#x3D; 2对应的两条指令也是类似的。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192137804-938965116.png" alt="img"></p>
<p><strong>然后8 LOAD_NAME 0 (pi)、10 LOAD_NAME 1 (r)、12 LOAD_CONST 2 (2)，表示将符号pi指向的值、符号r指向的值、常量2压入运行时栈。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192143225-1822001009.png" alt="img"></p>
<p><strong>然后14 BINARY_POWER表示进行幂运算，16 BINARY_MULTIPLY表示进行乘法运算。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192148891-744431496.png" alt="img"></p>
<p><strong>其中， <code>BINARY_POWER</code> 指令会从栈上弹出两个操作数(底数 *3* 和 指数 *2* )进行 幂运算，并将结果 *9* 压回栈中； <code>BINARY_MULTIPLY</code> 指令则进行乘积运算 ，步骤也是类似的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_POWER)</span>: &#123;</span><br><span class="line">    		<span class="comment">//从栈顶弹出元素, 这里是指数2</span></span><br><span class="line">            PyObject *<span class="built_in">exp</span> = POP();</span><br><span class="line">            <span class="comment">//我们看到这个是TOP, 所以其实它不是弹出底数3, 而是获取底数3, 所以3这个元素依旧在栈里面</span></span><br><span class="line">            PyObject *base = TOP();</span><br><span class="line">    	    <span class="comment">//进行幂运算</span></span><br><span class="line">            PyObject *res = PyNumber_Power(base, <span class="built_in">exp</span>, Py_None);</span><br><span class="line">            Py_DECREF(base);</span><br><span class="line">            Py_DECREF(<span class="built_in">exp</span>);</span><br><span class="line">            <span class="comment">//将幂运算的结果再设置回去, 所以原来的3被计算之后的9给替换掉了</span></span><br><span class="line">            SET_TOP(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_MULTIPLY)</span>: &#123;</span><br><span class="line">            <span class="comment">//同理这里也是弹出元素9</span></span><br><span class="line">            PyObject *right = POP();</span><br><span class="line">            <span class="comment">//获取元素3.14</span></span><br><span class="line">            PyObject *left = TOP();</span><br><span class="line">            <span class="comment">//乘法运算</span></span><br><span class="line">            PyObject *res = PyNumber_Multiply(left, right);</span><br><span class="line">            Py_DECREF(left);</span><br><span class="line">            Py_DECREF(right);</span><br><span class="line">            <span class="comment">//将运算的结果28.26将原来的3.14给替换掉</span></span><br><span class="line">            SET_TOP(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终执行指令18 STORE_NAME               2 (area)，会从符号表中加载索引为2的符号、即area，再将”area”和浮点数28.26绑定起来放到名字空间中。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192156864-1221966200.png" alt="img"></p>
<p><strong>整体的执行流程便如上面几张图所示，当然字节码指令有很多，我们说它们定义在Include&#x2F;opcode.h中，有121个。比如：除了LOAD_CONST、STORE_NAME之外，还有LOAD_FAST、LOAD_GLOBAL、STORE_FAST，以及if语句、循环语句所使用的跳转指令，运算使用的指令等等等等，这些在后面的系列中会慢慢遇到。</strong></p>
<h4 id="PyFrameObject中的动态内存空间"><a href="#PyFrameObject中的动态内存空间" class="headerlink" title="PyFrameObject中的动态内存空间"></a>PyFrameObject中的动态内存空间</h4><p><strong>上面我们提到了一个运行时栈，我们说加载常量的时候会将常量<code>(对象)</code>从常量池中获取、并压入运行时栈，当计算或者使用变量保存的时候，会将其从栈里面弹出来。那么这个运行时栈所需要的空间都保存在什么地方呢？</strong></p>
<p><strong>PyFrameObject中有这么一个属性f_localsplus<code>(可以回头看一下PyFrameObject的定义)</code>，我们说它是动态内存，用于”维护局部变量+cell对象集合+free对象集合+运行时栈所需要的空间”，因此可以看出这段内存不仅仅使用来给栈使用的，还有别的对象使用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFrameObject*</span><br><span class="line"><span class="title function_">PyFrame_New</span><span class="params">(PyThreadState *tstate, PyCodeObject *code,</span></span><br><span class="line"><span class="params">            PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//本质上调用了_PyFrame_New_NoTrack</span></span><br><span class="line">    PyFrameObject *f = _PyFrame_New_NoTrack(tstate, code, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//上一级的栈帧, PyThreadState指的是线程对象</span></span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    <span class="comment">//当前的栈帧</span></span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//builtin</span></span><br><span class="line">    PyObject *builtins;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">        ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">        nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">        <span class="comment">//这四部分便构成了PyFrameObject维护的动态内存区，其大小由extras确定</span></span><br><span class="line">        extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells +</span><br><span class="line">            nfrees;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">        f-&gt;f_code = code;</span><br><span class="line">        <span class="comment">//计算初始化运行时，栈的栈顶，所以没有加上stacksize</span></span><br><span class="line">        extras = code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        <span class="comment">//f_valuestack维护运行时栈的栈底</span></span><br><span class="line">        f-&gt;f_valuestack = f-&gt;f_localsplus + extras;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;extras; i++)</span><br><span class="line">            f-&gt;f_localsplus[i] = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f_stacktopk维护运行时栈的栈顶</span></span><br><span class="line">    f-&gt;f_stacktop = f-&gt;f_valuestack;</span><br><span class="line">    f-&gt;f_builtins = builtins;</span><br><span class="line">    Py_XINCREF(back);</span><br><span class="line">    f-&gt;f_back = back;</span><br><span class="line">    Py_INCREF(code);</span><br><span class="line">    Py_INCREF(globals);</span><br><span class="line">    f-&gt;f_globals = globals;</span><br><span class="line">    <span class="comment">/* Most functions have CO_NEWLOCALS and CO_OPTIMIZED set. */</span></span><br><span class="line">    <span class="keyword">if</span> ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==</span><br><span class="line">        (CO_NEWLOCALS | CO_OPTIMIZED))</span><br><span class="line">        ; <span class="comment">/* f_locals = NULL; will be set by PyFrame_FastToLocals() */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code-&gt;co_flags &amp; CO_NEWLOCALS) &#123;</span><br><span class="line">        locals = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>)</span><br><span class="line">            locals = globals;</span><br><span class="line">        Py_INCREF(locals);</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置一些其他属性，返回返回该栈帧</span></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，在创建PyFrameObject对象时，额外申请的”运行时栈”对应的空间并不完全是给运行时栈使用的，有一部分是给”PyCodeObject对象中存储的那些局部变量”、”co_freevars”、”co_cellvars”<code>(co_freevars、co_cellvars是与闭包有关的内容，后面章节会剖析)</code>使用的，而剩下的才是给真正运行时栈使用的。</strong></p>
<p><strong>并且这段连续的空间是由四部分组成，并且顺序是”局部变量”、”Cell对象”、”Free对象”、”运行时栈”。</strong></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们深入了 *Python* 虚拟机源码，研究虚拟机执行字节码的全过程。虚拟机在执行PyCodeObject对象里面的字节码之前，需要先根据PyCodeObject对象创建栈帧对象 ( *PyFrameObject* )，用于维护运行时的上下文信息。然后在PyFrameObject的基础上，执行字节码。</strong></p>
<p>*<strong>PyFrameObject* 关键信息包括：</strong></p>
<ul>
<li><code>f_locals: 局部名字空间</code></li>
<li><code>f_globals: 全局名字空间</code></li>
<li><code>f_builtins: 内建名字空间</code></li>
<li><code>f_code: PyCodeObject对象</code></li>
<li><code>f_lasti: 上条已执行指令的编号, 或者说偏移量、索引都可以</code></li>
<li><code>f_back: 该栈帧的上一级栈帧、即调用者栈帧</code></li>
<li><code>f_localsplus: 局部变量 + co_freevars + co_cellvars + 运行时栈, 这四部分需要的空间</code></li>
</ul>
<p><strong>栈帧对象通过 *f_back* 串成一个”栈帧调用链”，与 *CPU* 栈帧调用链有异曲同工之妙。我们还借助 *inspect* 模块成功取得栈帧对象<code>(底层是通过sys模块)</code>，并在此基础上输出整个函数调用链。</strong></p>
<p><strong>Python虚拟机的代码量不小，但是核心并不难理解，主要是*_PyEval_EvalFrameDefault*里面的一个巨大的for循环，准确的说for循环里面的那个巨型switch语句。其中的switch语句，case了每一个操作指令，当出现什么指令就执行什么操作。</strong></p>
<p><strong>另外我们提到运行时环境，这个运行时环境非常复杂，因为Python启动是要创建一个主进程、在进程内创建一个主线程的。所以还涉及到了进程和线程的初始化，在后面的系列中我们会详细说，包括GIL的问题。这里我们就先假设运行时环境已经初始化好了，我们直接关注虚拟机执行字节码的流程即可。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>08-解密Python中列表的底层实现</title>
    <url>/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="08-解密Python中列表的底层实现"><a href="#08-解密Python中列表的底层实现" class="headerlink" title="08-解密Python中列表的底层实现"></a>08-解密Python中列表的底层实现</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python中的列表可以说使用的非常广泛了，在初学列表的时候，老师会告诉你列表就是一个大仓库，什么都可以存放。不过在最开始的几个章节中，我们花了很大的笔墨介绍了Python中的对象，并明白了Python中变量的本质，我们知道列表中存放的元素其实都是泛型指针PyObject *，所以到现在列表已经没有什么好神秘的了。</strong></p>
<p><strong>并且根据我们使用列表的经验，我们可以得出以下两个结论：</strong></p>
<ul>
<li><code>每个列表中的元素个数可以不一样：所以这是一个变长对象</code></li>
<li><code>可以对列表中的元素进行添加、删除、修改等操作，所以这是一个可变对象</code></li>
</ul>
<p><strong>在分析列表对应的底层结构之前，我们先来回顾一下列表的使用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表，这里是通过Python/C API创建的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往列表尾部追加一个元素，此时是在本地操作的，返回值为None</span></span><br><span class="line"><span class="comment"># 但是列表被改变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾部弹出一个元素，会返回弹出的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment"># 此时列表也会被修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 另外在pop的时候还可以指定索引，弹出指定的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在指定位置插入一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过extend在尾部追加多个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.extend([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找指定元素第一次出现的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.index(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算某个元素在列表中出现的次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据元素的值删除第一个出现的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(<span class="number">4</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>上面的一些操作是列表经常使用的，但是在分析它的实现之前，我们肯定要了解它们的时间复杂度如何。这些东西即使不看源码，也是必须要知道的，尤其想要成为一名优秀的Python工程师。</strong></p>
<ul>
<li><code>append：会向尾部追加元素，所以时间复杂度为O(1)</code></li>
<li><code>pop：默认从尾部弹出元素，所以时间复杂度为O(1);如果不是尾部，而是从其它的位置弹出元素的话，那么该位置后面所有的元素都要向前移动，此时时间复杂度为O(n)</code></li>
<li><code>insert：向指定位置插入元素，该位置后面的所有元素都要向后移动，所以时间复杂度为O(n)</code></li>
</ul>
<p><strong>注意：由于列表里面的元素个数是可以自由变化的，所以列表有一个容量的概念，我们后面会说。当添加元素时，列表可能会扩容；同理当删除元素时，列表可能会缩容。</strong></p>
<p><strong>下面我们就来看一下列表对应的底层结构。</strong></p>
<h3 id="列表的内部结构–PyListObject"><a href="#列表的内部结构–PyListObject" class="headerlink" title="列表的内部结构–PyListObject"></a>列表的内部结构–PyListObject</h3><p>*<strong>list* 对象<code>(列表)</code>在 *Python* 内部，由 *PyListObject* 结构体表示，定义于头文件 *Include&#x2F;listobject.h* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面有如下成员：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 变长对象的公共头部信息</code></li>
<li><code>ob_item：一个二级指针，指向一个PyObject *类型的指针数组，这个指针数组保存的便是对象的指针，而操作底层数组都是通过ob_item来进行操作的。</code></li>
<li><code>allocated：容量, 我们知道列表底层是使用了C的数组, 而底层数组的长度就是列表的容量</code></li>
</ul>
<p><strong>列表之所以要有容量的概念，是因为列表可以动态添加元素，但是底层的数组在创建完毕之后，其长度却是固定的。所以一旦添加新元素的时候，发现底层数组已经满了，这个时候只能申请一个更长的数组，同时把原来数组中的元素依次拷贝到新的数组里面<code>(这一过程就是列表的扩容)</code>，然后再将新元素添加进去。但是问题来了，总不可能每添加一个元素，就申请一次数组、将所有元素都拷贝一次吧。所以Python在列表扩容的时候，会将底层数组申请的长一些，可以在添加元素的时候不用每次都申请新的数组。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040124028-249317005.png" alt="img"></p>
<p><strong>这便是列表的底层结构示意图，图中的object只是单纯的代指对象，不是Python中的基类object。我们看到底层数组的长度为5，说明此时列表的容量为5，但是里面只有3个PyObject  *指针，说明列表的ob_size是3，或者说列表里面此时有3个元素。注意：尽管底层数组的容量目前是5个，但是我们访问的时候，最多只能访问到第三个元素，也就是说索引最大只能是2，这是显而易见的，因为列表里面只有3个元素。</strong></p>
<p><strong>如果这个时候我们往列表中append一个元素，那么会将这个新元素设置在底层数组中索引为ob_size的位置、或者说第四个位置。一旦设置完，ob_size会自动加1，因为ob_size要和列表的长度保持一致。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040129642-1322638478.png" alt="img"></p>
<p><strong>如果此时再往列表中append一个元素的话，那么还是将新元素设置在索引为ob_size的位置，此时也就是第5个位置。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040138915-609447201.png" alt="img"></p>
<p><strong>列表的容量是5，但此时长度也达到了5，这说明当下一次append的时候已经没有办法再容纳新的元素了。因为此时列表的长度、或者说元素个数已经达到了容量，当然最直观的还是这里的底层数组，很明显全都占满了。那这个时候如果想再接收新的元素的话，要怎么办呢？显然只能扩容了。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040145842-412135912.png" alt="img"></p>
<p><strong>原来的容量是5个，长度也是5个，当再来一个新元素的时候由于没有位置了，所以要扩容。但是扩容的时候肯定会将容量申请的大一些、即底层数组申请的长一些<code>(具体申请多长,Python内部有一个公式,我们后面会说)</code>，假设申请的新的底层数组长度是8，那么说明列表的容量就变成了8。然后将原来数组中的PyObject  *按照顺序依次拷贝到新的数组里面，再让ob_item指向新的数组。最后将要添加的新元素设置在新的数组中索引为ob_size的位置、即第6个位置，然后将ob_size加1，此时ob_size就变成了6。</strong></p>
<p><strong>以上便是列表底层在扩容的时候所经历的过程。</strong></p>
<blockquote>
<p><strong>由于扩容会申请新的数组，然后将旧数组的元素拷贝到新数组中，所以这是一个时间复杂度为O(n)的操作。而append可能会导致列表扩容，因此append最坏情况下也是一个O(n)的操作，只不过扩容不会频繁发生，所以append的平均时间复杂度还是O(1)。</strong></p>
</blockquote>
<p>​        <strong>另外我们还可以看到一个现象，那就是Python中的列表在底层是分开存储的，因为PyListObject结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组的二级指针。显然我们添加、删除、修改元素等操作，都是通过ob_item这个二级指针来间接操作这个指针数组。</strong>    </p>
<p>​        <strong>所以底层对应的PyListObject实例的大小其实是不变的，因为指针数组没有存在PyListObject里面。但是Python在计算内存大小的时候是会将这个指针数组也算进去的，所以Python中列表的大小是可变的。</strong>    </p>
<p><strong>而且我们知道，列表在append之后地址是不变的，至于原因上面的几张图已经解释的很清楚了。如果长度没有达到容量，那么append其实就是往底层数组中设置了一个新元素；如果达到容量了，那么会扩容，但是扩容只是申请一个新的指针数组，然后让ob_item重新指向罢了。所以底层数组会变，但是PyListObject结构体实例本身是没有变化的。因此列表无论是append、extend、pop、insert等等，只要是在本地操作，那么它的地址是不会变化的。</strong></p>
<p><strong>下面我们再来看看Python中的列表所占的内存大小是怎么算的：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 24字节</code></li>
<li><code>ob_item: 二级指针, 8字节</code></li>
<li><code>allocated: 8字节</code></li>
</ul>
<p><strong>但是不要忘记，在计算列表大小的时候，ob_item指向的指针数组也要算在内。所以：一个列表的大小 &#x3D; 40 + 8 * 指针数组长度<code>(或者列表容量)</code>。注意是底层数组长度、或者列表容量，可不是列表长度，因为底层数组一旦申请了，不管你用没用，大小就摆在那里了。就好比你租了间房子，就算不住，房租该交还是得交。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显然一个空数组占40个字节</span></span><br><span class="line"><span class="built_in">print</span>([].__sizeof__())  <span class="comment"># 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 40 + 3 * 8 = 64</span></span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;x&quot;</span> * <span class="number">1000</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="comment"># 虽然里面有一个长度为1000的字符串，但我们说列表存放的都是指针, 所以大小都是8字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 我们通过l = [1, 2, 3]这种方式创建列表的话</span></span><br><span class="line"><span class="comment"># 不管内部元素有多少个, 其ob_size和allocated都是一样的</span></span><br><span class="line"><span class="comment"># 那么列表什么时候会扩容呢? 答案是在添加元素的时候发现容量不够了才会扩容</span></span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 40 + 10 * 8 = 120</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 120</span></span><br><span class="line"><span class="comment"># 这个时候append一个元素</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 184</span></span><br><span class="line"><span class="comment"># 我们发现大小达到了184, (184 - 40) // 8 = 18, 说明扩容之后申请的底层数据的长度为18 </span></span><br></pre></td></tr></table></figure>

<p><strong>所以列表的大小我们就知道是怎么来的了，而且为什么列表在通过索引定位元素的时候，时间复杂度是O(1)。因为列表中存储的都是对象的指针，不管对象有多大，其指针大小是固定的，都是8字节。通过索引可以瞬间计算出偏移量，从而找到对应元素的指针，而操作指针会自动操作指针所指向的内存。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="built_in">print</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]].__sizeof__())  <span class="comment"># 48</span></span><br></pre></td></tr></table></figure>

<p><strong>相信上面这个结果，你肯定能分析出原因。因为第一个列表中有3个指针，所以是40 + 24 &#x3D; 64；而第二个列表中有一个指针，所以是40 + 8 &#x3D; 48。用一张图来展示一下<code>[1, 2, 3]</code>和<code>[[1, 2, 3]]</code>的底层结构，看看它们之间的区别：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040157535-1310257941.png" alt="img"></p>
<p>​        <strong>分析完PyListObject之后，我们来看看它支持的操作，显然我们要通过类型对象PyList_Type来查看。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到，列表支持序列型操作和映射型操作，下面我们就来分析一下。</strong></p>
<h3 id="列表支持的操作"><a href="#列表支持的操作" class="headerlink" title="列表支持的操作"></a>列表支持的操作</h3><p><strong>我们看看平常使用的列表所支持的操作在底层是如何实现的。</strong></p>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p><strong>我们先来说说列表的扩容，因为我们知道列表是会自动扩容的，那么什么时候会扩容呢？我们说列表扩容的时候，是在添加元素时发现底层数组已经满了的情况下才会扩容。换句话说，一个列表在添加元素的时候会扩容，那么说明在添加元素之前，其内部的元素个数和容量是相等的。然后我们看看底层是怎么实现的，这些操作都位于Objects&#x2F;listobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_resize</span><span class="params">(PyListObject *self, Py_ssize_t newsize)</span></span><br><span class="line">&#123;   <span class="comment">//参数self就是列表啦，newsize指的元素在添加之后的ob_size</span></span><br><span class="line">    <span class="comment">//比如列表的ob_size是5，那么在append的时候发现容量不够，所以会扩容，那么这里的newsize就是6</span></span><br><span class="line">    <span class="comment">//如果是extend添加3个元素，那么这里的newsize就是8</span></span><br><span class="line">    <span class="comment">//当然list_resize这个函数不仅可以扩容，也可以缩容，假设列表原来有1000个元素，这个时候将列表清空了</span></span><br><span class="line">    <span class="comment">//那么容量肯定缩小，不然会浪费内存，如果清空了列表，那么这里的newsize显然就是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//items是一个二级指针，显然是用来指向指针数组的</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//新的容量，以及对应的内存大小</span></span><br><span class="line">    <span class="type">size_t</span> new_allocated, num_allocated_bytes;</span><br><span class="line">    <span class="comment">//获取原来的容量</span></span><br><span class="line">    Py_ssize_t allocated = self-&gt;allocated;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize达到了容量的一半，但还没有超过容量, 那么意味着newsize、或者新的ob_size和容量是匹配的，所以不会变化</span></span><br><span class="line">    <span class="keyword">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        assert(self-&gt;ob_item != <span class="literal">NULL</span> || newsize == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//只需要将列表的ob_size设置为newsize即可</span></span><br><span class="line">        Py_SIZE(self) = newsize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里说明容量和ob_size不匹配了，所以要进行扩容或者缩容。</span></span><br><span class="line">    <span class="comment">//因此要申请新的底层数组，申请多少个?这里给出了公式,一会儿我们可以通过Python进行测试</span></span><br><span class="line">    new_allocated = (<span class="type">size_t</span>)newsize + (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//显然容量不可能无限大，是有范围的，当然这个范围基本上是达不到的</span></span><br><span class="line">    <span class="keyword">if</span> (new_allocated &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize为0，那么容量也会变成0，假设将列表全部清空了，容量就会变成0</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">        new_allocated = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们说数组中存放的都是PyObject *, 所以要计算内存</span></span><br><span class="line">    num_allocated_bytes = new_allocated * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line">    <span class="comment">//申请相应大小的内存，将其指针交给items</span></span><br><span class="line">    items = (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果items是NULL, 代表申请失败</span></span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后让ob_item = items, 也就是指向新的数组, 此时列表就发生了扩容或缩容</span></span><br><span class="line">    self-&gt;ob_item = items;</span><br><span class="line">    <span class="comment">//将ob_size设置为newsize, 因为它维护列表内部元素的个数</span></span><br><span class="line">    Py_SIZE(self) = newsize;</span><br><span class="line">    <span class="comment">//将原来的容量大小设置为新的容量大小</span></span><br><span class="line">    self-&gt;allocated = new_allocated;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到还是很简单的，没有什么黑科技，下面我们就来分析一下列表扩容的时候，容量和元素个数之间的规律。其实在list_resize函数中是有注释的，其种一行写着：<code>The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</code></strong></p>
<p><strong>说明我们往一个空列表中不断append元素的时候，容量会按照上面的规律进行变化，我们来试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还记得底层是怎么改变容量的吗？</span></span><br><span class="line"><span class="comment"># 我们说有一个公式: new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="comment"># 我们来看一下</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此时容量是: 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    lst.append(item)  <span class="comment"># 添加元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算ob_size</span></span><br><span class="line">    ob_size = <span class="built_in">len</span>(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断ob_size和当前的容量</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        <span class="comment"># lst的大小减去空列表的大小, 再除以8显然就是容量的大小, 因为不管你有没有用, 容量已经分配了</span></span><br><span class="line">        allocated = (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;列表扩容啦, 新的容量是: <span class="subst">&#123;allocated&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时容量是: 0</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 4</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 8</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 16</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 25</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 35</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 46</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 58</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 72</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 88</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 106</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到和官方给的结果是一样的，显然这是毫无疑问的，我们根据底层的公式也能算出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ob_size = <span class="number">0</span></span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    ob_size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        allocated = ob_size + (ob_size &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> ob_size &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>)</span><br><span class="line">        <span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 0 4 8 16 25 35 46 58 72 88 106 </span></span><br></pre></td></tr></table></figure>

<p>​        <strong>但还是那句话，扩容是指解释器发现容量不够的情况下才会扩容，如果我们直接通过lst &#x3D; []这种形式创建列表的话，那么其长度和容量是一样的。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="comment"># 长度和容量一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但此时添加一个元素的话, 那么ob_size会变成1001, 大于容量1000</span></span><br><span class="line"><span class="comment"># 所以此时列表就要扩容了, 执行list_resize, 里面的new_size就是1001, 然后是怎么分配容量来着</span></span><br><span class="line"><span class="comment"># new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新容量:&quot;</span>, <span class="number">1001</span> + (<span class="number">1001</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">1001</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 新容量: 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append一个元素，列表扩容</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 计算容量</span></span><br><span class="line"><span class="built_in">print</span>((lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果是一样的, 因为底层就是这么实现的, 所以结果必须一样</span></span><br><span class="line"><span class="comment"># 只不过我们通过这种测试的方式证明了这一点, 也更加了解了底层的结构是什么样子的。</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>介绍完扩容，那么介绍缩容，因为列表元素个数要是减少到和容量不匹配的话，也要进行缩容。</strong>    </p>
<p>​        <strong>举个生活中的例子，假设你租了10间屋子用于办公，显然你要付10间屋子的房租，不管你有没有住，一旦租了肯定是要付钱的。同理底层数组也是一样，只要你申请了，不管有没有元素，内存已经占用了。但有一天你用不到10间屋子了，假设会用8间或者9间，那么会让剩余的屋子闲下来。但由于退租比较麻烦，并且只闲下来一两间屋子，所以多余的屋子就不退了，还是会付10间屋子的钱，这样当没准哪天又要用的时候就不用重新租了。对于列表也是如此，如果在删除元素(相当于屋子不用了)的时候发现长度没有超过容量但是又达到了容量的一半，所以也不会缩容。但是，如果屋子闲了8间，也就是只需要两间屋子就足够了，那么此时肯定要退租了，闲了8间，可能会退掉6间。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除500个元素, 此时长度或者说ob_size就为500</span></span><br><span class="line">lst[<span class="number">500</span>:] = []</span><br><span class="line"><span class="comment"># 但是ob_size还是达到了容量的一半, 所以不会缩容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 500 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果再删除一个元素的话, 那么不好意思, 显然就要进行缩容了, 因为ob_size变成了499, 小于1000 // 2</span></span><br><span class="line"><span class="comment"># 缩容之后容量怎么算呢? 还是之前那个公式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">499</span> + (<span class="number">499</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">499</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 567</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下, 删除一个元素, 看看会不会按照我们期待的规则进行缩容</span></span><br><span class="line">lst.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 499 567</span></span><br></pre></td></tr></table></figure>

<p><strong>一切都和我们想的是一样的，另外在代码中我们还看到一个if语句，就是如果newsize是0，那么容量也是0，我们来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line">lst[:] = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 0 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果按照之前的容量变化公式的话, 会发现结果应该是3, 但是结果是0, 就是因为多了if判断:如果newsize是0, 就把容量也设置为0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 但为什么要这么做呢?因为Python认为, 列表长度为0的话，说明你不想用这个列表了, 所以多余的3个也没有必要申请了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还以租房为栗, 如果你一间屋子都不用了, 说明可能你不用这里的屋子办公了</span></span><br><span class="line"><span class="comment"># 因此多余3间屋子也没有必要再租了, 所以直接全部退掉</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是列表在改变容量时所采用的策略，我们从头到尾全部分析了一遍。</strong></p>
<h4 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h4><p><strong>append方法用于像尾部追加一个元素，我们看看底层实现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_append</span><span class="params">(PyListObject *self, PyObject *object)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然调用的app1是核心, 它里面实现了添加元素的逻辑</span></span><br><span class="line">    <span class="comment">//Py_RETURN_NONE是一个宏，表示返回Python中的None, 因为list.append返回的就是None</span></span><br><span class="line">    <span class="keyword">if</span> (app1(self, object) == <span class="number">0</span>)</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">app1</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;	<span class="comment">//self是列表，v是要添加的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取列表的长度</span></span><br><span class="line">    Py_ssize_t n = PyList_GET_SIZE(self);</span><br><span class="line">    assert (v != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果长度已经达到了限制，那么无法再添加了, 会抛出OverflowError</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//还记得这个list_resize吗? self就是列表, n + 1就是newsize，或者说新的ob_size</span></span><br><span class="line">    <span class="comment">//会自动判断是否要进行扩容, 当然里面还有重要的一步，就是将列表的ob_size设置成newsize、也就是这里的n + 1</span></span><br><span class="line">    <span class="comment">//因为append之后列表长度大小会变化，而ob_size则要时刻维护这个大小</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//因为v作为了列表的一个元素，所以其指向的对象的引用计数要加1</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//然后调用PyList_SET_ITEM，这是一个宏，它的作用就是设置元素的，我们下面会看这个宏长什么样</span></span><br><span class="line">    <span class="comment">//原来的列表长度为n, 里面的元素的最大索引是n - 1，那么追加的话就等于将元素设置在索引为n的地方</span></span><br><span class="line">    PyList_SET_ITEM(self, n, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们说PyList_SET_ITEM是用来设置元素的，设置在什么地方呢？显然是设置在底层数组中</span></span><br><span class="line"><span class="comment">//PyList_SET_ITEM一个宏,除了这个宏之外，还有很多其它的宏，它们位于Inlcude/listobject.h中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_SIZE(op)    (assert(PyList_Check(op)),Py_SIZE(op))</span></span><br><span class="line"><span class="comment">//这些宏的作用是啥，一目了然</span></span><br></pre></td></tr></table></figure>

<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>我们在使用列表的时候，可以通过val &#x3D; lst[1]这种方式获取元素，那么底层是如何实现的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//先看item是不是一个整型，显然这个item除了整型之外，也可以是切片</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        Py_ssize_t i;</span><br><span class="line">        <span class="comment">//这里检测i是否合法，因为Python的整型是没有限制的</span></span><br><span class="line">        <span class="comment">//但是列表的长度和容量都是由一个有具体类型的变量维护的，所以其个数肯定是有范围的</span></span><br><span class="line">        <span class="comment">//所以你输入一个lst[2 ** 100000]显然是不行的, 在Python中会报错IndexError: cannot fit &#x27;int&#x27; into an index-sized integer</span></span><br><span class="line">        i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置异常</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果i小于0, 那么加上列表的长度, 变成正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//然后调用list_item</span></span><br><span class="line">        <span class="keyword">return</span> list_item(self, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">list_item(PyListObject *a, Py_ssize_t i)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//检测索引i的合法性，如果i &gt; 列表的长度, 那么会报出索引越界的错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        <span class="comment">//如果索引为负数也会报出索引越界错误,因为上面已经对负数索引做了处理了,但如果负数索引加上长度之后还是个负数, 那么同样报错。</span></span><br><span class="line">        <span class="comment">//假设列表长度是5, 你的索引是-100, 加上长度之后是-95，结果还是个负数, 所以也会报错</span></span><br><span class="line">        <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            indexerr = PyUnicode_FromString(</span><br><span class="line">                <span class="string">&quot;list index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PyErr_SetObject(PyExc_IndexError, indexerr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ob_item获取第i个元素</span></span><br><span class="line">    Py_INCREF(a-&gt;ob_item[i]);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> a-&gt;ob_item[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然获取元素的时候不光可以通过索引，还可以通过切片的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        start: 切片的起始位置</span></span><br><span class="line"><span class="comment">        end: 切片的结束位置</span></span><br><span class="line"><span class="comment">        step: 切片的步长</span></span><br><span class="line"><span class="comment">        slicelength: 获取元素个数,比如[1:5:2],显然slicelength就是2, 因为只能获取索引为1和3的元素</span></span><br><span class="line"><span class="comment">        cur: 底层数组中元素的索引</span></span><br><span class="line"><span class="comment">        i: 循环变量, 因为切片的话只能循环获取每一个元素, 比如[1:5:2], 需要循环两次。第一次循环, 上面的cur就是1, 第二次循环cur就是3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, cur, i;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面代码中会有所体现</span></span><br><span class="line">        PyObject* it;</span><br><span class="line">        PyObject **src, **dest;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//对切片item进行解包进行解包, 得到起始位置、结束位置、步长</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算出slicelength, 因为即便我们指定的切片是[1:3:5], 但如果列表只有3个元素, 所以slicelength也只能是1</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(Py_SIZE(self), &amp;start, &amp;stop,</span><br><span class="line">                                            step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果slicelength为0, 那么不好意思, 表示没有元素可以获取, 因此直接返回一个空列表即可</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//PyList_New表示创建一个PyListObject, 里面的参数表示底层数组的长度</span></span><br><span class="line">            <span class="comment">//另外对于创建列表，Python底层只提供了PyList_New这一种Python/C API</span></span><br><span class="line">            <span class="comment">//当我们执行lst = [1, 2, 3]的时候就会执行PyList_New(3)</span></span><br><span class="line">            <span class="keyword">return</span> PyList_New(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果步长为1, 那么会调用list_slice,这个函数内部的逻辑很简单,首先接收一个PyListObject *和两个整型(ilow, ihigh)</span></span><br><span class="line">        <span class="comment">//然后在内部会创建一个PyListObject *np, 申请相应的底层数组，设置allocated</span></span><br><span class="line">        <span class="comment">//然后将参数列表中索引为ilow的元素到索引为ihigh的元素依次拷贝到np -&gt; ob_item里面, 然后这是ob_size并返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list_slice(self, start, stop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里说明步长不为1, 我们说result是一个PyListObject *, 底层数组没有存储在PyListObject中，而是通过ob_item发生关联</span></span><br><span class="line">            <span class="comment">//所以这一步是申请底层数组、设置容量的，容量就是这里的slicelength, 上面的list_slice中也调用了这一步</span></span><br><span class="line">            result = list_new_prealloc(slicelength);</span><br><span class="line">            <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//src是一个二级指针, 也就是self -&gt; ob_item</span></span><br><span class="line">            src = self-&gt;ob_item;</span><br><span class="line">            <span class="comment">//同理dest是result -&gt; ob_item</span></span><br><span class="line">            dest = ((PyListObject *)result)-&gt;ob_item;</span><br><span class="line">            <span class="comment">//进行循环, cur从start开始遍历, 每次加上step步长</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += (<span class="type">size_t</span>)step, i++) &#123;</span><br><span class="line">                <span class="comment">//it就是self -&gt; ob_item中的元素</span></span><br><span class="line">                it = src[cur];</span><br><span class="line">                <span class="comment">//增加指向的对象的引用计数</span></span><br><span class="line">                Py_INCREF(it);</span><br><span class="line">                <span class="comment">//将其设置到dest中</span></span><br><span class="line">                dest[i] = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将大小设置为slicelength，说明通过切片创建新列表, 其长度和容量也是一致的</span></span><br><span class="line">            Py_SIZE(result) = slicelength;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明item不合法</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;list indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     item-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现这个和字符串类似啊，因为通过字符串也支持切片的方式获取。</strong></p>
<blockquote>
<p><strong>随着源码的分析，我们也渐渐明朗Python的操作在底层是如何实现的了，真的一点不神秘，实现的逻辑非常简单。</strong></p>
</blockquote>
<h4 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h4><p><strong>获取元素知道了，设置元素也不难了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_ass_subscript</span><span class="params">(PyListObject* self, PyObject* item, PyObject* value)</span></span><br><span class="line">&#123;	<span class="comment">//在list_subscript的基础上多了一个value参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//依旧是进行检测i是否合法</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//索引小于0，则加上列表的长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//调用list_ass_item进行设置，我们之前见到了list_item，是用来基于索引获取的</span></span><br><span class="line">        <span class="comment">//这里的list_ass_item是基于索引进行元素设置的</span></span><br><span class="line">        <span class="keyword">return</span> list_ass_item(self, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    	<span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">list_ass_item(PyListObject *a, Py_ssize_t i, PyObject *v)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//判断索引是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                        <span class="string">&quot;list assignment index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的list_ass_slice后面会说</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> list_ass_slice(a, i, i+<span class="number">1</span>, v);</span><br><span class="line">    <span class="comment">//增加v指向对象的引用计数，因为指向它的指针被传到了列表中</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将第i个元素设置成v</span></span><br><span class="line">    Py_SETREF(a-&gt;ob_item[i], v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过索引设置元素，逻辑很容易，关键是通过切片设置元素会比较复杂。而复杂的原因就在于步长，我们通过Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先通过切片进行设置的话, 右值一定要是一个可迭代对象</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="comment"># 会将lst[0]设置为11, lst[1]设置为22, lst[2]设置为33</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [11, 22, 33, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而且它们的长度是可以不相等的</span></span><br><span class="line"><span class="comment"># 这里表示将[0: 3]的元素设置为[1, 2], lst[0]设置成1, lst[1]设置成2</span></span><br><span class="line"><span class="comment"># 问题来了, lst[2]咋办? 由于右值中已经没有元素与之匹配了, 那么lst[2]就会被删掉</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们如果想删除[0: 3]的元素, 那么只需要执行lst[0: 3] = []即可</span></span><br><span class="line"><span class="comment"># 因为[]里面没有元素能与之匹配, 所以lst中[0: 3]的元素由于匹配不到, 所以直接就没了</span></span><br><span class="line"><span class="comment"># 当然由于Python的动态特性, lst[0: 3] = []、lst[0: 3] = ()、lst[0: 3] = &quot;&quot;等等都是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># 实际上我们del lst[0]的时候, 实际上就是执行了lst[0: 1] = []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然如果右值元素多的话也是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># lst[0]匹配1很好理解, 但是此时左边已经结束了, 所以剩余的元素会依次插在后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重点来了, 如果切片有步长的话, 那么两边一定要匹配</span></span><br><span class="line"><span class="comment"># 由于此时lst中有8个元素, lst[:: 2]会得到4个元素, 那么右边的可迭代对象的长度也是4</span></span><br><span class="line">lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;a&#x27;, 2, &#x27;b&#x27;, 4, &#x27;c&#x27;, 7, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果长度不一致</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 显然会报错</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># attempt to assign sequence of size 3 to extended slice of size 4</span></span><br></pre></td></tr></table></figure>

<p><strong>至于通过切片来设置元素，源码很长，这里就不分析了，总之核心如下：</strong></p>
<ul>
<li><code>如果步长为1: 那么会调用list_ass_slice。我们说:  list_item是基于索引获取元素、list_slice是基于切片获取元素、list_ass_item是基于索引设置元素、list_ass_slice是基于切片设置元素。而list_ass_slice内部的代码逻辑也很长，但是核心并不难, 我们通过lst[a: b] = [v1, v2, v3, ...]这种方式就会走这里的list_ass_slice。</code></li>
<li><code>如果步长不为1，那么就是采用循环的方式逐个设置。</code></li>
</ul>
<p><strong>主要是考虑的情况比较多，但是核心逻辑并不复杂，有兴趣可以自己去深入了解一下。</strong></p>
<h4 id="insert插入元素"><a href="#insert插入元素" class="headerlink" title="insert插入元素"></a>insert插入元素</h4><p><strong>insert用来在指定的位置插入元素，我们知道它是一个时间复杂度为O(n)的一个操作，因为插入位置后面的所有元素都要向后移动。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *newitem)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用ins1</span></span><br><span class="line">    <span class="keyword">return</span> ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ins1</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/*参数self：PyListObject *</span></span><br><span class="line"><span class="comment">    参数where：索引</span></span><br><span class="line"><span class="comment">    参数v：插入的值，这是一个PyObject *指针，因为list里面存的都是指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i:后面for循环遍历用的，n则是当前列表的元素个数</span></span><br><span class="line">    Py_ssize_t i, n = Py_SIZE(self);</span><br><span class="line">    <span class="comment">//指向指针数组的二级指针</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//如果v是NULL，错误的内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列表的元素个数不可能无限增大，一般当你还没创建到PY_SSIZE_T_MAX个对象时</span></span><br><span class="line">    <span class="comment">//你内存就已经玩完了，但是python仍然做了检测，当达到这个PY_SSIZE_T_MAX时，会报出内存溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调整列表容量，既然要inert，那么就势必要多出一个元素</span></span><br><span class="line">    <span class="comment">//这个元素还没有设置进去，但是先把这个坑给留出来</span></span><br><span class="line">    <span class="comment">//当然如果容量够的话，是不会扩容的，只有当容量不够的时候才会扩容</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//确定插入点</span></span><br><span class="line">    <span class="keyword">if</span> (where &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里可以看到如果where小于0，那么我们就加上n，也就是当前列表的元素个数</span></span><br><span class="line">        <span class="comment">//比如有6个元素，那么我们where=-1，加上6，就是5，显然就是insert在最后一个索引的位置上 </span></span><br><span class="line">        where += n;</span><br><span class="line">        <span class="comment">//如果吃撑了，写个-100，加上元素的个数还是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (where &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//那么where=0，就在开头插入</span></span><br><span class="line">            where = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果where &gt; n，那么就索引为n的位置插入，</span></span><br><span class="line">    <span class="comment">//可元素个数为n，最大索引是n-1啊，对，所以此时就相当于append</span></span><br><span class="line">    <span class="keyword">if</span> (where &gt; n)</span><br><span class="line">        where = n;</span><br><span class="line">    <span class="comment">//拿到原来的二级指针，指向一个指针数组</span></span><br><span class="line">    items = self-&gt;ob_item;</span><br><span class="line">    <span class="comment">//然后不断遍历，把索引为i的值赋值给索引为i+1</span></span><br><span class="line">    <span class="comment">//既然是在where处插入那么where之前的就不需要动了，到where处就停止了</span></span><br><span class="line">    <span class="keyword">for</span> (i = n; --i &gt;= where; )</span><br><span class="line">        items[i+<span class="number">1</span>] = items[i];</span><br><span class="line">    <span class="comment">//增加v指向的对象的引用计数，因为列表中的元素也引用了该对象</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将索引为where的值设置成v</span></span><br><span class="line">    items[where] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以可以看到，Python插入数据是非常灵活的。不管你在什么位置插入，都是合法的。因为它会自己调整位置，在确定位置之后，会将当前位置以及之后的所有元素向后挪动一个位置，空出来的地方设置为插入的值。</strong></p>
<h4 id="pop弹出元素"><a href="#pop弹出元素" class="headerlink" title="pop弹出元素"></a>pop弹出元素</h4><p><strong>pop默认是从尾部弹出元素的，因为如果不指定索引的话，默认是-1。当然我们也可以指定索引，弹出指定索引对应的元素。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_pop_impl</span><span class="params">(PyListObject *self, Py_ssize_t index)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//弹出的对象的指针，因为弹出一个元素实际上是先用某个变量保存起来，然后再从列表中删掉</span></span><br><span class="line">    PyObject *v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面代码中体现</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果列表长度为0，显然没有元素可以弹, 因此会报错</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop from empty list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//索引小于0，那么加上列表的长度得到正数索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        index += Py_SIZE(self);</span><br><span class="line">    <span class="comment">//依旧是调用valid_index，判断是否越界。显然pop没有insert那么智能</span></span><br><span class="line">    <span class="comment">//insert的话，索引在加上列表长度之和还小于0，那么默认是在索引为0的地方插入</span></span><br><span class="line">    <span class="comment">//但是pop就不行了，pop的话会报出索引越界错误，同理索引大于等于列表长度，insert会等价于append,而pop同样报出索引越界错误</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(index, Py_SIZE(self))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据索引获取指定位置的元素</span></span><br><span class="line">    v = self-&gt;ob_item[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里同样是一个快分支，如果index是最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (index == Py_SIZE(self) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//那么直接调用list_resize即可，我们说只要涉及元素的添加、删除都要执行list_resize</span></span><br><span class="line">        <span class="comment">//至于容量是否变化，就看是否满足newsize和allocated之间的关系,如果allocated//2 &lt;= newsize &lt;= allocated，那么容量就不变</span></span><br><span class="line">        <span class="comment">//list_resize中会将ob_size设置成newsize，也就是原来的ob_size减去1, 因为是在尾部删除的，所以只需要将ob_size设置为ob_size-1即可</span></span><br><span class="line">        status = list_resize(self, Py_SIZE(self) - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list_resize执行成功会返回0</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//直接将对象的指针返回</span></span><br><span class="line">            <span class="keyword">return</span> v; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明不是快分支</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//这里调用了list_ass_slice, 这一步等价于self[index: index + 1] = []</span></span><br><span class="line">    status = list_ass_slice(self, index, index+<span class="number">1</span>, (PyObject *)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置失败，减少引用计数</span></span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回指针</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以pop本质上也是调用了list_ass_slice。</strong></p>
<h4 id="index查询元素的索引"><a href="#index查询元素的索引" class="headerlink" title="index查询元素的索引"></a>index查询元素的索引</h4><p><strong>index可以接收一个元素，返回该元素首次出现的索引。当然还可以额外指定一个start和end，表示查询的范围</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_index_impl</span><span class="params">(PyListObject *self, PyObject *value, Py_ssize_t start,</span></span><br><span class="line"><span class="params">                Py_ssize_t stop)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果start小于0，加上长度。</span></span><br><span class="line">    <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果stop小于0，加上长度</span></span><br><span class="line">        <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">        stop += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (stop &lt; <span class="number">0</span>)</span><br><span class="line">            stop = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从start开始循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; stop &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取相应元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//增加引用计数，因为有指针指向它</span></span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//进行比较PyObject_RichCompareBool是一个富比较，接收三个参数：元素1、元素2、操作(这里显然是Py_EQ)</span></span><br><span class="line">        <span class="comment">//相等返回1，不相等返回0</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        <span class="comment">//比较完之后，减少引用计数</span></span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果相等，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环走完一圈，发现都没有相等的，那么报错，提示元素不再列表中</span></span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">&quot;%R is not in list&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以lst.index是一个时间复杂度为O(n)的操作，因为它在底层要循环整个列表，如果运气好，可以第一个元素就是，运气不好可能就好循环整个列表了。同理后面要说的if value in lst这种方式也是一样的，因为都要循环整个列表，只不过后者返回的是一个布尔值。</strong></p>
<h4 id="count查询元素出现的次数"><a href="#count查询元素出现的次数" class="headerlink" title="count查询元素出现的次数"></a>count查询元素出现的次数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_count</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//初始为0</span></span><br><span class="line">    Py_ssize_t count = <span class="number">0</span>;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//遍历每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//如果相等，那么count自增1，继续下一次循环</span></span><br><span class="line">        <span class="comment">//注意这里的相等，判断的是什么呢？显然是对象的地址，如果地址一样，那么肯定指向同一个对象，所以一定相等。</span></span><br><span class="line">        <span class="keyword">if</span> (obj == value) &#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//走到这里说明地址不一样，但是地址不一样只能说明a is b不成立，但并不代表a == b不成立，所以调用PyObject_RichCompareBool进行判断</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//大于0，说明相等，count++</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回count</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromSsize_t(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>count毫无疑问，无论在什么情况下，它都是一个时间复杂度为O(n)的操作，因为列表必须要从头遍历到尾。</strong></p>
<h4 id="remove根据元素的值删除元素"><a href="#remove根据元素的值删除元素" class="headerlink" title="remove根据元素的值删除元素"></a>remove根据元素的值删除元素</h4><p><strong>除了根据索引删除元素之外，也可以元素指向的对象维护的值删除元素，删除第一个出现元素。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_remove</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历，获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//比较是否相等</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//如果相等</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用list_ass_slice删除元素</span></span><br><span class="line">            <span class="keyword">if</span> (list_ass_slice(self, i, i+<span class="number">1</span>,</span><br><span class="line">                               (PyObject *)<span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//返回None</span></span><br><span class="line">                Py_RETURN_NONE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明元素不在列表中</span></span><br><span class="line">    PyErr_SetString(PyExc_ValueError, <span class="string">&quot;list.remove(x): x not in list&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reverse翻转列表"><a href="#reverse翻转列表" class="headerlink" title="reverse翻转列表"></a>reverse翻转列表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_reverse_impl</span><span class="params">(PyListObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果列表长度不大于1的话, 那么直接返回其本身即可</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//大于1的话，执行reverse_slice, 传递了两个参数</span></span><br><span class="line">        <span class="comment">//第一个参数self -&gt; ob_item显然是底层数组首元素的地址</span></span><br><span class="line">        <span class="comment">//而第二个参数self-&gt;ob_item + Py_SIZE(self)则是底层数组中索引为ob_size的元素的地址</span></span><br><span class="line">        <span class="comment">//但是很明显能访问的最大索引应该是ob_size - 1才对, 别急我们继续往下看, 看一下reverse_slice函数的实现</span></span><br><span class="line">        reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self));</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">reverse_slice</span><span class="params">(PyObject **lo, PyObject **hi)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(lo &amp;&amp; hi);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们看到又执行了一次--hi,将hi移动到了ob_size - 1位置，也就是说此时二级指针hi保存的还是索引为ob_size - 1的元素的值</span></span><br><span class="line">    <span class="comment">//所以个人觉得有点纳闷, 直接reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self) - 1);不行吗</span></span><br><span class="line">    --hi;</span><br><span class="line">    <span class="comment">//当lo小于hi的时候</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        PyObject *t = *lo;</span><br><span class="line">        *lo = *hi;</span><br><span class="line">        *hi = t;</span><br><span class="line">        <span class="comment">//上面三步就等价于 *lo, *hi = *hi, *lo, 但是C不支持这么写</span></span><br><span class="line">        <span class="comment">//所以我们看到就是将索引为0的元素和索引为ob_size-1的元素进行了交换，前后两个指针继续靠近,指向的元素继续交换，知道两个指针相遇</span></span><br><span class="line">        ++lo;</span><br><span class="line">        --hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以到现在，你还认为Python中的列表神秘吗？虽然我们不可能写出一个Python解释器，但是底层的一些思想其实并没有那么难，作为一名程序猿很容易想的到。</strong></p>
<h4 id="两个列表相加"><a href="#两个列表相加" class="headerlink" title="两个列表相加"></a>两个列表相加</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_concat</span><span class="params">(PyListObject *a, PyObject *bb)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size;  <span class="comment">//相加之后的列表长度</span></span><br><span class="line">    Py_ssize_t i; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="comment">//两个二级指针，指向ob_item</span></span><br><span class="line">    PyObject **src, **dest;</span><br><span class="line">    <span class="comment">//新的列表</span></span><br><span class="line">    PyListObject *np;</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(bb)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                  <span class="string">&quot;can only concatenate list (not \&quot;%.200s\&quot;) to list&quot;</span>,</span><br><span class="line">                  bb-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b ((PyListObject *)bb)</span></span><br><span class="line">    <span class="comment">//判断长度是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &gt; PY_SSIZE_T_MAX - Py_SIZE(b))</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//计算新列表的长度</span></span><br><span class="line">    size = Py_SIZE(a) + Py_SIZE(b);</span><br><span class="line">    <span class="comment">//设置np -&gt; ob_item指向的底层数组</span></span><br><span class="line">    np = (PyListObject *) list_new_prealloc(size);</span><br><span class="line">    <span class="keyword">if</span> (np == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取a -&gt; ob_item和np -&gt; ob_item</span></span><br><span class="line">    src = a-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item;</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(a); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取b-&gt;ob_item</span></span><br><span class="line">    <span class="comment">//获取np-&gt;ob_item + Py_SIZE(a), 要从Py_SIZE(a)的位置开始设置, 否则就把之前的元素覆盖掉了</span></span><br><span class="line">    src = b-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item + Py_SIZE(a);</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(b); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size</span></span><br><span class="line">    Py_SIZE(np) = size;</span><br><span class="line">    <span class="comment">//返回np</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)np;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断元素是否在列表中"><a href="#判断元素是否在列表中" class="headerlink" title="判断元素是否在列表中"></a>判断元素是否在列表中</h4><p><strong>对于一个序列来说，可以使用in操作符，等价于调用其<code>__contains__</code>魔法方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_contains</span><span class="params">(PyListObject *a, PyObject *el)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">	<span class="comment">//挨个循环，比较是否相等。存在cmp会等于1，cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)不满足，直接返回</span></span><br><span class="line">    <span class="comment">//不相等则为0, 会一直比完列表中所有的元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, cmp = <span class="number">0</span> ; cmp == <span class="number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i) &#123;</span><br><span class="line">        item = PyList_GET_ITEM(a, i);</span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        cmp = PyObject_RichCompareBool(el, item, Py_EQ);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真的非常简单，没有什么好说的。</strong></p>
<h4 id="列表的深浅拷贝"><a href="#列表的深浅拷贝" class="headerlink" title="列表的深浅拷贝"></a>列表的深浅拷贝</h4><p><strong>列表的深浅拷贝也是初学者容易犯的错误之一，我们看一个Python的例子。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是浅拷贝, 这个过程会创建一个新列表, 会将里面的指针拷贝一份</span></span><br><span class="line"><span class="comment"># 但是指针指向的内存并没有拷贝</span></span><br><span class="line">lst_cp = lst.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个对象的地址是一样的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]), <span class="built_in">id</span>(lst_cp[<span class="number">0</span>]))  <span class="comment"># 2207105155392 2207105155392</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst[0], 会改变lst_cp[0]</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123]] [[123]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst_cp[0], 会改变lst[0]</span></span><br><span class="line">lst_cp[<span class="number">0</span>].append(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123, 456]] [[123, 456]]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们通过索引或者切片也是一样的道理</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">val = lst[<span class="number">0</span>]</span><br><span class="line">lst_cp = lst[<span class="number">0</span>: <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> val <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 此外，lst[:]完全等价于lst.copy()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>之所以会有这样现象，是因为我们说过Python中变量、容器里面的元素都是一个泛型指针PyObject *，在传递的时候会传递指针， 但是在操作的时候会操作指针指向的内存。</strong></p>
<p><strong>所以lst.copy()就是创建了一个新列表，然后把元素拷贝了过去，并且这里的元素是指针。因为只是拷贝指针，没有拷贝指针指向的对象<code>(内存)</code>，所以它们的地址都是一样的，因为指向的是同一个对象。</strong></p>
</blockquote>
<p><strong>但如果我们就想在拷贝指针的同时也拷贝指针指向的对象呢？答案是使用一个叫copy的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[]]</span><br><span class="line"><span class="comment"># 此时拷贝的时候，就会把指针指向的对象也给拷贝一份</span></span><br><span class="line">lst_cp1 = copy.deepcopy(lst)</span><br><span class="line">lst_cp2 = lst[:]</span><br><span class="line"></span><br><span class="line">lst_cp2[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[123]]</span></span><br><span class="line"><span class="built_in">print</span>(lst_cp1)  <span class="comment"># [[]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lst[:]这种方式也是浅拷贝, 所以修改lst_cp2[0], 也会影响lst[0]</span></span><br><span class="line"><span class="comment"># 但是没有影响lst_cp1[0], 证明它们是相互独立的, 因为指向的是不同的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040208452-2140599376.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是一样的</strong></p>
<p><strong>深拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040216408-1830378933.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是不一样的</strong></p>
<p><strong>注意：copy.deepcopy虽然在拷贝指针的同时会将指针指向的对象也拷贝一份，但这仅仅是针对于可变对象，对于不可变对象是不会拷贝的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[], <span class="string">&quot;古明地觉&quot;</span>]</span><br><span class="line">lst_cp = copy.deepcopy(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>] <span class="keyword">is</span> lst_cp[<span class="number">1</span>])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会这样，其实原因很简单。因为不可变对象是不支持本地修改的，你若想修改只能指向新的对象，但是对其它的变量则没有影响，其它变量该指向谁就还指向谁。因为a &#x3D;  b只是将对象的指针拷贝一份给a，然后a和b都指向了同一个对象，至于a和b本身则是没有任何关系的。如果此时b指向了新的对象，是完全不会影响a的，a还是指向原来的对象。所以如果一个指针指向的对象不支持本地修改，那么深拷贝不会拷贝对象本身，因为指向的是不可变对象，所以不会有修改一个影响另一个的情况出现。</strong></p>
<p><strong>关于列表还有一些陷阱：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[]] * <span class="number">5</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [1], [1], [1], [1]]</span></span><br><span class="line"><span class="comment"># 列表乘上一个n，等于把列表里面的元素重复n次</span></span><br><span class="line"><span class="comment"># 注意: 类似于lst = [1, 2, 3], 虽然我们写的是整数，但是它存储的并不是整数，而是其指针</span></span><br><span class="line"><span class="comment"># 所以会把指针重复5次, 因此列表里面5个指针都指向了同一个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式创建的话，里面的元素都指向了不同的列表</span></span><br><span class="line">lst = [[], [], [], [], []]</span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [], [], [], []]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再比如字典，在后续系列中会说</span></span><br><span class="line">d = <span class="built_in">dict</span>.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [])</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [], 2: [], 3: [], 4: []&#125;</span></span><br><span class="line">d[<span class="number">1</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [123], 2: [123], 3: [123], 4: [123]&#125;</span></span><br><span class="line"><span class="comment"># 它们都指向了同一个列表，因此这种陷阱在工作中要注意, 因为一不小心就会出现大问题</span></span><br></pre></td></tr></table></figure>

<h3 id="创建PyListObject"><a href="#创建PyListObject" class="headerlink" title="创建PyListObject"></a>创建PyListObject</h3><p><strong>我们说创建一个列表，Python底层只提供了唯一一个Python&#x2F;C API，也就是PyList_New。这个函数接收一个size参数，从而允许我们在创建一个PyListObject对象时指定底层数组的长度。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyList_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个PyListObject *对象</span></span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size小于0，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存池是否可用，如果可用</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        <span class="comment">//将缓存池内对象个数减1</span></span><br><span class="line">        numfree--;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        <span class="comment">//设置引用计数</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不可用的时候，申请内存</span></span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size小于等于0，ob_item设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，创建一个指定容量的指针数组，然后让ob_item指向它</span></span><br><span class="line">        <span class="comment">//所以是先创建PyListObject对象, 然后创建底层数组, 最后通过ob_item建立联系</span></span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size和allocated，然后返回op</span></span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到源码里面有一个缓冲池，是的，创建PyListObject对象时，会先检测缓冲池free_lists里面是否有可用的对象，有的话直接拿来用，否则通过malloc在系统堆上申请。缓冲池中最多维护80个PyListObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Empty list reuse scheme to save calls to malloc and free */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyList_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyListObject *free_list[PyList_MAXFREELIST];</span><br></pre></td></tr></table></figure>

<p><strong>根据之前的经验我们知道，既然能从缓存池中获取，那么在执行析构函数的时候也要把列表放到缓存池里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_dealloc</span><span class="params">(PyListObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="comment">//将底层数组中每个指针指向的对象的引用计数都减去1</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//然后释放底层数组所占的内存</span></span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断缓冲池里面PyListObject对象的个数，如果没满，就添加到缓存池</span></span><br><span class="line">    <span class="comment">//注意：我们看到执行到这一步的时候, 底层数组已经被释放掉了</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则的话再释放掉PyListObject对象所占的内存</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道在创建一个新的PyListObject对象时，实际上是分为两步的，先创建PyListObject对象，然后创建底层数组，最后让PyListObject对象中的ob_item成员指向这个底层数组。同理，在销毁一个PyListObject对象时，先销毁ob_item维护的底层数组，然后再释放PyListObject对象自身<code>(如果缓存池已满的情况下)</code>。</strong></p>
<p><strong>现在可以很清晰地明白了，原本空荡荡的缓存池其实是被已经死去的PyListObject对象填充了，在以后创建新的PyListObject对象时，Python会首先唤醒这些死去的PyListObject对象，给它们一个洗心革面、重新做人的机会。但需要注意，这里缓存的仅仅是PyListObject对象，对于底层数组，其ob_item已经不再指向了。从list_dealloc中我们看到，PyListObject对象在放进缓存池之前，ob_item指向的数组就已经被释放掉了，同时数组中指针指向的对象的引用计数会减1。所以最终数组中这些指针指向的对象也大难临头各自飞了，或生存、或毁灭，总之此时和PyListObject之间已经没有任何联系了。但是为什么要这么做呢？为什么不连底层数组也一起维护呢？可以想一下，如果继续维护的话，数组中指针指向的对象永远不会被释放，那么很可能会产生悬空指针的问题，所以这些指针指向的对象所占的空间必须交还给系统<code>(前提是没有其它指针指向了)</code>。</strong></p>
<p><strong>但是实际上，是可以将PyListObject对象维护的底层数组进行保留的，即只将数组中指针指向的对象的引用计数减1，然后将数组中的指针都设置为NULL，不再指向之前的对象了，但是并不释放底层数组本身所占用的内存空间。因此这样一来，释放的内存不会交给系统堆，那么再次分配的时候，速度会快很多。但是这样带来一个问题，就是这些内存没人用也会一直占着，并且只能供PyListObject对象的ob_item指向的底层数组使用，因此Python还是为避免消耗过多内存，采取将底层数组的内存交换给了系统堆这样的做法，在时间和空间上选择了空间。</strong></p>
<h3 id="元组的底层结构–PyTupleObject"><a href="#元组的底层结构–PyTupleObject" class="headerlink" title="元组的底层结构–PyTupleObject"></a>元组的底层结构–PyTupleObject</h3><p><strong>因为元组比较简单，和列表比较相似，所以就放在一起介绍了。我们知道元组，就相当于不支持元素添加、修改、删除等操作的列表。</strong></p>
<p><strong>元组的实现机制非常简单，可以看做是在列表的基础上删除了<code>增删改</code>等操作。既然如此，那要元组有什么用呢？毕竟元组的功能只是列表的子集。元组存在的最大一个特点就是，它可以作为字典的key、以及可以作为集合的元素。因为字典和集合存储数据的原理是哈希表，字典和集合我们后续章节会说。对于列表这样的可变对象来说是可以动态改变的，而哈希值是一开始就计算好的，显然如果支持动态修改的话，那么哈希值肯定会变，这是不允许的。所以如果我们希望字典的key是一个序列，显然元组再适合不过了。</strong></p>
<p><strong>从tuple的特点也能看出：tuple的底层是一个变长对象，但同时也是一个不可变对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，对于不可变对象来说，它底层结构体定义也非常简单。一个引用计数、一个类型、一个指针数组。这里的1可以想象成n，我们在PyLongObject中说过。</strong></p>
<p><strong>并且我们发现不像列表，元组没有allocated，这是因为它是不可变的，不支持resize操作。至于维护的值，同样是指针组成的数组，数组里面的每一个指针都指向了具体的值。</strong></p>
<h4 id="PyTupleObject的创建"><a href="#PyTupleObject的创建" class="headerlink" title="PyTupleObject的创建"></a>PyTupleObject的创建</h4><p><strong>正如列表一样，Python创建PyTupleObject也提供了类似的初始化方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyTuple_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyTupleObject指针</span></span><br><span class="line">    PyTupleObject *op;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="comment">//元组同样有缓存池</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; free_list[<span class="number">0</span>]) &#123;</span><br><span class="line">        op = free_list[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        tuple_zero_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//如果长度为0，那么直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; PyTuple_MAXSAVESIZE &amp;&amp; (op = free_list[size]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        free_list[size] = (PyTupleObject *) op-&gt;ob_item[<span class="number">0</span>];</span><br><span class="line">        numfree[size]--;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        fast_tuple_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Inline PyObject_InitVar */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">        <span class="comment">//设置ob_size，和ob_type</span></span><br><span class="line">        Py_SIZE(op) = size;</span><br><span class="line">        Py_TYPE(op) = &amp;PyTuple_Type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//引用计数初始化为1</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 元组的元素个数同样有限制，但我们说这个限制一般达不到 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>)size &gt; ((<span class="type">size_t</span>)PY_SSIZE_T_MAX - <span class="keyword">sizeof</span>(PyTupleObject) -</span><br><span class="line">                    <span class="keyword">sizeof</span>(PyObject *)) / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">        op = PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, size);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        op-&gt;ob_item[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        free_list[<span class="number">0</span>] = op;</span><br><span class="line">        ++numfree[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);          <span class="comment">/* extra INCREF so that this is never freed */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_TRACK_COUNT</span></span><br><span class="line">    count_tracked++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject初始化类似，同样需要做一些类型检测，内存是否溢出等等。</strong></p>
<p><strong>当然有了列表的经验，元组的一些底层操作我们就不分析了，它是列表的子集。</strong></p>
<h4 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h4><p><strong>列表和元组两者在通过索引查找元素的时候是一致的，但是元组除了能作为字典的key之外，还有一个特点，就是分配的速度比较快。一方面是因为由于其不可变性，使得在编译的时候就确定了，另一方面就是它还具有静态资源缓存的作用。</strong></p>
<p><strong>对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python  就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。你可以理解为PyTupleObject对象在被析构时，不仅对象本身没有被回收，连底层的指针数组也被缓存起来了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = timeit(stmt=<span class="string">&quot;x1 = [1, 2, 3, 4, 5]&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line">t2 = timeit(stmt=<span class="string">&quot;x2 = (1, 2, 3, 4, 5)&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t1, <span class="number">2</span>))  <span class="comment"># 0.05</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t2, <span class="number">2</span>))  <span class="comment"># 0.01</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到用时，元组只是列表的五分之一。这便是元组的另一个优势，可以将资源缓存起来。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>09-字典和集合的底层实现</title>
    <url>/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="09-解密Python中字典和集合的底层实现，深度分析哈希表"><a href="#09-解密Python中字典和集合的底层实现，深度分析哈希表" class="headerlink" title="09-解密Python中字典和集合的底层实现，深度分析哈希表"></a>09-解密Python中字典和集合的底层实现，深度分析哈希表</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python的字典是一种映射型容器对象，保存了键(key)到值(value)的映射关系。通过字典，我们可以快速的实现值的查找，json这种数据结构也是借鉴了Python中的字典。而且字典在Python中是经过高度优化的，因为Python底层也在大量的使用字典这种数据结构。</strong></p>
<p><strong>那么这次我们就来全面分析一下Python中的字典。</strong></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>我们先来回顾一下字典的基本使用，然后再来分析它的一些特性以及底层实现。</strong></p>
<p><strong>创建一个字典：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者我们还可以通过dict, 传入关键字参数即可</span></span><br><span class="line">d = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然dict里面还可以接收位置参数, 但是最多接收一个</span></span><br><span class="line">d1 = <span class="built_in">dict</span>(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">d2 = <span class="built_in">dict</span>([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)], c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d2)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以根据已有字典创建新的字典</span></span><br><span class="line">d = &#123;**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然通过dict也是可以的, 但是注意: 通过**这种方式本质上是把字典变成多个关键字参数</span></span><br><span class="line"><span class="comment"># 所以里面的key一定要符合Python的变量规范</span></span><br><span class="line">d = <span class="built_in">dict</span>(**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这种是不合法的, 因为**&#123;1: 1&#125;等价于1=1</span></span><br><span class="line">    d = <span class="built_in">dict</span>(**&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># keywords must be strings</span></span><br><span class="line"><span class="comment"># 但是这种是合法的</span></span><br><span class="line">d = &#123;**&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>&#125;, **&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="string">&quot;嘿嘿&quot;</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 1, 2: 2, (1, 2, 3): &#x27;嘿嘿&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>字典支持的操作：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个空字典</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置键值对</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地觉&quot;</span></span><br><span class="line">d[<span class="string">&quot;where&quot;</span>] = <span class="string">&quot;东方地灵殿&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地觉&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新值, 字典里面的key是不重复的, 所以不会出现一个字典中有多个key的情况出现</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地恋&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地恋&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个值, 可以使用del或者pop</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">d.pop(<span class="string">&quot;where&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然字典支持的操作远不止上面那些，但是这些Python层面上的东西想必所有人都了如指掌了，因为字典支持的操作，仅仅相当于是一些API的调用罢了，对着文档查一遍、操作一波就完事了。我们重点是要分析字典这种数据结构在底层的实现方式，以及它背后的一些原理，这才是我们需要关注的。</strong></p>
<p><strong>首先字典的底层是借助哈希表实现的，什么是哈希表我们后面会详细说，总之字典的添加元素、删除元素、查找元素等操作的平均时间复杂度是O(1)。当然了，在哈希不均匀的情况下，最坏时间复杂度是O(n)，但是这种情况很少发生。</strong></p>
<p>​        <strong>我们来测试一下字典的执行效率，看看它和列表之间的区别。一个有1千万个键值对的字典。然后对两者使用in来查询某个元素是否存在,</strong>     </p>
<p>​        <strong>我们测试的方式是，使用if … in …来查询一个元素是否存在，看看它们的耗时如何。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">count: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param count: 循环次数</span></span><br><span class="line"><span class="string">    :param value: 查询的元素</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 有一千万个随机数的列表</span></span><br><span class="line">    lst = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">30</span>, size=<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># 根据这个列表构造出含有一千万个键值对的字典</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在列表中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> lst</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在字典中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> d</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字典查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别查询一千次、一万次、十万次、二十万次</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">3</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 0.13</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">4</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 1.22</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 12.68</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span> * <span class="number">2</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 25.72</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字典的查询速度非常快，从测试中我们看到，随着循环次数越来越多，列表所花费的总时间越来越长。但是字典由于查询所花费的时间极少，查询速度非常快，所以即便循环50万次，花费的总时间也不过才0.01秒左右。</strong></p>
<p><strong>此外字典还有一个特点，就是它的”快”不会受到数据量的影响，你从含有一万个键值对的字典中查找，和你从含有一千万个键值对的字典中查找，两者花费的时间几乎是没有区别的。</strong></p>
<p><strong>那么字典到底是使用了什么黑科技，才能达到这么快的效果呢？想要知道答案的话，那就从字典在底层的内部结构中寻找吧。</strong></p>
<h3 id="初识哈希表"><a href="#初识哈希表" class="headerlink" title="初识哈希表"></a>初识哈希表</h3><p>**由于映射型容器的使用场景非常广泛，几乎所有现代语言都支持映射型容器，而且特别关注”键”的搜索效率。例如：C++标准模板库中的 *map* 就是一种关联式容器，内部基于红黑树实现。红黑树是一种平衡二叉树，能够提供良好的操作效率，插入、删除、搜索等关键操作的时间复杂度均为*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>，Linux的epoll也是使用了红黑树。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20230329155658577-1680101009722.png" alt="image-20230329155658577"></p>
<p>**而对于Python来讲，映射型容器指的就是字典，我们说字典在Python内部是被高度优化的。因为不光我们在用，Python虚拟机在运行时也重度依赖字典，比如：自定义类、以及其实例对象都有自己的属性字典，还有名字空间本质上也是一个字典，因此Python对字典的要求会更加苛刻。所以Python在实现字典时采用的数据结构肯定是要优于红黑树的<code>(至少在添加、删除、查询元素等方面)</code>，也就是说它的时间复杂度是优于红黑树的。时间复杂度优于*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>的数据结构有哪些呢？没错，你应该已经猜到了，就是散列表、又称哈希表。</strong></p>
<p>​        <strong>所以在介绍字典之前，我们需要介绍一下哈希表。当然这里只是先大致介绍一下，能够一个宏观的认识，为了在理解字典时能够方便一些。至于更详细的内容，我们会在本文的后面介绍。</strong>    </p>
<p><strong>我们在介绍元组的时候，说元组可以作为字典的key，但是列表不可以，就是因为列表是不可哈希的。哈希表的原理是将key通过哈希函数进行运算转换为一个数值，用这个数值来充当索引，因此这就有一个前提，就是你的值不可以变。而列表是个可变对象，因此它不可以作为字典的key。</strong></p>
<p><strong>直接这么说的话，可能会感到很迷，我们画一张图。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164717645-250695028-1680101009725.png" alt="img"></p>
<p><strong>我们发现除了key、value之外，还有一个index。其实哈希表本质上也是使用了索引的思想，我们知道虽然列表在遍历的时候是个时间复杂度为O(n)的操作，但是通过索引定位元素则是一个时间复杂度为O(1)的操作，不管你列表有多长，通过索引总是能瞬间定位到指定元素。所以哈希表实际上也是使用了数组<code>(列表)</code>的思想，会把这个key通过哈希函数映射成一个数值，作为索引。至于它是怎么映射的，我们后面再谈，现在我们就假设是按照我们接下来说的方法映射的。</strong></p>
<p><strong>比如我们这里有一个能容纳10个元素的字典<code>(这里假设容量为10其实是不准确的,容量应该是2的n次方,但是这里只是介绍哈希表,所以不管了)</code>，我们先设置d[“satori”]&#x3D;82，那么会对”satori”这个字符串进行一个哈希运算，然后再对10、也就是和当前的总容量进行取模，这样的话是不是能够得到一个小于10的数呢？假设是5，那么就存在索引为5地方。然后又进行d[“koishi”]&#x3D;83，那么按照同样的规则运算得到8，那么就存在索引为8的位置，同理第三次设置d[“mashiro”]&#x3D;80，对mashiro进行哈希、取模，得到2，那么存储在索引为2的地方。</strong></p>
<p><strong>同理当我们根据键来获取值的时候，比如：d[“satori”]，那么同样会对字符串”satori”进行哈希、取模，得到索引发现是5，直接把索引为5的value给取出来。</strong></p>
<p><strong>当然这种方式肯定存在缺陷，比如：</strong></p>
<ul>
<li><code>不同的值进行哈希、取模运算之后得到的结果一定是不同的吗？</code></li>
<li><code>在运算之后得到索引的时候，发现这个位置已经有人占了怎么办？</code></li>
<li><code>取值的时候，索引为5，可如果索引为5对应的key和我们指定获取的key不一致怎么办？</code></li>
</ul>
<blockquote>
<p><strong>所以哈希值是有冲突的，如果一旦冲突，那么Python底层会改变策略重新映射，直到映射出来的索引没有人用。比如我们设置一个新的key、value，d[“tomoyo”]&#x3D;88，可是我们对”tomoyo”这个key进行映射之后得到的结果也是5，而索引为5的地方已经被key为”satori”的键给占了，那么Python就会改变规则来对”tomoyo”重新进行运算，找到一个空位置进行添加。但如果我们再次设置d[“satori”]&#x3D;100，那么对satori进行映射得到的结果也是5，而key是一致的，那么就会把对应的值进行修改。</strong></p>
<p><strong>同理，当我们获取值的时候，d[“tomoyo”]，对key进行映射，得到索引。但是发现key不是”tomoyo”而是”satori”，于是改变规则<code>(这个规则跟设置key冲突时，采用的规则是一样的)</code>，重新映射，得到索引，然后发现key是一致的，于是将值取出来。</strong></p>
<p><strong>但如果我们指定了一个不存在的key，那么哈希映射，找到对应索引，发现没有key，证明我们指定的key是不存在的。但如果有的话，发现key和我们指定的key不相等，说明哈希运算得到索引只是碰巧一样，但由于key不一样，因此会改变规则重新运算，得到新的索引。然而发现没有对应的key，于是报错：指定的key不存在。</strong></p>
</blockquote>
<p><strong>所以从这里就已经能说明问题了，就是把key转换成类似列表的索引。可能有人问，这些值貌似不是连续的啊，对的，肯定不是连续的。并不是说你先存，你的索引就小、就在前面，这是由key进行哈希运算之后的结果决定的。而且容量有10个，目前我们只存了4个元素，那么哈希表、或者说字典会不会扩容呢？当然，既然是可变对象，当然会扩容。并且它还不是像列表那样，容量不够才扩容，而当元素个数达到容量的三分之二的时候就会扩容。</strong></p>
<p><strong>我们可以认为字典底层还是使用了索引的思想，字典不可能会像列表那样，元素之间是连续的，一个一个挨在一起的。既然是哈希运算，得到的值肯定是随机的。容量为10，尽管有6个是空着的，但是没关系，我们只要保证设置的元素整体上是有序的即可。就好比有10张桌椅，小红坐在第3张，小明坐在第8张，尽管有空着的，但是没关系，就让它空着。只要我到第3张桌椅能够找到小红、第8张可以找到小明即可。这些桌椅的位置就可以看成是索引，只要我通过索引能够找到对应的元素即可。但是容量为10，为什么不能全部占满之后再扩容呢？试想一下，既然是随机的，那么肯定会出现哈希值碰撞，并且当元素个数到达三分之二之后，这种碰撞的概率非常大。因此当容量到达三分之二的时候，就会申请一份更大的空间，以便来容纳新的元素。</strong></p>
<p><strong>所以我们发现哈希表实际上就是一种空间换时间的方法，如果容量为100，那么就相当于有100个位置，每个元素都进行哈希映射，找到自己的位置。各自的位置都是不固定的，也许会空出来很多元素，但是无所谓，只要保证这些元素在100个位置上是相对有序、通过哈希运算得到索引之后，可以在相应的位置找到它即可。</strong></p>
<p><strong>所以相信应该所有人都能明白为什么哈希表的时间复杂度是O(1)了，就是因为使用了索引的思想，每一个索引都是连续的，只不过一部分索引没有相应的key、value罢了。但这无所谓，因为索引和key、value是一一对应的，通过索引我们能瞬间定位到指定的key，再来检测key是否存在以及和我们指定的key是否一致。如果不存在，那么不好意思，证明这个地方根本没有key、value，说明我们指定了一个不存在的key。而且由于元素个数达到容量的三分之二的时候，碰撞的概率非常大，因此几乎不可能出现容量正好都排满的情况，否则那要改变规则、重复映射多少次啊。</strong></p>
<p>​        <strong>一句话总结：哈希表就是一种空间换时间的方法</strong>    </p>
<p><strong>设置键值对如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164728024-1124533030-1680101009725.png" alt="img"></p>
<p><strong>根据键获取值，如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164734209-960036321-1680101009725.png" alt="img"></p>
<h3 id="字典的底层结构–PyDictObject"><a href="#字典的底层结构–PyDictObject" class="headerlink" title="字典的底层结构–PyDictObject"></a>字典的底层结构–PyDictObject</h3><p><strong>下面我们来看看字典在底层对应的结构体PyDictObject，位于Include&#x2F;dictobject.h中，它的实现还是很复杂的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里是PyObject_HEAD,不是PyObject_VAR_HEAD</span></span><br><span class="line">    <span class="comment">//PyObject_HEAD只有引用计数和类型，没有ob_size</span></span><br><span class="line">    <span class="comment">//但字典显然是一个变长对象，因此肯定有别的成员来维护字典的长度, 当然字典也有容量</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典里面键值对的个数</span></span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典版本：全局唯一，每一次value的变动，都会导致其改变</span></span><br><span class="line">    <span class="type">uint64_t</span> ma_version_tag;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ma_keys从定义上来看，它是一个指针, 指向了一个PyDictKeysObject对象</span></span><br><span class="line">    <span class="comment">//事实上在底层哈希表分为两种，分别是：combined table(结合表)和split table(分离表)</span></span><br><span class="line">    <span class="comment">//如果是结合表，那么键值对存在ma_keys里面，此时下面的ma_values为NULL</span></span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是分离表，那么&quot;键&quot;存在ma_keys里，&quot;value&quot;存在ma_values里</span></span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们下面介绍的是常用的结合表</span></span><br></pre></td></tr></table></figure>

<p><strong>所以名字起得很形象，结合表的话，键和值就存在一起；分离表的话，键和值就存在不同的地方。至于为什么这么做，后面会解释。</strong></p>
<p><strong>整个结构体实际上是看不出来啥的，主要的原因就在那个PyDictKeysObject，我们需要再来看看它长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们看到这是给struct _dictkeysobject起了一个别名，所以真正要看的是_dictkeysobject</span></span><br><span class="line"><span class="comment">//它位于Objects/dict-common.h中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> <span class="title">PyDictKeysObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> &#123;</span></span><br><span class="line">    <span class="comment">//引用计数，跟映射视图的实现有关，类似于对象的引用计数</span></span><br><span class="line">    Py_ssize_t dk_refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表大小，比如是2的n次方，这样可将模运算优化成按位与运算</span></span><br><span class="line">    <span class="comment">//所以我们在上面介绍哈希表的时候，假设字典能容纳10个元素，这个假设是不准确的，不过无所谓啦</span></span><br><span class="line">    Py_ssize_t dk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function to lookup in the hash table (dk_indices):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict(): general-purpose, and may return DKIX_ERROR if (and</span></span><br><span class="line"><span class="comment">         only if) a comparison raises an exception.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode(): specialized to Unicode string keys, comparison of</span></span><br><span class="line"><span class="comment">         which can never raise an exception; that function can never return</span></span><br><span class="line"><span class="comment">         DKIX_ERROR.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further</span></span><br><span class="line"><span class="comment">         specialized for Unicode string keys that cannot be the &lt;dummy&gt; value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_split(): Version of lookdict() for split tables. */</span></span><br><span class="line">    <span class="comment">//哈希查找函数的指针，从注释上我们看到有好几种，会根据字典的当前状态选用最优的版本</span></span><br><span class="line">    dict_lookup_func dk_lookup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中可用的entry数量，这个entry你可以理解为键值对，一个entry就是一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表是有容量的，所以这个dk_usable就表示当前的容量还能容纳多个entry</span></span><br><span class="line">    Py_ssize_t dk_usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中已经使用的entry数量</span></span><br><span class="line">    Py_ssize_t dk_nentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries,</span></span><br><span class="line"><span class="comment">       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The size in bytes of an indice depends on dk_size:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - 1 byte if dk_size &lt;= 0xff (char*)</span></span><br><span class="line"><span class="comment">       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)</span></span><br><span class="line"><span class="comment">       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)</span></span><br><span class="line"><span class="comment">       - 8 bytes otherwise (int64_t*)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span><br><span class="line">    <span class="comment">//哈希表 起始地址 ，哈希表后紧接着 键值对数组 dk_entries 。</span></span><br><span class="line">    <span class="type">char</span> dk_indices[];  <span class="comment">/* char is required to avoid strict aliasing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;PyDictKeyEntry dk_entries[dk_usable];&quot; array follows:</span></span><br><span class="line"><span class="comment">       see the DK_ENTRIES() macro */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>而我们说一个键值对在底层对应一个entry，而这个entry指的就是PyDictKeyEntry对象，我们看看这个结构体长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Cached hash code of me_key. */</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value; <span class="comment">/* This field is only meaningful for combined tables */</span></span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>显然ma_key和ma_value就是键和值，我们之前说Python中变量、以及容器内部的元素都是泛型指针PyObject  *，其中也包括字典，这里也得到了证明。但是我们看到entry除了有键和值之外，还有一个me_hash，它表示键对应的哈希值，这样可以避免重复计算。</strong></p>
<p><strong>至此，字典的整个底层结构就非常清晰了。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814180611353-1782148743-1680101009725.png" alt="img"></p>
<p><strong>字典的真正实现藏在PyDictKeysObject中，它的内部包含两个关键数组：一个是<strong><strong>哈希索引数组dk_indices</strong></strong>，另一个是<strong><strong>键值对数组dk_entries</strong></strong>。字典所维护的键值对<code>(entry)</code>按照先来后到的顺序保存在键值对数组中，而哈希索引数组则保存”键值对”在”键值对数组”中的索引。另外，哈希索引数组中的一个位置我们称之为一个”槽”，比如图中的哈希索引数组便有8个槽，它字典的数量是相等的。</strong></p>
<p><strong>比如我们往空字典<code>(但是容量已经有了, 初始是8个, 不过可用的数量为5个)</code>中插入键值对<code>&quot;夏色祭&quot;: &quot;お娘&quot;</code>的时候，Python会执行以下步骤：</strong></p>
<ul>
<li><code>1. 将键值对保存在dk_entries中，由于初始字典是空的，所以会保存在dk_entries数组中索引为0的位置</code></li>
<li><code>2. 通过哈希函数将键&quot;夏色祭&quot;映射成一个数值，作为索引，假设是5</code></li>
<li><code>3. 将插入的键值对在数组中的索引0，保存在哈希索引数组中索引为5的槽中</code></li>
</ul>
<p><strong>然后当我们在查找键”夏色祭”对应的值的时候，便可瞬间定位。过程如下：</strong></p>
<ul>
<li><code>1. 通过哈希函数将键&quot;夏色祭&quot;映射成数值，也就是索引。因为在设置的时候索引是5，所以在获取的时候映射出来的索引肯定也是5</code></li>
<li><code>2. 找到哈希索引数组中索引为5的槽，得到其保存的0，这里的0对应键值对数组的索引</code></li>
<li><code>3. 找到键值对数组中索引为0的位置，取出PyDictKeyEntry中的me_value，也就是值(当然肯定要先比较key、也就是me_key是否一致, 不一致则重新映射。当然如果该位置为NULL, 那么直接报出KeyError)</code></li>
</ul>
<p><strong>由于<strong><strong>哈希值计算</strong></strong>以及<strong><strong>数组定位</strong></strong>均是O(1)的时间复杂度，所以字典的查询速度才会这么快。当然我们上面没有涉及到哈希冲突，关于哈希冲突我们会在后面详细说，但是就字典在存储和获取的时候就是上面那个流程。</strong></p>
<blockquote>
<p><strong>当然我们在上面的”初识哈希表”这一部分，为了避免牵扯太多，所以说的相对简化了。比如：”mashiro”:  80，我们说”mashiro”映射出来的索引是2，那么键值对就直接存在索引为2的地方。这实际上是简化了，因为这相当于把”哈希索引数组”和”键值对数组”合在一块了。而在早期的Python中，它也确实是这么做的。</strong></p>
<p><strong>但是从上面字典的结构图中我们看到，实际上是先将”键值对”按照先来后到的顺序存在一个数组<code>(键值对数组)</code>中，然后再把其索引存放在另一个数组<code>(哈希索引数组)</code>中索引为2<code>(&quot;mashiro&quot;映射出来的索引是2)</code>的地方。所以在查找的时候，映射出来的索引2其实是哈希索引数组对应的索引。然后对应的槽也存储了一个索引，这个索引是键值对数组对应的索引，假设是4，所以会再根据索引4从键值对数组中获取指定的PyDictKeyEntry对象，再根据该对象获取指定的value。</strong></p>
<p><strong>所以可以看出两者整体思想是基本类似的，理解起来没有什么区别，甚至第一种方式实现起来还会更简单一些。但为什么采用后者这种实现方式，以及这两者之间的区别，我们在后面还会专门分析，之所以采用后者主要是基于内存的考量。</strong></p>
</blockquote>
<h4 id="容量策略"><a href="#容量策略" class="headerlink" title="容量策略"></a>容量策略</h4><p><strong>根据字典的行为我们断定，字典肯定和列表一样有着”预分配机制”。因为可以扩容，那么为了避免频繁申请内存，所以在扩容的是时候会将容量申请的比键值对个数要多一些。那么字典的容量策略是怎么样的呢？</strong></p>
<p><strong>在Object&#x2F;dictobject.c源文件中我们可以看到一个宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MINSIZE 8</span></span><br></pre></td></tr></table></figure>

<p><strong>从这个宏定义中我们可以得知，一个字典的最小容量是8，或者说内部哈希表的长度最小是8。</strong></p>
<p>​        <strong>哈希表越密集，哈希冲突则越频繁，性能也就越差。因此，哈希表必须是一种 稀疏 的表结构，越稀疏则性能越好。但由于  “内存开销”  的制约，哈希表不可能无限地稀疏，所以需要在时间和空间上进行权衡。实践经验表明，一个1&#x2F;2到2&#x2F;3满的哈希表，性能较为理想——以相对合理的  “内存” 换取相对高效的 “执行性能”。</strong>    </p>
<p>​        <strong>为保证哈希表的稀疏程度，进而控制哈希冲突频率， Python 通过 宏USABLE_FRACTION  将哈希表内元素控制在2&#x2F;3以内。宏USABLE_FRACTION 根据哈希表规模n，计算哈希表可存储元素的个数，也就是 键值对数组  的长度。以长度为 8 的哈希表为例，最多可以保持 5 个键值对，超出则需要扩容。</strong>    </p>
<p><strong>而USABLE_FRACTION 是一个非常重要的宏定义，位于源文件 *Objects&#x2F;dictobject.c* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span><br></pre></td></tr></table></figure>

<p><strong>哈希表规模一定是2的n次方，也就是说 *Python* 采用”翻倍扩容”的策略。例如，长度为 *8* 的哈希表扩容后，长度变为 *16* 。</strong></p>
<p><strong>最后，我们来考察一个空字典所占用的内存空间。*Python* 为空字典分配了一个长度为 *8* 的哈希表，因而也要占用相当多的内存，主要有以下几个部分组成：</strong></p>
<ul>
<li><code>PyDictObject中有6个成员，一个8字节，加起来共48字节</code></li>
<li><code>PyDictKeysObject中有7个成员，除了两个数组之外，剩余的每个成员也是一个8字节，所以加起来40字节</code></li>
<li><code>而剩余的两个数组，一个是char类型的数组dk_indices，里面1个元素占1字节；还有一个PyDictKeyEntry类型的数组dk_entries，里面一个元素占24字节，因为PyDictKeyEntry里面有三个成员，一个8字节。但是注意：字典容量为8，说明哈希索引数组长度为8，但是键值对数组dk_entries长度是5，至于原因我们上面分析的很透彻了。因此这两个数组加起来总共是 8 + 24 * 5 = 128字节</code></li>
</ul>
<p><strong>所以一个空字典占用的内存是：48 + 40 + 128 &#x3D; 216字节，我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">216</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是注意：我们说空字典容量为8，但前提它不是通过Python&#x2F;C API创建的，如果是d &#x3D; {}这种方式，那么初始容量就是0，显然此时只有48字节，因为ma_keys此时是NULL。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">48</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>另外，我们看到在计算内存的时候使用的不是sys.getsizeof，而是对象的__sizeof__方法，这两者有什么区别呢？答案是使用sys.getsizeof计算出来内存大小会比调用对象的__sizeof__方法计算出来的内存大小多出16个字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="built_in">dict</span>()), <span class="built_in">dict</span>().__sizeof__()</span><br><span class="line">(<span class="number">232</span>, <span class="number">216</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(&#123;&#125;), &#123;&#125;.__sizeof__()</span><br><span class="line">(<span class="number">64</span>, <span class="number">48</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>之所以会出现这种情况，是因为sys.getsizeof将垃圾回收器的开销也考虑进去了。</strong></p>
<blockquote>
<p><strong>我们说Python底层是通过引用计数来判断对象是否被回收，但是引用计数有一个致命缺陷就是它无法解决循环引用的问题，所以Python内部的gc就是专门用来解决循环引用的。如果创建了一个可能会发生循环引用的对象，那么Python会将该对象挂在链表上，当然链表总共有三条，分别是零代链表、一代链表、二代链表。</strong></p>
<p><strong>先将对象挂在零代链表上，Python的gc一旦发动，那么会采用三色标记模型来对零代链表上的对象进行标记–清除，将那些发生了循环引用的对象的引用计数减一。</strong></p>
<p><strong>而这样的链表为什么有三条呢？试想一下，gc发动的成本也是很高的，如果在gc的洗礼下还能活下来的对象，说明其暂时是较稳的，没有必要每次都对其进行检测。所以会将零代链表中比较稳定的对象移动到一代链表中，同理二代链表也是同理。当清理零代链表达到10次的时候，会清理一次一代链表，清理一代链表达到10次的时候会清理一次二代链表。这样的技术在Python中也被成为分代技术。</strong></p>
</blockquote>
<p><strong>而移动到链表中的对象，除了 PyObject 之外还会有一个额外的 PyGC_Head，所以 sys.getsizeof 计算结果多出的16字节，就是这个 PyGC_Head 所占的大小（在后续介绍GC的时候会说）。</strong></p>
<p><strong>但是整型、浮点型、字符串等等，它们使用sys.getsizeof和调用__sizeof__计算出来的结果是一样的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="number">123</span>), (<span class="number">123</span>).__sizeof__()</span><br><span class="line">(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="string">&quot;matsuri&quot;</span>), <span class="string">&quot;matsuri&quot;</span>.__sizeof__()</span><br><span class="line">(<span class="number">56</span>, <span class="number">56</span>)</span><br></pre></td></tr></table></figure>

<p><strong>至于为什么一样，想必你已经猜到了，因为整型、字符串这种对象是不可能发生循环引用的，只有容器对象才会有可能发生循环引用。我们说Python中的gc是专门针对可能发生循环引用的对象的，对于不会发生循环引用的对象来说，不会参与gc，一个引用计数足够了，所以它们使用两种方式计算出的结果是一样的。</strong></p>
<blockquote>
<p><strong>关于垃圾回收，是一门很复杂的学问，我们这里简单提一下。在该系列的后续，我们会详细的探讨Python中的垃圾回收。</strong></p>
</blockquote>
<h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><p><strong>我们说在Python早期，哈希表并没有分成两个数组实现，而是由一个键值对数组实现，这个数组也承担哈希索引的角色：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164757642-1115745631-1680101009725.png" alt="img"></p>
<p><strong>我们看到这种结构不正是我们在介绍哈希表的时候说的吗？一个键值对数组既用来存储，又用来充当索引，无需分成两个步骤，而且这种方式也似乎更简单、更直观。而我们说Python在早期确实是通过这种方式实现的哈希表，只是这种实现方式有一个弊端，就是太耗费内存了。</strong></p>
<p><strong>我们说哈希表必须保持一定程度的稀疏，最多只有2&#x2F;3满，这意味着至少要浪费1&#x2F;3的空间。</strong></p>
<p><em><em>所以Python为了尽量节省内存，将键值对数组压缩到原来的2&#x2F;3，只用来存储，而对key进行映射得到的索引由另一个数组<code>(哈希索引数组)</code>来存储。因为键值对数组里面一个元素要占用24字节，而哈希索引数组在容量不超过256的时候，里面一个元素只占一个字节；容量不超过65536的时候，里面一个元素只占两个字节，其它以此类推。由于哈希索引数组里面的元素大小比键值对数组里面的元素大小要小很多，所以将哈希表分成两个数组<code>(避免键值对数组的浪费)</code>来实现会更加的节省内存。我们可以举个栗子计算一下，假设我们容量是2 *</em> 16 &#x3D; 65536的哈希表。</em>*</p>
<p><strong>如果是通过第一种方式，只用一个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span></span><br><span class="line"><span class="number">1572864</span>  <span class="comment"># 总共需要这么多字节来存储</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> // <span class="number">3</span></span><br><span class="line"><span class="number">524288</span>  <span class="comment"># 除以3, 会浪费这么多字节</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果是通过第二种方式，使用两个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> * <span class="number">2</span> / <span class="number">3</span> + <span class="number">2</span> ** <span class="number">16</span> * <span class="number">2</span></span><br><span class="line"><span class="number">1179648</span>  <span class="comment"># 容量虽然是2 ** 16次方, 但是键值对数组是容量的2 / 3, 然后加上哈希索引数组的大小</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以一个数组存储比两个数组存储要多用393216字节的内存，因此Python选择使用两个数组来进行存储。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>我们通过考察字典的搜索效率，并深入源码研究其内部哈希表的实现，得到以下结论：</strong></p>
<ul>
<li><code>字典是一种高效的映射式容器，每秒完成高达 *200* 多万次搜索操作；</code></li>
<li><code>字典内部由哈希表实现，哈希表的稀疏特性意味着昂贵的内存开销；</code></li>
<li><code>为优化内存使用，Python将哈希表分为 哈希索引数组 和 键值对数组，也就是通过两个数组来实现；</code></li>
<li><code>哈希表在 1/2 到 2/3 满时，性能较为理想，较好地平衡了 内存开销 与 搜索效率；</code></li>
</ul>
<h3 id="深入哈希表"><a href="#深入哈希表" class="headerlink" title="深入哈希表"></a>深入哈希表</h3><p><strong>通过字典的底层实现，我们找到字典快速、高效的秘密–哈希表。对于映射式容器，一般是通过平衡搜索树或哈希表实现。而Python的字典选用了哈希表，主要是考虑到在搜索方面哈希表的效率更高。因为我们说Python底层重度依赖字典，所以对字典在搜索、设置元素方面的性能，要求的更加苛刻。</strong></p>
<p><strong>但是由于哈希表的稀疏特性，导致其会有巨大的内存牺牲，而为了优化，Python别出心裁的将哈希表分成两部分来实现，分别是：哈希索引数组和键值对数组。</strong></p>
<p><strong>但是显然这当中还有很多细节我们没有说，比如：哈希函数到底是怎么将一个键映射成索引的？哈希冲突了怎么办？哈希攻击又是什么？以及删除操作<code>(没有表面想的那么简单)</code>如何实现？而下面我们就来攻破这些难题，深入理解哈希表。</strong></p>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p><strong>Python内置函数hash会返回对象的哈希值，哈希表依赖于哈希值。</strong></p>
<p><strong>而根据哈希表的性质，我们知道键对象必须满足以下两个条件，否则哈希表便无法正常工作。</strong></p>
<ul>
<li><code>1. 哈希值在对象的整个生命周期内不可以改变</code></li>
<li><code>2. 可比较，如果两个对象相等(使用==操作符结果为True)，那么它们的哈希值一定相同</code></li>
</ul>
<p><strong>满足这两个条件的对象便是”可哈希(hashable)”对象，只有可哈希对象才可以作为哈希表的键<code>(key)</code>。因此像字典、集合等底层由哈希表实现的对象，其元素必须是可哈希对象。</strong></p>
<p><strong>Python中内置的不可变对象都是可哈希对象，比如：整数、浮点数、字符串、元组<code>(元组里面也要是不可变对象)</code>等等，而像可变对象，比如列表、字典等等便不可作为哈希表的键。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&quot;xxx&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;  <span class="comment"># 键是可哈希的就行，值是否可哈希则没有要求</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&#x27;xxx&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;[]: <span class="number">123</span>&#125;  <span class="comment"># 列表是可变对象，因为无法哈希</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;  <span class="comment"># 元组也是可哈希的</span></span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, []): <span class="number">123</span>&#125;  <span class="comment"># 但如果元组里面包含了不可哈希的对象，那么整体也会变成不可哈希对象</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而我们自定义的类的实例对象也是可哈希的，且哈希值是通过对象的地址计算得到的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 141215868971 141215869022</span></span><br></pre></td></tr></table></figure>

<p><strong>而且Python也支持我们重写哈希函数，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 123 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;&lt;__main__.A object at 0x000002A2842282B0&gt;: 1, &lt;__main__.A object at 0x000002A2842285E0&gt;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>并且我们看到虽然哈希值一样，但是在作为字典的键的时候，如果发生了冲突，会改变规则。注意：我们自定义的类的实例对象默认都是可哈希的，但如果类里面重写了__eq__方法，且没有重写__hash__方法的话，那么这个类的实例对象就不可哈希了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unhashable type: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么会有这种现象呢？首先我们说在没有重写__hash__方法的时候，哈希值默认是根据对象的地址计算得到的。而且对象如果相等<code>(使用==操作符会得到True)</code>，那么哈希值一定是一样的。但是我们重写了__eq__，相当于控制了&#x3D;&#x3D;操作符的比较结果，两个对象是否相等就是由我们来控制了，可哈希值却还是根据地址计算得到的。两个对象地址不同，哈希值不同，但是对象却可以相等、又可以不相等，这就导致了矛盾。因此在重写了__eq__、但是没有重写__hash__的情况下，其实例对象便不可哈希了。</strong></p>
<p><strong>但如果重写了__hash__，那么哈希值计算方式就不再通过地址计算了，因此此时是可以哈希的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)  <span class="comment"># &#123;&lt;__main__.A object at 0x000001CEC8D682B0&gt;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时我们看到字典里面只有一个元素了，因为我们说重写了__hash__方法之后，计算得到哈希值都是一样的</span></span><br><span class="line"><span class="string">但是在没有重写__eq__的情况下，默认都是不相等的。如果哈希值一样，但是对象不相等，所以会重新映射。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而我们重写了__eq__，返回的结果是True，所以Python认为对象是相等的，由于key的不重复性，保留了后面的键值对</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>同样的，我们再来看一个Python中字典的例子</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>: <span class="number">123</span>&#125;</span><br><span class="line"></span><br><span class="line">d[<span class="number">1.0</span>] = <span class="number">234</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 234&#125;</span></span><br><span class="line"></span><br><span class="line">d[<span class="literal">True</span>] = <span class="number">345</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 345&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>天哪，这是咋回事？因为整数在计算哈希的时候，得到结果就是其本身；而浮点数显然不是，但如果浮点数的小数点后面只有一个0，那么它和整数是等价的。因此两者的哈希值一样，而3和3.0在Python中也是相等的，因此它们视为同一个key，所以相当于是替换。同理True也是一样，我们说它bool继承自int，所以它等价于1，比如：9 + True &#x3D; 10，因为True的哈希值和1也是一样的，而且也是相等的，索引d[True] &#x3D; 345也是更新。</strong></p>
<blockquote>
<p><strong>但是问题来了，值更新了我们可以理解，字典里面只有一个元素也可以理解，但是为什么key一直是1呢？理论上最终结果应该是True才对啊。</strong></p>
<p><strong>其实这算是Python偷了个懒吧<code>(开个玩笑)</code>，因为key的哈希值是一样的，并且也相等，所以Python不会对key进行替换。从字典在设置元素的时候我们也知道，如果对key映射成索引之后发现哈希索引数组的此位置没有人用，那么就按照先来后到的顺序将”键值对”存在键值对数组中，再将其索引存在哈希索引数组的指定的槽中；如果有人用了，但是对应的key不想等，则重新映射找一个新位置；如果有人用了、并且相等，则说明是同一个key，那么把value换掉即可。所以在替换元素的整个过程中，根本没有涉及到对键的修改，因此上面那个例子的最终结果，value会变、但键依旧是1，而不是True。</strong></p>
</blockquote>
<p><strong>理想的哈希函数必须保证哈希值尽量均匀地分布于整个哈希空间中，越是相近的值，其哈希值差别应该越大。</strong></p>
<blockquote>
<p><strong>所以一个好的哈希函数对实现哈希表起到至关重要的作用。</strong></p>
</blockquote>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p><strong>一方面，不同的对象，哈希值有可能相同，另一方面，与哈希值空间相比，哈希表的槽位是非常有限的。因此，存在多个键被映射到哈希索引的同一槽位的可能性，这便是<strong><strong>索引冲突</strong></strong>。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164807998-1827451738-1680101009725.png" alt="img"></p>
<p><strong>解决哈希冲突的常用方法有两种：</strong></p>
<ul>
<li><code>分离链接法(separate chaining)</code></li>
<li><code>开放寻址法(open addressing)</code></li>
</ul>
<p><strong>Python采用的便是开放寻址法。</strong></p>
<h5 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h5><p><strong>“分离链接法”为每个哈希槽维护一个链表，所有哈希到同一槽位的键保存到对应的链表中：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164818019-995843865-1680101009725.png" alt="img"></p>
<p><strong>如上图所示，哈希索引数组的每一个槽都连接着一个链表，初始状态为空，哈希表某个槽位对应的”键”则保存在对应的链表中。例如：key1和key3都哈希到下标为3的槽位，依次保存在对应的链表中；key2被哈希到下标为1的槽位。</strong></p>
<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p><strong>Python依旧是将key映射成索引存在哈希索引数组的槽中，如果发现槽被占了，那么就尝试另一个。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164825466-1426145061-1680101009725.png" alt="img"></p>
<p>*<em>key3被哈希到槽位为3的时候，发现这个坑被key1给占了，所以只能重新找个坑了。但是为什么找到5呢？显然在解决哈希冲突的时候是有策略的，一般而言，如果是第i次尝试，那么会在首槽的基础上加上一个偏移量*d*<em>i*</em></em></p>
<p>**。比如哈希之后索引是n，那么首槽就是n，然而n这个槽被占了，于是重新映射，重新映射之后的索引就是n + *d**i****<em>，所以可以看出探测方式因函数*d*<em>i*</em></em></p>
<p><strong>而异。</strong></p>
<p><strong>而常见的探测函数有两种：</strong></p>
<ul>
<li><code>线性探测(linear probing)</code></li>
<li><code>平方探测(quadratic probing)</code></li>
</ul>
<p>*<em>线性探测很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个线性函数，例如：*d*<em>i*</em></em></p>
<p> <strong>&#x3D; 2 * i</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164833564-723416397-1680101009725.png" alt="img"></p>
<p>*<em>哈希之后对应的槽是1，但是被占了，这个时候会在首槽的基础上加一个偏移量*d*<em>i*</em></em></p>
<p><strong>。第1次尝试，偏移量是2；第2次尝试，偏移量是4；第3次尝试，偏移量是6。然后再加上首槽的1，所以尝试之后的位置分别是3、5、7。</strong></p>
<p>*<em>平方探测也很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个平方函数，例如：*d*<em>i*</em></em> <strong>&#x3D; *i*2</strong></p>
<p><strong>。同理如果是平方探测，首槽还是1，那么冲突之后重试的槽就是1 + 1、1 + 4、 1+ 9。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164841296-1736851838-1680101009725.png" alt="img"></p>
<blockquote>
<p><strong>线性探测和平方探测很简单，平方探测似乎更胜一筹。因为如果哈希表存在局部热点，探测很难快速跳过热点区域，而平方探测则可以解决这一点。但是这两种方法其实都不够好–因为固定的探测序列加大了冲突的概率。</strong></p>
</blockquote>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164847932-1766657391-1680101009725.png" alt="img"></p>
<p><strong>key1和key2都哈希到槽1，而由于探测序列是相同的，因此冲突概率很高。所以Python对此进行了优化，探测函数参考对象哈希值，生成不同的探测序列，进一步降低哈希冲突的可能性：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164855563-1413795961-1680101009726.png" alt="img"></p>
<h5 id="探测函数"><a href="#探测函数" class="headerlink" title="探测函数"></a>探测函数</h5><p><strong>Python为哈希表搜索提供了多种探测函数，lookdict、lookdict_unicode、lookdict_index，一般通用的是lookdict。lookdict_unicode是专门针对key为字符串的entry，lookdict_index针对key为整数的entry，可以把lookdict_unicode、lookdict_index看成lookdict的特殊实现，只不过key是整数和字符串的场景非常常见，因此为其单独实现了一个函数。</strong></p>
<blockquote>
<p><strong>注意: 我们对字典无论是设置值还是获取值，都需要进行搜索。</strong></p>
</blockquote>
<p><strong>我们这里重点看一下lookdict的函数实现，它位于 *Objects&#x2F;dictobject.c* 源文件内。关键代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">lookdict</span><span class="params">(PyDictObject *mp, PyObject *key,</span></span><br><span class="line"><span class="params">         Py_hash_t hash, PyObject **value_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i, mask, perturb;</span><br><span class="line">    <span class="comment">//keys数组的首地址</span></span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    <span class="comment">//entries数组的首地址</span></span><br><span class="line">    PyDictKeyEntry *ep0;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    dk = mp-&gt;ma_keys;</span><br><span class="line">    ep0 = DK_ENTRIES(dk);</span><br><span class="line">    mask = DK_MASK(dk);</span><br><span class="line">    perturb = hash;</span><br><span class="line">    <span class="comment">//哈希，定位探测链冲突的第一个entry的索引</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// dk-&gt;indecs[i]</span></span><br><span class="line">        Py_ssize_t ix = dk_get_index(dk, i);</span><br><span class="line">        <span class="comment">//如果ix == DKIX_EMPTY，说明没有存储值</span></span><br><span class="line">        <span class="comment">//理论上是报错的，但是在底层是将值的指针设置为NULL</span></span><br><span class="line">        <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">            *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> ix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ix &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到指定的entry的指针</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;ep0[ix];</span><br><span class="line">            assert(ep-&gt;me_key != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//如果两个key一样，那么直接将值的地址设置为ep-&gt;me_value</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            但是注意：我们说Python中的变量是一个指针</span></span><br><span class="line"><span class="comment">            所以这里的一样，表示的两个指针是一样的, 或者地址是一样的, 所以在Python中指向的是同一个对象</span></span><br><span class="line"><span class="comment">            也就是说这一步等价于Python中的: if a is b</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_key == key) &#123;</span><br><span class="line">                *value_addr = ep-&gt;me_value;</span><br><span class="line">                <span class="keyword">return</span> ix;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果两个对象不一样，那么就比较它们的哈希值是否相同</span></span><br><span class="line">            <span class="comment">//比如33和33是一个对象,都是小整数对象池里面整数，但是3333和3333却不是，但是它们的值是一样的</span></span><br><span class="line">            <span class="comment">//因此先判断id是否一致，如果不一致再比较哈希值是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_hash == hash) &#123;</span><br><span class="line">                <span class="comment">//哈希值一样的话, 那么获取me_key</span></span><br><span class="line">                PyObject *startkey = ep-&gt;me_key;</span><br><span class="line">                Py_INCREF(startkey);  <span class="comment">//inc ref</span></span><br><span class="line">                <span class="comment">//比较key是否一致</span></span><br><span class="line">                <span class="type">int</span> cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                Py_DECREF(startkey);  <span class="comment">//dec ref</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">return</span> DKIX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        *value_addr = ep-&gt;me_value;</span><br><span class="line">                        <span class="keyword">return</span> ix;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* The dict was mutated, restart */</span></span><br><span class="line">                    <span class="keyword">goto</span> top;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果条件均不满足，调整姿势，进行下一次探索</span></span><br><span class="line">        <span class="comment">//由于参考了对象哈希值，探测序列因哈希值而异</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i*<span class="number">5</span> + perturb + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希攻击"><a href="#哈希攻击" class="headerlink" title="哈希攻击"></a>哈希攻击</h4><p>*<strong>Python* 在 *3.3* 以前， 哈希算法只根据对象本身计算哈希值。因此，只要 *Python* 解释器相同，对象哈希值也肯定相同。</strong></p>
<p><strong>如果一些别有用心的人构造出大量哈希值相同的 *key* ，并提交给服务器，会发生什么事情呢？例如，向一台 *Python 2 Web* 服务器 *post* 一个 *json* 数据，数据包含大量的 *key* ，所有 *key* 的哈希值相同。这意味着哈希表将频繁发生哈希冲突，性能由 O(1)急剧下降为 O(N)，这便是哈希攻击。</strong></p>
<p><strong>问题虽然很严重，但是好在应对方法比较简单–直接往对象身上撒把盐(salt)即可。具体做法如下：</strong></p>
<ul>
<li><code>1. Python解释器进程启动后，产生一个随机数作为盐</code></li>
<li><code>2. 哈希函数同时参考对象本身以及随机数计算哈希值</code></li>
</ul>
<p><strong>这样一来，攻击者无法获悉解释器内部的随机数，也就无法构造出哈希值相同的对象了！*Python* 自 *3.3* 以后，哈希函数均采用加盐模式，杜绝了哈希攻击的可能性。*Python* 哈希算法在 *Python&#x2F;pyhash.c* 源文件中实现，有兴趣的可以自己去了解一下。</strong></p>
<p><strong>以我当前使用的Python3.8为例，在执行<code>hash(&quot;夏色祭&quot;)</code>的时候，每次执行得到的结果都是不一样的。</strong></p>
<h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p><strong>通过前面的学习，我们现在已经知道哈希表就是通过相应的函数将需要搜索的键映射为一个索引，最终通过索引去访问连续的内存区域。而对于哈希表这种数据结构，最终目的就是加速键的搜索过程。用于映射的函数就是哈希函数，映射之后的值就是哈希值，再由哈希值得到索引<code>(不过为了方便,我们有时会将哈希函数映射的结果直接称为索引)</code>。因此在哈希表的实现中，哈希函数的优劣将直接决定哈希表搜索效率的高低。</strong></p>
<p><strong>并且我们知道，当键值对数量越多，在映射成索引之后就越容易出现冲突。而我们之前说如果冲突了，就改变规则重新映射。事实上，Python也确实是这么做的，这种方法叫做开放寻址法。当发生冲突时，Python会通过一个二次探测函数f，计算下一个候选位置addr，如果可用就插入进去。如果不可用，会继续使用探测函数，直到找到一个可用的位置。通过多次使用探测函数f，从一个位置可以到达多个位置，我们认为这些位置就形成了一个”冲突探测链(探测序列)”。比如当我们插入一个key&#x3D;”satori”的键值对，在a位置发现不行，又走b位置，发现也被人占了，于是到达c位置，发现没有key，于是就占了c这个位置。那么a -&gt; b -&gt; c便形成了一条冲突探测链，同理我们查找的时候也会按照这个顺序进行查找。</strong></p>
<blockquote>
<p><strong>显然上面这些东西，现在理解起来已经没什么难度了，但是问题来了。</strong></p>
<p><strong>如果我此时把上面b位置的entry给删掉的话，会引发什么后果？首先我们知道，b位置上的key和我们指定的”satori”这个key的哈希值是一样的，不然它们也不会映射到同一个槽。当我们直接获取d[“satori”]，肯定会先走a位置，发现有人但key又不是”satori”，于是重新映射；然后走到b，发现还不对，再走到c位置，发现key是”satori”，于是就把值取出来了。显然这符合我们的预期，但是，我要说但是了。</strong></p>
<p><strong>如果我们把b位置上的entry删掉呢？那么老规矩，映射成索引，先走到a位置发现坑被占；于是又走到b位置，结果发现居然没有内容，那么直接就报出了一个KeyError。所以继续寻找的前提是，这个地方要存储了entry，并且存在的<code>entry -&gt; me_key</code>和指定的key不相同，但如果没有的话，就说明根本没有这个key，直接KeyError。然而”satori”这个key确实是存在的，因此发生这种情况我们就说<code>探测链断裂</code>。本来应该走到c的，但是由于b没有元素，因此探测函数在b处就停止了。</strong></p>
</blockquote>
<p><strong>因此我们发现，当一个元素只要位于任何一条探测链当中，在删除元素时都不能真正意义上的删除，而是一种”伪删除”操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个键值对就是一个entry, 在底层就是一个 PyDictKeyEntry 对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>在Python中，当一个PyDictObject对象发生变化时，其中的entry会在三种不同的状态之间进行切换：unused态、active态、dummy态。</strong></p>
<ul>
<li><code>当一个entry的me_key和me_value都是NULL的时候，entry处于unused态。unused态表明该entry中并没有存储key、value，并且在此之前也没有存储过它们，每一个entry在初始化的时候都会处于这个状态。不过me_value的话，即使不是unused态也可能为NULL，更准确的说不管何时它都可能会NULL，这取决于到底是combined table、还是split  table。我们说如果是分离表的话，value是不存在这里的，只有key存在这里，因此me_value永远是NULL。而如果是结合表，那么key和value都存在这里面。所以对于me_key，只可能在unused的时候才可能会NULL。</code></li>
<li><code>当entry存储了key时，那么此时entry便从unused态变成了active态。</code></li>
<li><code>当entry中的key(value)被删除后，状态便从active态变成dummy态。注意：这里是dummy，删除了并不代表就能够回到unused态，来存储其他key了。我们也说了，unused态是指当前没有、并且之前也没有存储过。key被删除后，会变成dummy，否则就会发生我们之前说的探测链断裂。至于这个dummy到底是啥，我们后面说。总是entry进入dummy态，就是我们刚才提到的伪删除技术。当Python沿着某条探测链搜索时，如果发现一个entry处于dummy态，就会明白虽然当前的entry是无效的，但是后面的entry可能是有效的，所以不会直接就停止搜索、报错，而是会继续搜索，这样就保证了探测链的连续性。至于报错，是在找到了unused状态的entry时才会报错，因为这里确实一直都没有存储过key，但是索引确实是这个位置，这说明当前指定的key就真的不存在哈希表中，此时才会报错。</code></li>
</ul>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164910070-2009596752-1680101009726.png" alt="img"></p>
<blockquote>
<p><strong>unused态只能转换为active态；active态只能转换为dummy态；dummy态只能转化为active态。</strong></p>
</blockquote>
<p><strong>哈希槽位状态常量在 *Objects&#x2F;dict-common.h* 头文件中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_EMPTY (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_DUMMY (-2)  <span class="comment">/* Used internally */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_ERROR (-3)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，如果一个entry被删除了，那么它就变成了dummy态。而我们说dummy态是可以转为active态的，要如何转化呢？如果新来了一个entry，这个entry在存储的时候发生冲突，那么会沿着冲突探测链查找，在查找的时候要是遇到了处于dummy态entry，那么原来处于dummy态的entry就会变成active态。</strong></p>
<p><strong>换句话说，对于处理dummy态的entry，Python压根不会主动理会，只是说这个元素被标记为删除了，但是内存还会继续占用。如果新来的entry，没有发生冲突，一上来就有位置可以存储，那么是不会理会dummy态entry的。只有当发生冲突的时候，正好撞上了dummy态的entry，才会将dummy态的entry给替换掉。此时entry就变成了active态，然后内部维护的就是新的键值对。</strong></p>
<p><strong>如果哈希表满了，那么就申请新的存储单元，然后将所有的active态的entry都搬过去，而处于dummy态的entry则直接丢弃。之所以可以丢弃，是因为dummy状态的entry存在是为了保证探测链不断裂，但是现在所有的active都拷贝到新的内存当中了，它们会形成一条新的探测链，因此也就不需要这些dummy态的entry了。至于到底是扩容、缩容、还是容量不变，取决于当前哈希表的entry个数。但是无论怎么样，当新的哈希表创建之后，便又有新的存储单元可用了。</strong></p>
<h3 id="PyDictObject的创建与维护"><a href="#PyDictObject的创建与维护" class="headerlink" title="PyDictObject的创建与维护"></a>PyDictObject的创建与维护</h3><h4 id="PyDictObject的创建"><a href="#PyDictObject的创建" class="headerlink" title="PyDictObject的创建"></a>PyDictObject的创建</h4><p><strong>Python内部通过PyDict_New来创建一个新的dict对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDict_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//new_keys_object表示创建PyDictKeysObject*对象</span></span><br><span class="line">    <span class="comment">//里面传一个数值，表示entry的容量</span></span><br><span class="line">    <span class="comment">//#define PyDict_MINSIZE 8，从宏定义我们能看出来为8</span></span><br><span class="line">    <span class="comment">//表示默认初始化能容纳8个entry的PyDictKeysObject</span></span><br><span class="line">    <span class="comment">//为什么是8，这是通过大量的经验得来的。</span></span><br><span class="line">    PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE);</span><br><span class="line">    <span class="keyword">if</span> (keys == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这一步则是根据PyDictKeysObject *创建一个新字典</span></span><br><span class="line">    <span class="keyword">return</span> new_dict(keys, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyDictKeysObject *<span class="title function_">new_keys_object</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测，size是否&gt;=PyDict_MINSIZE</span></span><br><span class="line">    assert(size &gt;= PyDict_MINSIZE);</span><br><span class="line">    assert(IS_POWER_OF_2(size));</span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(size);</span><br><span class="line">    <span class="comment">//es：哈希表中的每个索引占多少字节</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0xff</span>) &#123;</span><br><span class="line">        es = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        es = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">        es = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        es = <span class="keyword">sizeof</span>(Py_ssize_t);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注意到，字典里面也有缓冲池，当然这里指定是字典的key</span></span><br><span class="line">    <span class="comment">//如果有的话，直接从里面取</span></span><br><span class="line">    <span class="keyword">if</span> (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则malloc重新申请</span></span><br><span class="line">        dk = PyObject_MALLOC(<span class="keyword">sizeof</span>(PyDictKeysObject)</span><br><span class="line">                             + es * size</span><br><span class="line">                             + <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">        <span class="keyword">if</span> (dk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置引用计数、可用的entry个数等信息</span></span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = <span class="number">1</span>;</span><br><span class="line">    dk-&gt;dk_size = size;</span><br><span class="line">    dk-&gt;dk_usable = usable;</span><br><span class="line">    <span class="comment">//dk_lookup很关键，里面包括了哈希函数和冲突时的二次探测函数的实现</span></span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;</span><br><span class="line">    dk-&gt;dk_nentries = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//哈希表的初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dk-&gt;dk_indices[<span class="number">0</span>], <span class="number">0xff</span>, es * size);</span><br><span class="line">    <span class="built_in">memset</span>(DK_ENTRIES(dk), <span class="number">0</span>, <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">    <span class="keyword">return</span> dk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//这是一个字典的缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//系统堆中申请内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</span><br><span class="line">        <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DK_DECREF(keys);</span><br><span class="line">            free_values(values);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置key、value等等</span></span><br><span class="line">    mp-&gt;ma_keys = keys;</span><br><span class="line">    mp-&gt;ma_values = values;</span><br><span class="line">    mp-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>我们对PyDictObject对象的操作都是建立在搜索的基础之上的，插入和删除也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertdict</span><span class="params">(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//增加对key和value的引用计数</span></span><br><span class="line">    Py_INCREF(key);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_values != <span class="literal">NULL</span> &amp;&amp; !PyUnicode_CheckExact(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> Fail;</span><br><span class="line"></span><br><span class="line">    assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict);</span><br><span class="line">    MAINTAIN_TRACKING(mp, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查共享key，可能扩容哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp) &amp;&amp;</span><br><span class="line">        ((ix &gt;= <span class="number">0</span> &amp;&amp; old_value == <span class="literal">NULL</span> &amp;&amp; mp-&gt;ma_used != ix) ||</span><br><span class="line">         (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">        ix = DKIX_EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//搜索成功</span></span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">        <span class="comment">/* 插入一个新的slot，这个slot可以直接看成是entry */</span></span><br><span class="line">        assert(old_value == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_keys-&gt;dk_usable &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 需要resize */</span></span><br><span class="line">            <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> Fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找值的插入位置，就是我们之前说的将key这个值通过哈希函数映射为索引</span></span><br><span class="line">        Py_ssize_t hashpos = find_empty_slot(mp-&gt;ma_keys, hash);</span><br><span class="line">        <span class="comment">//拿到PyDictKeyEntry *指针</span></span><br><span class="line">        ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[mp-&gt;ma_keys-&gt;dk_nentries];</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries);</span><br><span class="line">        ep-&gt;me_key = key; <span class="comment">//设置key</span></span><br><span class="line">        ep-&gt;me_hash = hash;<span class="comment">//设置哈希</span></span><br><span class="line">        <span class="comment">//如果ma_values数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_values) &#123;</span><br><span class="line">            assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置进去，还记得这是什么表吗？对，这是一张split table</span></span><br><span class="line">            mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ma_values数据为空的话，那么value就设置在PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">            ep-&gt;me_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mp-&gt;ma_used++;<span class="comment">//使用个数+1</span></span><br><span class="line">        mp-&gt;ma_version_tag = DICT_NEXT_VERSION();<span class="comment">//版本数+1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_usable--;<span class="comment">//可用数-1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_nentries++;<span class="comment">//里面entry数量+1</span></span><br><span class="line">        assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= <span class="number">0</span>);</span><br><span class="line">        assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断key是否存在，存在即替换</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        mp-&gt;ma_values[ix] = value;</span><br><span class="line">        <span class="keyword">if</span> (old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* pending state */</span></span><br><span class="line">            assert(ix == mp-&gt;ma_used);</span><br><span class="line">            mp-&gt;ma_used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(old_value != <span class="literal">NULL</span>);</span><br><span class="line">        DK_ENTRIES(mp-&gt;ma_keys)[ix].me_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    Py_XDECREF(old_value); <span class="comment">/* which **CAN** re-enter (see issue #22653) */</span></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Fail:</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上是插入元素，但我们看到无论是插入元素、还是设置元素，insertdict都是可以胜任。但是请注意一下参数，有一个hash参数，这个hash是从什么地方获取的呢？答案是，在调用这个insertdict之前其实会首先调用<code>PyDict_SetItem</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_SetItem</span><span class="params">(PyObject *op, PyObject *key, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>)</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用insertdict，必要时调整元素 */</span></span><br><span class="line">    <span class="keyword">return</span> insertdict(mp, key, hash, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说如果entry个数达到容量的三分之二，那么会调整容量，如何调整呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增长率</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROWTH_RATE(d) ((d)-&gt;ma_used*3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertion_resize</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//本质上调用了dictresize，传入PyDictObject * 和增长率</span></span><br><span class="line">    <span class="keyword">return</span> dictresize(mp, GROWTH_RATE(mp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dictresize</span><span class="params">(PyDictObject *mp, Py_ssize_t minsize)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//新的容量，entry的个数</span></span><br><span class="line">    Py_ssize_t newsize, numentries;</span><br><span class="line">    <span class="comment">//老的keys</span></span><br><span class="line">    PyDictKeysObject *oldkeys;</span><br><span class="line">    <span class="comment">//老的values</span></span><br><span class="line">    PyObject **oldvalues;</span><br><span class="line">    <span class="comment">//老的entries，新的entries</span></span><br><span class="line">    PyDictKeyEntry *oldentries, *newentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确定table的大小*/</span></span><br><span class="line">    <span class="keyword">for</span> (newsize = PyDict_MINSIZE;</span><br><span class="line">         newsize &lt; minsize &amp;&amp; newsize &gt; <span class="number">0</span>;</span><br><span class="line">         newsize &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (newsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取原来的所有keys</span></span><br><span class="line">    oldkeys = mp-&gt;ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建能够容纳newsize个entry的内存空间 */</span></span><br><span class="line">    mp-&gt;ma_keys = new_keys_object(newsize);</span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_keys == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//把以前的key拷贝过去。</span></span><br><span class="line">        mp-&gt;ma_keys = oldkeys;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须满足 可用 &gt;= 已用</span></span><br><span class="line">    assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= mp-&gt;ma_used);</span><br><span class="line">    <span class="keyword">if</span> (oldkeys-&gt;dk_lookup == lookdict)</span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_lookup = lookdict;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取已用entries</span></span><br><span class="line">    numentries = mp-&gt;ma_used;</span><br><span class="line">    <span class="comment">//获取旧信息</span></span><br><span class="line">    oldentries = DK_ENTRIES(oldkeys);</span><br><span class="line">    newentries = DK_ENTRIES(mp-&gt;ma_keys);</span><br><span class="line">    oldvalues = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//如果oldvalues不为NULL，这应该是一个 split table</span></span><br><span class="line">    <span class="comment">//split table的特点是key是能是unicode、</span></span><br><span class="line">    <span class="comment">//那么需要把split table转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (oldvalues != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            assert(oldvalues[i] != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//将ma_values数组里面的元素统统都设置到PyDictKeyEntry对象里面去</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;oldentries[i];</span><br><span class="line">            PyObject *key = ep-&gt;me_key;</span><br><span class="line">            Py_INCREF(key);</span><br><span class="line">            newentries[i].me_key = key;</span><br><span class="line">            newentries[i].me_hash = ep-&gt;me_hash;</span><br><span class="line">            newentries[i].me_value = oldvalues[i];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//减少原来对oldkeys的引用计数</span></span><br><span class="line">        DK_DECREF(oldkeys);</span><br><span class="line">        <span class="comment">//将ma_values设置为NULL，因为所有的value都存在了PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">        mp-&gt;ma_values = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldvalues != empty_values) &#123;</span><br><span class="line">            free_values(oldvalues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 否则的话说明这本身就是一个combined table</span></span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_nentries == numentries) &#123;</span><br><span class="line">            <span class="comment">//将就得entries拷贝到新的entries里面去</span></span><br><span class="line">            <span class="built_in">memcpy</span>(newentries, oldentries, numentries * <span class="keyword">sizeof</span>(PyDictKeyEntry));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理旧的entries</span></span><br><span class="line">            <span class="comment">//active态的entry搬到新table中</span></span><br><span class="line">            <span class="comment">//dummy态的entry，调整key的引用计数，丢弃该entry</span></span><br><span class="line">            PyDictKeyEntry *ep = oldentries;</span><br><span class="line">            <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (ep-&gt;me_value == <span class="literal">NULL</span>)</span><br><span class="line">                    ep++;</span><br><span class="line">                newentries[i] = *ep++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//字典缓冲池的操作，后面介绍</span></span><br><span class="line">        assert(oldkeys-&gt;dk_lookup != lookdict_split);</span><br><span class="line">        assert(oldkeys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_size == PyDict_MINSIZE &amp;&amp;</span><br><span class="line">            numfreekeys &lt; PyDict_MAXFREELIST) &#123;</span><br><span class="line">            DK_DEBUG_DECREF keys_free_list[numfreekeys++] = oldkeys;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DK_DEBUG_DECREF PyObject_FREE(oldkeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//建立哈希表索引</span></span><br><span class="line">    build_indices(mp-&gt;ma_keys, newentries, numentries);</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_usable -= numentries;</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_nentries = numentries;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来看一下改变dict内存空间的一些动作：</strong></p>
<ul>
<li><code>首先要确定table的大小，很显然这个大小一定要大于minsize，这个minsize通过我们已经看到了，是通过宏定义的，是已用entry的3倍</code></li>
<li><code>根据新的table，重新申请内存</code></li>
<li><code>将原来的处于active状态的entry拷贝到新的内存当中，而对于处于dummy状态的entry则直接丢弃。可以丢弃的原因我们上面也说过了。主要是因为哈希表扩容了，会申请的一个新的数组，直接将原来的active态的entry组成一条新的探测链即可，因此也就不需要这些dummy态的entry了</code></li>
</ul>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>插入元素(设置元素)如果明白了，删除元素我觉得都可以不需要说了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_DelItem</span><span class="params">(PyObject *op, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这显然和dictresize一样，是先获取hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    assert(key);</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//真正来删除是下面这个函数</span></span><br><span class="line">    <span class="keyword">return</span> _PyDict_DelItem_KnownHash(op, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_PyDict_DelItem_KnownHash(PyObject *op, PyObject *key, Py_hash_t hash)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t ix;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(hash != <span class="number">-1</span>);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//获取对应entry的index</span></span><br><span class="line">    ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY || old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// split table不支持删除操作，如果是split table，需要转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictresize(mp, DK_SIZE(mp-&gt;ma_keys))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">        assert(ix &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//传入hash和ix，又调用了delitem_common</span></span><br><span class="line">    <span class="keyword">return</span> delitem_common(mp, hash, ix, old_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">delitem_common</span><span class="params">(PyDictObject *mp, Py_hash_t hash, Py_ssize_t ix,</span></span><br><span class="line"><span class="params">               PyObject *old_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到对应的hash索引</span></span><br><span class="line">    Py_ssize_t hashpos = lookdict_index(mp-&gt;ma_keys, hash, ix);</span><br><span class="line">    assert(hashpos &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//已经entries个数-1</span></span><br><span class="line">    mp-&gt;ma_used--;</span><br><span class="line">    <span class="comment">//版本-1</span></span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    <span class="comment">//拿到entry的指针</span></span><br><span class="line">    ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[ix];</span><br><span class="line">    <span class="comment">//将其设置为dummy状态</span></span><br><span class="line">    dk_set_index(mp-&gt;ma_keys, hashpos, DKIX_DUMMY);</span><br><span class="line">    ENSURE_ALLOWS_DELETIONS(mp);</span><br><span class="line">    old_key = ep-&gt;me_key;</span><br><span class="line">    <span class="comment">//将其key、value都设置为NULL</span></span><br><span class="line">    ep-&gt;me_key = <span class="literal">NULL</span>;</span><br><span class="line">    ep-&gt;me_value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    Py_DECREF(old_value);</span><br><span class="line"></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程非常清晰，也很简单。先使用PyDict_DelItem计算hash值，再使用_PyDict_DelItem_KnownHash计算出索引，最后使用delitem_common获取相应的entry，删除维护的元素，并将entry从active态设置为dummy态，同时还会调整ma_used(已用entry)的数量</strong></p>
<h3 id="PyDictObject缓存池"><a href="#PyDictObject缓存池" class="headerlink" title="PyDictObject缓存池"></a>PyDictObject缓存池</h3><p><strong>从介绍PyLongObject的小整数对象池的时候，我们就说过，不同的对象都有自己的缓存池，比如列表，当然字典也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyDict_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyDictObject *free_list[PyDict_MAXFREELIST];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>PyDictObject的缓存池机制其实和PyListObject的缓存池是类似的，开始时，这个缓存池什么也没有，直到第一个PyDictObject对象被销毁时，这个PyDictObject缓冲池里面才开始接纳被缓冲的PyDictObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dict_dealloc</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取ma_values指针</span></span><br><span class="line">    PyObject **values = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//获取所有的ma_keys指针</span></span><br><span class="line">    PyDictKeysObject *keys = mp-&gt;ma_keys;</span><br><span class="line">    <span class="comment">//两个整型</span></span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追踪、调试</span></span><br><span class="line">    PyObject_GC_UnTrack(mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(mp)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//调整引用计数    </span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (values != empty_values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123;</span><br><span class="line">                Py_XDECREF(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            free_values(values);</span><br><span class="line">        &#125;</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        assert(keys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将被销毁的对象放到缓冲池当中</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)</span><br><span class="line">        free_list[numfree++] = mp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject对象的缓冲池机制一样，缓冲池中只保留了PyDictObject对象。如果维护的是从系统堆中申请的内存空间，那么Python将释放这份内存空间，归还给系统堆。如果不是，那么仅仅只需要调整维护的对象的引用计数即可。</strong></p>
<p><strong>其实在创建一个PyDictObject对象时，如果缓冲池中有可用的对象，也会直接从缓冲池中取，而不需要再重新创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>​        <strong>关于字典的剖析我们就说到这里，其实内容还是很多的，尤其是哈希表背后的一些原理，值得好好体会一下。</strong>    </p>
<h3 id="PySetObject"><a href="#PySetObject" class="headerlink" title="PySetObject"></a>PySetObject</h3><p><strong>由于集合和字典在底层使用的都是哈希表，所以我们放在一起说吧。</strong></p>
<p><strong>既然集合也使用了哈希表，那么它的查询性能也是很高的。由于哈希表我们已经说了很多了，所以我们下面就直接来看集合的底层结构吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//python中的集合的每一个元素，是通过setentry这个结构体来存储的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject *key; <span class="comment">// 元素的指针</span></span><br><span class="line">    Py_hash_t hash; <span class="comment">// 元素的哈希值</span></span><br><span class="line">&#125; setentry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们发现在set中，每一个元素依然叫做entry</span></span><br><span class="line">    Py_ssize_t fill;            <span class="comment">/* active态以及dummy态的entry总数量*/</span></span><br><span class="line">    Py_ssize_t used;            <span class="comment">/* active态的entry数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 该table包含mask+1个slot，mask+1是2的幂次方</span></span><br><span class="line"><span class="comment">    我们存储的是mask，而不是size，因为更常需要mask</span></span><br><span class="line"><span class="comment">    这个mask是用来和哈希值进行运算的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于小表，该table指向固定大小的small table，对于bigger table则指向额外的malloc内存</span></span><br><span class="line"><span class="comment">    该table的指针永远不会为NULL。</span></span><br><span class="line"><span class="comment">    所以它是指向setentry数组的一个指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setentry *table;</span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* 该PySetObject的哈希值，只适用于frozenset */</span></span><br><span class="line">    Py_ssize_t finger;          </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于pop元素的，search finger就是我们从包含某个元素的节点开始，找到我们希望的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//smalltable就是显然就是一个保存了setentry类型的数组</span></span><br><span class="line">    <span class="comment">//PySet_MINSIZE是一个宏定义，默认是8。如果元素比较少的话，存在smalltable里面</span></span><br><span class="line">    <span class="comment">//当smalltable存不下的时候(仮)，就会使用malloc申请。存不下，指的是超过8个的时候吗？</span></span><br><span class="line">    <span class="comment">//由于哈希表的特性，需要预留一定的空间，因此还没存到8个的时候，就会扩容了</span></span><br><span class="line">    setentry smalltable[PySet_MINSIZE];</span><br><span class="line">    PyObject *weakreflist;      <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">&#125; PySetObject;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164928460-76799035-1680101009726.png" alt="img"></p>
<h4 id="PySetObject对象的创建"><a href="#PySetObject对象的创建" class="headerlink" title="PySetObject对象的创建"></a>PySetObject对象的创建</h4><p><strong>创建一个PySetObject对象可以使用PySet_New方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PySet_New</span><span class="params">(PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//底层调用了make_new_set</span></span><br><span class="line">    <span class="keyword">return</span> make_new_set(&amp;PySet_Type, iterable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">make_new_set</span><span class="params">(PyTypeObject *type, PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//申明一个PySetObject *指针</span></span><br><span class="line">    PySetObject *so;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//申请该元素所需要的内存</span></span><br><span class="line">    so = (PySetObject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//申请失败，返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (so == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化都为0</span></span><br><span class="line">    so-&gt;fill = <span class="number">0</span>;</span><br><span class="line">    so-&gt;used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//PySet_MINSIZE默认为8，mask初始化为7</span></span><br><span class="line">    so-&gt;mask = PySet_MINSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将table指向保存数据的smalltable的头指针</span></span><br><span class="line">    so-&gt;table = so-&gt;smalltable;</span><br><span class="line">    <span class="comment">//初始化hash值为-1</span></span><br><span class="line">    so-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//finger为0</span></span><br><span class="line">    so-&gt;finger = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//弱引用列表为NULL</span></span><br><span class="line">    so-&gt;weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果迭代器不为NULL，那么把元素依次更新的so这个PySetObject中</span></span><br><span class="line">    <span class="keyword">if</span> (iterable != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set_update_internal(so, iterable)) &#123;</span><br><span class="line">            Py_DECREF(so);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//返回初始化完成的set</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)so;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从以上步骤可以看出，初始化一个PySetObject对象主要初始化其内部的数据结构。</strong></p>
<h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>插入元素，会调用PySet_Add：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PySet_Add</span><span class="params">(PyObject *anyset, PyObject *key)</span></span><br><span class="line">&#123;	<span class="comment">//参数是两个指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PySet_Check(anyset) &amp;&amp;</span><br><span class="line">        (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != <span class="number">1</span>)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本质上调用了set_add_key</span></span><br><span class="line">    <span class="keyword">return</span> set_add_key((PySetObject *)anyset, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个变量，显然是存储哈希值的</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//计算哈希值</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="comment">//如果传入的元素不能被hash，那么直接返回-1</span></span><br><span class="line">        <span class="comment">//在python层面显然会报错</span></span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用了set_add_entry，并把hash也作为参数传了进去</span></span><br><span class="line">    <span class="keyword">return</span> set_add_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *table;  <span class="comment">//指向setentry数组的指针，当然数组里面也是指针</span></span><br><span class="line">    setentry *freeslot;<span class="comment">//存放不可hash的entry</span></span><br><span class="line">    setentry *entry;<span class="comment">//entry指针</span></span><br><span class="line">    <span class="type">size_t</span> perturb;</span><br><span class="line">    <span class="type">size_t</span> mask;<span class="comment">//和hash运算</span></span><br><span class="line">    <span class="type">size_t</span> i; <span class="comment">//一个整型变量，后面的索引值</span></span><br><span class="line">    <span class="type">size_t</span> j;<span class="comment">//遍历用的</span></span><br><span class="line">    <span class="type">int</span> cmp;<span class="comment">//比较的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pre-increment is necessary to prevent arbitrary code in the rich</span></span><br><span class="line"><span class="comment">       comparison from deallocating the key just before the insertion. */</span></span><br><span class="line">    Py_INCREF(key);  <span class="comment">//增加key的引用计数</span></span><br><span class="line"></span><br><span class="line">  restart:</span><br><span class="line"></span><br><span class="line">    mask = so-&gt;mask;  <span class="comment">//获取mask</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;<span class="comment">//mask和hash进行与运算，得到一个索引</span></span><br><span class="line"></span><br><span class="line">    entry = &amp;so-&gt;table[i];<span class="comment">//获取对应的entry指针</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果entry-&gt;key == NULL，表示当前位置没有被使用</span></span><br><span class="line">        <span class="comment">//直接跳到found_unused标签</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则说明有人用了</span></span><br><span class="line">    freeslot = <span class="literal">NULL</span>;</span><br><span class="line">    perturb = hash; <span class="comment">// 将perturb设置为hash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        找到entry-&gt;hash，之前说了，entry结构体由两部分组成</span></span><br><span class="line"><span class="comment">        一个*key，也就是指向真正元素的指针，另一个是hash值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//如果和我们当前的hash值一样的话</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">            <span class="comment">//拿到当前的key</span></span><br><span class="line">            PyObject *startkey = entry-&gt;key;</span><br><span class="line">            <span class="comment">/* startkey cannot be a dummy because the dummy hash field is -1 */</span></span><br><span class="line">            <span class="comment">//entry里面的key不可以为dummy态，因为这相当于删除(伪删除)了，hash为-1</span></span><br><span class="line">            assert(startkey != dummy);</span><br><span class="line">            <span class="comment">//如果已经存在的key和我们添加的key是一样，说明重复了</span></span><br><span class="line">            <span class="comment">//而集合内的元素不允许重复</span></span><br><span class="line">            <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                <span class="comment">//直接跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//如果是unicode，那么先转化，然后再比较两个key是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                <span class="comment">//如果一样，跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//那么获取头部指针</span></span><br><span class="line">            table = so-&gt;table;</span><br><span class="line">            <span class="comment">//增加startkey的引用计数</span></span><br><span class="line">            Py_INCREF(startkey);</span><br><span class="line">            <span class="comment">//不一样的话，通过富比较，去比较两个对象维护的值是否一致</span></span><br><span class="line">            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">            <span class="comment">//介绍startkey的引用计数</span></span><br><span class="line">            Py_DECREF(startkey);</span><br><span class="line">            <span class="comment">//如果cmp大于0，比较成功</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)          </span><br><span class="line">                <span class="comment">//说明索引被人占了</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//小于0说明比较失败</span></span><br><span class="line">                <span class="keyword">goto</span> comparison_error;</span><br><span class="line">            <span class="comment">/* 如果table或者entry改变了，我们必须从头开始 */</span></span><br><span class="line">            <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                <span class="comment">//跳转到restart标签</span></span><br><span class="line">                <span class="keyword">goto</span> restart;</span><br><span class="line">            <span class="comment">//拿到当前的mask</span></span><br><span class="line">            mask = so-&gt;mask;                 <span class="comment">/* help avoid a register spill */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能hash</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="comment">//则设置为freeslot</span></span><br><span class="line">            freeslot = entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果当前索引值加上9小于当前的mask</span></span><br><span class="line">        <span class="comment">//#define LINEAR_PROBES 9</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//循环9次</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; LINEAR_PROBES ; j++) &#123;</span><br><span class="line">                <span class="comment">//每次得到下一个entry</span></span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//如果hash=0，并且对应的key为NULL</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == <span class="number">0</span> &amp;&amp; entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="comment">//跳转到found_unused_or_dummy标签</span></span><br><span class="line">                    <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">                    <span class="comment">//如果hash值相同，获取对应的key</span></span><br><span class="line">                    PyObject *startkey = entry-&gt;key;</span><br><span class="line">                    <span class="comment">//key必须不为dummy态</span></span><br><span class="line">                    assert(startkey != dummy);</span><br><span class="line">                    <span class="comment">//如果两个key相同，跳转到found_active标签</span></span><br><span class="line">                    <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//如果为unicode，还是转化后比较</span></span><br><span class="line">                    <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                        &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                        &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//下面的跟if (i + LINEAR_PROBES &lt;= mask) &#123;上面的是一样的</span></span><br><span class="line">                    table = so-&gt;table;</span><br><span class="line">                    Py_INCREF(startkey);</span><br><span class="line">                    cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                    Py_DECREF(startkey);</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> comparison_error;</span><br><span class="line">                    <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                        <span class="keyword">goto</span> restart;</span><br><span class="line">                    mask = so-&gt;mask;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">                    freeslot = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有找到，说明哈希值冲突，改变规则，重新计算索引值</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        <span class="comment">//按照(i * 5 + 1 + perturb) &amp; mask重新计算</span></span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//获取新索引对应的entry</span></span><br><span class="line">        entry = &amp;so-&gt;table[i];</span><br><span class="line">        <span class="comment">//如果对应的key为NULL，说明重新计算索引之后找到了可以存储的地方</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//跳转到found_unused_or_dummy</span></span><br><span class="line">            <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">        <span class="comment">//否则说明比较倒霉，改变规则重新映射索引依旧冲突</span></span><br><span class="line">        <span class="comment">//那么继续循环，比较key是否一致等等</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//未使用或者dummy，dummy我们是不可以使用的</span></span><br><span class="line">  found_unused_or_dummy:</span><br><span class="line">    <span class="comment">//如果这个freeslot为NULL，说明是可用的</span></span><br><span class="line">    <span class="keyword">if</span> (freeslot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">    <span class="comment">//否则，说明为dummy态，那么我们依旧可以使用，正好废物利用</span></span><br><span class="line">    <span class="comment">//将used数量加一</span></span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    freeslot-&gt;key = key;</span><br><span class="line">    freeslot-&gt;hash = hash;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//发现未使用的</span></span><br><span class="line">  found_unused:</span><br><span class="line">    <span class="comment">//将fill和used个数+1</span></span><br><span class="line">    so-&gt;fill++;</span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">    <span class="comment">//检查active态+dummy的entry个数是否小于mask的3/5</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)so-&gt;fill*<span class="number">5</span> &lt; mask*<span class="number">3</span>)</span><br><span class="line">        <span class="comment">//是的话，表示无需扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则要进行扩容</span></span><br><span class="line">    <span class="comment">//扩容的规则就是如果active态的entry各式各样如果大于50000，那么两倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="keyword">return</span> set_table_resize(so, so-&gt;used&gt;<span class="number">50000</span> ? so-&gt;used*<span class="number">2</span> : so-&gt;used*<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//如果是found_active，表示key重复了</span></span><br><span class="line">  <span class="comment">//直接减少一个引用计数即可</span></span><br><span class="line">  found_active:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//比较失败，同样减少引用计数，返回-1</span></span><br><span class="line">  comparison_error:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下流程就是：</strong></p>
<ul>
<li><code>传入hash值，计算出索引值，通过索引值找到对应的entry</code></li>
<li><code>如果entry-&gt;key=NULL，那么将hash和key存到对应的entry</code></li>
<li><code>如果有key，但是值相同，则不插入，直接减少引入计数。因为不是字典，不存在更新一说</code></li>
<li><code>如果有key，但是值不相同。那么从该索引往后的9个entry(i + 9 &lt;= mask)，如果存在key为NULL的entry，那么设置进去。</code></li>
<li><code>如果以上条件都不满足，那么改变策略重新计算索引值，直到找到一个满足key为NULL的entry</code></li>
<li><code>判断容量问题，如果active态+dummy态的entry个数不小于3/5 * mask，那么扩容，扩容的规则是active态的entry个数是否大于50000，是的话就二倍扩容，否则4倍扩容。</code></li>
</ul>
<h4 id="PySetObject扩容"><a href="#PySetObject扩容" class="headerlink" title="PySetObject扩容"></a>PySetObject扩容</h4><p><strong>我们之前说PySetObject会改变容量，那么它是如何改变的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_table_resize</span><span class="params">(PySetObject *so, Py_ssize_t minused)</span></span><br><span class="line">&#123;	<span class="comment">//显然参数是：PySetObject *指针以及容量大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//三个setentry *指针</span></span><br><span class="line">    setentry *oldtable, *newtable, *entry;</span><br><span class="line">    <span class="comment">//oldmask</span></span><br><span class="line">    Py_ssize_t oldmask = so-&gt;mask;</span><br><span class="line">    <span class="comment">//newmask</span></span><br><span class="line">    <span class="type">size_t</span> newmask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否为其申请过内存</span></span><br><span class="line">    <span class="type">int</span> is_oldtable_malloced;</span><br><span class="line">    <span class="comment">//将PySet_MINSIZE个entry直接copy过来</span></span><br><span class="line">    <span class="comment">//因为你既然要扩容的话，那么肯定是这里面存不下了</span></span><br><span class="line">    setentry small_copy[PySet_MINSIZE];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//minused必须大于等于0</span></span><br><span class="line">    assert(minused &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the smallest table size &gt; minused. */</span></span><br><span class="line">    <span class="comment">/* XXX speed-up with intrinsics */</span></span><br><span class="line">    <span class="comment">//newsize扩大二倍，直到大于minused</span></span><br><span class="line">    <span class="comment">//所以我们刚才说的大于50000，二倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="comment">//实际上是最终的newsize是比二倍或者四倍扩容的结果要大的</span></span><br><span class="line">    <span class="type">size_t</span> newsize = PySet_MINSIZE;</span><br><span class="line">    <span class="keyword">while</span> (newsize &lt;= (<span class="type">size_t</span>)minused) &#123;</span><br><span class="line">        <span class="comment">//newsize最大顶多也就是PY_SSIZE_T_MAX + 1，但是基本不可能存储这么多元素</span></span><br><span class="line">        newsize &lt;&lt;= <span class="number">1</span>; <span class="comment">// The largest possible value is PY_SSIZE_T_MAX + 1.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get space for a new table. */</span></span><br><span class="line">    <span class="comment">//为新的table申请空间</span></span><br><span class="line">    oldtable = so-&gt;table;</span><br><span class="line">    assert(oldtable != <span class="literal">NULL</span>);</span><br><span class="line">    is_oldtable_malloced = oldtable != so-&gt;smalltable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize和PySet_MINSIZE(这里的8)相等</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == PySet_MINSIZE) &#123;</span><br><span class="line">        <span class="comment">/* A large table is shrinking, or we can&#x27;t get any smaller. */</span></span><br><span class="line">        <span class="comment">//拿到smalltable，就是默认初始化8个entry数组的那哥们</span></span><br><span class="line">        newtable = so-&gt;smalltable;</span><br><span class="line">        <span class="comment">//如果oldtable和newtable一样</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == oldtable) &#123;</span><br><span class="line">            <span class="comment">//并且没有dummy态的entry</span></span><br><span class="line">            <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">                <span class="comment">/* No dummies, so no point doing anything. */</span></span><br><span class="line">                <span class="comment">//那么无需做任何事情</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We&#x27;re not going to resize it, but rebuild the</span></span><br><span class="line"><span class="comment">               table anyway to purge old dummy entries.</span></span><br><span class="line"><span class="comment">               Subtle:  This is *necessary* if fill==size,</span></span><br><span class="line"><span class="comment">               as set_lookkey needs at least one virgin slot to</span></span><br><span class="line"><span class="comment">               terminate failing searches.  If fill &lt; size, it&#x27;s</span></span><br><span class="line"><span class="comment">               merely desirable, as dummies slow searches. */</span></span><br><span class="line">            <span class="comment">//否则的话，dummy的个数一定大于0</span></span><br><span class="line">            assert(so-&gt;fill &gt; so-&gt;used);</span><br><span class="line">            <span class="comment">//扔掉dummy态，只把oldtable中active态的拷贝过来</span></span><br><span class="line">            <span class="built_in">memcpy</span>(small_copy, oldtable, <span class="keyword">sizeof</span>(small_copy));</span><br><span class="line">            <span class="comment">//将small_copy重新设置为oldtable</span></span><br><span class="line">            oldtable = small_copy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，肯定大于8，申请newsize个setentry所需要的空间</span></span><br><span class="line">        newtable = PyMem_NEW(setentry, newsize);</span><br><span class="line">        <span class="comment">//如果newtable为NULL，那么申请内存失败，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the set empty, using the new table. */</span></span><br><span class="line">    <span class="comment">//newtable肯定不等于oldtable</span></span><br><span class="line">    assert(newtable != oldtable);</span><br><span class="line">    <span class="comment">//创建一个能融安newsize个entry的空set</span></span><br><span class="line">    <span class="built_in">memset</span>(newtable, <span class="number">0</span>, <span class="keyword">sizeof</span>(setentry) * newsize);</span><br><span class="line">    <span class="comment">//将mask设置为newsize-1</span></span><br><span class="line">    <span class="comment">//将table设置为newtable</span></span><br><span class="line">    so-&gt;mask = newsize - <span class="number">1</span>;</span><br><span class="line">    so-&gt;table = newtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the data over; this is refcount-neutral for active entries;</span></span><br><span class="line"><span class="comment">       dummy entries aren&#x27;t copied over, of course */</span></span><br><span class="line">    <span class="comment">//获取newmask</span></span><br><span class="line">    newmask = (<span class="type">size_t</span>)so-&gt;mask;</span><br><span class="line">    <span class="comment">//将原来旧table的setentry数组里面所有setentry的key和hash值全部设置到新的table里面</span></span><br><span class="line">    <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        so-&gt;fill = so-&gt;used;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span> &amp;&amp; entry-&gt;key != dummy) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果已经为其申请了内存，那么要将其归还给系统堆</span></span><br><span class="line">    <span class="keyword">if</span> (is_oldtable_malloced)</span><br><span class="line">        PyMem_DEL(oldtable);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置元素是通过set_insert_clean设置的</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">set_insert_clean</span><span class="params">(setentry *table, <span class="type">size_t</span> mask, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    <span class="type">size_t</span> perturb = hash;</span><br><span class="line">    <span class="type">size_t</span> i = (<span class="type">size_t</span>)hash &amp; mask; <span class="comment">//计算索引</span></span><br><span class="line">    <span class="type">size_t</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        entry = &amp;table[i];  <span class="comment">//获取当前entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> found_null; <span class="comment">//如果为空则跳转found_null设置key与hash</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//如果没有还是老规矩，遍历之后的9个entry</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LINEAR_PROBES; j++) &#123;</span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//找到空的entry，那么跳转到found_null设置key与hash</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> found_null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到，那么改变规则，重新计算索引</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">  found_null:</span><br><span class="line">    <span class="comment">//设置key与hash</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_remove</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *tmpkey;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将该值设置为dummy态</span></span><br><span class="line">    rv = set_discard_key(so, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//类型检测</span></span><br><span class="line">        <span class="keyword">if</span> (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="comment">//对该值重新初始化为frozenset</span></span><br><span class="line">        tmpkey = make_new_set(&amp;PyFrozenSet_Type, key);</span><br><span class="line">        <span class="keyword">if</span> (tmpkey == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将该key设置为空</span></span><br><span class="line">        rv = set_discard_key(so, tmpkey);</span><br><span class="line">        Py_DECREF(tmpkey);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果没有找到则报错</span></span><br><span class="line">    <span class="keyword">if</span> (rv == DISCARD_NOTFOUND) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面调用了set_discard_key方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//老套路，先计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将hash值也船进入</span></span><br><span class="line">    <span class="keyword">return</span> set_discard_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">////通过传入的key和hash找到该entry</span></span><br><span class="line">    <span class="comment">//并且hash对应的key要和传入的key是一样的</span></span><br><span class="line">    entry = set_lookkey(so, key, hash);  </span><br><span class="line">    <span class="comment">//如果entry为NULL，直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果entry不为NULL，但是对应的key为NULL</span></span><br><span class="line">    <span class="comment">//返回DISCARD_NOTFOUND</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> DISCARD_NOTFOUND;</span><br><span class="line">    <span class="comment">//获取要删除的key</span></span><br><span class="line">    old_key = entry-&gt;key;</span><br><span class="line">    <span class="comment">//并将entry的key设置为dummy</span></span><br><span class="line">    entry-&gt;key = dummy;</span><br><span class="line">    <span class="comment">//hash值设置为-1</span></span><br><span class="line">    entry-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//减少使用数量</span></span><br><span class="line">    so-&gt;used--;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    <span class="comment">//返回DISCARD_FOUND</span></span><br><span class="line">    <span class="keyword">return</span> DISCARD_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到集合添加、删除元素和字典是有些相似的，毕竟底层都是使用了hash表嘛。</strong></p>
<h4 id="集合的运算-交集"><a href="#集合的运算-交集" class="headerlink" title="集合的运算(交集)"></a>集合的运算(交集)</h4><p><strong>在python中使用集合的时候，可以取两个集合的交集、并集、差集、对称差集等等，这里介绍一下交集，其余的可以自行看源码研究<code>(Objects/setobject.c)</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_intersection</span><span class="params">(PySetObject *so, PyObject *other)</span></span><br><span class="line">&#123;	    </span><br><span class="line">    <span class="comment">//result，显然是用来存储两者交集运算的结果的</span></span><br><span class="line">    PySetObject *result;</span><br><span class="line">    <span class="comment">//不看下面代码的话，很难知道这几个PyObject * 是用来干啥的</span></span><br><span class="line">    <span class="comment">//我们下面代码再看看这是干啥的</span></span><br><span class="line">    PyObject *key, *it, *tmp;</span><br><span class="line">    <span class="comment">//这个肯定是hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果两个对象一样</span></span><br><span class="line">    <span class="keyword">if</span> ((PyObject *)so == other)</span><br><span class="line">        <span class="comment">//直接返回其中一个的拷贝即可</span></span><br><span class="line">        <span class="keyword">return</span> set_copy(so);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这行代码表示创建一个空的PySetObject *</span></span><br><span class="line">    result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果result == NULL，说明创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测other是不是PySetObject *</span></span><br><span class="line">    <span class="keyword">if</span> (PyAnySet_Check(other)) &#123;</span><br><span class="line">        <span class="comment">//初始索引为0</span></span><br><span class="line">        Py_ssize_t pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//setentry *</span></span><br><span class="line">        setentry *entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果other元素的个数大于so</span></span><br><span class="line">        <span class="keyword">if</span> (PySet_GET_SIZE(other) &gt; PySet_GET_SIZE(so)) &#123;</span><br><span class="line">            <span class="comment">//就把so和other进行交换</span></span><br><span class="line">            tmp = (PyObject *)so;</span><br><span class="line">            so = (PySetObject *)other;</span><br><span class="line">            other = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从少的那一方的开头开始便利</span></span><br><span class="line">        <span class="keyword">while</span> (set_next((PySetObject *)other, &amp;pos, &amp;entry)) &#123;</span><br><span class="line">            <span class="comment">//拿到key和hash</span></span><br><span class="line">            key = entry-&gt;key;</span><br><span class="line">            hash = entry-&gt;hash;</span><br><span class="line">            <span class="comment">//传入other的key和hash，在so中去找</span></span><br><span class="line">            rv = set_contains_entry(so, key, hash);</span><br><span class="line">            <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果对应的rv不存在，那么显然就没有</span></span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">                <span class="comment">//存在的话设置进result里面</span></span><br><span class="line">                <span class="keyword">if</span> (set_add_entry(result, key, hash)) &#123;</span><br><span class="line">                    Py_DECREF(result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果不是PyObject *</span></span><br><span class="line">    <span class="comment">//那么获取其对应的迭代器，相当于python中的__iter__</span></span><br><span class="line">    it = PyObject_GetIter(other);</span><br><span class="line">    <span class="comment">//如果是NULL，降低其引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="comment">//返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面的没必要分析了，在python中，只能set和set(或者frozenset)之间才可以取交集</span></span><br><span class="line">    <span class="keyword">while</span> ((key = PyIter_Next(it)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        rv = set_contains_entry(so, key, hash);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set_add_entry(result, key, hash))</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">  error:</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    Py_DECREF(result);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合小结"><a href="#集合小结" class="headerlink" title="集合小结"></a>集合小结</h4><p><strong>可以看到，剖析集合的时候话很少。主要是有了剖析字典的经验，因此再剖析集合的时候就很简单了。并且在Python中还有一个frozenset，就是不可变的集合。但是不像列表和元组，元组还是有很多特殊的，并不单单只是不可变的列表，从具有自己独自的结构体就能看出来。而frozenset对象和set对象都是一个结构体，只有一个PySetObject，没有PyFrozenSetObject。我们在看PySetObject的时候，发现里面有一个hash成员，如果是frozenset的话，那么hash值是不为-1的，因为它不可以添加、删除元素，是不可变对象。由于比较相似，因此frozenset就不再说了，可以自己源码中研究，位置还是<code>Object/setobject.c</code>。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>14-函数在底层的数据结构以及创建方式</title>
    <url>/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="14-函数在底层的数据结构、以及它的创建方式"><a href="#14-函数在底层的数据结构、以及它的创建方式" class="headerlink" title="14-函数在底层的数据结构、以及它的创建方式"></a>14-函数在底层的数据结构、以及它的创建方式</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>函数是任何一门编程语言都具备的基本元素，它可以将多个动作组合起来，一个函数代表了一系列的动作。当然我们之前说函数也是一个变量，该变量指向一个函数。而且在调用函数时会干什么来着，没错，要在运行时栈中创建栈帧，用于函数的执行。</strong></p>
<p><strong>那么下面就来看看函数在C中是如何实现的，生得一副什么模样。</strong></p>
<h3 id="PyFunctionObject对象"><a href="#PyFunctionObject对象" class="headerlink" title="PyFunctionObject对象"></a>PyFunctionObject对象</h3><p><strong>我们说过Python中一切皆对象，函数也不例外。在Python中，函数这种抽象机制是通过<code>PyFunctionObject</code>对象实现的，位于 *Include&#x2F;funcobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD               <span class="comment">/* 头部信息, 不用多说 */</span></span><br><span class="line">    PyObject *func_code;        <span class="comment">/* 函数的PyCodeObject对象, 因为函数就是根据该PyCodeObject对象创建的 */</span></span><br><span class="line">    PyObject *func_globals;     <span class="comment">/* 函数的global名字空间 */</span></span><br><span class="line">    PyObject *func_defaults;    <span class="comment">/* 函数参数的默认值, 一个元组或者空 */</span></span><br><span class="line">    PyObject *func_kwdefaults;  <span class="comment">/* 只能通过关键字参数传递的&quot;参数&quot;和&quot;该参数的默认值&quot;, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_closure;     <span class="comment">/* 获取闭包对象 */</span></span><br><span class="line">    PyObject *func_doc;         <span class="comment">/* 函数的doc */</span></span><br><span class="line">    PyObject *func_name;        <span class="comment">/* 函数名 */</span></span><br><span class="line">    PyObject *func_dict;        <span class="comment">/* 属性字典, 一般为空 */</span></span><br><span class="line">    PyObject *func_weakreflist; <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">    PyObject *func_module;      <span class="comment">/* 函数所在的模块 */</span></span><br><span class="line">    PyObject *func_annotations; <span class="comment">/* 函数参数的注解, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_qualname;    <span class="comment">/* 函数的全限定名, 我们后面会说它和func_name之间的区别 */</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant:</span></span><br><span class="line"><span class="comment">     *     func_closure contains the bindings for func_code-&gt;co_freevars, so</span></span><br><span class="line"><span class="comment">     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</span></span><br><span class="line"><span class="comment">     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyFunctionObject;</span><br></pre></td></tr></table></figure>

<p><strong>PyFunctionObject的这些成员都是以func开头的，比如：func_name，但是我们在Python中获取的时候直接通过__name__获取即可。</strong></p>
<p><strong>func_code：函数的字节码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = foo.__code__</span><br><span class="line"><span class="built_in">print</span>(code)  <span class="comment"># &lt;code object foo at 0x000001D250B9D3A0, file &quot;C:/Users/satori/Desktop/三无少女/2.py&quot;, line 1&gt;</span></span><br><span class="line"><span class="built_in">print</span>(code.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>func_globals：global命名空间</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="comment"># __globals__其实就是外部的global名字空间</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__)  <span class="comment"># &#123;......, &#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__ == <span class="built_in">globals</span>())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>func_defaults：函数参数的默认值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是默认值</span></span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)  <span class="comment"># (&#x27;夏色祭&#x27;, -1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(): </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有默认值的话, __defaults__为None</span></span><br><span class="line"><span class="built_in">print</span>(bar.__defaults__)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>func_kwdefaults：只能通过关键字参数传递的”参数”和”该参数的默认值”</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印是为None的, 这是因为虽然有默认值, 但是它并不要求必须通过关键字的方式传递</span></span><br><span class="line"><span class="built_in">print</span>(foo.__kwdefaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在前面加上一个*, 表示后面的参数就必须通过关键字的方式传递</span></span><br><span class="line"><span class="comment"># 因为如果不通过关键字的话, 那么无论多少个位置参数都会被*给吸收掉, 无论如何也不可能传递给name、age</span></span><br><span class="line"><span class="comment"># 我们经常会看到*args, 这是因为我们需要函数调用时传递过来的值, 所以可以通过args以元组的形式来拿到这些值</span></span><br><span class="line"><span class="comment"># 但是这里我们不需要, 我们只是希望后面的参数必须通过关键字参数传递, 因此前面写一个*即可</span></span><br><span class="line"><span class="comment"># 当然写*args或者其他的也可以, 但是我们用不到, 所以写一个*即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">*, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时就打印了默认值，因为这是只能通过kw(关键字)传递的参数的默认值</span></span><br><span class="line"><span class="built_in">print</span>(bar.__kwdefaults__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;satori&#x27;, &#x27;age&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_closure：闭包对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="keyword">nonlocal</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看的是闭包里面nonlocal的值</span></span><br><span class="line"><span class="comment"># 这里有两个nonlocal，所以foo().__closure__是一个有两个元素的元组</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__)  <span class="comment"># (&lt;cell at 0x000001FD1D3B02B0: int object at 0x00007FFDE559D660&gt;,</span></span><br><span class="line">                          <span class="comment"># &lt;cell at 0x000001FD1D42E310: str object at 0x000001FD1D3DA090&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">1</span>].cell_contents)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：查看闭包属性我们使用的是内层函数，不是外层的foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_doc：函数的文档</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span>, age is <span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__doc__)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_name：函数名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_dict：属性字典</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般函数的属性字典都会空，属性字典基本上在类里面使用</span></span><br><span class="line"><span class="built_in">print</span>(foo.__dict__)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_weakreflist：弱引用列表</strong></p>
<p><strong>Python无法获取这个属性，底层没有提供相应的接口。</strong></p>
<p><strong>func_module：函数所在的模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__module__)  <span class="comment"># __main__</span></span><br></pre></td></tr></table></figure>

<p><strong>func_annotations：注解</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name: <span class="built_in">str</span>, age: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.5的时候新增的语法</span></span><br><span class="line"><span class="built_in">print</span>(foo.__annotations__)  <span class="comment"># &#123;&#x27;name&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;age&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_qualname：全限定名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__, foo.__qualname__)  <span class="comment"># foo foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.foo.__name__, A.foo.__qualname__)  <span class="comment"># foo A.foo</span></span><br></pre></td></tr></table></figure>

<p><strong>在PyFunctionObject的定义中，我们看到一个func_code成员，指向了一个PyCodeObject对象，我们说函数就是根据这个PyCodeObject对象创建的。因为我们知道一个PyCodeObject对象是对一段代码的静态表示，Python编译器在将源代码进行编译之后，对里面的每一个代码块<code>(code block)</code>都会生成一个、并且是唯一一个PyCodeObject对象，这个PyCodeObject对象中包含了这个代码块中的一些静态信息，也就是可以从源代码中看到的信息。</strong></p>
<blockquote>
<p><strong>比如：某个函数对应的code block中有一个 name &#x3D; “夏色祭” 这样的表达式，那么符号”a”和对应的值1、以及它们之间的联系就是静态信息。这些信息会被静态存储起来，符号”a”会被存在符号表<code>co_varnames</code>中、值1会被存在常量池<code>co_consts</code>中、这两者之间是一个赋值，因此会有两条指令LOAD_CONSTS和STORE_FAST存在字节码指令序列<code>co_code</code>中。</strong></p>
<p><strong>这些信息是编译的时候就可以得到的，因此PyCodeObject对象是编译时候的结果。</strong></p>
</blockquote>
<p><strong>但是PyFunctionObject对象是何时产生的呢？实际上PyFunctionObject对象是Python代码在运行时动态产生的，更准确的说，是在执行一个def语句的时候创建的。</strong></p>
<blockquote>
<p><strong>当Python虚拟机在当前栈帧中执行字节码时发现了def语句，那么就代表发现了新的PyCodeObject对象，因为它们是可以层层嵌套的。所以虚拟机会根据这个PyCodeObject对象创建对应的PyFunctionObject对象，然后将函数名和函数体对应的PyFunctionObject对象组成键值对放在当前的local空间中。</strong></p>
<p><strong>显然在PyFunctionObject对象中，也会包含这些函数的静态信息，这些信息存储在func_code中，实际上，func_code一定会指向与函数对应的PyCodeObject对象。除此之外，PyFunctionObject对象中还包含了一些函数在执行时所必须的动态信息，即上下文信息。比如func_globals，就是函数在执行时关联的global作用域(globals)，说白了就是让你在局部变量找不到的时候能够找全局变量，可如果连global空间都没有的话，那即便想找也无从下手呀。而global作用域中的符号和值必须在运行时才能确定，所以这部分必须在运行时动态创建，无法存储在PyCodeObject中，所以要根据PyCodeObject对象创建PyFunctionObject对象，相当于一个封装。总之一切的目的，都是为了更好的执行字节码。</strong></p>
</blockquote>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先虚拟机从上到下执行字节码</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pia, 出现了一个def</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么知道源代码进入了一个新的作用域了, 这里遇到一个新的PyCodeObject对象了</span></span><br><span class="line"><span class="comment"># 而通过def知道这是一个函数, 所以会进行封装, 将PyCodeObject对象封装成PyFunctionObject</span></span><br><span class="line"><span class="comment"># 所以当执行完def语句之后, 一个函数就被创建了, 放在当前的local空间中, 当然对于模块来说: local空间也是global空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;......, &#x27;foo&#x27;: &lt;function foo at 0x000001B299FAF3A0&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的类型是&lt;class &#x27;function&#x27;&gt;, 当然这个类Python没有暴露给我们</span></span><br><span class="line"><span class="comment"># 当我们调用函数foo的时候, 会从local空间中取出符号&quot;foo&quot;对应的PyFunctionObject对象</span></span><br><span class="line"><span class="comment"># 然后根据这个PyFunctionObject对象创建PyFrameObject对象, 也就是为函数创建一个栈帧</span></span><br><span class="line"><span class="comment"># 然后将执行权交给新创建的栈帧, 在新创建的栈帧中执行字节码</span></span><br></pre></td></tr></table></figure>

<h4 id="PyFrameObject和PyFunctionObject对象的区别与联系"><a href="#PyFrameObject和PyFunctionObject对象的区别与联系" class="headerlink" title="PyFrameObject和PyFunctionObject对象的区别与联系"></a>PyFrameObject和PyFunctionObject对象的区别与联系</h4><p><code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器内部用于实现函数调用和执行的两个重要数据结构。它们之间有以下区别和联系：</p>
<ol>
<li>区别：</li>
</ol>
<ul>
<li><code>PyFrameObject</code>表示Python解释器的执行栈帧，包含了函数调用时的局部变量、参数、返回值等信息。每当Python解释器执行一个函数时，就会在执行栈上创建一个新的<code>PyFrameObject</code>，并将该栈帧推入执行栈中。当函数执行完毕时，该栈帧将被弹出执行栈。</li>
<li><code>PyFunctionObject</code>表示Python中的函数对象，包含了函数的代码、参数、默认值等信息。每当Python解释器遇到一个函数定义时，就会创建一个新的<code>PyFunctionObject</code>对象，并将其保存在内存中。在函数调用时，Python解释器会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上，从而完成函数调用。</li>
</ul>
<ol>
<li>联系：</li>
</ol>
<p><code>PyFrameObject</code>和<code>PyFunctionObject</code>之间存在密切的联系，因为它们一起实现了Python解释器中的函数调用和执行过程。具体来说，当Python解释器执行一个函数时，它会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上。在函数执行过程中，<code>PyFrameObject</code>对象将存储函数的局部变量、参数和返回值等信息，并通过Python解释器的执行栈来管理函数调用的层次关系。当函数执行完毕时，Python解释器会弹出执行栈，并将<code>PyFrameObject</code>对象从内存中释放掉。</p>
<p>总的来说，<code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器中实现函数调用和执行的两个重要数据结构。<code>PyFrameObject</code>用于存储函数调用时的局部变量、参数和返回值等信息，而<code>PyFunctionObject</code>用于存储函数的代码、参数和默认值等信息。它们之间紧密地协作，以实现Python函数的调用和执行过程。</p>
<h3 id="函数对象如何创建"><a href="#函数对象如何创建" class="headerlink" title="函数对象如何创建"></a>函数对象如何创建</h3><p><strong>我们现在已经看清了函数的模样，它在底层对应PyFunctionObject对象，并且它和PyCodeObject对象关系密切。那么Python底层又是如何完成PyCodeObject对象到PyFunctionObject对象之间的转变呢？想了解这其中的奥秘，就必须要从字节码入手。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然这个代码中出现了两个PyCodeObject对象，一个对应整个py文件，另一个则是对应函数foo。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把字符串当成是一个py文件来进行编译</span></span><br><span class="line">co = <span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  </span><br><span class="line"><span class="comment"># (&#x27;夏色祭&#x27;, &lt;code object foo at 0x00000183F9101450, file &quot;func&quot;, line 3&gt;, &#x27;foo&#x27;, 1, 2, None)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_name)  <span class="comment"># &lt;module&gt;</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts[<span class="number">1</span>].co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，”函数foo对应的PyCodeObject对象”是”py文件对应的PyCodeObject对象”的常量池co_consts中的一个元素。因为在对py文件创建PyCodeObject对象的时候，发现了一个函数代码块foo，那么会对函数代码块foo继续创建一个PyCodeObject对象(每一个代码块都会对应一个PyCodeObject对象)，而函数foo对应的PyCodeObject对象则是py文件对应的PyCodeObject对象的co_consts常量池当中的一个元素。</strong></p>
<blockquote>
<p><strong>通过以上例子，我们发现PyCodeObject对象是嵌套的。之前我们我们说过，每一个code block<code>(函数、类等等)</code>都会对应一个PyCodeObject对象。现在我们又看到了，根据层级来分的话，”内层代码块对应的PyCodeObject对象”是”最近的外层代码块对应的PyCodeObject对象”的常量池co_consts中的一个元素。而最外层则是模块对应的PyCodeObject对象，因此这就意味着我们通过最外层的PyCodeObject对象可以找到所有的PyCodeObject对象，显然这是毋庸置疑的。而这里和栈帧也是对应的，栈帧我们说过也是层层嵌套的，而内层栈帧通过f_back可以找到外层、也就是调用者对应的栈帧，当然这里我们之前的章节已经说过了，这里再提一遍。</strong></p>
</blockquote>
<p><strong>这里再来重新看一下上面的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然dis模块自动帮我们分成了两部分，上面是模块的字节码，下面是函数的字节码。首先函数很简单我们就不看了，直接看模块的。</strong></p>
<p><strong>首先开头的LOAD_CONST和STORE_NAME显然是 name &#x3D; “夏色祭” 对应的指令。然后我们看<code>4 LOAD_CONST</code>，这条指令也是加载了一个常量，但这个常量是一个PyCodeObject对象；<code>6 LOAD_CONST</code>则是将字符串常量”foo”、即函数名加载了进来，然后通过MAKE_FUNCTION指令构建一个PyFunctionObject对象；然后<code>10 STORE_NAME</code>，让符号foo指向这个PyFunctionObject对象。再下面就是函数调用了，函数调用的具体细节我们之后会详细说。</strong></p>
<p><strong>并且我们还看到一个有趣的现象，那就是源代码的行号。我们发现之前看到源代码的行号都是从上往下、依次增大的，这很好理解，毕竟一条一条解释嘛。但是这里却发生了变化，先执行了第6行，之后再执行第4行。如果是从Python层面的函数调用来理解的话，很容易一句话就解释了，因为函数只有在调用的时候才会执行。但是从字节码的角度来理解的话，我们发现函数的声明和实现是分离的，是在不同的PyCodeObject对象中。确实如此，虽然一个函数名和函数体是一个整体，但是Python虚拟机在实现这个函数的时候，却在物理上将它们分离开了，构建函数的字节码指令序列必须在模块对应的PyCodeObject对象中。</strong></p>
<blockquote>
<p><strong>我们之前说过，函数即变量。我们是可以把函数当成是普通的变量来处理的，函数名就相当于变量名，函数体就相当于是变量指向的值。而foo函数显然是在全局中定义的一个函数，那么foo是不是要出现在py文件对应的PyCodeObject对象的符号表co_names里面呢？foo对应的PyCodeObject对象是不是要出现在py文件对应的PyCodeObject对象的常量池co_consts里面呢？</strong></p>
</blockquote>
<p><strong>至此，函数的结构就已经非常清晰了。</strong></p>
<p><img src="/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/1229382-20200822015055004-867736003.png" alt="img"></p>
<p><strong>所以函数名和函数体是分离的，它们存在不同的PyCodeObject对象当中。分析完结构之后，我们的重点就在于那个MAKE_FUNCTION指令了，我们说当遇到<code>def foo(a, b)</code>的时候，在语法上将这是函数的声明语句，但是从虚拟机的角度来看这其实是函数对象的创建语句。所以下面我们就要分析一下这个指令，看看它到底是怎么将一个PyCodeObject对象变成一个PyFunctionObject对象的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(MAKE_FUNCTION)</span>: &#123;</span><br><span class="line">    PyObject *qualname = POP(); <span class="comment">//弹出符号表中的函数名</span></span><br><span class="line">    PyObject *codeobj = POP();  <span class="comment">//弹出对应的字节码对象</span></span><br><span class="line">    <span class="comment">//创建PyFunctionObject对象, 接收三个参数, 首先第一个参数和第三个参数很好理解, 但重点是第二个参数</span></span><br><span class="line">    <span class="comment">//首先f指的就是当前所在的栈帧, 对于我们目前这个里而言就是模块、或者py文件对应的栈帧</span></span><br><span class="line">    <span class="comment">//然后将f_globals、也就是global名字空间传递了进去, 所以我们现在明白了为什么函数可以调用__globals__了</span></span><br><span class="line">    <span class="comment">//当然也明白为什么函数可以在局部变量找不到的时候去找全局变量了</span></span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//下面是设置闭包、注解、参数默认值等属性</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//将函数或者说函数对象压入运行时栈</span></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在MAKE FUNCTION之前，先进行了LOAD  CONST，显然是将foo对应的字节码对象和符号foo压入到了栈中。所以在执行MAKE  FUNCTION的时候，首先就是将这个字节码对象以及对应符号弹出栈，然后再加上当前PyFrameObject对象中维护的global名字空间f_globals对象，三者作为参数传入PyFunction_NewWithQualName函数中，从而构建出相应的PyFunctionObject对象。</strong></p>
<p><strong>下面我们来看看PyFunction_NewWithQualName是如何构造出一个函数的，它位于 *Objects&#x2F;funcobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFunction_NewWithQualName</span><span class="params">(PyObject *code, PyObject *globals, PyObject *qualname)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//要返回的PyFunctionObject *, 这里先声明一下</span></span><br><span class="line">    PyFunctionObject *op;</span><br><span class="line">    <span class="comment">//函数的doc、PyCodeObject的co_consts、函数所在的模块</span></span><br><span class="line">    PyObject *doc, *consts, *module;</span><br><span class="line">    <span class="type">static</span> PyObject *__name__ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        __name__ = PyUnicode_InternFromString(<span class="string">&quot;__name__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyObject_GC_New为函数对象申请空间</span></span><br><span class="line">    op = PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面就是设置PyFunctionObject对象的成员属性了</span></span><br><span class="line">    op-&gt;func_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(code);</span><br><span class="line">    op-&gt;func_code = code;</span><br><span class="line">    Py_INCREF(globals);</span><br><span class="line">    op-&gt;func_globals = globals;</span><br><span class="line">    op-&gt;func_name = ((PyCodeObject *)code)-&gt;co_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_name);</span><br><span class="line">    op-&gt;func_defaults = <span class="literal">NULL</span>; <span class="comment">/* No default arguments */</span></span><br><span class="line">    op-&gt;func_kwdefaults = <span class="literal">NULL</span>; <span class="comment">/* No keyword only defaults */</span></span><br><span class="line">    op-&gt;func_closure = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;vectorcall = _PyFunction_Vectorcall;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyCodeObject对象获取常量池</span></span><br><span class="line">    consts = ((PyCodeObject *)code)-&gt;co_consts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们知道函数的doc其实就是一个字符串, 显然它也是常量池的一个常量, 并且是常量池的第一个元素</span></span><br><span class="line">    <span class="comment">//否则的话它就是不能成为doc</span></span><br><span class="line">    <span class="keyword">if</span> (PyTuple_Size(consts) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//所以如果consts&gt;=1, 并且第一个元素是字符串, 那么它就是函数的doc</span></span><br><span class="line">        doc = PyTuple_GetItem(consts, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!PyUnicode_Check(doc))</span><br><span class="line">            doc = Py_None;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则doc就是None</span></span><br><span class="line">        doc = Py_None;</span><br><span class="line">    Py_INCREF(doc);</span><br><span class="line">    <span class="comment">//下面也是设置PyFunctionObject对象的成员</span></span><br><span class="line">    op-&gt;func_doc = doc;</span><br><span class="line"></span><br><span class="line">    op-&gt;func_dict = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_module = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_annotations = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __module__: If module name is in globals, use it.</span></span><br><span class="line"><span class="comment">       Otherwise, use None. */</span></span><br><span class="line">    module = PyDict_GetItemWithError(globals, __name__);</span><br><span class="line">    <span class="keyword">if</span> (module) &#123;</span><br><span class="line">        Py_INCREF(module);</span><br><span class="line">        op-&gt;func_module = module;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qualname)</span><br><span class="line">        op-&gt;func_qualname = qualname;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op-&gt;func_qualname = op-&gt;func_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_qualname);</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以通过MAKE_FUNCTION我们便创建了PyFunctionObject对象，然后它会被压入栈中，再通过STORE_NAME将符号foo和PyFunctionObject对象组成一个entry，存储在当前栈帧的local名字空间中，当然也是global名字空间。只不过为了和函数保持统一，我们都说成local名字空间，只不过不同的作用域对应的local空间是不一样的。</strong></p>
<p><strong>当然了我们说函数对象的类型是<code>&lt;class &#39;function&#39;&gt;</code>，但是这个类底层没有暴露给我们，但是我们依旧可以通过曲线救国的方式进行获取。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="comment"># lambda匿名函数的类型也是&lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="keyword">lambda</span>: <span class="literal">None</span>))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们可以仿照底层的思路，通过<code>&lt;class &#39;function&#39;&gt;</code>来创建一个函数对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到PyCodeObject对象</span></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="comment"># 根据class function创建函数对象, 接收三个参数: PyCodeObject对象、名字空间、函数名</span></span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, <span class="built_in">globals</span>(), <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f.__name__)  <span class="comment"># 根据f创建的new_f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>是不是很神奇呢？另外我们说函数在访问gender指向的对象时，显然先从自身的符号表中找，如果没有那么回去找全局变量。这是因为，我们在创建函数的时候将global名字空间传进去了，如果我们不传递呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f = <span class="built_in">type</span>(f)(code, <span class="literal">None</span>, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function() argument &#x27;globals&#x27; must be dict, not None</span></span><br><span class="line"><span class="comment"># 这里告诉我们function的第二个参数globals必须是一个字典</span></span><br><span class="line"><span class="comment"># 我们传递一个空字典</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f1.__name__)  <span class="comment"># 根据f创建的new_f1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(new_f1(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;gender&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到告诉我们gender没有定义</span></span><br></pre></td></tr></table></figure>

<p><strong>因此现在我们又在Python的角度上理解了一遍，为什么Python中的函数能够在局部变量找不到的时候，去找全局变量，原因就在于构建函数的时候，将global名字空间交给了函数。使得函数可以在global空间进行变量查找，所以它才能够找到全局变量。而我们这里给了一个空字典，那么显然就找不到gender这个变量了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;萌妹子&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以手动传递一个字典进去, 此时我们传递的字典对于函数来说就是global名字空间</span></span><br><span class="line"><span class="comment"># 所以在函数内部找不到某个变量的时候, 就会去我们指定的名字空间中找</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: 萌妹子</span></span><br><span class="line"><span class="comment"># 所以此时的gender不再是外部的&quot;female&quot;, 而是我们指定的&quot;萌妹子&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此外我们还可以为函数指定默认值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须接收一个PyTupleObject对象</span></span><br><span class="line">new_f.__defaults__ = (<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"><span class="comment"># 即使我们不传递参数, 也是完全可以的, 因为已经有默认值了</span></span><br><span class="line"><span class="built_in">print</span>(new_f())  <span class="comment"># name: 神乐mea, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以指定部分默认参数</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"><span class="comment"># 这里的在设置默认值的时候是从后往前设置的, 比如: (&quot;神乐mea&quot;, 38)</span></span><br><span class="line"><span class="comment"># 是将38设置为age的默认值, &quot;神乐mea&quot;设置为name的默认值</span></span><br><span class="line"><span class="comment"># 所以这里的(38,) , 会将38设置为age的默认值, 不是name</span></span><br><span class="line"><span class="comment"># 那name怎么办? 如果没有对应的默认值了, 那么它就必须在函数调用的时候由我们显式的传递</span></span><br><span class="line">new_f1.__defaults__ = (<span class="number">38</span>,)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f1()</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># f() missing 1 required positional argument: &#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_f1(<span class="string">&quot;神楽めあ&quot;</span>))  <span class="comment"># name: 神楽めあ, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">但是问题来了, 为什么在设置默认值的时候要从后往前呢?</span></span><br><span class="line"><span class="string">首先如果默认值的个数和参数的个数正好匹配, 那么相安无事, 如果不匹配那么只能是默认值的个数小于参数个数</span></span><br><span class="line"><span class="string">如果是从后往前, 那么(38,)就意味着38设置为age的默认值, name就必须由我们在调用的时候传递</span></span><br><span class="line"><span class="string">但如果是从前往后, 那么(38,)就意味着38设置为name的默认值, age就必须由我们在调用的时候来传递</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是问题来了, 如果38设置为name的默认值, 这会是什么情况? 显然等价于:</span></span><br><span class="line"><span class="string">def new_f1(name=38, age):</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">你认为这样的函数能够通过编译吗?显然是不行的, 因为默认参数必须在非默认参数的后面</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 所以Python的这个做法是完全正确的, 必须要从后往前进行设置</span></span><br></pre></td></tr></table></figure>

<p><strong>当然，这种设置默认值的方式显然也可以使用于通过def定义的函数，因为我们上面的new_f、new_f1和f都是<code>&lt;class &#39;function&#39;&gt;</code>对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认值</span></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你用的是pycharm, 那么会在f()这个位置给你做上标记, 提示你参数没有传递</span></span><br><span class="line"><span class="comment"># 但我们知道由于使用__defaults__已经设置了默认值, 所以这里是不会报错的, 只不过pycharm没有检测到, 当然基本上所有的ide都无法做到这一点</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>另外我们说，默认值的个数一定要小于等于参数的个数，但如果大于呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>, <span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 神乐mea, age: 38, gender: female</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依旧从后往前, 38给age、&quot;神乐mea&quot;给name</span></span><br><span class="line"><span class="comment"># 参数都有默认值了, 那么就结束了</span></span><br><span class="line"><span class="comment"># 当然如果是__defaults__指向的元组先结束, 那么没有得到默认值的参数就必须由我们来传递了</span></span><br></pre></td></tr></table></figure>

<p>​        *<em>想不到Python中的函数可以玩出这么多新花样，现在你是不是对函数有了一个更深刻的认识了呢？当然目前介绍的只是函数的一小部分内容，还有函数如何调用、位置参数和关键字参数如何解析、对于有默认值的参数如何在我们不传递的时候使用默认值以及在我们传递的时候使用我们传递的值、*args和*<em>kwargs又如何解析、闭包怎么做到的、还有装饰器等等等等，这些我们接下来会单独用几篇博客详细说。</em></em>    </p>
<p>​        <strong>因为放在一篇博客里面的话，字数至少要好几万，而我使用的Markdown编辑器typora在字数达到一万五的时候就会出现明显卡顿，要是一下子都写完的话，绝对卡到爆，而且越往后越卡，这对我而言也是个痛苦。而且函数的内容也比较多，我们就多用一些篇幅去介绍它吧。</strong>    </p>
<h3 id="判断函数都有哪些参数"><a href="#判断函数都有哪些参数" class="headerlink" title="判断函数都有哪些参数"></a>判断函数都有哪些参数</h3><p><strong>最后我们再来看看我们如何检测一个函数有哪些参数，首先函数的局部变量<code>(包括参数)</code>在编译是就已经确定，会存在符号表co_varnames中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意: 在定义函数的时候*和**最多只能出现一次</span></span><br><span class="line"><span class="comment"># 显然a和b必须通过位置参数传递</span></span><br><span class="line"><span class="comment"># c和d可以通过位置参数或者关键字参数传递</span></span><br><span class="line"><span class="comment"># e和f必须通过关键字参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *args, e, f, **kwargs</span>):</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    h = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">varnames = f.__code__.co_varnames</span><br><span class="line"><span class="built_in">print</span>(varnames)</span><br><span class="line"><span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;args&#x27;, &#x27;kwargs&#x27;, &#x27;g&#x27;, &#x27;h&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先co_varnames打印的符号表是有顺序的, 参数永远在函数内部定义的局部变量的前面</span></span><br><span class="line"><span class="string">g和h就是函数内部定义的局部变量, 所以它在所有的后面</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果是参数的话, 那么*和**会位于最后面, 其它参数位置不变, 所以除了g和h, 最后面的就是args和kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 我们就可以进行判断了</span></span><br><span class="line"><span class="comment"># 1. 寻找必须通过位置参数传递的参数</span></span><br><span class="line">posonlyargcount = f.__code__.co_posonlyargcount</span><br><span class="line"><span class="built_in">print</span>(posonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: posonlyargcount])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 寻找可以通过位置参数传递或者关键字参数传递的参数</span></span><br><span class="line">argcount = f.__code__.co_argcount</span><br><span class="line"><span class="built_in">print</span>(argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: <span class="number">4</span>])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(varnames[posonlyargcount: <span class="number">4</span>])  <span class="comment"># (&#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 寻找必须通过关键字参数传递的参数</span></span><br><span class="line">kwonlyargcount = f.__code__.co_kwonlyargcount</span><br><span class="line"><span class="built_in">print</span>(kwonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[argcount: argcount + kwonlyargcount])  <span class="comment"># (&#x27;e&#x27;, &#x27;f&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 寻找*args和**kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在介绍PyCodeObject对象的时候, 我们说里面有一个co_flags成员</span></span><br><span class="line"><span class="string">它是专门用来判断参数中是否有*args和**kwargs的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flags = f.__code__.co_flags</span><br><span class="line"><span class="comment"># 如果flags和4进行按位与之后为真, 那么就代表有*args, 否则没有</span></span><br><span class="line"><span class="comment"># 如果flags和8进行按位与之后为真, 那么就代表有**kwargs, 否则没有</span></span><br><span class="line">step = argcount + kwonlyargcount</span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x04</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># args</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x08</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># kwargs</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 虽然我们这里打印的是args和kwargs, 但主要取决定义的时候使用的名字</span></span><br><span class="line"><span class="comment"># 如果定义的时候是*ARGS和**KWARGS, 那么这里就是ARGS和KWARGS, 只不过一般我们都叫做*args和**kwargs</span></span><br></pre></td></tr></table></figure>

<p><strong>如果我们定义的不是*args，只是一个*，那么它就不是参数了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到此时只有a、b、c</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x04</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x08</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 显然此时也都为假</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们简单的分析了一下函数在底层对应的数据结构，以及如何创建一个函数，并且还在Python的层面上做了一些小trick。最后我们也分析了如何通过PyCodeObject对象来检索Python中的参数，以及相关种类，当然标准库中的inspect模块也是这么做的。当然说白了，其实是我们模仿人家的思路做的。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>16-闭包的底层实现</title>
    <url>/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="16-闭包的底层实现以及调用"><a href="#16-闭包的底层实现以及调用" class="headerlink" title="16-闭包的底层实现以及调用"></a>16-闭包的底层实现以及调用</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>上一篇我们看了函数是如何调用的，这一次我们看一下函数中局部变量的访问、以及闭包相关的知识。</strong></p>
<h3 id="函数中局部变量的访问"><a href="#函数中局部变量的访问" class="headerlink" title="函数中局部变量的访问"></a>函数中局部变量的访问</h3><p><strong>我们说过函数的参数和函数内部定义的变量都属于局部变量，所以它也一样是通过静态的方式进行访问。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a和b是局部变量，x是全局变量，因此是2</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_nlocals)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar2</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar2.__code__.co_nlocals)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到，无论是参数还是内部新创建的变量，本质上都是局部变量。并且我们发现如果函数内部定义的变量如果和函数参数一致，那么参数就没用了，很好理解，因为本质上就相当于重新赋值罢了，此时外面无论给bar2函数的a、b参数传递什么，最终都会变成1和2。所以其实局部变量的实现机制和函数参数的实现机制是一致的。</strong></p>
<p><strong>按照我们的理解，当访问一个全局变量的时候，会去访问 global 名字空间，而这也确实如此。但是当访问函数内的局部变量的时候，是不是访问其内部的 local 名字空间呢？ 之前我们说过 Python 变量的访问是有规则的，按照<code>本地</code>、<code>闭包</code>、<code>全局</code>、<code>内置</code>的顺序去查找，所以首当其冲当然去 local 名字空间去查找啊。但不幸的是，在调用函数期间，Python 通过 <code>_PyFrame_New_NoTrack</code> 创建 PyFrameObject 对象时，这个至关重要的 local 名字空间并没有被创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在前面对函数调用时的 global 名字空间的解析中，我们看到，当 Python 虚拟机执行 <code>xxx.py</code> 的时候，f_locals 和 f_globals 指向的是同一个 PyDictObject 对象，然而现在在函数里面 f_locals 则变成了NULL，那么的话，那些重要的符号到底存储在什么地方呢？<code>(显然我们知道是符号表co_varnames中, 但你们就装作不知道配合我一下好吧(#^.^#))</code>。别急，我们先来看看使用局部变量的函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>看一下它的字节码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x0000013E31511450</span>, file <span class="string">&quot;local&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">3</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">16</span> POP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_CONST               <span class="number">4</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">20</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x0000013E31511450</span>, file <span class="string">&quot;local&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">4</span> BINARY_ADD</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">2</span> (c)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们说 f_localsplus  这段内存虽然是连续的，但它是给四个老铁使用的，分别是：局部变量、cell对象、free对象、运行时栈，而我们看到字节码偏移量为 6 和 10  的两条指令分别是：STORE_FAST 和 LOAD_FAST，所以它和我们之前分析参数的时候是一样的，都是存储在 f_localsplus  中运行时栈前面的那段内存中。</strong></p>
<p><strong>此时我们对局部变量 c  的藏身之处已经了然于心。但是为什么在函数的实现中没有使用 local  名字空间呢？其实函数内部的局部变量有多少，在编译的时候就已经确定了，个数是不会变的。因此编译时就能确定局部变量使用的内存空间位置，也能确定访问局部变量的字节码指令应该如何访问内存。有了这些信息，Python 就能使用静态的方法来实现局部变量的查找，而不需要借助于动态查找 PyDictObject 对象的技术，尽管 PyDictObject  是被高度优化的，但肯定没有静态的方法快啊，而且 Python  里面函数是对象，也是一等公民，并且函数使用的太普遍了。至于在后面的类的剖析中，由于类的特殊性，无论是类的实例对象、还是类对象本身，都是可以在运行时动态修改属性的，那么我们知道显然 Python 就不会再对类使用静态属性查找的方式了。</strong></p>
<p><strong>并且我们还可以从 Python 的层面来验证这个结论：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">globals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>我们在函数内部访问了 global 名字空间，而 global 空间显然是全局唯一的，在 Python 层面上就是一个 dict 对象，那么我们修改 x，在外部再打印 x 肯定会变。但是，我要说但是了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们按照相同的套路，却并没有成功，这是为什么？原因就是我们刚才解释的那样，函数内部的局部变量在编译时就已经确定好了，存储在符号表 co_varnames 中，查询的时候是静态查找的，而不是从 locals() 中查找。locals() 不像  globals()，globals() 虽然和 locals() 都是一个 PyDictObject 对象，但是全局变量的访问是从  globals() 这个字典里面访问的，并且全局唯一，我们调用 globals()  就直接访问到了存放全局变量的字典，一旦做了更改，肯定会影响外面的全局变量。但是locals()  则不会，因为局部变量压根就不是从它这里访问的，尽管它和 globals() 类似，在函数中也唯一，也会随着当前的上下文动态改变。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">locals</span>()))</span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">locals</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;x&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">2459571657088</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">2459571657088</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们看到真的就是类似于全局名字空间一样, 前后地址没有变化, 但是键值对的个数在增加</span></span><br><span class="line"><span class="comment"># 因为 locals() 底层会执行 PyEval_GetLocals, 实际上拿到就是当前栈帧对象的 f_locals 属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以这里可以看到一个比较奇特的现象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b</span>):</span><br><span class="line">    d = <span class="built_in">locals</span>()</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(d[<span class="string">&quot;d&quot;</span>] <span class="keyword">is</span> d[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>] <span class="keyword">is</span> d[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;d&#x27;: &#123;...&#125;&#125;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 可能有人好奇了, d 里面不是没有 &quot;d&quot; 这个 key 吗?</span></span><br><span class="line"><span class="comment"># 我们执行 d[&quot;d&quot;] 之前再次调用了 locals, 由于此时局部空间多了一个键值对 &quot;d&quot;: locals(), 所以 locals() 对应的字典被更新了</span></span><br><span class="line"><span class="comment"># 但我们说 locals() 在局部空间又是唯一的, 所以 d1 指向的空间也变了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于字典这个现象, 其实可以类似于 globals 与 __builtins__ 之间的关系</span></span><br><span class="line">x = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;x&quot;</span>])  <span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 之所以能够形成这个现象, 原因就在于字典里面的 key、value 存储的都是 PyObject * 泛型指针</span></span><br></pre></td></tr></table></figure>

<p><strong>再看一个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>此时会得到什么结果估计不用我说了，因为内部、外部、builtin都没有变量 x。在编译的时候，没有找到类似于 <code>x = 1</code> 这样的字眼。因此尽管在locals()里面，但是我们说局部变量的值不是从它这里获取的，而是 f_localsplus 前面的那段内存里面，然后那段内存并没有，而且符号表中就没有 ‘x’ 这个符号，所以报错。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p><strong>原因不再废话了，一句话：foo函数里面没有 x 这个变量，所以打印的是全局变量，因此输出123。</strong></p>
<p><strong>另外关于局部变量的查找，再来看看最后一个栗子，搭配 exec 可以说明一切：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;&#125;</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;&#x27;x&#x27;: 1&#125;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;x&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>尽管 locals() 变了，但是依旧访问不到 x，因为  Python 在将 foo 对应的 block 编译成 PyCodeObject  对象时，并不知道这是创建了一个局部变量，它只知道这是一个函数调用。而 exec(“x &#x3D; 1”) 相当于创建一个变量 x &#x3D;  1，但它默认影响的是当前所在的作用域，所以 exec(“x &#x3D; 1”) 的效果就是改变了局部名字空间，里面多了一个 “x”: 1  键值对。但关键的是，局部变量 x 的访问不是从局部名字空间中查找的，exec 终究还是错付了人。由于函数 foo 对应的  PyCodeObject 对象的符号表中并没有 x 这个符号，所以报错了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 这么做是可以的, 因为 exec 默认是影响当前作用域, 这里是全局作用域</span></span><br><span class="line"><span class="comment"># 而全局变量的查找是从字典中获取的, 所以这里是可以获取的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们把上面的例子改一下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="comment"># 此时 exec 影响的就是全局名字空间</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 123&quot;</span>, <span class="built_in">globals</span>())</span><br><span class="line">    <span class="comment"># 这里不会报错, 但是此时的 x 不是局部变量, 而是全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题又来了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>])</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面打印 1, 显然这是没有问题的, 因为 &quot;x&quot;: 1 这个键值对已经在 local 空间中了</span></span><br><span class="line"><span class="comment"># 但是, 是的我又要说但是了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File .....</span></span><br><span class="line"><span class="string">    bar()</span></span><br><span class="line"><span class="string">  File .....</span></span><br><span class="line"><span class="string">    print(locals()[&quot;x&quot;])</span></span><br><span class="line"><span class="string">KeyError: &#x27;x&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这就比较尴尬了，为啥会出现这种效果？解决这个问题首先要明确两点：</strong></p>
<ul>
<li><code>1. 函数内的局部变量在编译的时候已经确定, 由语法规则所决定的, 并存储在对应的 PyCodeObject 对象的符号表 (co_varnames) 中;</code></li>
<li><code>2. 函数内的局部变量在其整个作用域范围内都是可见的;</code></li>
</ul>
<p><strong>举一个常见的错误：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">调用 foo 没有问题, 但调用 bar 的时候会报出如下错误 </span></span><br><span class="line"><span class="string">	UnboundLocalError: local variable &#x27;x&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">原因就在于我们之前说的两个点, 函数内的局部变量在编译的时候已经确定, 所以对于 bar 函数而言, 符号表中是存在 &quot;x&quot; 这个符号的 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_varnames)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_varnames)  <span class="comment"># (&#x27;x&#x27;,)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">而函数内的局部变量在整个作用域内都是可见的, 因此对于bar而言, 在 print(x) 的时候知道符号表中存在 &quot;x&quot; 这个符号</span></span><br><span class="line"><span class="string">那么它也就认为局部作用域存在 x 这个局部变量, 因此就不会去找全局变量了, 而是去找局部变量</span></span><br><span class="line"><span class="string">但是显然 print(x) 是在 x = 2 之前发生的, 所以此时 print(x) 的时候就报错了</span></span><br><span class="line"><span class="string">       UnboundLocalError: 局部变量 &#x27;x&#x27; 在赋值（x = 2）之前被引用（print(x)）了</span></span><br><span class="line"><span class="string">因为 print(x) 的时候, 常量池中还没有对应的值与之绑定, 或者说 x 此时还是 C 中的 NULL(空指针), 并没有指向一块合法的内存</span></span><br><span class="line"><span class="string">当 x = 2 之后, x 才会和 2 这个 PyLongObject 对象进行绑定, 只可以我们在绑定之前就使用 x 这个变量了, 显然这是不合法的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>那么我们的那个问题就很好解释了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;x&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">bar()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 对于 foo 而言, 结果符合我们的预期, 但是对于 bar 而言, 只是多了一个赋值语句, 结果局部空间就变成空字典了</span></span><br><span class="line"><span class="comment"># 原因在于 &#x27;x&#x27; 已经在符号表当中了, exec(&quot;x = 1&quot;) 并没有往局部空间中加入这个键值对</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">有兴趣可以查看解释器源代码: Python\bltinmodule.c 中的 builtin_exec_impl 函数, 看看 exec 底层到底是如何执行的</span></span><br><span class="line"><span class="string">因为 exec 里面的字符串实际上是作为一个独立的编译单元去执行的, 里面的可以写很多很多内容</span></span><br><span class="line"><span class="string">要是再加上它是如何影响当前作用域的, 那么背后会牵扯非常多的内容, 从头到尾分析下来需要的工作量不敢想象, 因此这里不深入展开了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 但是访问 locals() 又是在 x = 123 之前发生的, 因此打印的是空字典, locals[&#x27;x&#x27;] 自然就出现 KeyError 了</span></span><br><span class="line"><span class="comment"># 如果将 x = 123, 改成 y = 123 的话, 显然 foo 和 bar 里面的打印结果是一样的</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套函数、闭包与decorator"><a href="#嵌套函数、闭包与decorator" class="headerlink" title="嵌套函数、闭包与decorator"></a>嵌套函数、闭包与decorator</h3><p><strong>我们之前一直反复提到了四个字，名字空间。一段代码执行的结果不光取决于代码中的符号，更多取决于代码中符号的语义，而这个运行时的语义正是由名字空间决定的。名字空间是在运行时由Python虚拟机动态维护的，但是有时我们希望将命名空间静态化。换句话说，我们希望有的代码不受命名空间变换带来的影响，始终保持一致的功能该怎么办呢？</strong></p>
<p><strong>比如下面的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">name, password, nickname</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (name == <span class="string">&quot;satori&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拜拜&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;欢迎:<span class="subst">&#123;nickname&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;夏色祭&quot;</span>))  <span class="comment"># 欢迎:夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;白上吹雪&quot;</span>))  <span class="comment"># 欢迎:白上吹雪</span></span><br></pre></td></tr></table></figure>

<p><strong>我们注意到每次都需要输入username和password，于是我们可以只设置一次基准值，通过使用嵌套函数来实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">name, password</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">nickname</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (name == <span class="string">&quot;satori&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拜拜&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;欢迎:<span class="subst">&#123;nickname&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = wrap(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;夏色祭&quot;</span>))  <span class="comment"># 欢迎:夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;白上吹雪&quot;</span>))  <span class="comment"># 欢迎:白上吹雪</span></span><br></pre></td></tr></table></figure>

<p><strong>尽管我们调用index的时候，local名字空间<code>(对应那片内存)</code>里面没有name和password，但是warp里面有。也就是说，index函数作为wrap函数的返回值被传递的时候，有一个名字空间<code>(wrap的local名字空间)</code>就已经和index紧紧地绑定在一起了，在执行内层函数index的时候，在自己的local空间找不到，就会从和自己绑定的local空间里面去找，这就是一种名字空间静态化的方法。这个名字空间和内层函数捆绑之后的结果我们就称之为闭包<code>(closure)</code></strong></p>
<blockquote>
<p><strong>闭包：外部作用域 + 内层函数。</strong></p>
</blockquote>
<p><strong>在前面我们也知道了，PyFunctionObject是Python虚拟机专门为字节码指令准备的大包袱，global名字空间，默认参数都能在PyFunctionObject中与字节码指令捆绑在一起，同样的，PyFunctionObject也是Python中闭包的具体体现。</strong></p>
<h4 id="实现闭包的基石"><a href="#实现闭包的基石" class="headerlink" title="实现闭包的基石"></a>实现闭包的基石</h4><p><strong>闭包的创建通常是利用嵌套的函数来完成的，在PyCodeObject中，与嵌套函数相关的属性是co_cellvars和co_freevars，两者的具体含义如下：</strong></p>
<ul>
<li><code>co_cellvars:通常是一个tuple，保存了嵌套的作用域中使用的变量名的集合;</code></li>
<li><code>co_freevars:通常是一个tuple，保存了使用了的外层作用域中的变量名集合;</code></li>
</ul>
<p><strong>光看概念的话比较抽象，实际演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;mashiro&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="keyword">nonlocal</span> age</span><br><span class="line">        <span class="built_in">print</span>(gender)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_cellvars)  <span class="comment"># (&#x27;age&#x27;, &#x27;gender&#x27;, &#x27;name&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_freevars)  <span class="comment"># (&#x27;age&#x27;, &#x27;gender&#x27;, &#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_freevars)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_cellvars)  <span class="comment"># ()</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现无论是外层函数还是内层函数都有co_cellvars和co_freevars，但是无论是co_cellvars还是co_freevars，得到结果是一样的，都是内层函数使用nonlocal声明的变量、以及内层函数使用的外层函数的变量。只不过外层函数需要使用co_cellvars获取，内层函数需要使用co_freevars获取。如果使用外层函数获取co_freevars的话，那么得到的结果显然就是个空元组的，除非foo也作为某个函数的内层函数，并且内部有nonlocal声明、或者使用外层函数的某个变量，同理内层也是一样的道理。</strong></p>
<p><strong>在PyFrameObject对象中，也有一个属性和闭包的实现相关，这个属性就是f_localsplus，这样一说，是不是有些隐隐约约察觉到了呢？其实在<code>_PyFrame_New_NoTrack</code>就有一行代码泄漏了天机。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">    Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">    ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">    nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">	<span class="comment">//玄机在这里，extras正是f_localsplus指向的那片内存的大小，这里已经清晰的说明了</span></span><br><span class="line">    <span class="comment">//这片内存是属于四个老铁的：运行时栈，局部变量，cell对象(对应co_cellvars)，free对象(对应co_freevars)，但是各自的顺序不是按照这个顺序来的</span></span><br><span class="line">    extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>虽然之前我们就见过f_localsplus的结构，但是到现在为止，其面纱才算是真正被揭开。</strong></p>
<h4 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h4><p><strong>在介绍了实现闭包的基石之后，我们可以开始追踪闭包的具体实现过程了，当然还是要先看一下闭包对应的字节码，老规矩嘛。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def get_func():</span></span><br><span class="line"><span class="string">    value = &quot;inner&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def func():</span></span><br><span class="line"><span class="string">        print(value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return func</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">show_value = get_func()</span></span><br><span class="line"><span class="string">show_value()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>首先这个py文件执行之后，肯定会打印出”inner”这个字符串，下面让我们来看看它的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object get_func at <span class="number">0x000001AAB6F4AB30</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;get_func&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (get_func)</span><br><span class="line"></span><br><span class="line"> <span class="number">11</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (get_func)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">1</span> (show_value)</span><br><span class="line"></span><br><span class="line"> <span class="number">12</span>          <span class="number">14</span> LOAD_NAME                <span class="number">1</span> (show_value)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object get_func at <span class="number">0x000001AAB6F4AB30</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_DEREF              <span class="number">0</span> (value)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>           <span class="number">4</span> LOAD_CLOSURE             <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">6</span> BUILD_TUPLE              <span class="number">1</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (&lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;get_func.&lt;locals&gt;.func&#x27;</span>)</span><br><span class="line">             <span class="number">12</span> MAKE_FUNCTION            <span class="number">8</span> (closure)</span><br><span class="line">             <span class="number">14</span> STORE_FAST               <span class="number">0</span> (func)</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">16</span> LOAD_FAST                <span class="number">0</span> (func)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;:</span><br><span class="line">  <span class="number">6</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_DEREF               <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>相信里面大部分的指令你都认识，我们直接介绍构建闭包对应的指令、以及调用内层函数对应的指令，先来看看前者：</strong></p>
<ul>
<li><code>0 LOAD_CONST    1 (&#39;inner&#39;): 把字符串&#39;inner&#39;这个常量load进来;</code></li>
<li><code>2 STORE_DEREF    0 (value): 这个STORE_DEREF是什么鬼？从功能来看应该类似于STORE_FAST,具体是啥暂时不用管;</code></li>
<li><code>4 LOAD_CLOSURE    0 (value): 又是一条未见过的指令，不过这个我们从名字上可以看出来是load一个闭包;</code></li>
<li><code>6 BUILD_TUPLE    1: build一个元组, 为什么? 显然是为了存储内层函数(闭包)的</code></li>
<li><code>8 LOAD_CONST    2 (&lt;code object func...: LOAD字节码,显然是内层函数func的字节码;</code></li>
<li><code>10 LOAD_CONST    3 (&#39;get_func.&lt;locals&gt;.func&#39;): 又是一个LOAD_CONST,我们按照之前的分析，这次LOAD的应该是外层的local名字空间;</code></li>
<li><code>12 MAKE_FUNCTION    8 (closure): MAKE_FUNCTION,构造一个函数, 参数是8; 而且括号里面写着closure, 表示这是个闭包;</code></li>
<li><code>14 STORE_FAST    0 (func):  调用STORE_FAST，将符号func和之前的PyFunctionObject组合成entry存储起来,  当然我们知道这里不是存在字典里面的;符号func是在符号表中, PyFunctionObject对象是在常量池中,  并且它们在各自数组中的索引是相等的;</code></li>
<li><code>16 LOAD_FAST    0 (func): 因为我们返回了func,所以LOAD_CONST的参数是func;</code></li>
<li><code>18 RETURN_VALUE: 返回func;</code></li>
</ul>
<p><strong>最后再来看看调用内层函数执行的指令：</strong></p>
<ul>
<li><code>0 LOAD_GLOBAL     0 (print): 首先是LOAD_GLOBAL得到print函数，这不需要多说;</code></li>
<li><code>2 LOAD_DEREF    0 (value): 关键是这条LOAD_DEREF指令，显然和上面的STORE_DEREF是一组，关系应该是类似于LOAD_FAST和STORE_FAST之间的关系那样, 我们猜测;</code></li>
<li><code>4 CALL_FUNCTION     1: 调用函数, 参数个数为1;</code></li>
</ul>
<p><strong>虽然我们看到了几个不认识的指令，不过不用慌，我们下面会顺藤摸瓜，沿着那美丽动人的曲线慢慢地、逐一探索。目前只需要知道，在Python虚拟机执行<code>8 LOAD_CONST    2 (&lt;code object func...</code>指令的时候，就已经开始为closure的实现悄悄地添砖加瓦了。</strong></p>
<h5 id="创建closure"><a href="#创建closure" class="headerlink" title="创建closure"></a>创建closure</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()</span><br></pre></td></tr></table></figure>

<p><strong>我们前面介绍了，虚拟机在执行CALL_FUNCTION指令时，会进入 *_PyFunction_FastCallDict* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    <span class="comment">//......    </span></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p><strong>而在 *_PyFunction_FastCallDict* 中，由于当前的PyCodeObject为函数get_func对应的PyCodeObject。对于有闭包的函数来说，显然这个条件是不满足的，因此不会进入快速通道，而是会进入 *_PyEval_EvalCodeWithName* 。而且当前的这个PyCodeObject的co_cellvars是有东西的，可能这里有人奇怪了，我们没看到代码里面使用nonlocal声明啊，其实之前说了，除了使用nonlocal声明的变量外，还有内层函数使用的外层作用域中的变量。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value1 = <span class="string">&quot;inner&quot;</span></span><br><span class="line">    value2 = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        value2 = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(value1)</span><br><span class="line">        <span class="built_in">print</span>(value2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(get_func.__code__.co_cellvars)  <span class="comment"># (&#x27;value1&#x27;,)</span></span><br><span class="line"><span class="built_in">print</span>(get_func().__code__.co_freevars)  <span class="comment"># (&#x27;value1&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现了内层函数自己定义了value2，所以它不再co_cellvars中，但是value1在内层函数中没有，而是使用的外层函数内部的value1变量，所以它也在co_cellvars中。因此除了那些被nonlocal关键字声明的变量之外，还有被内层函数使用的外层函数的变量。</strong></p>
<p><strong>因此在 *_PyEval_EvalCodeWithName* 中，Python虚拟机会如同处理默认参数一样，将co_cellvars中的东西拷贝到新创建的PyFrameObject的f_localsplus里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) &#123;</span><br><span class="line">        <span class="comment">//声明 Cell 对象，这个 Cell 对象是什么后面就知道了</span></span><br><span class="line">        PyObject *c;</span><br><span class="line">        Py_ssize_t arg;</span><br><span class="line">        <span class="comment">/* 处理被嵌套函数共享的外层函数的局部变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_cell2arg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) &#123;</span><br><span class="line">            <span class="comment">//创建 Cell 对象</span></span><br><span class="line">            c = PyCell_New(GETLOCAL(arg));</span><br><span class="line">            SETLOCAL(arg, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = PyCell_New(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        SETLOCAL(co-&gt;co_nlocals + i, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 Cell 对象拷贝一份, 因为外层函数和内层函数都可以调用</span></span><br><span class="line"><span class="comment">       只不过一个是co_cellvars、一个是co_freevars */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">        PyObject *o = PyTuple_GET_ITEM(closure, i);</span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在 *_PyEval_EvalCodeWithName* 中，Python虚拟机会如同处理默认参数一样，将co_cellvars中的东西拷贝到新创建的PyFrameObject的f_localsplus里面。</strong></p>
<p><strong>嵌套函数有时候很复杂，如果嵌套的层数比较多的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">foo3</span>():</span><br><span class="line">            x = <span class="number">2</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">foo4</span>():</span><br><span class="line">                <span class="built_in">print</span>(x)</span><br><span class="line">            <span class="keyword">return</span> foo4</span><br><span class="line">        <span class="keyword">return</span> foo3</span><br><span class="line">    <span class="keyword">return</span> foo2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1()()()()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>但是无论多少层，我们之前说的结论是不会变的。之前我们提到了，Cell 对象在python底层也是一个对象，那它必然也是一个PyObject，我们看一下它的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *ob_ref;       <span class="comment">/* Content of the cell or NULL when empty */</span></span><br><span class="line">&#125; PyCellObject;</span><br></pre></td></tr></table></figure>

<p><strong>这个对象似乎出乎意料的简单，仅仅维护了一个PyObject_HEAD，和一个ob_ref<code>(指向某个对象的指针)</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCell_New</span><span class="params">(PyObject *obj)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个PyCellObject对象</span></span><br><span class="line">    PyCellObject *op;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//为这个PyCellObject申请空间，类型是PyCell_Type</span></span><br><span class="line">    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这里的obj是什么呢？显然是上面_PyEval_EvalCodeWithName里面的GETLOCAL(arg)或者NULL</span></span><br><span class="line">    <span class="comment">//说白了，就是我们之前说的那些被内层函数引用的外层函数的局部变量，或者NULL，如果没人引用的话就是NULL</span></span><br><span class="line">    op-&gt;ob_ref = obj;</span><br><span class="line">    Py_XINCREF(obj);</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是实际上一开始是不知道这个ob_ref指向的是谁的，什么时候才知道呢？是在我们一开始的闭包代码中，那句<code>value = &#39;inner&#39;</code>指令指令的时候，才会真正知道ob_ref指向的是谁。随后这个cell对象被拷贝到了新创建的PyFrameObject对象的f_localsplus中，并且位置是<code>co-&gt;co_nlocals+i</code>，说明在f_localsplus中，cell对象的位置是在局部变量之后的，这完全符合我们之前说的f_localsplus的内存布局。另外图中画错了，指向应该是一个字符串 “inner”，但我不知道为啥画成了整数 10</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065426762-1258006550.png" alt="img"></p>
<p><strong>但是我们发现了一个奇怪的地方，那就是我们发现这个cell对象<code>(value)</code>好像没有设置名字诶。实际上这个和我们之前提到的Python虚拟机将对局部变量符号的访问方式从PyDictObject的查找变成了对PyTupleObject的索引是一个道理。在get_func这个函数执行的过程中，对value这个cell对象是通过基于索引访问在f_localsplus中完成，因此完全不需要知道cell对象的名字。这个cell对象的名字实际上是在处理被内层函数引用外层函数的默认参数是产生的。我们说参数和内部的创建的变量都是局部变量，在处理默认参数的时候，就把value这个cell对象一并处理了。</strong></p>
<p><strong>在处理了cell对象之后，Python虚拟机将正式进入PyEval_EvalFrameEx，从而正式开始对函数get_func的调用过程。再看一下字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_DEREF              <span class="number">0</span> (value)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>           <span class="number">4</span> LOAD_CLOSURE             <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">6</span> BUILD_TUPLE              <span class="number">1</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (&lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;get_func.&lt;locals&gt;.func&#x27;</span>)</span><br><span class="line">             <span class="number">12</span> MAKE_FUNCTION            <span class="number">8</span> (closure)</span><br><span class="line">             <span class="number">14</span> STORE_FAST               <span class="number">0</span> (func)</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">16</span> LOAD_FAST                <span class="number">0</span> (func)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;:</span><br><span class="line">  <span class="number">6</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_DEREF               <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到执行<code>0 LOAD_CONST 1 (&#39;inner&#39;)</code>之后，会将PyUnicodeObject对象’inner’压入到运行时栈，紧接着便执行一条我们从未见过的全新的字节码指令–<code>STORE_DEREF</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">	freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_DEREF)</span>: &#123;</span><br><span class="line">            <span class="comment">//这里pop弹出的显然是运行时栈的PyUnicodeObject对象&#x27;inner&#x27;</span></span><br><span class="line">            PyObject *v = POP();</span><br><span class="line">             <span class="comment">//获取cell，也就是闭包; 注意：这里要和之前说的cell对象区分一下，之前的cell对象是变量</span></span><br><span class="line">            <span class="comment">//这里的cell则是闭包(内层函数+外层函数的局部作用域)</span></span><br><span class="line">            PyObject *cell = freevars[oparg];</span><br><span class="line">            <span class="comment">//获取老的cell对象</span></span><br><span class="line">            PyObject *oldobj = PyCell_GET(cell);</span><br><span class="line">            <span class="comment">//我们看到了一个PyCell_SET，那么玄机肯定就在这里面了</span></span><br><span class="line">            PyCell_SET(cell, v);</span><br><span class="line">            Py_XDECREF(oldobj);</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们发现，ob_ref指向的对象似乎就是通过PyCell_SET设置的，没错，这家伙就是干这个勾当的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.h</span></span><br><span class="line">PyAPI_FUNC(<span class="type">int</span>) PyCell_Set(PyObject *, PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cellobject.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyCell_Set</span><span class="params">(PyObject *op, PyObject *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject* oldobj;</span><br><span class="line">    <span class="keyword">if</span> (!PyCell_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oldobj = PyCell_GET(op);</span><br><span class="line">    Py_XINCREF(obj);</span><br><span class="line">    PyCell_SET(op, obj);</span><br><span class="line">    Py_XDECREF(oldobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如此一来，f_localsplus就发生了变化。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065435213-2141751147.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()</span><br></pre></td></tr></table></figure>

<p><strong>现在在get_func的环境中我们知道了value符号对应着一个PyUnicodeObject对象，但是closure是要将这个约束进行冻结，为了在嵌套函数func中被调用的时候还可以使用这个约束。这一次，我们的工具人PyFunctionObject就又登场了，在执行接下来的<code>def func()</code>表达式对应的字节码时，python虚拟机就会将<code>(value, &#39;inner&#39;)</code>这个约束塞到PyFunctionObject中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_CLOSURE)</span>: &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];</span><br><span class="line">    Py_INCREF(cell);</span><br><span class="line">    PUSH(cell);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>4 LOAD_CLOSURE</code>会将刚刚放置好的PyCellObject对象取出，并压入运行时栈，紧接着<code>6 BUILD_TUPLE</code>指令将PyCellObject对象打包进一个PyTupleObject对象，显然这个PyTupleObject对象中可以存放多个PyCellObject对象，只不过我们的例子中只有一个PyCellObject对象。</strong></p>
<p><strong>随后Python虚拟机通过<code>8 LOAD_CONST</code>和<code>10 LOAD_CONST</code>将内层函数func对应PyCodeObject和符号LOAD进来，压入运行时栈，紧接着以一个<code>12 MAKE_FUNCTION 8</code>指令完成约束和PyCodeObject之间的绑定，注意这里的字节码指令依旧是<code>MAKE_FUNCTION</code>，但是参数是8，我们再次看看<code>MAKE_FUNCTION</code>这个指令，还记得这个指令在哪里吗？没错，之前说了只要是字节码指令，都在<code>ceval.c</code>中</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(MAKE_FUNCTION) &#123;</span><br><span class="line">    <span class="comment">//弹出名字</span></span><br><span class="line">    PyObject *qualname = POP();</span><br><span class="line">    <span class="comment">//弹出PyCodeObject</span></span><br><span class="line">    PyObject *codeobj = POP();</span><br><span class="line">    <span class="comment">//根据PyCodeObject对象、global命名空间、名字构造出PyFunctionObject</span></span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//我们看到参数是8，因此这个条件是成立的</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        <span class="comment">//弹出闭包需要使用的变量信息，将该信息写入到func_closure中</span></span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是处理注解的：只在python3.6+中存在</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理关键字参数</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理默认参数</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//压入运行时栈</span></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时便将约束<code>(内层函数需要使用的作用域信息)</code>和内层函数绑定在了一起。然后执行<code>14 STORE_FAST</code>将新创建的PyFunctionObject对象放置到了f_localsplus当中。这样的话，f_localsplus就又发生了变化。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065442949-1280274412.png" alt="img"></p>
<p><strong>从图上我们发现内层函数居然在get_func的局部变量里面，是的没有错。其实按照我们之前说的，函数即变量，所以函数和普通变量一样，都是在上一级栈帧的f_localsplus里面的。最后这个新建的PyFunctionObject对象被压入到了上一级栈帧的运行时栈中，并且被作为上一个栈帧的返回值返回了。显然有人就能猜到下一步要介绍什么了，既然拿到了闭包、或者说内层函数对应的PyFunctionObject，那么肯定要使用啊。而且估计有人猜到了，当外面拿到闭包的时候，调用，显然会找到对应的闭包，然后抽出里面的PyCodeObject对象继续创建栈帧。</strong></p>
<h5 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h5><p><strong>closure是在get_func函数中被创建的，而对closure的使用，则是在inner_func中。在执行<code>show_value()</code>对应的CALL_FUNCTION指令时，因为func对应的PyCodeObject对象的co_flags域中包含了CO_NESTED，因此在 *_PyFunction_FastCallDict* 函数中不会进入快速通道<code>function_code_fastcall</code>，而是会进入 *_PyEval_EvalCodeWithName* 、*PyEval_EvalFrameEx* 、继而进入 *_PyEval_EvalFrameDefault* 。不过问题是，Python是怎么知道co_flags域中包含了CO_NESTED呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line"><span class="built_in">print</span>(show_value.__code__.co_flags)  <span class="comment"># 19</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到func函数的字节码的co_flags是19，那么这个值是什么计算出来的呢？还是记得我们在介绍PyCodeObject对象和pyc文件那一章中，当时我们说，co_flags这个域主要用于mask，用来判断参数类型的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_OPTIMIZED    0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NEWLOCALS    0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARARGS      0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARKEYWORDS  0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NESTED       0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_GENERATOR    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NOFREE       0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_COROUTINE            0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_ITERABLE_COROUTINE   0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_ASYNC_GENERATOR      0x0200</span></span><br></pre></td></tr></table></figure>

<p><strong>函数没有参数，显然CO_VARARGS和CO_VARKEYWORDS是不存在的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0x0001</span> | <span class="number">0x0002</span> | <span class="number">0x0010</span>)  <span class="comment"># 19</span></span><br><span class="line"><span class="comment"># 因此闭包是包含CO_NESTED这个域的</span></span><br></pre></td></tr></table></figure>

<p><strong>根据之前说了，对于闭包来说，func对应的PyCodeObject中的co_freevars里面有引用了外层作用域中的符号名，在 *_PyEval_EvalCodeWithName* 中就会对这个co_freevars进行处理。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    <span class="comment">/* Copy closure variables to free variables */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">        PyObject *o = PyTuple_GET_ITEM(closure, i);</span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中的closure变量是作为倒数第三个参数传递进来的，我们可以看看到底传递了什么？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//funcobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFunction_GET_CLOSURE(func) \</span></span><br><span class="line"><span class="meta">        (((PyFunctionObject *)func) -&gt; func_closure)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs,</span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到了，是把PyFunctionObject对象的func_closure拿出来了，这个func_closure是啥还记得吗？之前说得，不记得了再看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(MAKE_FUNCTION) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        <span class="comment">//弹出闭包需要使用的变量信息，将该信息写入到func_closure中</span></span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然这个func_closure就是PyFunctionObject对象中的、我们之前说得那个与对应PyCodeObject绑定的、装满了PyCellObject对象的PyTupleObject。所以在 *_PyEval_EvalCodeWithName* 中，进行的动作就是将这个PyTupleObject里面的PyCellObject对象一个一个的放到f_localsplus中相应的位置。在处理完之后，func对应的PyFrameObject中f_localsplus就变成了这样。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065450935-1586497820.png" alt="img"></p>
<p><strong>我们看到闭包使用的变量信息，被设置在了func_closure中，而这个函数是内层函数，那么我们可以通过__closure__进行获取。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line"><span class="comment"># cell是针对外层函数的</span></span><br><span class="line"><span class="comment"># free是针对内层函数的</span></span><br><span class="line"><span class="comment"># 我们看到在设置func_closure的时候是对内层函数进行设置的, 所以</span></span><br><span class="line"><span class="built_in">print</span>(get_func.__closure__)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(show_value.__closure__)  <span class="comment"># (&lt;cell at 0x000001E07D8382B0: str object at 0x000001E07D82D3F0&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到外层函数的__closure__为None, 内层函数的__closure__则不是None</span></span><br><span class="line"><span class="comment"># 因此相当于将所有的cell对象(指针)拷贝了一份, 存在了free区域, 那么如何获取cell对象的值呢</span></span><br><span class="line"><span class="built_in">print</span>(show_value.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># inner</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在func调用的过程中，当引用外层作用域的符号时，一定是到f_localsplus里面的free变量区域去获取对应PyCellObject，通过内部的ob_ref进而获取符号对应的值。这正是func函数中’print(value)’表达式对应的第一条字节码指令<code>0 LOAD_DEREF 0</code>的意义。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_DEREF)</span>: &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];  <span class="comment">//获取PyCellObject对象   </span></span><br><span class="line">    PyObject *value = PyCell_GET(cell);<span class="comment">//获取PyCellObject对象的ob_ref指向的对象 </span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        format_exc_unbound(tstate, co, oparg);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);<span class="comment">//压入运行时栈</span></span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以在func调用的过程中，当引用外层作用域的符号时，一定是到f_localsplus里面的free变量区域去获取对应PyCellObject，通过内部的ob_ref进而获取符号对应的值。这正是func函数中’print(value)’表达式对应的第一条字节码指令<code>0 LOAD_DEREF 0</code>的意义。</strong></p>
<p><strong>此外通过闭包，我们还可以玩出一些新花样，但是工作中不要这么做。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()  <span class="comment"># inner</span></span><br><span class="line"></span><br><span class="line">show_value.__closure__[<span class="number">0</span>].cell_contents = <span class="string">&quot;内层函数&quot;</span></span><br><span class="line">show_value()  <span class="comment"># 内层函数</span></span><br></pre></td></tr></table></figure>

<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p><strong>装饰器算是Python中一个亮点，当然其实也不算什么亮点，本质上也是使用了闭包的思想，只不过给我们提供了一个优雅的语法糖。</strong></p>
<blockquote>
<p><strong>装饰器的本质就是高阶函数加上闭包，至于为什么要有装饰器，我觉得有句话说的非常好，装饰器存在的最大意义就是可以在不改动原函数的代码和调用方式的情况下，为函数增加一些新的功能。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;都闪开，我要开始装饰了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始了&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco    </span><span class="comment"># 这一步就等价于foo = deco(foo)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="comment"># 因此上来就会打印deco里面的print</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时再调用foo，已经不再是原来的foo了，而是deco里面的闭包inner</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体输出如下:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">都闪开，我要开始装饰了</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string">开始了</span></span><br><span class="line"><span class="string">1 2</span></span><br><span class="line"><span class="string">结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 根据输出的---------，我们知道deco里面的print是在装饰的时候就已经打印了</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以使用之前的方式：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;都闪开，我要开始装饰了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始了&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实@deco的方式就是一个语法糖，它本质上就是</span></span><br><span class="line">foo = deco(foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">都闪开，我要开始装饰了</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">开始了</span></span><br><span class="line"><span class="string">1 2</span></span><br><span class="line"><span class="string">结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以这个现象告诉我们，装饰器只是类似于<code>foo = deco(foo)</code>的一个语法糖罢了</strong></p>
<p><strong>装饰器本质上就是使用了闭包，两者的字节码很类似，这里就不再看了。还是那句话，<code>@</code>只是个语法糖，它和我们直接调用<code>foo = deco(foo)</code>是一样的，所以理解装饰器(decorator)的关键就在于理解闭包(closure)。</strong></p>
<blockquote>
<p><strong>当然函数在被装饰器装饰之后，整个函数其实就已经变了，为了保留原始信息我们一般会从functools中导入一个wraps函数。当然装饰器的使用方式、以及类装饰器，这些都属于Python层级的东西了，我们就不说了。</strong></p>
</blockquote>
<p><strong>当然，我们知道函数可以同时被多个装饰器装饰的。如果有多个装饰器，那么它们是怎么装饰的呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco1&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco1&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco2&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco2&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco3</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco3&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco3&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco1</span></span><br><span class="line"><span class="meta">@deco2</span></span><br><span class="line"><span class="meta">@deco3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hanser&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo())</span><br></pre></td></tr></table></figure>

<p><strong>请问它的输出结果是什么呢？</strong></p>
<blockquote>
<p><strong>可以先分析，解释器还是从上到下解释，但是发现了<code>@deco1</code>的时候，肯定要装饰了，但是发现在它下面的哥们不是函数也是一个装饰器，于是说：要不哥们，你先装饰。然后<code>@deco2</code>发现它下面还是一个装饰器，于是重复了刚才的话，但是当<code>@deco3</code>的时候，发现下面终于是一个普通的函数了。于是装饰了，当deco3装饰完毕之后，<code>foo = deco3(foo)</code>，然后deco2发现deco3已经装饰完毕了，然后对deco3装饰的结果再进行装饰，此时<code>foo = deco2(deco3(foo))</code>，同理再经过deco1的装饰，得到了<code>foo = deco1(deco2(deco3(foo)))</code></strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(foo())  <span class="comment"># &lt;deco1&gt;&lt;deco2&gt;&lt;deco3&gt;hanser&lt;/deco3&gt;&lt;/deco2&gt;&lt;/deco1&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="关于函数的面试题"><a href="#关于函数的面试题" class="headerlink" title="关于函数的面试题"></a>关于函数的面试题</h3><p>​        <strong>1. Python 中有几个名字空间，分别是什么？Python 变量以什么顺序进行查找？</strong>    </p>
<p><strong>Python总共有4个名字空间：</strong></p>
<ul>
<li><code>局部名字空间(local)</code></li>
<li><code>闭包名字空间(closure)</code></li>
<li><code>全局名字空间(global)</code></li>
<li><code>内建名字空间(builtin)</code></li>
</ul>
<p><strong>我们之前说过，*Python* 查找变量时，依次检查 局部 、闭包、全局、内建 这几个名字空间，直到变量被找到为止。如果几个空间都遍历完了还没找到，那么会抛出NameError。</strong></p>
<p>​        <strong>2. 如何在一个函数内部修改全局变量？</strong>    </p>
<p><strong>在函数内部用 *global* 关键字将变量声明为全局，然后再进行修改：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>或者获取global名字空间，然后通过字典进行修改，因为全局变量是通过字典来存储的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">globals</span>()[<span class="string">&quot;a&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>3. 不使用 def 关键字的话，还有什么办法可以创建函数对象？</strong>    </p>
<p><strong>根据 *Python* 对象模型，实例对象可以通过调用类型对象来创建。而函数类型对象，虽然没有直接暴露给我们，但我们可以通过函数对象找到：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__class__)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span>: <span class="literal">None</span>).__class__)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>事实上，*Python* 将函数类型对象暴露在 *types* 模块中，可通过模块属性 *FunctionType* 访问到：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(FunctionType)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(f.__class__ <span class="keyword">is</span> FunctionType)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>然而它干的事情和我们本质上是一样的，我们看一下源码怎么实现的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(): <span class="keyword">pass</span></span><br><span class="line">FunctionType = <span class="built_in">type</span>(_f)</span><br></pre></td></tr></table></figure>

<p><strong>吱吱吱~~~</strong></p>
<p><strong>而创建函数的时候，可以根据PyCodeObject对象创建，我们之前已经见过了。当时我们传递了3个参数：PyCodeObject、名字空间、函数名。其实可以传递五个参数：</strong></p>
<ul>
<li><code>PyCodeObject对象</code></li>
<li><code>globals</code></li>
<li><code>name</code></li>
<li><code>argdef: 默认参数的值</code></li>
<li><code>closure: 闭包变量</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">global</span> value</span><br><span class="line">    value = v </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = &#123;&#125;</span><br><span class="line"><span class="comment"># 对于new_f而言, g就是它的全局名字空间, 所以设置的全局变量value会体现在g中</span></span><br><span class="line">new_f = <span class="built_in">type</span>(f)(f.__code__, g, <span class="string">&quot;new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line">new_f(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># &#123;&#x27;value&#x27;: 10&#125;</span></span><br><span class="line"></span><br><span class="line">new_f(<span class="string">&quot;夏色祭&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># &#123;&#x27;value&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>是不是奇怪的知识又增加了呢？但还是那句话，这种做法没有什么实际用途，只是让我们能够更好地理解函数的机制。</strong></p>
<p>​        <strong>4. 请介绍装饰器的运行原理，并说说你对 @xxxx 这种写法的理解？</strong>    </p>
<p><strong>装饰器用于包装函数对象，在不修改函数源码和调用方式的前提下、达到修改函数行为的目的。它的本质是高阶函数加上闭包，而@xxxx只是一个语法糖。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deco</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;++++++&quot;</span>)</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;******&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deco</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">++++++</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">******</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>还是那句话，装饰器本质是高阶函数加上闭包，而很多语言都有闭包，也可以多层函数嵌套。但是对于Python而言，装饰器显得格外的优雅。</strong></p>
<blockquote>
<p><strong>flask框架就用到了大量的装饰器，比如：@app.route(“&#x2F;“)，不得不说，flask的作者真的是非常喜欢使用装饰器，还有它们团队开发的、用于处理命令行参数的click模块，也是大量使用了装饰器。</strong></p>
</blockquote>
<p>​        <strong>5. Python 中的闭包变量(外层作用域的变量)可以被内部函数修改吗？</strong>    </p>
<p><strong>显然是可以的，有两种方式：一种是通过nonlocal关键字，另一种是通过获取闭包变量的方式。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = f1()</span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># 0</span></span><br><span class="line">f.__closure__[<span class="number">0</span>].cell_contents = <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># &gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>6. 请描述执行以下程序将输出什么内容？并试着解释其中的原因。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n, l=[]</span>):</span><br><span class="line">    l.append(n)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">2</span>))  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>))  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>出现这种问题的原因就在于，*Python* 函数在创建时便完成了默认参数的初始化，并保存在函数对象的 *<strong>defaults</strong>* 字段中，并且是不变的，永远是那一个对象：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n, l=[]</span>):</span><br><span class="line">    l.append(n)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">2</span>))  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>))  <span class="comment"># [1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065459727-1555535085.png" alt="img"></p>
<p><strong>显然在函数执行的时候，如果我们没有传递参数，那么会从栈帧的f_localsplus中获取对应的默认值，当然这个默认值也在函数的__defaults__中。这个f_localsplus由局部变量、cell对象、free对象、运行时栈组成，运行时栈位于栈顶，*Python* 虚拟机负责从函数对象中取出默认参数并设置相关局部变量：</strong></p>
<p><strong>由于列表是可变对象，因此采用append的方式，那么显然每一次都会有变化的，因为操作的是同一个列表。</strong></p>
<p><strong>所以在设置默认参数的时候，不要设置成可变对象。如果你的IDE比较智能的话，比如pycharm，那么会给你抛出警告的。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065507599-355200755.png" alt="img"></p>
<p><strong>我们看到飘黄了，因为默认参数的值是一个可变对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>到目前为止，我们关于函数的内容就算分析完了，可以好好体会一下函数的底层实现。我们下一篇将来分析Python中类的实现，又是一块难啃的骨头。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>15-函数在底层是如何被调用的</title>
    <url>/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/</url>
    <content><![CDATA[<h2 id="15-函数在底层是如何被调用的"><a href="#15-函数在底层是如何被调用的" class="headerlink" title="15-函数在底层是如何被调用的"></a>15-函数在底层是如何被调用的</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在上一篇博客中，我们说了Python函数的底层实现，并且还演示了如何自定义一个函数，虽然这在工作中没有太大意义，但是可以让我们深刻理解函数的行为。此外我们还介绍了如何获取函数的参数，而这一次我们就来看看函数如何调用的。</strong></p>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def foo():</span></span><br><span class="line"><span class="string">    a, b = 1, 2</span></span><br><span class="line"><span class="string">    return a + b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>我们以一个非常简单的函数为例，看看它的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object foo at <span class="number">0x00000219BA3F1450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">12</span> POP_TOP</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">16</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object foo at <span class="number">0x00000219BA3F1450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> ((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">              <span class="number">2</span> UNPACK_SEQUENCE          <span class="number">2</span></span><br><span class="line">              <span class="number">4</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>还是那句话，模块有一个PyCodeObject对象，函数也有一个PyCodeObject对象，只不过后者是在前者的常量池当中。而且dis模块在显示字节码的时候，自动帮我们分开了，我们从上到下依次捋一遍。</strong></p>
<ul>
<li><code>0 LOAD_CONST	0 (&lt;code object......: 遇到def关键字知道这是一个函数, 所以会加载其对应的PyCodeObject对象</code></li>
<li><code>2 LOAD_CONST 	1 (&#39;foo&#39;): 加载函数名</code></li>
<li><code> 4 MAKE_FUNCTION    0: 通过MAKE_FUNCTION指令构造一个函数</code></li>
<li><code>6 STORE_NAME    0 (foo): 将符号&quot;foo&quot;和上一步得到的函数绑定起来, 存储在local空间中, 这个local空间显然是模块的local空间、即global空间</code></li>
<li><code>8 LOAD_NAME    0 (foo): 注意这一步是在调用的时候发生的, 将变量foo加载进来</code></li>
<li><code>10 CALL_FUNCTION    0: 通过CALL_FUNCTION指令调用该函数(我们后面将要分析的重点), 后面的0表示参数个数</code></li>
<li><code>12 POP_TOP: 将上一步函数的返回值从运行时栈的顶部弹出</code></li>
<li><code>14 LOAD_CONST    2 (None): 加载返回值None</code></li>
<li><code>16 RETURN_VALUE: 将返回值返回</code></li>
</ul>
<p><strong>模块对应的字节码就是上面那样，再来看看函数的，事实上对于现在的你来说已经很简单了。</strong></p>
<ul>
<li><code>0 LOAD_CONST    1 ((1, 2)): 从常量池中加载元组, 我们说对于列表而言是先将内部的元素一个一个加载进来、然后通过BUILD_LIST构建一个列表, 但是对于元组来说则可以直接加载, 原因就是元组内的元素指向对象的地址不可以变</code></li>
<li><code>2 UNPACK_SEQUENCE    2: 解包</code></li>
<li><code>4 STORE_FAST    0 (a): 将解包得到两个常量中的第一个常量赋值给a</code></li>
<li><code>6 STORE_FAST    0 (B): 将解包得到两个常量中的第二个常量赋值给b</code></li>
<li><code>8 LOAD_FAST    0 (a): 加载局部变量a</code></li>
<li><code>10 LOAD_FAST    1 (b): 加载局部变量b</code></li>
<li><code>12 BINARY_ADD: 执行加法运算</code></li>
<li><code>14 RETURN_VALUE: 将返回值返回</code></li>
</ul>
<p><strong>所以从目前来看，这些字节码已经没什么难度了，但是我们看到调用函数是用过CALL_FUNCTION指令，那么这个指令都做了哪些事情呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_FUNCTION)</span>: &#123;</span><br><span class="line">    PREDICTED(CALL_FUNCTION);</span><br><span class="line">    <span class="comment">//sp: 运行时栈栈顶指针</span></span><br><span class="line">    <span class="comment">//res: 函数的返回值, 一个PyObject *</span></span><br><span class="line">    PyObject **sp, *res;</span><br><span class="line">    <span class="comment">//指向运行时栈的栈顶</span></span><br><span class="line">    sp = stack_pointer;</span><br><span class="line">    <span class="comment">//调用函数, 将返回值赋值给res, tstate表示线程对象, &amp;sp显然是一个三级指针了, oparg表示指令的操作数</span></span><br><span class="line">    res = call_function(tstate, &amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">    stack_pointer = sp;</span><br><span class="line">    PUSH(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重点是call_function函数，我们来看一下，同样位于 *ceval.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyCFunction_Check(op) (Py_TYPE(op) == &amp;PyCFunction_Type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFunction_Check(op) (Py_TYPE(op) == &amp;PyFunction_Type)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(PyObject *) _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">call_function</span><span class="params">(PyThreadState *tstate, PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取PyFunctionObject对象，因为pp_stack是在CALL_FUNCTION指令中传入的栈顶指针</span></span><br><span class="line">    <span class="comment">//传入的oparg是0，kwnames是NULL，这里的pfunc就是MAKE_FUNCTION中创建的PyFunctionObject对象</span></span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里的func和pfunc是一样的</span></span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    PyObject *x, *w;</span><br><span class="line">    <span class="comment">//处理参数，对于我们当前的函数来说，这里的nkwargs和nargs都是0    </span></span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs;</span><br><span class="line">    <span class="comment">//移动栈指针</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//然后这里有两种执行方式, 我们后面会说, 但是我们看到将返回值赋值给了x</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;use_tracing) &#123;</span><br><span class="line">        x = trace_call_function(tstate, func, <span class="built_in">stack</span>, nargs, kwnames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = _PyObject_Vectorcall(func, <span class="built_in">stack</span>, nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert((x != <span class="literal">NULL</span>) ^ (_PyErr_Occurred(tstate) != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空函数栈</span></span><br><span class="line">    <span class="keyword">while</span> ((*pp_stack) &gt; pfunc) &#123;</span><br><span class="line">        w = EXT_POP(*pp_stack);</span><br><span class="line">        Py_DECREF(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">trace_call_function</span><span class="params">(PyThreadState *tstate,</span></span><br><span class="line"><span class="params">                    PyObject *func,</span></span><br><span class="line"><span class="params">                    PyObject **args, Py_ssize_t nargs,</span></span><br><span class="line"><span class="params">                    PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *x; <span class="comment">//返回值</span></span><br><span class="line">    <span class="comment">//调用_PyObject_Vectorcall, 将返回值设置给x</span></span><br><span class="line">    <span class="keyword">if</span> (PyCFunction_Check(func)) &#123;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func, args, nargs, kwnames));</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里暂时先不用管, 这里是调用一个方法, 显然它是和类相关, 我们在介绍类的时候会说</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Py_TYPE(func) == &amp;PyMethodDescr_Type &amp;&amp; nargs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *self = args[<span class="number">0</span>];</span><br><span class="line">        func = Py_TYPE(func)-&gt;tp_descr_get(func, self, (PyObject*)Py_TYPE(self));</span><br><span class="line">        <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func,</span><br><span class="line">                                        args+<span class="number">1</span>, nargs<span class="number">-1</span>,</span><br><span class="line">                                        kwnames));</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_Vectorcall(func, args, nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后会调用 *_PyFunction_FastCallDict* 函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func); <span class="comment">//获取PyCodeObject对象</span></span><br><span class="line">    PyObject *globals = PyFunction_GET_GLOBALS(func);<span class="comment">//获取global名字空间</span></span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);<span class="comment">//获取参数</span></span><br><span class="line">    PyObject *kwdefs, *closure, *name, *qualname; <span class="comment">//一些其它属性</span></span><br><span class="line">    PyObject *kwtuple, **k;</span><br><span class="line">    PyObject **d;</span><br><span class="line">    Py_ssize_t nd, nk;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(func != <span class="literal">NULL</span>);</span><br><span class="line">    assert(nargs &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(nargs == <span class="number">0</span> || args != <span class="literal">NULL</span>);</span><br><span class="line">    assert(kwargs == <span class="literal">NULL</span> || PyDict_Check(kwargs));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们观察一下下面的return</span></span><br><span class="line">    <span class="comment">//一个是function_code_fastcall，一个是最后的_PyEval_EvalCodeWithName</span></span><br><span class="line">    <span class="comment">//从名字上能看出来function_code_fastcall是一个快分支, 它适用于没有参数函数</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fast paths */</span></span><br><span class="line">        <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">            <span class="comment">//function_code_fastcall里面逻辑很简单</span></span><br><span class="line">            <span class="comment">//直接抽走当前PyFunctionObject里面PyCodeObject和函数运行时的global命名空间等信息</span></span><br><span class="line">            <span class="comment">//根据PyCodeObject对象直接为其创建一个PyFrameObject对象，然后PyEval_EvalFrameEx执行栈帧</span></span><br><span class="line">            <span class="comment">//也就是真正的进入了函数调用，执行函数里面的代码</span></span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, nargs, globals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)) &#123;</span><br><span class="line">            <span class="comment">/* function called with no arguments, but all parameters have</span></span><br><span class="line"><span class="comment">               a default value: use default values as arguments .*/</span></span><br><span class="line">            args = _PyTuple_ITEMS(argdefs);</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, PyTuple_GET_SIZE(argdefs),</span><br><span class="line">                                          globals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//适用于有参数的情况</span></span><br><span class="line">    nk = (kwargs != <span class="literal">NULL</span>) ? PyDict_GET_SIZE(kwargs) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nk != <span class="number">0</span>) &#123;</span><br><span class="line">        Py_ssize_t pos, i;</span><br><span class="line">        kwtuple = PyTuple_New(<span class="number">2</span> * nk);</span><br><span class="line">        <span class="keyword">if</span> (kwtuple == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = _PyTuple_ITEMS(kwtuple);</span><br><span class="line">        pos = i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(kwargs, &amp;pos, &amp;k[i], &amp;k[i+<span class="number">1</span>])) &#123;</span><br><span class="line">            Py_INCREF(k[i]);</span><br><span class="line">            Py_INCREF(k[i+<span class="number">1</span>]);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i / <span class="number">2</span> == nk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwtuple = <span class="literal">NULL</span>;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取相关参数</span></span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func);</span><br><span class="line">    closure = PyFunction_GET_CLOSURE(func);</span><br><span class="line">    name = ((PyFunctionObject *)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = _PyTuple_ITEMS(argdefs);</span><br><span class="line">        nd = PyTuple_GET_SIZE(argdefs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果有参数的话，现在会走这一步，逻辑会复杂一些，不过这些都是后话了</span></span><br><span class="line">    <span class="comment">//但是显然最终也会经过PyEval_EvalFrameEx, 进而进入哪一个大大的for循环</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs,</span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230612755-992873571.png" alt="img"></p>
<p><strong>因此我们看到，总共有两条路径，分别针对无参和有参，但是最终殊途同归、都会走到PyEval_EvalFrameEx那里。然后虚拟机在新的栈帧中执行新的PyCodeObject，而这个PyCodeObject就是函数对应的PyCodeObject。</strong></p>
<p><strong>但是到这里恐怕就有人有疑问了，我们之前说过PyFrameObject是根据PyCodeObject创建的，而PyFunctionObject也是根据PyCodeObject创建的，那么PyFrameObject和PyFunctionObject之间有啥关系呢？</strong></p>
<blockquote>
<p><strong>如果把PyCodeObject比喻成”妹子”的话，那么PyFunctionObject就是妹子的”备胎”，PyFrameObject就是妹子的”心上人”。其实PyEval_EvalFrameEx在栈帧中执行的时候，PyFunctionObject的影响就已经消失了，真正对栈帧产生影响的是PyFunctionObject里面的PyCodeObject对象和global名字空间。也就是说，最终是PyFrameObject对象和PyCodeObject对象两者如胶似漆，跟PyFunctionObject对象之间没有关系，所以PyFunctionObject辛苦一场，实际上是为别人做了嫁衣。PyFunctionObject主要是对PyCodeObject和global名字空间的一种打包和运输方式。</strong></p>
</blockquote>
<p><strong>另外我们这里提到了快速通道，那么函数是通过什么来判断是否可以进入快速通道呢？答案是通过函数参数的形式来决定是否可以进入快速通道，下面我们就来看看函数中参数的实现。</strong></p>
<h3 id="函数参数的实现"><a href="#函数参数的实现" class="headerlink" title="函数参数的实现"></a>函数参数的实现</h3><p><strong>函数最大的特点就是可以传入参数，否则就只能单纯的封装，这样未免太无趣了。对于Python来说，参数会传什么对于函数来说是不知道的，函数体内部只是利用参数做一些事情，比如调用参数的get方法，但是到底能不能调用get方法，就取决于你给参数传的值到底是什么了。因此可以把参数看成是一个占位符，我们假设有这么个东西，直接把它当成已存在的变量或者常量去进行操作，然后调用的时候，将某个值传进去赋给相应的参数，然后参数对应着传入的具体的值将逻辑走一遍即可。</strong></p>
<h4 id="参数类别"><a href="#参数类别" class="headerlink" title="参数类别"></a>参数类别</h4><p><strong>在Python中，调用函数时所传递的参数根据形式的不同可以分为四种类别：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>位置参数(positional argument)：</strong><code>foo(a, b), a和b通过位置参数传递</code></li>
<li><strong>关键字参数(keyword argument)：</strong><code>foo(a=1, b=2), a和b通过关键字参数</code></li>
<li><strong>扩展位置参数(excess positional argument)：</strong><code>foo(*args), args通过扩展位置参数传递</code></li>
<li>**扩展关键字参数(excess keyword argument)**：<code>foo(**kwargs), kwargs通过扩展位置参数传递</code></li>
</ul>
<p><strong>我们下面来看一下python的call_function是如何处理函数信息的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_LOCAL_INLINE(PyObject *) _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">call_function</span><span class="params">(PyThreadState *tstate, PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;</span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    PyObject *x, *w;</span><br><span class="line">    <span class="comment">/*当python虚拟机在开始执行MAKE_FUNCTION指令时，会先获取一个指令参数oparg</span></span><br><span class="line"><span class="comment">    oparg里面记录函数的参数个数信息，包括位置参数和关键字参数的个数。</span></span><br><span class="line"><span class="comment">    虽然扩展位置参数和扩展关键字参数是更高级的用法，但是本质上也是由多个位置参数、多个关键字参数组成的。</span></span><br><span class="line"><span class="comment">    这就意味着，虽然Python中存在四种参数，但是只要记录位置参数和关键字参数的个数，就能知道一共有多少个参数，进而知道一共需要多大的内存来维护参数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//nkwargs就是关键字参数的个数，nargs是位置参数的个数 </span></span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs;</span><br><span class="line">    PyObject **<span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br></pre></td></tr></table></figure>

<p><strong>而且Python的每个指令都是两个字节，第一个字节存放指令序列本身，第二个字节存放参数个数，既然是一个字节，说明最多只允许有255个参数，不过这已经足够了。但是在Python3.8中，这个限制被打破了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze3ik2oh85c6hanp0hmZ ~]<span class="comment"># python3 1.py </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;1.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">exec</span>(s))</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">SyntaxError: more than <span class="number">255</span> arguments</span><br><span class="line">[root@iZ2ze3ik2oh85c6hanp0hmZ ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p><strong>以我阿里云上的Python3.6为例，发现参数不能超过255个，但是在Python3.8的时候，即使有1000000个参数也是没问题的。所以Python3.8的源码变动是有些大的，3.6和3.7实际上是差不多的，虚拟机实现代码甚至和Python2也高度相似。但是在Python3.8，变动就有点大了。</strong></p>
<p><strong>Python函数内部局部变量信息，可以通过co_nlocals和co_argcount来获取。从名字也能看出来这个不是PyFunctionObject里面的，而是PyCodeObject里面的。co_nlocals，我们之前说过，这是函数内部局部变量的个数，co_argcount是参数的个数。实际上，函数参数和函数局部变量是非常密切的，某种意义上函数参数就是一种函数局部变量，它们在内存中是连续放置的。当Python需要为函数申请局部变量的内存空间时，就需要通过co_nlocals知道局部变量的总数。不过既然如此，那还要co_argcount干什么呢？别急，看个例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>函数的参数也是一个局部变量，因此co_nlocals是参数的个数加上函数体中新创建的局部变量的个数。注意函数参数也是一个局部变量，比如参数有一个a，但是函数体里面的变量还是a，相当于重新赋值了，因此还是相当于一个参数。但是co_argcount则是存储记录参数的个数。因此一个很明显的结论：<code>对于任意一个函数，co_nlocals至少是大于等于co_argcount的</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span>, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><strong>另外我们看到，对于扩展位置参数、扩展关键字参数来说，co_argcount是不算在内的，因为你完全可以不传递，所以直接当成0来算。而对于co_nlocals来说，我们在函数体内部肯定是能拿到args和kwargs的，而这可以看成是两个参数。因此co_argcount是4，co_nlocals是6。其实所有的扩展位置参数是存在了一个PyTupleObject对象中的，所有的扩展关键字参数是存储在一个PyDictObject对象中的。而即使我们多传、或者不传，对于co_argcount和co_nlocals来说，都不会有任何改变了，因为这两者的值是在编译的时候就已经确定了的。</strong></p>
<h4 id="位置参数的传递"><a href="#位置参数的传递" class="headerlink" title="位置参数的传递"></a>位置参数的传递</h4><p><strong>下面我们就来看看位置参数是如何传递的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def f(name, age):</span></span><br><span class="line"><span class="string">    age = age + 5</span></span><br><span class="line"><span class="string">    print(name, age)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">age = 5</span></span><br><span class="line"><span class="string">f(&quot;satori&quot;, age)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis </span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>字节码如下，我们来分析一下，当然基础的就一笔带过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object f at <span class="number">0x00000224C3941450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (f)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (<span class="number">5</span>)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (age)</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;satori&#x27;</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_NAME                <span class="number">1</span> (age)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span> <span class="comment">//oparg是2, 表示调用的时候传递了两个参数</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">4</span> (None)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object f at <span class="number">0x00000224C3941450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (age) <span class="comment">//此时age和对应的值已经存在函数的符号表和常量池当中了</span></span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)  <span class="comment">//加载常量5</span></span><br><span class="line">              <span class="number">4</span> BINARY_ADD</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (age) <span class="comment">//相加之后, 重新使用age保存</span></span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_GLOBAL              <span class="number">0</span> (print) <span class="comment">//加载print</span></span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">0</span> (name) <span class="comment">//加载局部变量name和age</span></span><br><span class="line">             <span class="number">12</span> LOAD_FAST                <span class="number">1</span> (age)</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION            <span class="number">2</span>  <span class="comment">//函数调用,显然是print, 参数是两个</span></span><br><span class="line">             <span class="number">16</span> POP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">20</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码虽然解释完了， 但是最重要的还是没有说。<code>f(name, age)</code>，这里的name和age显然是外层定义的，但是外层定义的这两个变量是怎么传给函数f的。下面我们通过源码重新分析：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;satori&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> LOAD_NAME                <span class="number">1</span> (age)</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到<code>CALL_FUNCTION</code>上面有三条指令，其实当这三条指令执行完毕之后，函数需要的参数已经被压入了运行时栈中。</strong></p>
<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230620325-1367321592.png" alt="img"></p>
<p><strong>通过 *_PyFunction_FastCallDict* 函数，然后执行function_code_fastcall。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line"><span class="type">static</span> PyObject* _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">function_code_fastcall</span><span class="params">(PyCodeObject *co, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span></span><br><span class="line"><span class="params">                       PyObject *globals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *f; <span class="comment">//栈帧对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET(); <span class="comment">//线程状态对象</span></span><br><span class="line">    PyObject **fastlocals; <span class="comment">//f-&gt;localsplus, 后面会说</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(globals != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* XXX Perhaps we should create a specialized</span></span><br><span class="line"><span class="comment">       _PyFrame_New_NoTrack() that doesn&#x27;t take locals, but does</span></span><br><span class="line"><span class="comment">       take builtins without sanity checking them.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建与函数对应的PyFrameObject，我们看到参数是co，所以是根据字节码指令来创建的</span></span><br><span class="line">    <span class="comment">//然后还有一个globals, 表示global名字空间, 所以我们看到最后实际上没有PyFunctionObject什么事, 它只是起到一个输送的作用</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_INCREF(*args);</span><br><span class="line">        fastlocals[i] = *args++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键：拷贝函数参数，从运行时栈到PyFrameObject.f_localsplus</span></span><br><span class="line">    result = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_REFCNT(f) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++tstate-&gt;recursion_depth;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        --tstate-&gt;recursion_depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源码中我们看到通过 *_PyFrame_New_NoTrack*  创建了函数f对应的PyFrameObject对象，参数是co对应的PyFunctionObject对象中保存的PyCodeObject对象。随后，Python虚拟机将参数逐个拷贝到新建的PyFrameObject对象的f_localsplus中。可在分析Python虚拟机框架时，我们知道，这个f_localsplus所指向的内存块里面也存储了Python虚拟机所使用的那个运行时栈。那么参数所占的内存和运行时栈所占的内存有什么关联呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是_PyFrame_New_NoTrack，对外暴露的是PyFrame_New,但是本质上调用了这个</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">        ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">        nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">        extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        <span class="keyword">if</span> (free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//为f_localsplus申请内存空间, 大小为extras, 注意这个extras, 我们看到它实际上分为四个部分</span></span><br><span class="line">            <span class="comment">//分别是: 运行时栈、局部变量、cell对象、free对象, 注意:但在内存中它们可不是这个顺序</span></span><br><span class="line">            f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type,</span><br><span class="line">            extras);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(builtins);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        f-&gt;f_code = code;</span><br><span class="line">        <span class="comment">//获取局部变量的个数 + cell对象的个数 + free对象的个数</span></span><br><span class="line">        extras = code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        f-&gt;f_valuestack = f-&gt;f_localsplus + extras;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;extras; i++)</span><br><span class="line">            f-&gt;f_localsplus[i] = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前面提到，在函数对应的PyCodeObject对象的co_nlocals域中，包含着函数参数的个数，因为函数参数也是局部符号的一种。所以从f_localsplus开始，extras中一定有供函数参数使用的内存。或者说，函数的参数存放在运行时栈之前的那段内存中。</strong></p>
<p><strong>另外从_PyFrame_New_NoTrack当中我们可以看到，在数组f_localsplus中存储函数参数的空间和运行时栈的空间在逻辑上是分离的，并不是共享同一片内存，尽管它们是连续的，但这两者是鸡犬相闻，但又泾渭分明、老死不相往来。</strong></p>
<p><strong>在处理完参数之后，还没有进入PyEval_EvalFrameEx，所以此时运行时栈是空的。但是函数的参数已经位于f_localsplus中了。所以这时新建PyFrameObject对象的f_localsplus就是这样：</strong></p>
<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230635471-1010256465.png" alt="img"></p>
<h4 id="位置参数的访问"><a href="#位置参数的访问" class="headerlink" title="位置参数的访问"></a>位置参数的访问</h4><p><strong>当参数拷贝的动作完成之后，就会进入新的PyEval_EvalFrameEx，开始真正的f的调用动作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (age) </span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)  </span><br><span class="line">            <span class="number">4</span> BINARY_ADD</span><br><span class="line">            <span class="number">6</span> STORE_FAST               <span class="number">1</span> (age) </span><br></pre></td></tr></table></figure>

<p><strong>首先对参数的读写，肯定是通过<code>LOAD_FAST</code>,<code>LOAD_CONST</code>,<code>STORE_FAST</code>这几条指令集完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个宏, 这里的fastlocals显然就是f -&gt; localsplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETLOCAL(i)     (fastlocals[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_FAST)</span>: &#123;</span><br><span class="line">            <span class="comment">//从fastlocals中获取索引为oparg的值</span></span><br><span class="line">            PyObject *value = GETLOCAL(oparg);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format_exc_check_arg(tstate, PyExc_UnboundLocalError,</span><br><span class="line">                                     UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                                     PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_FAST)</span>: &#123;</span><br><span class="line">            PREDICTED(STORE_FAST);</span><br><span class="line">            PyObject *value = POP(); <span class="comment">//弹出元素</span></span><br><span class="line">            SETLOCAL(oparg, value);  <span class="comment">//将索引为oparg的元素设置为value</span></span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们发现，LOAD_FAST和STORE_FAST这一对指令是以f_localsplus这一片内存为操作目标的，指令<code>0 LOAD_FAST 1 (age)</code>的结果是将f_localsplus[1]对应的对象压入到运行时栈中。而在完成加法操作之后，又将结果通过STORE_FAST放入到f_localsplus[1]中，这样就实现了对a的更新，那么以后在print(a)的时候，得到的结果就是10了。</strong></p>
<p><strong>现在关于Python的位置参数在函数调用时是如何传递的、在函数执行又是如何被访问的，已经真相大白了。在调用函数时，Python将函数参数的值从左至右依次压入到运行时栈中，而在call_function中通过调用 *_PyFunction_FastCallDict*  ，进而调用function_code_fastcall，而在function_code_fastcall中，又将这些参数依次拷贝到和PyFrameObject对象的f_localsplus中。最终的效果就是，Python虚拟机将函数调用时使用的参数，从左至右依次地存放在新建的PyFrameObject对象的f_localsplus中。</strong></p>
<p><strong>因此在访问函数参数时，python虚拟机并没有按照通常访问符号的做法，去查什么名字空间，而是直接通过一个索引<code>(偏移位置)</code>来访问f_localsplus中存储的符号对应的值，是的，f_localsplus存储的是符号<code>(变量名)</code>，并不是具体的值。因为我们说Python中的变量只是一个指针，至于值是否改变，则取决于对应的值是可变对象还是不可变对象，而不是像其他编程语言那样通过传值或者传指针来决定是否改变。因此这种通过索引<code>(偏移位置)</code>来访问参数的方式也正是位置参数的由来。</strong></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p><strong>Python函数的一个特点就是支持默认参数，这是非常方便的，我们来看看实现机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def foo(a=1, b=2):</span></span><br><span class="line"><span class="string">    print(a + b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">5</span> ((<span class="number">1</span>, <span class="number">2</span>))//我们看到在构造函数的时候就已经把默认值加载进来了</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">2</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x000002076ED83BE0</span>, file <span class="string">&quot;default&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> MAKE_FUNCTION            <span class="number">1</span> (defaults) </span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">10</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x000002076ED83BE0</span>, file <span class="string">&quot;default&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们对比一下开始的没有默认参数的函数，会发现相比于无默认参数的函数，有默认参数的函数，除了load函数体对应的PyCodeObject、和foo这个符号之外，会先将默认参数的值给load进来，将这三者都压入运行时栈。但是我们发现这是默认参数是组合成一个元组的形式入栈的，而且我们再来观察一下<code>MAKE_FUNCTION</code>这个指令，我们发现后面的参数是1 (defaults)，之前的都是0，那么这个1是什么呢？而且又提示了我们一个defaults，我们知道PyFunctionObject对象有一个func_defaults，这两者之间有关系吗？那么带着这些疑问再来看看<code>MAKE_FUNCTION</code>指令。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(MAKE_FUNCTION)</span>: &#123;</span><br><span class="line">    PyObject *qualname = POP();</span><br><span class="line">    PyObject *codeobj = POP();</span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////默认参数，我们发现确实是存储在func_defaults里面</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过以上命令我们很容易看出，<code>MAKE_FUNCTION</code>指令除了创建PyFunctionObject对象，并且还会处理参数的默认值。<code>MAKE_FUNCTION</code>指令参数表示当前运行时栈中是存在默认值的，但是默认值具体多少个通过参数是看不到的，因为默认值都会按照顺序塞到一个PyTupleObject对象里面，所以整体相当于是一个。然后会调用<code>PyFunction_SetDefaults</code>将该PyTupleObject对象设置为PyFunctionObject.func_defaults的值，在Python层面可以使用<code>__defaults__</code>访问。如此一来，函数参数的默认值也成为了PyFunctionObject对象的一部分，函数和其参数的默认值最终被Python虚拟机捆绑在了一起，它和PyCodeObject、global命名空间一样，也被塞进了PyFunctionObject这个大包袱。所以说PyFunctionObject这个嫁衣做的是很彻底的，工具人PyFunctionObject对象，给个赞。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyFunction_SetDefaults</span><span class="params">(PyObject *op, PyObject *defaults)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyFunction_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defaults == Py_None)</span><br><span class="line">        defaults = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (defaults &amp;&amp; PyTuple_Check(defaults)) &#123;</span><br><span class="line">        Py_INCREF(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError, <span class="string">&quot;non-tuple default args&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将PyFunctionObject对象的func_defaults成员设置为defaults</span></span><br><span class="line">    Py_XSETREF(((PyFunctionObject *)op)-&gt;func_defaults, defaults);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们还是以这个foo函数为例，看看不同的调用方式对应的底层实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a=<span class="number">1</span>, b=<span class="number">2</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>

<p>​        <strong>不传入参数，直接执行foo()</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的PyCodeObject</span></span><br><span class="line">    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的global名字空间</span></span><br><span class="line">    PyObject *globals = PyFunction_GET_GLOBALS(func);</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的默认值</span></span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);</span><br><span class="line">    <span class="comment">//一些额外属性</span></span><br><span class="line">    PyObject *kwdefs, *closure, *name, *qualname;</span><br><span class="line">    PyObject *kwtuple, **k;</span><br><span class="line">    PyObject **d;</span><br><span class="line">    Py_ssize_t nd, nk;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(func != <span class="literal">NULL</span>);</span><br><span class="line">    assert(nargs &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(nargs == <span class="number">0</span> || args != <span class="literal">NULL</span>);</span><br><span class="line">    assert(kwargs == <span class="literal">NULL</span> || PyDict_Check(kwargs));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里进行判断能否进入快速通道, 一个函数如果想进入快速通道必须要满足两个条件</span></span><br><span class="line">    <span class="comment">//1. 函数定义的时候不可以有默认参数; 2. 函数调用时，必须都通过位置参数指定。</span></span><br><span class="line">    <span class="comment">//所以这里检测co_kwonlyargcount和kwargs是否均为零</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//然后继续检测: 这里的nargs是通过call_function函数传递的</span></span><br><span class="line">        <span class="comment">//而这个nargs在call_function函数中是Py_ssize_t nargs = oparg - nkwargs;</span></span><br><span class="line">        <span class="comment">//所以这里的nargs就是传递的参数个数减去通过关键字参数方式传递的参数个数</span></span><br><span class="line">        <span class="comment">//而co_argcount是函数参数的总个数，所以一旦哪怕有一个参数使用了关键字参数的方式传递，都会造成两者不相等，从而无法进入快速通道</span></span><br><span class="line">        <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, nargs, globals);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//但是这样的条件确实有点苛刻了，毕竟参数哪能没有默认值呢？所以Python还提供了一种进入快速通道的方式</span></span><br><span class="line">        <span class="comment">//我们发现在有默认的前提下，如果还能满足nargs==0 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)也能进入快速通道</span></span><br><span class="line">        <span class="comment">//co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)是要求函数的参数个数必须等于默认参数的个数，也就是函数参数全是默认参数</span></span><br><span class="line">        <span class="comment">//nargs==0则是需要传入的参数个数减去通过关键字参数传递的参数个数等于0，即要么不传参(都是用默认参数)、要么全部都通过关键字参数的方式传参。</span></span><br><span class="line">        <span class="comment">//这种方式也可以进入快速通道</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)) &#123;</span><br><span class="line">            args = _PyTuple_ITEMS(argdefs);</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, PyTuple_GET_SIZE(argdefs),</span><br><span class="line">                                          globals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果以上两点都无法满足的话，那么就没办法了，只能走常规方法了</span></span><br><span class="line">    <span class="comment">//获取默认参数的信息</span></span><br><span class="line">    nk = (kwargs != <span class="literal">NULL</span>) ? PyDict_GET_SIZE(kwargs) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nk != <span class="number">0</span>) &#123;</span><br><span class="line">        Py_ssize_t pos, i;</span><br><span class="line"></span><br><span class="line">        kwtuple = PyTuple_New(<span class="number">2</span> * nk);</span><br><span class="line">        <span class="keyword">if</span> (kwtuple == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = _PyTuple_ITEMS(kwtuple);</span><br><span class="line">        pos = i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(kwargs, &amp;pos, &amp;k[i], &amp;k[i+<span class="number">1</span>])) &#123;</span><br><span class="line">            Py_INCREF(k[i]);</span><br><span class="line">            Py_INCREF(k[i+<span class="number">1</span>]);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i / <span class="number">2</span> == nk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwtuple = <span class="literal">NULL</span>;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是获取函数的一些属性，默认关键字参数、闭包等等</span></span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func);</span><br><span class="line">    closure = PyFunction_GET_CLOSURE(func);</span><br><span class="line">    name = ((PyFunctionObject *)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取默认参数的值的地址、以及默认参数的个数</span></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = _PyTuple_ITEMS(argdefs);</span><br><span class="line">        nd = PyTuple_GET_SIZE(argdefs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用_PyEval_EvalCodeWithName, 传入函数的PyCodeObject对象以及参数信息</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs, </span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_PyEval_EvalCodeWithName</code>是一个非常重要的函数，在后面分析扩展位置参数和扩展关键字参数是还会遇到。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyCodeObject对象, 通过_PyFunction_FastCallDict中接收的func得到</span></span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;</span><br><span class="line">    <span class="comment">//栈帧</span></span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    PyObject *retval = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//f -&gt; localsplus, 和co -&gt; co_freevars, 这个co_freevars、以及co_freevars都是与闭包相关的</span></span><br><span class="line">    PyObject **fastlocals, **freevars;</span><br><span class="line">    PyObject *x, *u;</span><br><span class="line">    <span class="comment">//参数总个数: 可以通过位置参数传递的参数个数  +  只能通过关键字参数传递的参数个数</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount;</span><br><span class="line">    Py_ssize_t i, j, n;</span><br><span class="line">    PyObject *kwdict;</span><br><span class="line"></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();  <span class="comment">//获取线程状态对象</span></span><br><span class="line">    assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (globals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;PyEval_EvalCodeEx: NULL globals&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建栈帧</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//还记得这个co_flags吗? 我们说它是用来判断参数的, 如果它和0x08进行&quot;与运算&quot;结果为真, 那么说明有**kwargs</span></span><br><span class="line">    <span class="comment">//如果它和0x04进行&quot;与运算&quot;结果为真, 那么说明有*args</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        kwdict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        i = total_args;</span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        SETLOCAL(i, kwdict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwdict = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//argcount是实际传来的位置参数的个数，co-&gt;co_argcount则是可以通过位置参数传递的参数个数</span></span><br><span class="line">    <span class="comment">//如果argcount &gt; co-&gt;co_argcount，证明有扩展参数，否则没有    </span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        <span class="comment">//所以这里的n等于co-&gt;co_argcount</span></span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有扩展位置参数, 那么调用者通过位置参数的方式传了几个、n就是几</span></span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后我们仔细看一下这个n，假设我们定义了一个函数def foo(a, b, c=1,d=2, *args)</span></span><br><span class="line">    <span class="comment">//如果argcount &gt; co-&gt;co_argcount, 说明我们传递的位置参数的个数超过了4个，但n是4</span></span><br><span class="line">    <span class="comment">//但是如果我们只传递了两个，比如foo(&#x27;a&#x27;, &#x27;b&#x27;)，那么n显然为2</span></span><br><span class="line">    <span class="comment">//下面就是将已经传递的参数的值依次设置到f_localsplus里面去，这里的j就是索引，x就是值。</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        x = args[j];</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">        SETLOCAL(j, x);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面显然是扩展位置参数参数的逻辑，我们暂时先跳过，后面会说</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        u = _PyTuple_FromArray(args + n, argcount - n);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        SETLOCAL(total_args, u);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//关键字参数，同样后面说</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会再进行检测，argcount &gt; co-&gt;co_argcount说明我们多传递了, 然后检测是否存在*args</span></span><br><span class="line">    <span class="comment">//如果co-&gt;co_flags &amp; CO_VARARGS为False, 那么直接报错</span></span><br><span class="line">    <span class="keyword">if</span> ((argcount &gt; co-&gt;co_argcount) &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) &#123;</span><br><span class="line">        too_many_positional(tstate, co, argcount, defcount, fastlocals);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果传入的参数个数比函数定义的参数的个数少，那么证明有默认参数。</span></span><br><span class="line">    <span class="comment">//defcount表示设置了默认参数的个数</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &lt; co-&gt;co_argcount) &#123;</span><br><span class="line">        <span class="comment">//显然m = 参数总个数(不包括*args和**kwargs之外的所有形参的个数) - 默认参数的个数</span></span><br><span class="line">        Py_ssize_t m = co-&gt;co_argcount - defcount;</span><br><span class="line">        Py_ssize_t missing = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因此m就是需要传递的没有默认值的参数的总个数</span></span><br><span class="line">        <span class="keyword">for</span> (i = argcount; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//而i=argcount则是我们调用函数时传递的位置参数的总个数，很明显如果参数足够，那么 i &lt; m 是不会满足的</span></span><br><span class="line">            <span class="comment">//比如一个函数接收6个参数，但是有两个是默认参数，因此这就意味着调用者通过位置参数的方式传递的话，需要至少传递4个，那么m就是4</span></span><br><span class="line">            <span class="comment">//而如果我们也传递了四个，那么初始的i同样是 4</span></span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//但如果我们只传递了两个，那么通过GETLOCAL从f -&gt; f_localsplus中就会获取不到值</span></span><br><span class="line">                <span class="comment">//而一旦找不到，missing：缺少的参数个数就会+1</span></span><br><span class="line">                missing++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//那么按照我们上面的逻辑，显然还有两个没传递，但是它们会使用默认值</span></span><br><span class="line">        <span class="comment">//如果是只传递了3个参数, 那么显然还有3个参数没有传, 但默认值只有两个, 因此missing不为0</span></span><br><span class="line">        <span class="keyword">if</span> (missing) &#123;</span><br><span class="line">            <span class="comment">//直接抛出异常</span></span><br><span class="line">            missing_arguments(tstate, co, missing, defcount, fastlocals);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面可能难理解，我们说这个m，是需要由调用者传递的参数个数</span></span><br><span class="line">        <span class="comment">//而n是以位置参数的形式传递过来的参数的个数，如果比函数参数个数少，那么n就是传来的参数个数，如果比函数参数的个数大，那么n则是函数参数的个数。比如：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        def foo(a, b, c, d=1, e=2, f=3):</span></span><br><span class="line"><span class="comment">        	pass</span></span><br><span class="line"><span class="comment">        这是一个有6个参数的函数，显然m是3，实际上函数定义好了，m就是一个不变的值了，就是没有默认参数的参数总个数</span></span><br><span class="line"><span class="comment">        但是我们调用时可以是foo(1,2,3)，也就是只传递3个，那么这里的n就是3，</span></span><br><span class="line"><span class="comment">        foo(1, 2, 3, 4, 5)，那么显然n=5，而m依旧是3</span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">            <span class="comment">//因此现在这里的逻辑就很好理解了，假设调用时foo(1, 2, 3, 4, 5)</span></span><br><span class="line">            <span class="comment">//由于有3个是默认参数，那么调用只传递3个就可以了，但是这里传递了5个，前3个是必传的</span></span><br><span class="line">            <span class="comment">//至于后面两个，则说明我不想使用默认值，我想重新传递，而使用默认值的只有最后一个</span></span><br><span class="line">            <span class="comment">//所以这个i就是明明可以使用默认值、但却没有使用的参数的个数            </span></span><br><span class="line">            i = n - m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//另外如果按照位置参数传递的话，程序能走到这一步，说明已经不存在少传的情况了</span></span><br><span class="line">            <span class="comment">//因此这个n至少是&gt;=m的，因此如果n == m的话，那么i就是0</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; defcount; i++) &#123;     </span><br><span class="line">            <span class="comment">//默认参数的值一开始就已经被压入栈中，整体作为一个PyTupleObject对象，被设置到了func_defaults这个域中</span></span><br><span class="line">            <span class="comment">//但是对于函数的参数来讲，肯定还要设置到f_localsplus里面去，并且它只能是在后面。</span></span><br><span class="line">            <span class="comment">//因为默认参数的顺序要在非默认参数之后            </span></span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(m+i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//这里是把索引为i对应的值从func_defaults对应的PyTupleObject里面取出来</span></span><br><span class="line">                <span class="comment">//这个i要么是n-m，要么是0。还按照之前的例子，函数接收6个参数，但是我们传了5个</span></span><br><span class="line">                <span class="comment">//因此我们只需要将最后一个、也就是索引为2的元素拷贝到f_localsplus里面去即可。</span></span><br><span class="line">                <span class="comment">//而n=5，m=3，显然i = 2</span></span><br><span class="line">                <span class="comment">//那么如果我们传递了3个呢？</span></span><br><span class="line">                <span class="comment">//显然i是0，因为此时n==m嘛，那么就意味着默认参数都使用默认值，既然这样，那就从头开始开始拷呗。</span></span><br><span class="line">                <span class="comment">//同理传了4个参数，证明第一个默认参数的默认值是不需要的，那么就只需要再把后面两个拷过去就可以了</span></span><br><span class="line">                <span class="comment">//那么显然要从索引为1的位置拷到结束，而此时n-m、也就是i，正好为1</span></span><br><span class="line">                <span class="comment">//所以，n-m就是&quot;默认参数值组成的PyTupleObject对象中需要拷贝到f_localsplus中的第一个值的索引&quot;</span></span><br><span class="line">                <span class="comment">//然后i &lt; defcount; i++，一直拷到结尾                             </span></span><br><span class="line">                PyObject *def = defs[i];</span><br><span class="line">                Py_INCREF(def);</span><br><span class="line">                <span class="comment">//将值设置到f_localsplus里面，这里显然索引是m+i</span></span><br><span class="line">                <span class="comment">//比如：def foo(a,b,c,d=1,e=2,f=3)</span></span><br><span class="line">                <span class="comment">//foo(1, 2, 3, 4)，显然d不会使用默认值，那么只需要把后两个默认值拷给e和f即可</span></span><br><span class="line">                <span class="comment">//显然e和f根据顺序在f_localsplus中对应索引为4、5</span></span><br><span class="line">                <span class="comment">//m是3，i是n-m等于4-3等于1，所以m+i正好是4，</span></span><br><span class="line">                <span class="comment">//f_localsplus: [1, 2, 3, 4]</span></span><br><span class="line">                <span class="comment">//PyTupleObject:(1, 2, 3)</span></span><br><span class="line">                <span class="comment">//因此PyTupleObject中索引为i的元素，拷贝到f_localsplus中正好是对应m+i的位置               </span></span><br><span class="line">                SETLOCAL(m+i, def);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此通过以上我们就知道了位置参数的默认值是怎么一回事了。</strong></p>
<p>​        <strong>传入一个关键字参数，执行foo(b&#x3D;3)</strong>    </p>
<p><strong>在对foo进行第二次调用的时候，我们指定了b&#x3D;3，但是调用方式本质是一样的。在<code>CALL_FUNCTION</code>之前，python虚拟机将PyUnicodeObject对象b和PyLongObject对象3压入了运行时栈。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;	</span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历关键字参数，确定函数的def语句中是否出现了关键字参数的名字 */</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">        PyObject **co_varnames;  <span class="comment">//符号表</span></span><br><span class="line">        PyObject *keyword = kwnames[i]; <span class="comment">//获取参数名</span></span><br><span class="line">        PyObject *value = kwargs[i];  <span class="comment">//获取参数值</span></span><br><span class="line">        Py_ssize_t j;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//显然参数必须是字符串, 所以在字典中你可以这么做: &#123;**&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;&#125;</span></span><br><span class="line">        <span class="comment">//但你不可以这么做: dict(**&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">if</span> (keyword == <span class="literal">NULL</span> || !PyUnicode_Check(keyword)) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() keywords must be strings&quot;</span>,</span><br><span class="line">                          co-&gt;co_name);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里的逻辑我们后面会详细说, 总之核心就是检测一个参数是否同时通过位置参数和关键字参数传递了, 也就是判断是否传递了两次</span></span><br><span class="line">        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;</span><br><span class="line">        <span class="comment">//在函数的符号表中寻找关键字参数, 注意: 这里的j不是从0开始的, 而是从posonlyargcount开始</span></span><br><span class="line">        <span class="comment">//因为在Python3.8中引入了/, 在/前面的参数只能通过位置参数传递</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="keyword">if</span> (name == keyword) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 逻辑和上面一样 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="type">int</span> cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">        assert(j &gt;= total_args);</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//如果符号表中没有出现指定的符号, 那么表示出现了一个不需要的关键字参数(当然**kwargs后面说)</span></span><br><span class="line">            <span class="keyword">if</span> (co-&gt;co_posonlyargcount</span><br><span class="line">                &amp;&amp; positional_only_passed_as_keyword(tstate, co,</span><br><span class="line">                                                     kwcount, kwnames))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got an unexpected keyword argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItem(kwdict, keyword, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      kw_found:</span><br><span class="line">        <span class="keyword">if</span> (GETLOCAL(j) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got multiple values for argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        SETLOCAL(j, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在编译时：Python会将函数的def语句中出现的符号都记录在符号表(co_varnames)里面。由于我们已经看到，在foo(b&#x3D;3)的指令序列中，Python虚拟机在执行<code>CALL_FUNCTION</code>指令之前会将关键字参数的名字都压入到运行时栈，那么在<code>_PyEval_EvalCodeWithName</code>中就能利用运行时栈中保存的关键字参数的名字在Python编译时得到的co_varnames中进行查找。最妙的是，在co_varnames中定义的变量名的顺序是由规律的的。而且经过刚才的分析，我们也知道，在PyFrameObject对象的f_localsplus所维护的内存中，用于存储函数参数的内存也是按照相同规律排列的。所以在co_varnames中搜索到关键字参数的参数名时，我们可以直接根据所得到的序号信息直接设置f_localsplus中的内存，这就为默认参数设置了函数调用者希望的值。</strong></p>
<p><strong>因此我们可以再举个简单例子，总结一下。def foo(a, b, c,  d&#x3D;1,e&#x3D;2,  f&#x3D;3)，对于这样的一个函数。首先Python虚拟机知道调用者至少要给a、b、c传递参数。如果是foo(1)，那么1会传递给a，但是b和c是没有接受到值的，所以报错。但如果是foo(1, e&#x3D;4, c&#x3D;2,  b&#x3D;3)，还是老规矩1传递给a，发现依旧不够，这时候会把希望寄托于关键字参数上。并且我们说过f_localsplus维护的内存中存储的参数的顺序、co_varnames中参数的顺序都是一致的。所以关键字参数是不讲究顺序的，当找到了e&#x3D;4，那么Python虚拟机通过co_varnames符号表，就知道把e设置为f_localsplus中索引为4的地方，c&#x3D;2，设置为索引为2的地方，b&#x3D;3，设置为索引为1的地方。那么当位置参数和关键字参数都是设置完毕之后，python虚拟机会检测需要传递的参数、也就是没有默认值的参数，调用者有没有全部传递。</strong></p>
<blockquote>
<p><strong>但是这里再插一句，我们说关键字参数设置具体设置在f_localsplus中的哪一个地方，是通过将关键字参数名代入到co_varnames符号表里面查找所得到的的，但是如果这个关键字参数的参数名不在co_varnames里面，怎么办？另外在我们讲位置参数的时候，如果传递的位置参数，比co_argcount还要多，怎么办？对，聪明如你，肯定知道了，就是我们下面要介绍扩展关键字、扩展位置参数。</strong></p>
</blockquote>
<h4 id="扩展位置参数和扩展关键字参数"><a href="#扩展位置参数和扩展关键字参数" class="headerlink" title="扩展位置参数和扩展关键字参数"></a>扩展位置参数和扩展关键字参数</h4><p><strong>之前我们看到了使用扩展位置参数和扩展关键字参数时指令参数个数的值，我们还是再看一遍吧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>**我们看到对于co_nlocals来说，它统计的是所有局部变量的个数，结果是4；但是对于co_argcount来说，统计的是不包括*args个*<em>kwargs的所有参数的个数，因此结果是2。既然如此，那么也如我们之前所分析的，*args可以接收多个位置参数，但是最终这些参数都会放在args这个PyTupleObject对象里面；*<em>kwargs可以接收多个关键字参数，但是这些关键字参数会组成一个PyDictObject对象，由kwargs指向。事实上也确实如此，即使不从源码的角度来分析，从Python的实际使用中我们也能得出这个结论。</em></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">foo(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), **&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>*<em>当然啦，在传递的时候如果对一个元组或者列表、甚至是字符串使用*，那么会将这个可迭代对象直接打散，相当于传递了多个位置参数。同理如果对一个字典使用*<em>，那么相当于传递了多个关键字参数。</em></em></p>
<p><strong>下面我们就来看看扩展参数是如何实现的，首先还是进入到 *_PyEval_EvalCodeWithName* 这个函数里面来，当然这个函数应该很熟悉了，我们看看扩展参数的处理。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           <span class="comment">//位置参数的相关信息</span></span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           <span class="comment">//关键字参数的相关信息                 </span></span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep, <span class="comment">//关键字参数个数</span></span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           <span class="comment">//默认值、闭包、函数名、全限定名等信息              </span></span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;<span class="comment">//拿到PyFunctionObject的PyCodeObject</span></span><br><span class="line">    PyFrameObject *f;<span class="comment">//声明一个PyFrameObject</span></span><br><span class="line">    PyObject *retval = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **fastlocals, **freevars;</span><br><span class="line">    PyObject *x, *u;</span><br><span class="line">    <span class="comment">//获取总参数的个数</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount;</span><br><span class="line">    Py_ssize_t i, j, n;</span><br><span class="line">    PyObject *kwdict;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">//创建一个栈帧</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的所有参数</span></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    <span class="comment">//闭包</span></span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否传递扩展关键字参数，CO_VARKEYWORDS和下面的CO_VARARGS都是标识符</span></span><br><span class="line">    <span class="comment">//用于判断是否出现了扩展关键字参数和扩展位置参数</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        <span class="comment">//创建一个字典</span></span><br><span class="line">        kwdict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="comment">//i是参数总个数，假设值foo(a, b, c, *args, **kwargs)</span></span><br><span class="line">        i = total_args;</span><br><span class="line">        <span class="comment">//如果还传递了扩展位置参数，那么i要加上1</span></span><br><span class="line">        <span class="comment">//因为即使是扩展，关键字参数依旧要在位置参数后面</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//如果没有扩展位置参数，那么kwdict要处于索引为3的位置</span></span><br><span class="line">        <span class="comment">//有扩展位置参数，那么kwdit处于索引为4的位置，这显然是合理的</span></span><br><span class="line">        <span class="comment">//然后放到f_localsplus中        </span></span><br><span class="line">        SETLOCAL(i, kwdict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有的话，那么为NULL</span></span><br><span class="line">        kwdict = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里我们之前介绍了，是将位置参数拷贝到本地(显然这里不包含扩展位置参数) */</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        x = args[j];</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">        SETLOCAL(j, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关键来了，将多余的位置参数拷贝到*args里面去 */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        <span class="comment">//申请一个argcount - n大小的元组</span></span><br><span class="line">        u = _PyTuple_FromArray(args + n, argcount - n);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放到f -&gt; f_localsplus里面去</span></span><br><span class="line">        SETLOCAL(total_args, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是拷贝扩展关键字参数，但是我们发现这里是从两个数组中分别得到符号和值的信息的</span></span><br><span class="line">    <span class="comment">//因此再结合最上面的变量声明，我们就明白了，我们传递的关键字参数并不是上来就设置到字典里面</span></span><br><span class="line">    <span class="comment">//而是将符号和值各自存储在对应的数组里面，显然就是下面的kwnames和kwargs</span></span><br><span class="line">    <span class="comment">//然后使用索引遍历，按照顺序依次取出，通过比较传递的关键字参数的符号是否已经出现在函数定义的参数中</span></span><br><span class="line">    <span class="comment">//来判断传递的这个参数究竟是普通的关键字参数，还是扩展关键字参数</span></span><br><span class="line">    <span class="comment">//比如:def foo(a, b, c, **kwargs)，那么foo(1, 2, c=3, d=4)</span></span><br><span class="line">    <span class="comment">//那么显然关键字参数有两个c=3和d=4，那么c已经出现在了函数定义的参数中，所以c就是一个普通的关键字参数</span></span><br><span class="line">    <span class="comment">//但是d没有，所有d同时也是扩展关键字参数，因此要设置到kwargs这个字典里面</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="comment">//按照索引，依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">        PyObject **co_varnames; <span class="comment">//符号表</span></span><br><span class="line">        PyObject *keyword = kwnames[i];<span class="comment">//关键字参数的key</span></span><br><span class="line">        PyObject *value = kwargs[i];<span class="comment">//关键字参数的value</span></span><br><span class="line">        Py_ssize_t j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyword == <span class="literal">NULL</span> || !PyUnicode_Check(keyword)) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() keywords must be strings&quot;</span>,</span><br><span class="line">                          co-&gt;co_name);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到符号表，得到所有的符号，这样就知道函数参数都有哪些</span></span><br><span class="line">        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;</span><br><span class="line">        <span class="comment">//我们看到内部又是一层for循环</span></span><br><span class="line">        <span class="comment">//首先外层循环是遍历所有的关键字参数，也就是我们传递的参数</span></span><br><span class="line">        <span class="comment">//而内层循环则是遍历函数的除了仅限位置参数之外的所有参数</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            <span class="comment">//将我们传来每一个关键字参数的符号都会和符号表中的所有符号进行比对</span></span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="comment">//如果相等，说明传递的是关键字参数，并不是扩展关键字参数</span></span><br><span class="line">            <span class="keyword">if</span> (name == keyword) &#123;</span><br><span class="line">                <span class="comment">//然后kw_found这个label中, 会检测对应的参数有没有通过位置参数传递</span></span><br><span class="line">                <span class="comment">//如果已经位置参数传递了, 那么显然一个参数被传递了两次</span></span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 逻辑和上面一样 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="type">int</span> cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(j &gt;= total_args);</span><br><span class="line">        <span class="comment">//走到这里，说明肯定传入了符号不在符号表co_varnames里面的关键字参数</span></span><br><span class="line">        <span class="comment">//如果kwdict是NULL，证明根本函数根本没定义扩展参数，那么就直接报错了</span></span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (co-&gt;co_posonlyargcount</span><br><span class="line">                &amp;&amp; positional_only_passed_as_keyword(tstate, co,</span><br><span class="line">                                                     kwcount, kwnames))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got an unexpected keyword argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里将属于扩展关键字参数的keyword和value都设置到之前创建的字典里面去</span></span><br><span class="line">        <span class="comment">//然后continue进入下一个关键字参数逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItem(kwdict, keyword, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      kw_found:</span><br><span class="line">        <span class="comment">//之前我们说，如果不是扩展，而是普通关键字参数那么会走这一步</span></span><br><span class="line">        <span class="comment">//获取对应的符号，但是发现不为NULL，说明已经通过位置参数传递了</span></span><br><span class="line">        <span class="keyword">if</span> (GETLOCAL(j) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//那么这里就报出一个TypeError，表示某个参数接收了多个值</span></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got multiple values for argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="comment">//比如说：def foo(a, b, c=1, d=2)</span></span><br><span class="line">            <span class="comment">//如果这样传递的foo(1, 2, c=3)，那么肯定没问题</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为开始会把位置参数拷贝到f_localsplus里面，所以此时f_localsplus是[a, b, NULL, NULL]</span></span><br><span class="line"><span class="comment">            然后设置关键字参数的时候，此时的j对应索引为2，那么GETLOCAL(j)是NULL，所以不会报错</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//但如果这样传递，foo(1, 2, 3, c=3)</span></span><br><span class="line">            <span class="comment">//那么不好意思，此时f_localsplus则是[a, b, c, NULL],GETLOCAL(j)是c，不为NULL</span></span><br><span class="line">            <span class="comment">//说明c这个位置已经有人传递了，那么关键字参数就不能传递了</span></span><br><span class="line">            <span class="comment">//还是那句话f_localsplus存储的是符号，每一个符号都会对应相应的值，这些顺序都是一致的            </span></span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        SETLOCAL(j, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里检测位置参数是否多传递了 */</span></span><br><span class="line">    <span class="keyword">if</span> ((argcount &gt; co-&gt;co_argcount) &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) &#123;</span><br><span class="line">        too_many_positional(tstate, co, argcount, defcount, fastlocals);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在对参数进行处理的时候，机制还是很复杂的。我们知道Python在定义函数的时候，通过&#x2F;可以使得&#x2F;前面的参数必须通过位置参数传递，通过*可以使得*后面的参数必须通过位置参数传递，而我们在分析的时候是没有考虑这一点的。</strong></p>
<blockquote>
<p>*<em>其实扩展关键字参数的传递机制和普通关键字参数的传递机制有很大的关系，我们之前分析函数参数的默认值机制已经看到了关键字参数的传递机制，这里我们再次看到了。对于关键字参数，不论是否扩展，都会把符号和值分别按照对应顺序放在两个数组里面。然后Python会按照索引的顺序，遍历存放符号的数组，对每一个符号都会和符号表co_varnames里面的符号逐个进行比对，发现在符号表中找不到我们传递的关键字参数的符号，那么就说明这是一个扩展关键字参数。然后就是我们在源码中看到的那样，如果函数定义了*<em>kwargs，那么kwdict就不为空，会把扩展关键字参数直接设置进去，否则就报错了，提示接收到了一个不期待的关键字参数。</em></em></p>
<p><strong>而且Python虚拟机也确实把该PyDictObject对象<code>(kwargs)</code>放到了f_localsplus中，这个f_localsplus里面包含了所有的参数，不管是什么参数，都会在里面。但是kwargs一定是在最后面，至于*args理论上是没有顺序的，你是可以这么定义的:<code>def foo(a, \*args, b)</code>，这样定义是完全没有问题的，只是此时的b就必须要通过关键字参数来传递了，因为如果不通过关键字参数的方式，那么无论多少个位置参数，都会止步于<code>\*args</code>。之前也介绍过，假设只需要name,age, gender这三个参数，并且gender必须要通过关键字参数指定的话，那么就可以这么设计：<code>def foo(name, age, \*, gender)</code>，我们看到连args都省去了，只保留一个<code>\*</code>，这是因为我们定义了args也用不到，我们只是保证后面的gender必须通过关键字方式传递，所以只需要一个<code>\*</code>就ok了。</strong></p>
<p><strong>另外在Python3.8中，注意只有Python3.8开始才支持，可以强制使用位置参数，语法是通过<code>/</code>。</strong></p>
<p><strong>当然访问传递过来的扩展位置参数和扩展关键字参数就通过args对应的PyTupleObject和kwargs对应的PyDictObject操作就可以了。</strong></p>
</blockquote>
<p><strong>此外，我们在分析参数的时候，一直是截取部分片段，没有从上到下整体分析，因此可以再对着源码自己看一遍。当然核心还是Python在处理函数参数时的机制，整体流程如下<code>(先不考虑/和\*)</code>：</strong></p>
<ul>
<li><strong>1. 获取所有通过位置参数传递的个数，然后循环遍历将它们从运行时栈依次拷贝到 f_localsplus 指定的位置中；</strong></li>
<li><strong>2.  计算出可以通过位置参数传递的参数个数，如果实际传递的位置参数个数大于可以通过位置参数传递个数，那么会检测是否存在  *args，如果存在，那么将多余的位置参数拷贝到一个元组中；不存在，则报错：TypeError: function() takes ‘m’  positional argument but ‘n’ were given，其中 n 大于 m，表示接收了多个位置参数；</strong></li>
<li><strong>3. 如果实际传递的位置参数个数小于等于可以通过位置参数传递个数，那么程序继续往下执行，检测关键字参数，它是通过两个数组来实现的，参数名和值是分开存储的；</strong></li>
<li><strong>4. 然后进行遍历，两层 for 循环，第一层 for 循环遍历存放关键字参数名的数组，第二层遍历符号表，会将传递参数名和符号表中的每一个符号进行比较；</strong></li>
<li>**5. 如果指定了不在符号表中的参数名，那么会检测是否定义了  *<em>kwargs，如果没有则报错：TypeError: function() got an unexpected keyword  argument ‘xxx’，接收了一个不期望的参数 xxx；如果定义了 *<em>kwargs，那么会设置在字典中；</em></em></li>
<li><strong>6. 如果参数名在符号表中存在，那么跳转到 kw_found  标签，然后获取该符号对应的 value，如果 value 不为 NULL，那么证明该参数已经通过位置参数传递了，会报错：TypeError:  function() got multiple values for argument ‘xxx’，提示函数的参数 xxx 接收了多个值；</strong></li>
<li><strong>7. 最终所有的参数都会存在 f_localsplus 中，然后检测是否存在对应的 value 为 NULL 的符号，如果存在，那么检测是否具有默认值，有则使用默认值，没有则报错：</strong></li>
</ul>
<p><strong>所以Python在处理参数的大致流程是上面那样的，具体细节层面也很好理解，只是要处理各种各样的情况，导致看起来让人有点头疼。当然Python中的生成器和异步生成器的逻辑也在这个函数里面，我们后续系列中会分析。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们分析了函数调用时候的场景，以及如何处理不同形式的参数，重点还是有一个整体性的认识。下一篇，我们将来分析闭包。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>13-剖析Python的流程控制语句</title>
    <url>/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"><a href="#13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制" class="headerlink" title="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"></a>13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在上一章中，我们介绍了Python虚拟机中常见的字节码指令。但我们的流程都是从上往下顺序执行的，在执行的过程中没有任何变化，但是显然这是不够的，因为怎么能没有流程控制呢。下面我们来看看Python所提供的流程控制手段，其中也包括异常检测机制。</strong></p>
<h3 id="Python虚拟机中的if控制流"><a href="#Python虚拟机中的if控制流" class="headerlink" title="Python虚拟机中的if控制流"></a>Python虚拟机中的if控制流</h3><h4 id="if字节码"><a href="#if字节码" class="headerlink" title="if字节码"></a>if字节码</h4><p><strong>if语句算是最简单也是最常用的控制流语句，那么它的字节码是怎么样的呢？当然我们这里的if语句指的是if、elif、elif…、else整体，里面的if、某个elif或者else叫做该if语句的分支。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">gender = &quot;男&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if gender == &quot;男&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;nice muscle&quot;)</span></span><br><span class="line"><span class="string">elif gender == &quot;女&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;白い肌&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;秀吉&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>反编译得到的字节码指令比较多，我们来慢慢分析。</strong></p>
<blockquote>
<p><strong>注意：到了现在，相信对字节码指令都已经熟悉了，因此之前说过的指令我们就不详细展开说了，只会简单提一下。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>) <span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)<span class="comment">//建立符号和对象的映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)<span class="comment">//加载变量gender</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;男&quot;进行==操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span><span class="comment">//这里的22表示如果为False, 就跳转到字节码偏移量、或者字节码的索引为22的地方</span></span><br><span class="line">    					  <span class="comment">//显然是下面的22 LOAD_NAME 0 (gender), 即：该if下面的elif</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//如果gender == &quot;男&quot;成立, 那么不会跳转, 直接往下执行, 加载符号print</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">18</span> POP_TOP	<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)<span class="comment">//if语句只会执行一个分支, 一旦执行了某个分支, 整个if语句就结束了</span></span><br><span class="line">    					          <span class="comment">//所以跳转到字节码偏移量为48的位置, 这里的22就表示相对于当前位置向前跳转了多少</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) <span class="comment">//显然这是elif的分支, 加载变量gender</span></span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)<span class="comment">//加载字符串常量&quot;女&quot;</span></span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;女&quot;进行==判断</span></span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span><span class="comment">//如果不成立就跳转到字节码偏移量为40的地方, 显然是elif下面的else</span></span><br><span class="line">    					  <span class="comment">//如果elif下面还有elif, 那么就跳转到下一个elif, 总之就是一个分支一个分支的往下跳转</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)<span class="comment">//走到这里说明gender == &quot;女&quot;成立, 加载变量print</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)<span class="comment">//加载字符串常量&quot;白い肌&quot;</span></span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用, 参数为1个</span></span><br><span class="line">           <span class="number">36</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)<span class="comment">//整个if语句结束, 还是跳转到字节码偏移量为48的位置</span></span><br><span class="line">    						  <span class="comment">//这里参数是8, 所以if的跳转是采用相对跳跃, 分支不同跳跃的指令数也不同</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//走到这里说明执行的是else分支, 加载符号print</span></span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)<span class="comment">//加载字符串常量&quot;秀吉&quot;</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去,如果是执行else分支并且执行完毕, 显然就不需要再跳转了,</span></span><br><span class="line">    		       <span class="comment">//因为else分支位于整个if语句的最后面</span></span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)<span class="comment">//这里便是整个if语句结束后的第一条指令, 加载常量None</span></span><br><span class="line">           <span class="number">50</span> RETURN_VALUE<span class="comment">//返回</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字节码中 “源代码行号” 和 “字节码偏移量” 之间有几个<code>&gt;&gt;</code>这样的符号，这是什么呢？仔细看一下应该就知道，这显然就是if语句中的每一个分支开始的地方，当然最后的<code>&gt;&gt;</code>是返回值。</strong></p>
<p><strong>但是经过分析，我们发现整个if语句的字节码指令还是很简单的。从上到下执行分支，如果某个分支成立，就执行该分支的代码，执行完毕后直接跳转到整个if语句下面的第一条指令；分支不成立那么就跳转到下一个分支。</strong></p>
<p><strong>核心指令就在于COMPARE_OP、POP_JUMP_IF_FALSE和JUMP_FORWARD，从结构上我们不难分析：</strong></p>
<ul>
<li><code>COMPARE_OP: 进行比较操作</code></li>
<li><code>POP_JUMP_IF_FALSE: 跳转到下一个分支</code></li>
<li><code>JUMP_FORWARD:跳转到整个if语句结束后的第一条指令</code></li>
</ul>
<p>​        <strong>我们首先分析COMPARE_OP，我们看到COMPARE_OP后面也是有参数的，比如 8 COMPARE_OP               2  (&#x3D;&#x3D;)，显然oparg<code>(字节码指令参数)</code>就是2，那么这个2代表啥呢？其实想都不用想，肯定代表的是&#x3D;&#x3D;，因为都已经告诉我们了。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="comment">/* Rich comparison opcodes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LT 0 <span class="comment">//小于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LE 1 <span class="comment">//小于等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_EQ 2 <span class="comment">//等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_NE 3 <span class="comment">//不等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GT 4 <span class="comment">//大于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GE 5 <span class="comment">//大于等于</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//opcode.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cmp_op</span> &#123;</span>PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE,</span><br><span class="line">                PyCmp_GT=Py_GT, PyCmp_GE=Py_GE, PyCmp_IN, PyCmp_NOT_IN,</span><br><span class="line">                PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看，虚拟机中是如何进行比较操作的。另外本章中如果没有指定源码位置，那么默认是在Python&#x2F;ceval.c里面</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">cmp_outcome</span><span class="params">(<span class="type">int</span> op, PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//python中的is, 在C的层面直接判断两个指针是否相等即可        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的is not, , 在C的层面直接判断两个指针是否不相等即可    </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS_NOT:</span><br><span class="line">        res = (v != w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的in, 调用PySequence_Contains</span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的not in, 调用PySequence_Contains再取反        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_NOT_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        res = !res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的异常      </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_EXC_MATCH:</span><br><span class="line">        <span class="comment">//这里判断给定的类是不是异常类, 比如我们肯定不能except int as e, 异常类一定要继承BaseException</span></span><br><span class="line">        <span class="comment">//如果是元组的话, 那么元组里面都要是异常类</span></span><br><span class="line">        <span class="keyword">if</span> (PyTuple_Check(w)) &#123;</span><br><span class="line">            Py_ssize_t i, length;</span><br><span class="line">            length = PyTuple_Size(w);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i += <span class="number">1</span>) &#123;</span><br><span class="line">                PyObject *exc = PyTuple_GET_ITEM(w, i);</span><br><span class="line">                <span class="keyword">if</span> (!PyExceptionClass_Check(exc)) &#123;</span><br><span class="line">                    PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                    CANNOT_CATCH_MSG);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PyExceptionClass_Check(w)) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                CANNOT_CATCH_MSG);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断指定的异常能否捕获相应的错误</span></span><br><span class="line">        res = PyErr_GivenExceptionMatches(v, w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//然后进行比较操作, 传入两个对象以及操作符, 即上面的Py_LT、Py_LE...之一</span></span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Py_True和Py_False就相当于Python中的True和False, 本质上是一个PyLongObject</span></span><br><span class="line">    <span class="comment">//根据res的结果返回True和False</span></span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面的比较函数PyObject_RichCompare很重要，我们来看一下，该函数位于Object&#x2F;object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先有一个PyObject_RichCompareBool, 它是用来判断两个对象是否相等或不等的</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyObject_RichCompareBool</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="type">int</span> ok;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果v和w相等的话, 说明这两个变量指向同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (v == w) &#123;</span><br><span class="line">        <span class="comment">//那么如果op是==, 显然返回True</span></span><br><span class="line">        <span class="keyword">if</span> (op == Py_EQ)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果op是!=, 显然返回False</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == Py_NE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有人问如果我们重写了__eq__怎么办? 所以这个方法只适用于内建的类的实例对象</span></span><br><span class="line">    <span class="comment">//如果是我们自定义的类会直接调用这里的PyObject_RichCompare</span></span><br><span class="line">    <span class="comment">//另外我们看到即便是内置的类的实例对象, 如果两个对象不相等, 或者相等、但是op不是==和!=的时候也会走这里的PyObject_RichCompare</span></span><br><span class="line">    res = PyObject_RichCompare(v, w, op);</span><br><span class="line">    <span class="comment">//通过PyObject_RichCompare进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果返回的是布尔值, 那么判断是否和Py_True相等, 返回的是True那么比较的结果也是True, 否则是False</span></span><br><span class="line">    <span class="keyword">if</span> (PyBool_Check(res))</span><br><span class="line">        ok = (res == Py_True);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//返回的不是布尔值, 那么调用PyObject_IsTrue, 显然这相当于Python中的bool(res)</span></span><br><span class="line">        <span class="comment">//不是0的整数、长度不为0的字符串、元组、列表等等也是True</span></span><br><span class="line">        ok = PyObject_IsTrue(res);</span><br><span class="line">    Py_DECREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点来了, 我们来看看PyObject_RichCompare</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_RichCompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">//首先会对op进行判断, 要确保Py_LT &lt;= op &lt;= Py_GE, 即0 &lt;= op &lt;= 5, 要保证op是几个操作符中的一个</span></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="comment">//首先v和w不能是C的空指针, 要确保它们都指向一个具体的PyObject, 但是说实话底层的这些检测我们在Python的层面基本不会遇到</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PyErr_Occurred())</span><br><span class="line">            PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以核心是下面的do_richcompare, 但是在do_richcompare之前我们看到这里调用了Py_EnterRecursiveCall</span></span><br><span class="line">    <span class="comment">//这和函数和递归有关, 比如我们在__eq__中又对self使用了==, 那么会不断调用__eq__, 这是会无限递归的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_EnterRecursiveCall(<span class="string">&quot; in comparison&quot;</span>))</span><br><span class="line">        <span class="comment">//所以Py_EnterRecursiveCall是让解释器追踪递归的深度的</span></span><br><span class="line">	    <span class="comment">//如果递归层数过多, 超过了指定限制(默认是999, 可以通过sys.getrecursionlimit()查看), 那么能够及时抛出异常, 从递归中摆脱出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用do_richcompare, 还是这三个参数, 得到比较的结果</span></span><br><span class="line">    res = do_richcompare(v, w, op);</span><br><span class="line">    <span class="comment">//离开递归调用</span></span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    <span class="comment">//返回res, 执行PyObject_RichCompareBool中下面的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到核心其实是do_richcompare, 我们需要继续往下看</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">do_richcompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    richcmpfunc f; <span class="comment">//富比较函数</span></span><br><span class="line">    PyObject *res; <span class="comment">//比较结果</span></span><br><span class="line">    <span class="type">int</span> checked_reverse_op = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果type(v)和type(w)不一样 &amp;&amp; type(w)是type(v)的子类 &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type != w-&gt;ob_type &amp;&amp;</span><br><span class="line">        PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type) &amp;&amp;</span><br><span class="line">        (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        checked_reverse_op = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//那么直接调用type(w)的to_richcompare进行比较</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(v)和type(w)不同, 或者 type(w) 不是 type(v) 的子类, 或者type(w)中没有定义tp_richcompare</span></span><br><span class="line">    <span class="comment">//如果type(v)定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> ((f = v-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用type(v)的tp_richcompare方法</span></span><br><span class="line">        res = (*f)(v, w, op);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(w) 不是 type(v) 的子类 &amp;&amp; type(v)中没有定义tp_richcompare &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (!checked_reverse_op &amp;&amp; (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//那么执行w的tp_richcompare</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以以上三种情况就相当于: 如果type(w) 是 type(v) 的子类, 那么优先调用w的tp_richcompare</span></span><br><span class="line">    <span class="comment">//否则，type(v) 和 type(w) 中谁的tp_richcompare不为空就调用谁的</span></span><br><span class="line">    <span class="comment">//如果都没有那么就走下面的逻辑了</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//直接比较两者是否相等</span></span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        res = (v == w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//比较两者是否不等        </span></span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">        res = (v != w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//显然此时的两个对象只能判断相等或者不等, 如果是比大小那么显然是报错的, 下面的信息你一定很熟悉</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;&#x27;%s&#x27; not supported between instances of &#x27;%.100s&#x27; and &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                     opstrings[op],</span><br><span class="line">                     v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                     w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，这里面又出现了tp_richcompare，如果我们自定义的类没有重写的话，那么默认调用的是基类object的tp_richcompare，包括内置的类也是调用object的tp_richcompare，有兴趣可以看一下。</strong></p>
<p>​        <strong>然后我们再来看看POP_JUMP_IF_FALSE</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)</span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">18</span> POP_TOP</span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) </span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)</span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)</span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">36</span> POP_TOP</span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)</span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">46</span> POP_TOP</span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">50</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下10 POP_JUMP_IF_FALSE       22这条字节码，这表是if语句不成立，那么会跳转到字节码偏移量为22的位置，所以这里有一个指令跳跃的动作。那么Python虚拟机是如何完成指令跳跃的呢？关键就在于一个名为 *predict* 的宏里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DYNAMIC_EXECUTION_PROFILE) || USE_COMPUTED_GOTOS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op)             <span class="keyword">if</span> (0) goto PRED_##op</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op) \</span></span><br><span class="line"><span class="meta">    do&#123; \</span></span><br><span class="line"><span class="meta">        _Py_CODEUNIT word = *next_instr; \</span></span><br><span class="line"><span class="meta">        opcode = _Py_OPCODE(word); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (opcode == op)&#123; \</span></span><br><span class="line"><span class="meta">            oparg = _Py_OPARG(word); \</span></span><br><span class="line"><span class="meta">            next_instr++; \</span></span><br><span class="line"><span class="meta">            goto PRED_##op; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICTED(op)           PRED_##op:</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python中，有一些字节码指令通常都是按照顺序出现的，通过上一个字节码指令直接预测下一个字节码指令是可能的。比如COMPARE_OP的后面通常都会紧跟着POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE，这在上面的字节码中可以很清晰的看到。</strong></p>
<p><strong>为什么要有这样的一个预测功能呢？因为当字节码之间的指令搭配出现的概率非常高时，如果预测成功，能够省去很多无谓的操作，使得执行效率大幅提高。我们可以看到， <code>PREDICTED(POP_JUMP_IF_FALSE);</code>实际上就是检查下一条待处理的字节码是否是POP_JUMP_IF_FALSE。如果是，那么程序会直接跳转到PRED_POP_JUMP_IF_FALSE那里，如果将COMPARE_OP这个宏展开，可以看得更加清晰。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_FALSE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_FALSE;</span><br><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_TRUE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_TRUE</span><br></pre></td></tr></table></figure>

<p><strong>但是问题又来了，PRED_POP_JUMP_IF_TRUE和PRED_POP_JUMP_IF_FALSE这些标识在哪里呢？我们知道指令跳跃的目的是为了绕过一些无谓的操作，直接进入POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE指令对应的case语句之前。</strong></p>
<p><strong>首先<code>if gender == &quot;男&quot;</code>这条字节码序列中，存在POP_JUMP_IF_FALSE指令，那么在COMPARE_OP指令的实现代码的最后，将执行<code>goto PRED_POP_JUMP_IF_FALSE;</code>，而显然这句代码要在<code>POP_JUMP_IF_FALSE</code>之前执行。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PREDICTED(POP_JUMP_IF_FALSE);</span><br><span class="line">TARGET(POP_JUMP_IF_FALSE) &#123;</span><br><span class="line">    <span class="comment">//取出之前比较的结果。</span></span><br><span class="line">    PyObject *cond = POP();</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="comment">//比较结果为True，顺序执行</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_True) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较结果为False，进行跳转</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_False) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    err = PyObject_IsTrue(cond);</span><br><span class="line">    Py_DECREF(cond);</span><br><span class="line">    <span class="keyword">if</span> (err &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到这里的调用跳转使用的<code>JUMPTO</code>，在for循环中我们还会见到，这是一个宏。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_Py_CODEUNIT 是 uint16_t 的别名 typedef uint16_t _Py_CODEUNIT，占两个字节; </span></span><br><span class="line"><span class="comment">从名字也能看出这表示字节码的指令单元, 一条指令两个字节, 所以字节码指令对应的偏移量是0 2 4 6 8..., 每次增加2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另外这里的first_str指向字节码偏移量为0的位置, 也就是第一条指令</span></span><br><span class="line"><span class="comment">next_str表示在first_str基础上跳转之后的指令, 所以如果x是12的话, 那么next_str = 0 + 6, 显然就是第7条指令</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Python虚拟机中的for循环控制流"><a href="#Python虚拟机中的for循环控制流" class="headerlink" title="Python虚拟机中的for循环控制流"></a>Python虚拟机中的for循环控制流</h3><p><strong>我们在if语句中已经见识了最基本的控制，但是我们发现if里面只能向前，不管是哪个分支，都是通过<code>JUMP_FORWARD</code>。下面介绍for循环，我们会见到指令时可以回退的。但是在if语句的分支中，我们看到无论哪个分支、其指令的跳跃距离通常都是当前指令与目标指令的距离，相当于向前跳了多少步。那么指令回退时，是不是相当于向后跳了多少步呢？带着疑问，我们来往下看。</strong></p>
<h4 id="for字节码"><a href="#for字节码" class="headerlink" title="for字节码"></a>for字节码</h4><p><strong>我们来看看一个简单的for循环的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">lst = [1, 2]</span></span><br><span class="line"><span class="string">for item in lst:</span></span><br><span class="line"><span class="string">    print(item)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) //加载常量<span class="number">1</span></span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) //加载常量<span class="number">2</span></span><br><span class="line">              <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     //构建PyListObject对象, 元素个数为<span class="number">2</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) //使用符号<span class="string">&quot;lst&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) //加载变量lst</span><br><span class="line">             <span class="number">10</span> GET_ITER					   //获取对应的迭代器</span><br><span class="line">        &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)//开始<span class="keyword">for</span>循环, 循环结束跳转到字节码偏移量为<span class="number">26</span>的地方</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) //将元素迭代出来, 使用符号<span class="string">&quot;item&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">print</span>) //加载函数<span class="built_in">print</span></span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) //加载变量item</span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        //函数调用</span><br><span class="line">             <span class="number">22</span> POP_TOP						    //从栈顶弹出<span class="built_in">print</span>函数的返回值, 这里是<span class="literal">None</span></span><br><span class="line">             <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 //<span class="keyword">for</span>循环遍历一圈之后, 继续跳转回去, 遍历下一圈, 直到结束</span><br><span class="line">        &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>) //走到这里<span class="keyword">for</span>循环就结束了, 加载常量<span class="literal">None</span>, 然后返回</span><br><span class="line">             <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们再来详细分析一下上面的指令：</strong></p>
<blockquote>
<p><strong><code>lst = [1, 2]</code>我们就不分析了，当  for item in  lst:的时候，肯定首先要找到lst，所以指令是LOAD_NAME是没问题的。但是下面出现了GET_ITER，从字面上我们知道这是获取迭代器，其实即使不从源码的角度，我相信有的小伙伴对于for循环的机制也不是很了解。</strong></p>
<p><strong>实际上我们for循环遍历一个对象的时候，首先要满足后面的对象是一个可迭代对象，遍历这个对象的时候，会先调用这个对象的__iter__方法，把它变成一个迭代器。然后不断地调用这个迭代器的__next__方法，一步一步将里面的值全部迭代出来，然后再进行一次迭代出现StopIteration异常，for循环捕捉，然后退出。注意：for item in lst是先将lst对应的迭代器中的元素迭代出来，然后交给变量item。所以字节码中先是<code>12 FOR_ITER</code>，然后才是<code>14 STORE_NAME</code>。因此10个元素的迭代器，是需要迭代11次才能结束的，因为Python不知道迭代10次就能结束，它需要再迭代一次发现没有元素可以迭代、从而抛出StopIteration异常、再被for循环捕捉之后才能结束。</strong></p>
<p><strong>所以for循环后面如果跟的是一个迭代器，那么直接调用__next__方法，如果是可迭代对象，会先调用其内部的__iter__方法将其变成一个迭代器，然后再调用该迭代器的__next__方法。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表、字符串、元组、字典、集合等等都是可迭代对象</span></span><br><span class="line"><span class="comment"># 但它们不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterator))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要调用__iter__之后才是一个迭代器, 当然迭代器也是可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到 24 JUMP_ABSOLUTE，它是跳转到字节码偏移量为12、也就是FOR_ITER的位置，并没有跳到GET_ITER那里，所以for循环在遍历的时候只会创建一次迭代器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">lst_iter = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst_iter:</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">iter</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我们看到结果是一样的, for item in iter(lst)和for item in lst是等价的</span></span><br><span class="line"><span class="comment"># 都会先创建迭代器, 并且只创建一次, 然后遍历这个迭代器</span></span><br></pre></td></tr></table></figure>

<h4 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h4><p><strong>Python虚拟机通过<code>LOAD_NAME 0 (lst)</code>指令，将刚创建的PyListObject对象压入运行时栈。然后再通过<code>GET_ITER</code>指令来获取PyListObject对象的迭代器。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(GET_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">/* before: [obj]; after [getiter(obj)] */</span></span><br><span class="line">    <span class="comment">//从运行时栈获取PyListObject对象</span></span><br><span class="line">    PyObject *iterable = TOP();</span><br><span class="line">    <span class="comment">//获取该PyListObject对象的iterator</span></span><br><span class="line">    PyObject *iter = PyObject_GetIter(iterable);</span><br><span class="line">    Py_DECREF(iterable);</span><br><span class="line">    <span class="comment">//将iterator压入栈中, 设置在栈顶</span></span><br><span class="line">    SET_TOP(iter);</span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    PREDICT(FOR_ITER);</span><br><span class="line">    PREDICT(CALL_FUNCTION);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到获取迭代器是调用了PyObject_GetIter函数，我们看看这个函数长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> PyObject *(*getiterfunc) (PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/abstract.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GetIter</span><span class="params">(PyObject *o)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取对象的类型</span></span><br><span class="line">    PyTypeObject *t = o-&gt;ob_type;</span><br><span class="line">    <span class="comment">//一个函数指针, 接收一个PyObject *, 返回一个PyObject *</span></span><br><span class="line">    getiterfunc f;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用类型对象的tp_iter</span></span><br><span class="line">    f = t-&gt;tp_iter;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果f是NULL, 并且还不是序列型对象, 那么直接抛出异常, &#x27;xxx&#x27; object is not iterable</span></span><br><span class="line">        <span class="keyword">if</span> (PySequence_Check(o))</span><br><span class="line">            <span class="keyword">return</span> PySeqIter_New(o);</span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">&quot;&#x27;%.200s&#x27; object is not iterable&quot;</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用tp_iter, 传入对象获取迭代器。我们获取迭代器是通过iter(lst)或者lst.__iter__()</span></span><br><span class="line">        <span class="comment">//但是在底层相当于list.__iter__(lst), 所以&quot;实例.方法(*args, **kwargs)&quot;等价于&quot;类.函数(self, *args, **kargs)&quot;</span></span><br><span class="line">        PyObject *res = (*f)(o);</span><br><span class="line">        <span class="comment">//如果res不为空、并且还不是迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span> &amp;&amp; !PyIter_Check(res)) &#123;</span><br><span class="line">            <span class="comment">//那么报错TypeError, __iter__返回了一个非迭代器</span></span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">&quot;iter() returned non-iterator &quot;</span></span><br><span class="line">                         <span class="string">&quot;of type &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                         res-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">            res = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以看到，PyObject_GetIter是调用对象对应的类型对象中的tp_iter操作来获取与对象关联的迭代器的。我们说Python一切皆对象，那么这些迭代器也是一个实实在在的对象，那么也必然会有对应的类型对象，因为Python中对象对应的结构体都继承了PyObject，所以任何一个对象都有引用计数和类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD <span class="comment">//迭代器显然是不可变对象</span></span><br><span class="line">    Py_ssize_t it_index; <span class="comment">//迭代的元素的索引, 初始为0, 每迭代1个元素it_index就加1</span></span><br><span class="line">    PyListObject *it_seq; <span class="comment">//指向一个PyListObject对象, 显然迭代的就是这个PyListObject对象里面的元素, 当元素迭代完毕之后it_seq会被设置成NULL</span></span><br><span class="line">&#125; listiterobject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyTypeObject PyListIter_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list_iterator&quot;</span>,                            <span class="comment">/* tp_name */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后PyList_Type中tp_iter域被设置为list_iter，显然这是PyObject_GetIter中的那个f，而这也正是创建迭代器的关键所在。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_iter</span><span class="params">(PyObject *seq)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//列表对应的迭代器的指针</span></span><br><span class="line">    listiterobject *it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果seq不是列表，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(seq)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为listiterobject申请空间</span></span><br><span class="line">    it = PyObject_GC_New(listiterobject, &amp;PyListIter_Type);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//迭代器的索引, 用来遍历列表的, 初始为0</span></span><br><span class="line">    it-&gt;it_index = <span class="number">0</span>;</span><br><span class="line">    Py_INCREF(seq);</span><br><span class="line">    <span class="comment">//这里的seq就是之前的PyListObject对象</span></span><br><span class="line">    it-&gt;it_seq = (PyListObject *)seq;</span><br><span class="line">    _PyObject_GC_TRACK(it);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到PyListObject的迭代器对象只是对PyListObject对象做了一个简单的包装，在迭代器中，维护了迭代是要访问的元素在PyListObject对象中的索引：<code>it_index</code>。通过这个索引，listiterobject对象就可以实现PyListObject的遍历。</strong></p>
<blockquote>
<p><strong>所以我们看到迭代器的实现真的很简单，创建谁的迭代器就对谁进行一层包装罢了，迭代器内部有一个索引。每迭代1次索引就加1，迭代完毕之后将指针设置为NULL，然后再迭代就抛出异常。</strong></p>
</blockquote>
<p><strong>所以任何一个列表对应的迭代器的内存大小都是32字节，PyObject是16字节，再加上一个Py_ssize_t和一个指针，总共32字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;夏色祭&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 6074 32</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__(), <span class="built_in">iter</span>(lst).__sizeof__())  <span class="comment"># 24040 32</span></span><br><span class="line"></span><br><span class="line">tpl = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(tpl.__sizeof__(), <span class="built_in">iter</span>(tpl).__sizeof__())  <span class="comment"># 24024 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不光是列表, 包括字符串、元组也是一样的, 都是32字节</span></span><br></pre></td></tr></table></figure>

<p><strong>但是字典有些特殊，因为它的底层是通过哈希表存储的，它需要额外维护一些信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/dictobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyDictObject *di_dict; <span class="comment">/* Set to NULL when iterator is exhausted */</span></span><br><span class="line">    Py_ssize_t di_used;</span><br><span class="line">    Py_ssize_t di_pos;</span><br><span class="line">    PyObject* di_result; <span class="comment">/* reusable result tuple for iteritems */</span></span><br><span class="line">    Py_ssize_t len;</span><br><span class="line">&#125; dictiterobject;</span><br></pre></td></tr></table></figure>

<p><strong>所以字典对应的迭代器是56字节，集合对应的迭代器则是48字节，关于集合可以去源码中查看，看看为什么会占48字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">range</span>(<span class="number">100000</span>), <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(d.__sizeof__(), <span class="built_in">iter</span>(d).__sizeof__())  <span class="comment"># 5242952 56</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 4194504 48</span></span><br></pre></td></tr></table></figure>

<p><strong>在指令<code>GET_ITER</code>完成之后，Python虚拟机开始了<code>FOR_ITER</code>指令的预测动作，如你所知，这样的预测动作是为了提高执行的效率。</strong></p>
<h4 id="迭代控制"><a href="#迭代控制" class="headerlink" title="迭代控制"></a>迭代控制</h4><p><strong>源代码中的for循环，在虚拟机层面也一定对应着一个相应的循环控制结构。因为无论进行怎样的变换，都不可能在虚拟机层面利用顺序结构来实现源码层面上的循环结构，这也可以看成是程序的拓扑不变性。显然正如我们刚才分析的，当创建完迭代器之后，就正式开始进入for循环了，没错就是从<code>FOR ITER</code>开始，进入了Python虚拟机层面上的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">//指令预测</span></span><br><span class="line">    PREDICTED(FOR_ITER);</span><br><span class="line">    <span class="comment">/* before: [iter]; after: [iter, iter()] *or* [] */</span></span><br><span class="line">    <span class="comment">/* 从栈顶获取iterator对象 */</span></span><br><span class="line">    PyObject *iter = TOP();</span><br><span class="line">    <span class="comment">//调用迭代器类型对象的tp_iternext方法、传入迭代器, 迭代出当前索引对应的元素, 然后索引+1, 然后下次迭代下一个元素</span></span><br><span class="line">    PyObject *next = (*iter-&gt;ob_type-&gt;tp_iternext)(iter);</span><br><span class="line">    <span class="comment">//如果next不为NULL, 那么将元素压入运行时栈, 显然要赋值给for循环的变量了</span></span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUSH(next);</span><br><span class="line">        PREDICT(STORE_FAST);</span><br><span class="line">        PREDICT(UNPACK_SEQUENCE);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">        <span class="comment">//如果出现异常、并且没有捕获到, 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tstate指的是线程对象, 我们会后面分析, 这里与回溯栈相关</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj, tstate, f);</span><br><span class="line">        &#125;</span><br><span class="line">        _PyErr_Clear(tstate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 走到这里说明本次迭代正常结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">    Py_DECREF(iter);</span><br><span class="line">    JUMPBY(oparg);</span><br><span class="line">    PREDICT(POP_BLOCK);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FOR_ITER的指令代码会首先从运行时栈中获得PyListObject对象的迭代器，然后调用迭代器的tp_iternext开始进行迭代，迭代出元素的同时将索引+1。如果抵达了迭代器的结束位置，那么tp_iternext将返回NULL，这个结果预示着遍历结束。</strong></p>
<p><strong>FOR_ITER的指令代码会检查tp_iternext的返回结果，如果得到的是一个有效的元素<code>(next!=NULL)</code>，那么将获得的这个元素压入到运行时栈中，并开始进行一系列的字节码预测动作。在我们当前的例子中，显然会预测失败，因此会执行<code>STORE_NAME</code>。那么如何获取迭代器的下一个元素呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">listiter_next</span><span class="params">(listiterobject *it)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *seq;</span><br><span class="line">    PyObject *item;</span><br><span class="line"></span><br><span class="line">    assert(it != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//seq：显然是获取迭代器对象的PyListObject对象的指针</span></span><br><span class="line">    seq = it-&gt;it_seq;</span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//一定是一个PyListObject对象</span></span><br><span class="line">    assert(PyList_Check(seq));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//当前的索引小于列表的长度、即当前索引小于等于最大索引</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index &lt; PyList_GET_SIZE(seq)) &#123;</span><br><span class="line">        <span class="comment">//获得索引为it_index的对应元素</span></span><br><span class="line">        item = PyList_GET_ITEM(seq, it-&gt;it_index);</span><br><span class="line">        <span class="comment">//调整index, 使其自增1, 然后下一次遍历得到下一个元素</span></span><br><span class="line">        ++it-&gt;it_index;</span><br><span class="line">        <span class="comment">//增加引用计数、返回</span></span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代完毕之后，设置为NULL，所以迭代器只能够顺序迭代一次</span></span><br><span class="line">    it-&gt;it_seq = <span class="literal">NULL</span>;</span><br><span class="line">    Py_DECREF(seq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后python虚拟机将沿着字节码的顺序一条一条的执行下去，从而完成输出的动作。但是我们知道，for循环中肯定会有指令回退的动作，我们之前从字节码中也看到了，for循环遍历一次之后，会再次跳转到<code>FOR_ITER</code>，而跳转所使用的指令就是<code>JUMP_ABSOLUTE</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(JUMP_ABSOLUTE)</span>: &#123;</span><br><span class="line">            PREDICTED(JUMP_ABSOLUTE);</span><br><span class="line">            <span class="comment">//显然这里的oparg表示字节码偏移量, 表示直接跳转到偏移量为oparg的位置上</span></span><br><span class="line">            JUMPTO(oparg);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FAST_LOOPS</span></span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到和if不一样，for循环使用的是绝对跳跃。JUMP_ABSOLUTE是强制设置next_instr的值，将next_instr设定到距离<code>f-&gt;f_code-&gt;co_code</code>开始地址的某一特定偏移的位置。这个偏移的量由JUMP_ABSOLUTE的指令参数决定，所以这条参数就成了for循环中指令回退动作的最关键的一点。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) </span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) </span><br><span class="line">            <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     </span><br><span class="line">            <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) </span><br><span class="line">           <span class="number">10</span> GET_ITER					   </span><br><span class="line">      &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)</span><br><span class="line">           <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) </span><br><span class="line">           <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        </span><br><span class="line">           <span class="number">22</span> POP_TOP						    </span><br><span class="line">           <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 </span><br><span class="line">      &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (None) </span><br><span class="line">           <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到JUMP_ABSOLUTE的参数是12，<code>next_str = 0 + 12 / 2 = 6</code>，表示跳转到字节码偏移量为12、或者说第7条指令的位置上，也就是<code>12 FOR_ITER</code>这条指令，那么Python虚拟机的下一步动作就是执行<code>FOR_ITER</code>指令，即通过PyListObject对象的迭代器获取PyListObject对象中的元素，然后依次向前，执行输出，遇到JUMP_ABSOLUTE再跳转回去。因此FOR_ITER指令和JUMP_ABSOLUTE指令之间构造出了一个循环结构，这个循环结构正是对应源码中的for循环结构。</strong></p>
<p><strong>但是我们发现，FOR_ITER后面跟了一个参数，这里是12，可是目前为止我们并没有看到有地方使用了这个12啊，那么它代表啥含义呢。其实，聪明如你肯定能猜到，因为从后面(to 26)也能看到，这是用于终止迭代的。表示从当前位置跳跃12个偏移量、等于24，或者在当前指令的基础上再跳转6条指令，也就是到达<code>26 LOAD_CONST</code>的位置。</strong></p>
<h4 id="终止迭代"><a href="#终止迭代" class="headerlink" title="终止迭代"></a>终止迭代</h4><p><strong>“天下没有不散的宴席”，for循环也是要退出的，不用想这个退出的动作只能落在FOR_ITER的身上。在FOR_ITER指令执行的过程中，如果通过PyListObject对象的迭代器获取的下一个元素不是有效的元素(会是NULL)，这就意味着迭代结束了。这个结果将直接导致Python虚拟机会将迭代器对象从运行时栈中弹出，同时执行一个JUMPBY的动作，向前跳跃，在字节码的层面上是向下，就是字节码偏移量增大的方向。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPBY(x)       (next_instr += (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//走到这里说明循环结束了</span></span><br><span class="line">            STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">            Py_DECREF(iter);</span><br><span class="line">            <span class="comment">//直接进行跳转</span></span><br><span class="line">            JUMPBY(oparg);</span><br><span class="line">            PREDICT(POP_BLOCK);</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="python虚拟机中的while循环控制结构"><a href="#python虚拟机中的while循环控制结构" class="headerlink" title="python虚拟机中的while循环控制结构"></a>python虚拟机中的while循环控制结构</h3><p><strong>会了if、for，那么再来看while就简单了。不仅如此，我们还要分析两个关键字：break、continue，当然goto就别想了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a = 0</span></span><br><span class="line"><span class="string">while a &lt; 10:</span></span><br><span class="line"><span class="string">    a += 1</span></span><br><span class="line"><span class="string">    if a == 5:</span></span><br><span class="line"><span class="string">        continue</span></span><br><span class="line"><span class="string">    if a == 7:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    print(a)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>指令方面，while和for有很多是类似的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)  <span class="comment">//加载常量0</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)  <span class="comment">//使用变量a存储</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>     &gt;&gt;    <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//进入while循环了, 首先是a &lt; 10, 加载变量a</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="number">10</span>) <span class="comment">//加载常量10</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">0</span> (&lt;)  <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">50</span>  <span class="comment">//为False直接结束循环, 跳转到字节码偏移量为50的位置, 也就是第26条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//这里是进入循环了, 加载变量a</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>) <span class="comment">//加载常量1</span></span><br><span class="line">           <span class="number">16</span> INPLACE_ADD 		       <span class="comment">//执行a += 1操作, 这里相当于先执行了a + 1</span></span><br><span class="line">           <span class="number">18</span> STORE_NAME               <span class="number">0</span> (a) <span class="comment">//然后在重新让变量a指向相加之后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">20</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//进入a == 5, 加载变量a</span></span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">3</span> (<span class="number">5</span>) <span class="comment">//加载常量5</span></span><br><span class="line">           <span class="number">24</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">26</span> POP_JUMP_IF_FALSE       <span class="number">30</span>  <span class="comment">//如果为False, 那么直接跳转到偏移量为30的位置, 也就是当前if语句的下一条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>          <span class="number">28</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//如果a == 5成立, 那么绝对跳转, 跳到字节码偏移量为4的位置, 所以continue对一个绝对跳转, 目标是循环开始的地方</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>     &gt;&gt;   <span class="number">30</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//走到这里说明a == 5不成立, 判断a == 7, 加载变量a</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">4</span> (<span class="number">7</span>) <span class="comment">//加载常量7</span></span><br><span class="line">           <span class="number">34</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较是否相等</span></span><br><span class="line">           <span class="number">36</span> POP_JUMP_IF_FALSE       <span class="number">40</span>  <span class="comment">//如果为False, 跳转到偏移量为40的位置, 也就是print(a)</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>          <span class="number">38</span> JUMP_ABSOLUTE           <span class="number">50</span>  <span class="comment">//如果a == 5成立, 那么也是跳转到字节码偏移量为50的地方, 因为是break, 也是结束循环</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//加载变量print</span></span><br><span class="line">           <span class="number">42</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//加载变量a</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span>  <span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP		            <span class="comment">//从栈顶弹出返回值</span></span><br><span class="line">           <span class="number">48</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//走到这里说明while循环执行一圈了, 那么再度跳转到while a &lt; 10的地方</span></span><br><span class="line">      &gt;&gt;   <span class="number">50</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">52</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>所以有了for循环，再看while循环就简单多了，整体逻辑和for高度相似，当然里面还结合了if。另外我们看到break和continue都是使用了JUMP_ABSOLUTE实现的。JUMP_ABSOLUTE是跳转到指定位置，通过绝对跳转实现的。break是跳转到while语句结束后的第一条指令；continue则是跳转到while循环的开始位置。</strong></p>
<p><strong>然后执行一圈之后，遇到了<code>48 JUMP_ABSOLUTE </code>，再度跳转回去。当循环不满足的时候，通过<code>10 POP_JUMP_IF_FALSE       50</code>直接结束循环，所以while事实上比for还是要简单一些的。</strong></p>
<h3 id="Python虚拟机中的异常控制流"><a href="#Python虚拟机中的异常控制流" class="headerlink" title="Python虚拟机中的异常控制流"></a>Python虚拟机中的异常控制流</h3><p><strong>异常这个东西应该是最常见的了，程序在运行的过程中经常会遇到大量的错误，而Python中也定义了大量的异常类型供我们使用，下面我们来看看Python中的异常机制，因为这也是一个控制语句。</strong></p>
<h4 id="Python中的异常机制"><a href="#Python中的异常机制" class="headerlink" title="Python中的异常机制"></a>Python中的异常机制</h4><p>​        <strong>Python虚拟机自身抛出异常</strong>    </p>
<p><strong>Python有一套内建的异常捕捉机制，即使在python的脚本文件中没有出现try语句，python脚本执行出现的异常还是会被虚拟机捕捉到。首先我们就从<code>ZeroDivisionError</code>这个异常来分析。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 / 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  2           0 LOAD_CONST               0 (1)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (0)</span></span><br><span class="line"><span class="string">              4 BINARY_TRUE_DIVIDE</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看第3条字节码指令，异常也正是在执行这条指令的时候触发的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_TRUE_DIVIDE)</span>: &#123;</span><br><span class="line">    <span class="comment">//co_consts -&gt; (0, 1)</span></span><br><span class="line">    PyObject *divisor = POP(); <span class="comment">//1</span></span><br><span class="line">    PyObject *dividend = TOP();<span class="comment">//0</span></span><br><span class="line">    <span class="comment">//调用__truediv__</span></span><br><span class="line">    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    <span class="comment">//将结果设置在栈顶</span></span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="comment">//如果结果是NULL, 那么就报错了</span></span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑很简单， 就是获取两个值，然后调用<code>PyNumber_TrueDivide</code>进行除法运算。正常情况下得到的肯定是一个数值，如果不能相除那么就返回NULL，如果接收的<code>quotient</code>是NULL，那么抛异常。因此我们来看看<code>PyNumber_TrueDivide</code>都干了些啥？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longobject.c</span></span><br><span class="line"><span class="comment">//最终调用的是long_true_divide</span></span><br><span class="line"><span class="comment">//代码很长我们截取一部分</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_true_divide</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//都是在计算除法时需要的临时变量</span></span><br><span class="line">    PyLongObject *a, *b, *x;</span><br><span class="line">    Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;</span><br><span class="line">    digit mask, low;</span><br><span class="line">    <span class="type">int</span> inexact, negate, a_is_small, b_is_small;</span><br><span class="line">    <span class="type">double</span> dx, result;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(v, w);</span><br><span class="line">    <span class="comment">//将v和w中维护的整数值转存到a和b中</span></span><br><span class="line">    a = (PyLongObject *)v;</span><br><span class="line">    b = (PyLongObject *)w;</span><br><span class="line">    a_size = Py_ABS(Py_SIZE(a));</span><br><span class="line">    b_size = Py_ABS(Py_SIZE(b));</span><br><span class="line">    negate = (Py_SIZE(a) &lt; <span class="number">0</span>) ^ (Py_SIZE(b) &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取b_size, 就是b对应的ob_size, 我们在分析PyLongObject对象时说过, 如果这个对象维护的值为0，那么ob_size就是0，这是个特殊情况</span></span><br><span class="line">    <span class="comment">//并且这个ob_size还可以体现出维护的值的正负</span></span><br><span class="line">    <span class="comment">//我们看到如果b_size == 0, 那么抛出PyExc_ZeroDivisionError</span></span><br><span class="line">    <span class="keyword">if</span> (b_size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ZeroDivisionError,</span><br><span class="line">                        <span class="string">&quot;division by zero&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果除以0，那么直接设置异常信息。另外我们说过Python中一切皆对象，那么异常也是一个对象，是一个PyObject类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pyerrors.h</span></span><br><span class="line"><span class="comment">//这里面定义了大量的异常, 比如:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">&#125; PyBaseExceptionObject; <span class="comment">//BaseException, 所有异常的基类, Exception也继承自它</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *filename;</span><br><span class="line">    PyObject *lineno;</span><br><span class="line">    PyObject *offset;</span><br><span class="line">    PyObject *text;</span><br><span class="line">    PyObject *print_file_and_line;</span><br><span class="line">&#125; PySyntaxErrorObject; <span class="comment">//语法异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *path;</span><br><span class="line">&#125; PyImportErrorObject; <span class="comment">//导包异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *encoding;</span><br><span class="line">    PyObject *object;</span><br><span class="line">    Py_ssize_t start;</span><br><span class="line">    Py_ssize_t end;</span><br><span class="line">    PyObject *reason;</span><br><span class="line">&#125; PyUnicodeErrorObject;<span class="comment">//Unicode异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *value;</span><br><span class="line">&#125; PyStopIterationObject; <span class="comment">//StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>在线程状态对象中记录异常信息(线程的知识后续会说)</strong>    </p>
<p><strong>我们之前看到，异常信息是通过<code>PyErr_SetString(异常类型, 异常信息)</code>来设置的，而除了这个<code>PyErr_SetString</code>，还会经过<code>PyErr_SetObject</code>，最终到达<code>PyErr_Restore</code>。在<code>PyErr_Restore</code>中，Python将这个异常放置到了一个安全的地方。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Restore</span><span class="params">(PyObject *type, PyObject *value, PyObject *traceback)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取线程对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Restore(tstate, type, value, traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Restore(PyThreadState *tstate, PyObject *type, PyObject *value,</span><br><span class="line">               PyObject *traceback)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//异常类型、异常值、异常的回溯栈, 对应Python中sys.exc_info()返回的元组里面的3个元组</span></span><br><span class="line">    PyObject *oldtype, *oldvalue, *oldtraceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果traceback不为空并且不是回溯栈, 那么将其设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (traceback != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(traceback)) &#123;</span><br><span class="line">        Py_DECREF(traceback);</span><br><span class="line">        traceback = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取以前的异常信息</span></span><br><span class="line">    oldtype = tstate-&gt;curexc_type;</span><br><span class="line">    oldvalue = tstate-&gt;curexc_value;</span><br><span class="line">    oldtraceback = tstate-&gt;curexc_traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置当前的异常信息</span></span><br><span class="line">    tstate-&gt;curexc_type = type;</span><br><span class="line">    tstate-&gt;curexc_value = value;</span><br><span class="line">    tstate-&gt;curexc_traceback = traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将之前的异常信息的引用计数分别减1</span></span><br><span class="line">    Py_XDECREF(oldtype);</span><br><span class="line">    Py_XDECREF(oldvalue);</span><br><span class="line">    Py_XDECREF(oldtraceback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后在tstate<code>(PyThreadState对象)</code>的curexc_type中存下了<code>PyExc_ZeroDivisionError</code>，而cur_value中存下了字符串<code>division by zero</code>，curexc_traceback存下了回溯栈。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type)  <span class="comment"># &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(exc_value)  <span class="comment"># division by zero</span></span><br><span class="line">    <span class="built_in">print</span>(exc_tb)  <span class="comment"># &lt;traceback object at 0x000001C43F29F4C0&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># exc_tb也可以通过e.__traceback__获取</span></span><br><span class="line">    <span class="built_in">print</span>(e.__traceback__ <span class="keyword">is</span> exc_tb)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再来看看PyThreadState对象<code>(这里先简单看一下，后续会详细说)</code>，这个之前说了是与线程有关的，但是它只是线程信息的一个抽象描述，而真实的线程及状态肯定是由操作系统来维护和管理的。因为Python虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。而PyThreadState对象正是Python为线程准备的、在虚拟机层面保存线程状态信息的对象<code>(后面简称线程状态对象、或者线程对象)</code>。在这里，当前活动线程<code>(OS原生线程)</code>对应的PyThreadState对象可以通过PyThreadState_GET获得，在得到了线程状态对象之后，就将异常信息存放到线程状态对象中。</strong></p>
<p>​        <strong>展开栈帧</strong>    </p>
<p><strong>首先我们知道异常已经被记录在了线程的状态中了，现在可以回头看看，在跳出了分派字节码指令的switch块所在的for循环之后，发生了什么动作。</strong></p>
<blockquote>
<p><strong>我们知道在Python&#x2F;ceval.c中有一个 *_PyEval_EvalFrameDefault* 函数，它是执行字节码指令的。里面有一个for循环，会依次遍历每一条字节码，在这个for循环里面有一个巨型switch，里面case了所有指令出现的情况。当所有指令执行完毕之后，这个for循环就结束了。</strong></p>
</blockquote>
<p><strong>但这里还存在一个问题，那就是导致跳出那个巨大的switch块所在的for循环的原因：”1. 可以是执行完了所有的字节码之后正常跳出”，”2. 也可以是发生异常后跳出”，那么Python虚拟机到底如何区分这是哪一种呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">error: <span class="comment">//一旦出现异常, 会使用goto语句跳转到error标签这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                             <span class="string">&quot;error return without exception set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        assert(_PyErr_Occurred(tstate));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果在执行switch语句的时候出现了异常，那么会跳转到error这里，否则会跳转到其它地方。当跳转到error标签的时候就代表出现异常了，注意：是在执行过程中出现异常之后Python虚拟机才获取到异常信息。</strong></p>
<p><strong>那么问题就来了，  如果在在涉及到函数调用的时候发生了异常该怎么办呢？首先在python虚拟机意识到有异常发生后，它就要开始进入异常处理的流程，这个流程会涉及到我们介绍PyFrameObject对象时所提到的那个PyFrameObject对象链表。在介绍PyFrameObject对象的时候，我们说过PyFrameObject实际上就是对栈帧的模拟，当发生函数函数调用，python会新创建一个栈帧，并将其内部的f_back连接到调用者对应的PyFrameObject，这样就形成了一条栈帧链。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是脚本运行时产生的输出，我们看到了函数调用的信息：比如在源代码的哪一行调用了哪一个函数，那么这些信息是从何而来的呢？而且我们发现输出的信息是一个链状的结构，是不是和栈帧链比较相似啊。没错，在Python虚拟机处理异常的时候，涉及到了一个traceback对象，在这个对象中记录栈帧链表的信息，Python虚拟机利用这个对象来将栈帧链表中的每一个栈帧的状态进行可视化，这个可视化的结果就是上面输出的异常信息。</strong></p>
<p><strong>回到我们的例子，当异常发生时，当前活动的栈帧是函数h对应的栈帧。在Python虚拟机开始处理异常的时候，它首先的动作就是创建一个traceback对象，用于记录异常发生时活动栈帧的状态。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里tstate还是我们之前提到的与当前活动线程对应的线程对象</span></span><br><span class="line">        <span class="comment">//其中的c_tracefunc是用户自定义的追踪函数，主要用于编写python的debugger。</span></span><br><span class="line">        <span class="comment">//但是通常情况下这个值都是NULL，所以不考虑它。</span></span><br><span class="line">        <span class="comment">//我们主要看上面的PyTraceBack_Here(f)，它到底使用PyFrameObject对象创建了一个怎样的traceback</span></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/traceback.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyTraceBack_Here</span><span class="params">(PyFrameObject *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *exc, *val, *tb, *newtb;</span><br><span class="line">    <span class="comment">//获取线程中保存线程状态的traceback对象, 进行设置</span></span><br><span class="line">    PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);</span><br><span class="line">    <span class="comment">//_PyTraceBack_FromFrame创建新的traceback对象</span></span><br><span class="line">    newtb = _PyTraceBack_FromFrame(tb, frame);</span><br><span class="line">    <span class="keyword">if</span> (newtb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_ChainExceptions(exc, val, tb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的traceback对象交给线程状态对象</span></span><br><span class="line">    PyErr_Restore(exc, val, newtb);</span><br><span class="line">    Py_XDECREF(tb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原来traceback对象是保存在线程状态对象之中的，我们来看看这个traceback对象究竟长得什么样：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/cpython/traceback.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> *<span class="title">tb_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">tb_frame</span>;</span></span><br><span class="line">    <span class="type">int</span> tb_lasti;</span><br><span class="line">    <span class="type">int</span> tb_lineno;</span><br><span class="line">&#125; PyTracebackObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到里面有一个tb_next，所以很容易想到这个traceback也是一个链表结构。其实这个PyTracebackObject对象的链表结构应该跟PyFrameObject对象的链表结构是同构的、或者说一一对应的，即一个PyFrameObject对象应该对应一个PyTracebackObject对象。我们看看这个链表是怎么产生的，在PyTraceBack_Here函数中我们看到它是通过_PyTraceBack_FromFrame创建的，那么秘密就隐藏在这个函数中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/traceback.h</span></span><br><span class="line">PyObject*</span><br><span class="line">_PyTraceBack_FromFrame(PyObject *tb_next, PyFrameObject *frame)</span><br><span class="line">&#123;</span><br><span class="line">    assert(tb_next == <span class="literal">NULL</span> || PyTraceBack_Check(tb_next));</span><br><span class="line">    assert(frame != <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//底层调用了tb_create_raw, 参数分别是下一个traceback、当前栈帧、当前f_lasti、以及源代码行号</span></span><br><span class="line">    <span class="keyword">return</span> tb_create_raw((PyTracebackObject *)tb_next, frame, frame-&gt;f_lasti,</span><br><span class="line">                         PyFrame_GetLineNumber(frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">tb_create_raw</span><span class="params">(PyTracebackObject *next, PyFrameObject *frame, <span class="type">int</span> lasti,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> lineno)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTracebackObject *tb;</span><br><span class="line">    <span class="keyword">if</span> ((next != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(next)) ||</span><br><span class="line">                    frame == <span class="literal">NULL</span> || !PyFrame_Check(frame)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    tb = PyObject_GC_New(PyTracebackObject, &amp;PyTraceBack_Type);</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//建立链表</span></span><br><span class="line">        Py_XINCREF(next);</span><br><span class="line">        <span class="comment">//这里的tb_next就是下一个traceback</span></span><br><span class="line">        tb-&gt;tb_next = next;</span><br><span class="line">        Py_XINCREF(frame);</span><br><span class="line">        <span class="comment">//设置栈帧, 所以我们可以通过e.__traceback__.tb_frame获取栈帧</span></span><br><span class="line">        tb-&gt;tb_frame = frame;</span><br><span class="line">        <span class="comment">//执行完毕时字节码偏移量</span></span><br><span class="line">        tb-&gt;tb_lasti = lasti;</span><br><span class="line">        <span class="comment">//源代码行号</span></span><br><span class="line">        tb-&gt;tb_lineno = lineno;</span><br><span class="line">        <span class="comment">//加入GC追踪, 参与垃圾回收</span></span><br><span class="line">        PyObject_GC_Track(tb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源码中我们看到，tb_next是将两个traceback连接了起来，不过这个和PyFrameObject里面f_back正好相反。f_back指向的是上一个栈帧，而tb_next指向的是下一个traceback。另外在新创建的对象中，还使用tb_frame和对应的PyFrameObject对象建立了联系，当然还有最后执行完毕的字节码偏移量以及其在源代码中对应的行号。话说还记得PyCodeObject对象中的那个co_lnotab吗，这里的tb_lineno就是通过co_lnotab获取的。</strong></p>
<p><strong>Python虚拟机意识到有异常抛出，并创建了traceback对象之后，它会在当前栈帧中寻找except语句，来执行开发人员指定的捕捉异常的动作。如果没有找到，那么Python虚拟机将退出当前的活动栈帧，并沿着栈帧链回退到上一个栈帧，在上一个栈帧中寻找except语句。就像我们之前说的，出现函数调用会创建栈帧，当函数执行完毕或者出现异常的时候，会回退到上一级栈帧。一层一层创建、一层一层返回。至于回退的这个动作，则是在<code>PyEval_EvalFrameEx</code>的最后完成，当然准确的说应该是其内部调用的<code>_PyEval_EvalFrameDefault</code>的最后。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opcode)&#123;</span><br><span class="line">            <span class="comment">//巨型switch</span></span><br><span class="line">        &#125;</span><br><span class="line">exception_unwind:</span><br><span class="line">    <span class="comment">//如果发生了异常, 这里会将异常进行展开, 然后试图进行捕获</span></span><br><span class="line">    <span class="comment">//注意: exception_unwind是位于这个大大的for循环的内部的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//里面是和异常捕获相关的逻辑, 后面会分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//retval表示_PyEval_EvalFrameDefault函数的返回值, 返回值为NULL, 那么表示有异常发生	</span></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">exit_eval_frame:</span><br><span class="line">    <span class="keyword">if</span> (PyDTrace_FUNCTION_RETURN_ENABLED())</span><br><span class="line">        dtrace_function_return(f);</span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将线程状态对象中的活动栈帧设置为上一个栈帧, 完成栈帧回退的动作</span></span><br><span class="line">    tstate-&gt;frame = f-&gt;f_back;</span><br><span class="line">    <span class="keyword">return</span> _Py_CheckFunctionResult(<span class="literal">NULL</span>, retval, <span class="string">&quot;PyEval_EvalFrameEx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>如果开发人员没有任何的捕获异常的动作，那么将通过break跳出python执行字节码的那个for循环。最后，由于没有捕获到异常， 其返回值被设置为NULL，同时通过将当前线程状态对象中的活动栈帧，设置为上一级栈帧，从而完成栈帧回退的动作。</strong></p>
<p><strong>此时我们的例子就很好解释了，当虚拟机执行函数f时，它是在PyEval_EvalFrameEx<code>(内部调用的_PyEval_EvalFrameDefault)</code>中执行与f对应的<code>PyFrameObject</code>对象中的字节码指令序列。当在函数f中调用g时，Python虚拟机又会为函数g创建新的<code>PyFrameObject</code>对象，会把控制权交给函数g对应的<code>PyFrameObject</code>，当然调用的也是<code>PyEval_EvalFrameEx</code>，只不过这次是在执行与g对应的<code>PyFrameObject</code>对象中的字节码指令序列了。同理函数g调用函数h的时候，也是一样的。所以当在函数h中发生异常，没有异常捕获、导致<code>PyEval_EvalFrameEx</code>结束时，自然要返回到、或者把控制权再交给与函数g对应的<code>PyFrameObject</code>，由<code>PyEval_EvalFrameEx</code>继续执行。由于在返回时，retval被设置为NULL，所以回到g中，Python虚拟机再次意识到有异常产生，可由于函数g中调用的时候也没有异常捕获，那么同样也要退出，再把<code>PyEval_EvalFrameEx</code>执行栈帧的控制权交给函数f对应的栈帧，如果还没有异常捕获，那么回到py文件对应的栈帧，再没有的话就直接报错了。</strong></p>
<p><strong>这个沿着栈帧链不断回退的过程我们称之为<code>栈帧展开</code>，在这个栈帧展开的过程中，Python虚拟机不断地创建与各个栈帧对应的traceback，并将其链接成链表。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012533952-1339104654.png" alt="img"></p>
<p><strong>由于我们没有设置任何的异常捕获的代码，那么python虚拟机的执行流程会一直返回到<code>PyRun_SimpleFileExFlags</code>中，这个<code>PyRun_SimpleFileExFlags</code>是干啥的我们先不管，以后分析Python运行时候的初始化时，就可以看到这个函数的作用了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_SimpleFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                        PyCompilerFlags *flags)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">       <span class="comment">//执行pyc文件 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* When running from stdin, leave __main__.__loader__ alone */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, <span class="string">&quot;&lt;stdin&gt;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            set_main_loader(d, filename, <span class="string">&quot;SourceFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用了PyRun_FileExFlags</span></span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyRun_FileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, <span class="type">int</span> start, PyObject *globals,</span></span><br><span class="line"><span class="params">                  PyObject *locals, <span class="type">int</span> closeit, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了run_mod</span></span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    Py_XDECREF(filename);</span><br><span class="line">    <span class="keyword">if</span> (arena != <span class="literal">NULL</span>)</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用run_eval_code_obj</span></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_eval_code_obj</span><span class="params">(PyCodeObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCode</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (!v &amp;&amp; PyErr_Occurred() == PyExc_KeyboardInterrupt) &#123;</span><br><span class="line">        _Py_UnhandledKeyboardInterrupt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/ceval.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCode</span><span class="params">(PyObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCodeEx</span></span><br><span class="line">    <span class="keyword">return</span> PyEval_EvalCodeEx(co,</span><br><span class="line">                      globals, locals,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCodeEx</span><span class="params">(PyObject *_co, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *args, <span class="type">int</span> argcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *kws, <span class="type">int</span> kwcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *defs, <span class="type">int</span> defcount,</span></span><br><span class="line"><span class="params">                  PyObject *kwdefs, PyObject *closure)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了_PyEval_EvalCodeWithName</span></span><br><span class="line">    <span class="keyword">return</span> _PyEval_EvalCodeWithName(_co, globals, locals,</span><br><span class="line">                                    args, argcount,</span><br><span class="line">                                    kws, kws != <span class="literal">NULL</span> ? kws + <span class="number">1</span> : <span class="literal">NULL</span>,</span><br><span class="line">                                    kwcount, <span class="number">2</span>,</span><br><span class="line">                                    defs, defcount,</span><br><span class="line">                                    kwdefs, closure,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalFrameEx, 里面的f就是在该函数中创建的栈帧对象</span></span><br><span class="line">    <span class="comment">//还记得这个返回值retval吗? 如果它是NULL, 那么代表该栈帧中有异常发生了</span></span><br><span class="line">    retval = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fail: </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//返回retval</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrameEx</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个线程对象, 里面会调用其它函数创建一个线程</span></span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET_UNSAFE();</span><br><span class="line">    <span class="comment">//执行线程对象的eval_frame</span></span><br><span class="line">    <span class="keyword">return</span> interp-&gt;eval_frame(f, throwflag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pystate.c</span></span><br><span class="line">PyInterpreterState *</span><br><span class="line"><span class="title function_">PyInterpreterState_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//你看到了什么? interp-&gt;eval_frame被设置成了_PyEval_EvalFrameDefault</span></span><br><span class="line">    interp-&gt;eval_frame = _PyEval_EvalFrameDefault;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到兜了这么多圈，最终<code>PyRun_SimpleFileExFlags</code>返回的值就是<code>PyEval_EvalFrameEx</code>返回的那个retval<code>(当然出现异常的话，就是NULL)</code>。所以接下来会调用<code>PyErr_Print</code>，然后在<code>PyErr_Print</code>中，Python虚拟机取出其维护的traceback，并遍历traceback链表，逐个输出其中的信息，也就是我们在python中看到的那个打印的异常信息。并且这个顺序是：.py文件、函数f、函数g、函数h，不是函数h、函数g、函数f、py文件。因为每一个栈帧对应一个traceback，而且是按照顺序遍历的，所以是：.py文件、函数f、g、h的顺序，当然从打印这一点也能看出来。</strong></p>
<blockquote>
<p><strong>因为是在函数h中报的错，所以退到函数g的栈帧中寻找异常捕获；如果retval为NULL，那么在退到函数f的栈帧中寻找异常捕获，再没有的话则退到模块对应的栈帧中。</strong></p>
<p><strong>模块中也没有异常捕获，那么报错。所以获取模块栈帧对应的traceback，打印异常信息，然后通过tb_next找到 *f*  对应的traceback打印其信息，依次下去……。事实上稍微想一下就能理解，虽然是在 *h* 中报的错，但根本原因是我们在模块中调用了 *f*，所以依次打印模块、f、g、h中traceback的异常信息。</strong></p>
</blockquote>
<h4 id="Python中的异常捕获"><a href="#Python中的异常捕获" class="headerlink" title="Python中的异常捕获"></a>Python中的异常捕获</h4><p><strong>目前我们知道了Python中的异常在虚拟机级别是什么，抛出异常这个动作在虚拟机层面上是怎样的一个行为，最后我们还知道了Python在处理异常时候的栈帧展开行为。但这只是Python虚拟机中内建的处理异常的动作，并没有使用Python语言中提供的异常捕获，下面我们就来看一下Python提供的异常捕获机制是如何影响Python虚拟机的异常处理流程的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    raise Exception(&quot;raise an exception&quot;)</span></span><br><span class="line"><span class="string">except Exception as e:</span></span><br><span class="line"><span class="string">    print(e)</span></span><br><span class="line"><span class="string">finally:</span></span><br><span class="line"><span class="string">    print(&quot;finally code&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;exception&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> SETUP_FINALLY           <span class="number">60</span> (to <span class="number">62</span>)</span><br><span class="line">              <span class="number">2</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;raise an exception&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> POP_BLOCK</span><br><span class="line">             <span class="number">14</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">58</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>     &gt;&gt;   <span class="number">16</span> DUP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">             <span class="number">20</span> COMPARE_OP              <span class="number">10</span> (exception <span class="keyword">match</span>)</span><br><span class="line">             <span class="number">22</span> POP_JUMP_IF_FALSE       <span class="number">56</span></span><br><span class="line">             <span class="number">24</span> POP_TOP</span><br><span class="line">             <span class="number">26</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">28</span> POP_TOP</span><br><span class="line">             <span class="number">30</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">32</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">36</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">38</span> POP_TOP</span><br><span class="line">             <span class="number">40</span> POP_BLOCK</span><br><span class="line">             <span class="number">42</span> BEGIN_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">44</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">46</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">48</span> DELETE_NAME              <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">50</span> END_FINALLY</span><br><span class="line">             <span class="number">52</span> POP_EXCEPT</span><br><span class="line">             <span class="number">54</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">58</span>)</span><br><span class="line">        &gt;&gt;   <span class="number">56</span> END_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">58</span> POP_BLOCK</span><br><span class="line">             <span class="number">60</span> BEGIN_FINALLY</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>     &gt;&gt;   <span class="number">62</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">64</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;finally code&#x27;</span>)</span><br><span class="line">             <span class="number">66</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">68</span> POP_TOP</span><br><span class="line">             <span class="number">70</span> END_FINALLY</span><br><span class="line">             <span class="number">72</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">74</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先这个指令集比较复杂，因为要分好几种情况。try里面没有出现异常；try里面出现了异常、但是except语句没有捕获到；try里面出现了异常，except语句捕获到了。但我们知道无论是哪种情况，都要执行finally。</strong></p>
<p><strong>我们先看上面的SETUP_FINALLY指令，这里为包含finally语句做准备的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(SETUP_FINALLY)</span>: &#123;</span><br><span class="line">            <span class="comment">/* <span class="doctag">NOTE:</span> If you add any new block-setup opcodes that</span></span><br><span class="line"><span class="comment">               are not try/except/finally handlers, you may need</span></span><br><span class="line"><span class="comment">               to update the PyGen_NeedsFinalizing() function.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            <span class="comment">//我们看到仅仅是调用了一个PyFrame_BlockSetup函数</span></span><br><span class="line">            PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,</span><br><span class="line">                               STACK_LEVEL());</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/frameobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyFrame_BlockSetup</span><span class="params">(PyFrameObject *f, <span class="type">int</span> type, <span class="type">int</span> handler, <span class="type">int</span> level)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个PyTryBlock *</span></span><br><span class="line">    PyTryBlock *b;</span><br><span class="line">    <span class="comment">//这个f_iblock为当前指令在f_blockstack上的索引, 还记得这个f_blockstack吗?我们在介绍栈帧的时候说过的,它可以用于try代码块</span></span><br><span class="line">    <span class="comment">//f_blockstack是一个数组, 内部存储了多个PyTryBlock对象</span></span><br><span class="line">    <span class="comment">//PyTryBlock f_blockstack[CO_MAXBLOCKS]; CO_MAXBLOCKS是一个宏，为20</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_iblock &gt;= CO_MAXBLOCKS)</span><br><span class="line">        Py_FatalError(<span class="string">&quot;XXX block stack overflow&quot;</span>);</span><br><span class="line">    <span class="comment">//这里我们算是真正意义上第一次使用栈帧中的f_blockstack属性</span></span><br><span class="line">    <span class="comment">//这里得到的b显然是个PyTryBlock结构体实例</span></span><br><span class="line">    b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++];</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    b-&gt;b_type = type;</span><br><span class="line">    b-&gt;b_level = level;</span><br><span class="line">    b-&gt;b_handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//frameobject.h</span></span><br><span class="line"><span class="comment">//我们看看PyTryBlock长什么样</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> b_type;                 <span class="comment">/* what kind of block this is */</span></span><br><span class="line">    <span class="type">int</span> b_handler;              <span class="comment">/* where to jump to find handler */</span></span><br><span class="line">    <span class="type">int</span> b_level;                <span class="comment">/* value stack level to pop to */</span></span><br><span class="line">&#125; PyTryBlock;</span><br><span class="line"><span class="comment">//显然PyFrameObject对象中的f_blockstack是一个由PyTryBlock对象组成的数组，而SETUP_FINALLY指令所做的就是从这个数组中获得了一块PyTryBlock对象</span></span><br><span class="line"><span class="comment">//并在这个对象中存放了一些Python虚拟机当前的状态信息。比如当前执行的字节码指令，当前运行时栈的深度等等。</span></span><br><span class="line"><span class="comment">//那么这个结构在try控制结构中起着什么样的作用呢？我们后面就会知晓</span></span><br><span class="line"><span class="comment">//我们注意到PyTryBlock中有一个b_type域，注释写着这个域是用来表示是block的种类, 也就意味着存在着多种不同用途的PyTryBlock对象。</span></span><br><span class="line"><span class="comment">//从PyFrame_BlockSetup中可以看到，这个b_type实际上被设置为当前Python虚拟机正在执行的字节码指令，以字节码指令作为区分PyTryBlock的不同用途</span></span><br></pre></td></tr></table></figure>

<p><strong>但我们看到开头有两个SETUP_FINALLY，其实在Python3.8之前，第二个SETUP_FINALLY应该是SETUP_EXCEPT，但是在3.8中都变成了SETUP_FINALLY。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012542306-595809675.png" alt="img"></p>
<p><strong>在这里分出两块PyTryBlock，肯定是要在捕捉异常的时候用。不过别着急，我们先回到抛出异常的地方看看：<code>10 RAISE_VARARGS 1</code>。在<code>RAISE_VARARGS</code>之前，通过<code>LOAD_NAME</code>、<code>LOAD_CONST</code>、<code>CALL_FUNCTION</code>构造出了一个异常对象，当然尽管Exception是一个类，但调用的指令也同样是CALL_FUNCTION<code>(至于这个指令的剖析和对象的创建后面章节会介绍，这里只需要知道一个异常已经被创建出来了)</code>，并将这个异常压入栈中。而<code>RAISE_VARARGS</code>指令的工作就从把这个异常对象从运行时栈取出开始。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(RAISE_VARARGS)</span>: &#123;</span><br><span class="line">    PyObject *cause = <span class="literal">NULL</span>, *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (oparg) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cause = POP(); <span class="comment">/* cause */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        exc = POP(); <span class="comment">/* exc */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (do_raise(tstate, exc, cause)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;bad RAISE_VARARGS oparg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里RAISE_VARARGS后面的参数是1，所以直接将异常对象取出赋给exc，然后调用do_raise函数。在do_raise中，最终调用之前的说过的<code>PyErr_Restore</code>函数，将异常对象存储到当前的线程对象中。在经过了一系列繁复的动作之后<code>(比如创建并设置traceback)</code>，通过do_raise，Python虚拟机将携带着<code>(f_iblock=2)</code>信息抵达真正捕捉异常的代码，我们看到跳转到了标签为exception_unwind的地方进行异常捕获，并且在最后，Python虚拟机通过一个break的动作跳出了分发字节码指令的那个巨大的switch语句所在的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">exception_unwind:</span><br><span class="line">        <span class="comment">/* Unwind stacks if an exception occurred */</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            PyTryBlock *b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock];</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;b_type == SETUP_FINALLY) &#123;</span><br><span class="line">                PyObject *exc, *val, *tb;</span><br><span class="line">                <span class="type">int</span> handler = b-&gt;b_handler;</span><br><span class="line">                _PyErr_StackItem *exc_info = tstate-&gt;exc_info;</span><br><span class="line">                <span class="comment">/* Beware, this invalidates all b-&gt;b_* fields */</span></span><br><span class="line">                PyFrame_BlockSetup(f, EXCEPT_HANDLER, <span class="number">-1</span>, STACK_LEVEL());</span><br><span class="line">                PUSH(exc_info-&gt;exc_traceback);</span><br><span class="line">                PUSH(exc_info-&gt;exc_value);</span><br><span class="line">                <span class="keyword">if</span> (exc_info-&gt;exc_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    PUSH(exc_info-&gt;exc_type);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Py_INCREF(Py_None);</span><br><span class="line">                    PUSH(Py_None);</span><br><span class="line">                &#125;</span><br><span class="line">                _PyErr_Fetch(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="comment">/* Make the raw exception data</span></span><br><span class="line"><span class="comment">                   available to the handler,</span></span><br><span class="line"><span class="comment">                   so a program can emulate the</span></span><br><span class="line"><span class="comment">                   Python main loop. */</span></span><br><span class="line">                _PyErr_NormalizeException(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="keyword">if</span> (tb != <span class="literal">NULL</span>)</span><br><span class="line">                    PyException_SetTraceback(val, tb);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    PyException_SetTraceback(val, Py_None);</span><br><span class="line">                Py_INCREF(exc);</span><br><span class="line">                exc_info-&gt;exc_type = exc;</span><br><span class="line">                Py_INCREF(val);</span><br><span class="line">                exc_info-&gt;exc_value = val;</span><br><span class="line">                exc_info-&gt;exc_traceback = tb;</span><br><span class="line">                <span class="keyword">if</span> (tb == <span class="literal">NULL</span>)</span><br><span class="line">                    tb = Py_None;</span><br><span class="line">                Py_INCREF(tb);</span><br><span class="line">                PUSH(tb);</span><br><span class="line">                PUSH(val);</span><br><span class="line">                PUSH(exc);</span><br><span class="line">                JUMPTO(handler);</span><br><span class="line">                <span class="comment">/* Resume normal execution */</span></span><br><span class="line">                <span class="keyword">goto</span> main_loop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">/* unwind stack */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* End the loop as we still have an error */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">/* main loop */</span></span><br><span class="line"></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机首先从当前的<code>PyFrameObject</code>对象中的<code>f_blockstack</code>中弹出一个<code>PyTryBlock</code>来，从代码中能看到弹出的是<code>b_type = SETUP_FINALLY, b_handler=16</code>的PyTryBlock。另一方面，Python虚拟机通过<code>PyErr_Fetch</code>得到了当前线程状态对象中存储的最新的异常对象和traceback对象：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Fetch</span><span class="params">(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Fetch(tstate, p_type, p_value, p_traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Fetch(PyThreadState *tstate, PyObject **p_type, PyObject **p_value,</span><br><span class="line">             PyObject **p_traceback)</span><br><span class="line">&#123;</span><br><span class="line">    *p_type = tstate-&gt;curexc_type;</span><br><span class="line">    *p_value = tstate-&gt;curexc_value;</span><br><span class="line">    *p_traceback = tstate-&gt;curexc_traceback;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;curexc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_traceback = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回到exception_unwind，我们看到之后python虚拟机调用PUSH将tb、val、exc分别压入运行时栈中，而且Python知道此时程序猿已经为异常处理做好了准备，所以接下来的异常处理工作，则需要交给程序员指定的代码来解决，这个动作通过JUMP_FORWARD<code>(JUMPTO(b-&gt;b_handler))</code>来完成。JUMPTO其实仅仅是进行了一下指令的跳跃，将Python虚拟机将要执行的下一条指令设置为异常处理代码编译后所得到的第一条字节码指令。</strong></p>
<p><strong>因为f_blockstack是从后往前弹出的，所以第一个弹出的是PyTryBlock中b_handler为16的SETUP_FINALLY，那么Python虚拟机将要执行的下一条指令就是偏移量为16的那条指令，而这条指令就是DUP_TOP，异常处理代码对应的第一条字节码指令。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(DUP_TOP)</span>: &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    PUSH(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们<code>except Exception</code>，毫无疑问要LOAD_NAME，把这个异常给load进来，然后调用指令COMPARE_OP，这个显然就是比较我们指定捕获的异常和运行时栈中存在的那个被捕获的异常是否匹配。POP_JUMP_IF_FALSE如果为Py_True表示匹配，那么继续往下执行print(e)对应的字节码指令，POP_TOP将异常从栈顶弹出，赋值给e，然后打印等等。如果POP_JUMP_IF_FALSE为Py_False表示不匹配，那么我们发现直接跳转到了<code>56 END_FINALLY</code>，因为异常不匹配的话，那么异常的相关信息还是要重新放回线程对象当中，让Python重新引发异常，而这个动作就由END_FINALLY完成，通过PyErr_Restore函数将异常信息重新写回线程对象中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(END_FINALLY)</span>: &#123;</span><br><span class="line">    PREDICTED(END_FINALLY);</span><br><span class="line">    <span class="comment">/* At the top of the stack are 1 or 6 values:</span></span><br><span class="line"><span class="comment">       Either:</span></span><br><span class="line"><span class="comment">        - TOP = NULL or an integer</span></span><br><span class="line"><span class="comment">       or:</span></span><br><span class="line"><span class="comment">        - (TOP, SECOND, THIRD) = exc_info()</span></span><br><span class="line"><span class="comment">        - (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject *exc = POP();</span><br><span class="line">    <span class="keyword">if</span> (exc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyLong_CheckExact(exc)) &#123;</span><br><span class="line">        <span class="type">int</span> ret = _PyLong_AsInt(exc);</span><br><span class="line">        Py_DECREF(exc);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; _PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        JUMPTO(ret);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(PyExceptionClass_Check(exc));</span><br><span class="line">        PyObject *val = POP();</span><br><span class="line">        PyObject *tb = POP();</span><br><span class="line">        <span class="comment">//将异常信息又写入到了线程状态对象当中了</span></span><br><span class="line">        _PyErr_Restore(tstate, exc, val, tb);</span><br><span class="line">        <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然而不管异常是否匹配，最终处理异常的两条岔路都会在<code>58 POP_BLOCK</code>处汇合。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PREDICTED(POP_BLOCK);</span><br><span class="line">TARGET(POP_BLOCK) &#123;</span><br><span class="line">    <span class="comment">//这里将当前PyFrameObject的f_blockstack中还剩下的那个与SETUP_FINALLY对应的PyTryBlock对象弹出</span></span><br><span class="line">    <span class="comment">//然后python虚拟机的流程就进入了与finally表达式对应的字节码指令了。</span></span><br><span class="line">    PyTryBlock *b = PyFrame_BlockPop(f);</span><br><span class="line">    UNWIND_BLOCK(b);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在Python异常机制的实现中，最终要的就是虚拟机状态以及PyFrameObject对象中f_blockstack里存放的PyTryBlock对象了。首先根据Python虚拟机状态可以判断当前是否发生了异常，而PyTryBlock对象则告诉python虚拟机，程序员是否为异常设置了except代码块和finally代码块，python虚拟机异常处理的流程就是在虚拟机所处的状态和PyTryBlock的共同作用下完成的。</strong></p>
<blockquote>
<p><strong>还是那句话，在3.8之前Python的指令集中存在一个SETUP_EXCEPT，但是在3.8的时候只有SETUP_FINALLY了。</strong></p>
</blockquote>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012551427-2065530599.png" alt="img"></p>
<p><strong>总之Python中一旦出现异常了，那么会将异常类型、异常值、异常回溯栈设置在线程状态对象中，然后栈帧一步一步的后退寻找异常捕获代码<code>(从内向外)</code>。如果退到了模块级别还没有发现异常捕获，那么从外向内打印traceback中的信息，当走到最后一层的时候再将线程中设置的异常类型和异常值打印出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先是在模块中调用了f、f调用了g、g调用了h, 所以在h中出现了异常、发现又没有异常捕获, 所以将执行权交给函数g对应的栈帧</span></span><br><span class="line"><span class="comment"># 但是g也没有异常捕获, 所以再将执行权交给函数f对应的栈帧, 所以调用的时候栈帧一层一层创建, 执行完毕、或者出现异常, 栈帧一层一层向后退</span></span><br><span class="line"><span class="comment"># 所以h的f_back指向g、g的f_back指向f、f的f_back指向模块、模块的f_back为None</span></span><br><span class="line"><span class="comment"># 但是对应的traceback则是模块的tb_next指向f、f的tb_next指向g、g的tb_next指向h、h的tb_next为None</span></span><br><span class="line"><span class="comment"># 而我们说栈帧层层后退, 退到模块对应的栈帧的时候要是还没有发现异常捕获, 那么就报错了</span></span><br><span class="line"><span class="comment"># 所以此时会打印模块对应的traceback的信息, 然后依次是f、g、h, 因为栈帧是从&quot;函数h到模块&quot;、但traceback则是从&quot;模块到函数h&quot;</span></span><br><span class="line"><span class="comment"># 所以我们仔细观察一下输出的异常信息, 不难印证我们的结论</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):  # traceback回溯栈</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;  # 打印模块的traceback</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f  # 打印f的traceback</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g   # 打印g的traceback</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h   # 打印h的traceback</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero  # h的tb_next为None, 证明是在h中发生了错误, 所以再将之前设置线程状态对象中异常类型和异常值打印出来即可</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>至于Python在处理异常的时候都经历哪些历程，我们虽然分析了，但其实还不够详细。因为Python的异常机制牵扯到底层的方方面面，并且涉及到了很多的宏，有兴趣可以自己再仔细深入研究。另外需要注意的是：Python3.8变化还是比较大的，在字节码方面你通过和3.7对比就可以发现。</strong></p>
<p>​        <strong>最后再看一个思考题</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># NameError: name &#x27;e&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>why？我们发现在外面打印e的时候，告诉我们e没有被定义。这是为什么呢？首先可以肯定的是，肯定是<code>except Exception as e</code>导致的，因为我们as的也是e，和外面的e重名了，如果我们as的是e1呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="built_in">print</span>(e1)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># 2.718</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到as的是e1就没有问题了，但是为什么呢？即便不知道原因，也能推测出来。因为外面的变量叫e，而我们捕获异常as的也是e，此时e的指向就变了，而当异常处理结束的时候，e这个变量就被销毁了，所以外面就找不到了。然而事实上也确实如此。我们可以看一下字节码，通过观察我们上面例子的字节码，就能很清晰地看出端倪了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2.718</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">6</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;我要引发异常了&#x27;</span>)</span><br><span class="line">           <span class="number">10</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">12</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">           <span class="number">14</span> POP_BLOCK</span><br><span class="line">           <span class="number">16</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>     &gt;&gt;   <span class="number">18</span> DUP_TOP</span><br><span class="line">           <span class="number">20</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">           <span class="number">22</span> COMPARE_OP              <span class="number">10</span> (exception match)</span><br><span class="line">           <span class="number">24</span> POP_JUMP_IF_FALSE       <span class="number">58</span></span><br><span class="line">           <span class="number">26</span> POP_TOP</span><br><span class="line">           <span class="number">28</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">30</span> POP_TOP</span><br><span class="line">           <span class="number">32</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">46</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">36</span> LOAD_NAME                <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">38</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">40</span> POP_TOP</span><br><span class="line">           <span class="number">42</span> POP_BLOCK</span><br><span class="line">           <span class="number">44</span> BEGIN_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">46</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">48</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">50</span> DELETE_NAME              <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">52</span> END_FINALLY</span><br><span class="line">           <span class="number">54</span> POP_EXCEPT</span><br><span class="line">           <span class="number">56</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">60</span>)</span><br><span class="line">      &gt;&gt;   <span class="number">58</span> END_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">60</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">62</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码很长，但是我们只需要看偏移量为50的那个字节码即可。你看到了什么，<code>DELETE_NAME</code>直接把e这个变量给删了，所以我们就找不到了，因此代码相当于下面这样：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> e</span><br></pre></td></tr></table></figure>

<p><strong>因此在异常处理的时候，如果把异常赋予了一个变量，那么这个变量异常处理结束会被删掉，因此只能在except里面使用，这就是原因。但是原因有了，可动机呢？Python这么做的动机是什么？根据官网文档解释：</strong></p>
<blockquote>
<p><strong>当使用 as 将目标赋值为一个异常时，它将在 except  子句结束时被清除，这意味着异常必须赋值给一个不同的名称(不同于外部指定的变量)，才能在 except  子句之后引用它(外部指定的变量)。异常会被清除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变量保持存活直到发生下一次垃圾回收。</strong></p>
</blockquote>
<p>​        <strong>try、except、finally的返回值问题</strong>    </p>
<p><strong>我们看看这三者的返回值之间的关系：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于没有发生异常, 所以返回了try指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时发生异常, 所以返回了except指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># 456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的还是try指定的返回值, 因为finally中没有指定返回值</span></span><br><span class="line"><span class="built_in">print</span>(f3())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f4</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦finally中出现了return, 那么在没有报错的情况下返回的都是finally指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f4())  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f5</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们函数一旦出现了return, 那么就表示结束函数直接返回了</span></span><br><span class="line"><span class="comment"># 但是return如果是在try中, 那么可以认为将返回值存起来了, 执行完finally之后再返回</span></span><br><span class="line"><span class="comment"># 如果finally也指定了return, 那么会返回finally指定的返回值, 否则还是返回之前的</span></span><br><span class="line"><span class="comment"># 总之一句话, 只要在try或者except中出现了return(前提是没有异常、或者异常被成功捕获)</span></span><br><span class="line"><span class="comment"># 那么在finally执行完毕之后, 会立即返回, 不会执行finally下面的代码</span></span><br><span class="line"><span class="built_in">print</span>(f5())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f6</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常, 所以except的return没啥卵用, 但是try和finally中也没有return</span></span><br><span class="line"><span class="comment"># 所以程序会继续往下走</span></span><br><span class="line"><span class="built_in">print</span>(f6())  <span class="comment"># 789</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们就分析了Python的控制语句，if、for、while都比较简单。但Python中的异常捕获算是比较复杂的，主要是牵扯的东西比较多，有时候分析某一个地方需要跳好几个源文件，进行查找。因此有兴趣的话，可以杀进源码中自由翱翔，但是注意Python的版本，我们说3.8版本和3.8之前的版本之间区别还是蛮大的。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Python字符串的底层实现</title>
    <url>/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="07-Python字符串的底层实现"><a href="#07-Python字符串的底层实现" class="headerlink" title="07-Python字符串的底层实现"></a>07-Python字符串的底层实现</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这一次我们分析一下Python中的字符串，首先Python中的字符串是一个变长对象，因为不同长度的字符串所占的内存空间是不一样的；但同时字符串又是一个不可变对象，因为一旦创建就不可以再修改了。</strong></p>
<p><strong>而Python中的字符串是通过unicode来表示的，因此在底层对应的结构体是PyUnicodeObject。但是为什么需要unicode呢?</strong></p>
<blockquote>
<p><strong>首先计算机存储的基本单位是字节，由8个比特位组成，由于英文字母算上大小写只有52个，再加上若干字符，数量不会超过256个，因此一个字节完全可以表示，这些字符称之为ASCII字符。但是随着非英文字符的出现，导致一个字节已经无法表示了，只能曲线救国，对于一个字节无法表示的字符，使用多个字节表示。</strong></p>
<p><strong>但是这样会出现两个问题：</strong></p>
<ul>
<li><code>不支持多国语言，例如中文的编码不可以包含日文；</code></li>
<li><code>没有统一标准，例如中文有GB2312、GBK、GB18030等多个标准；</code></li>
</ul>
<p><strong>所以由于编码不统一，开发人员经常在不同的编码间来回转换，会错误频出。为了彻底解决这个问题，unicode标准诞生了。unicode对世界上的文字系统进行了系统的整理、编码，让计算机可以用统一的方式处理文本，而且目前已经支持超过13万个字符，天然地支持多国语言。</strong></p>
</blockquote>
<p><strong>但是问题来了，unicode能表示这么多的字符，那么占用的内存一定不低吧。是的，根据当时的编码，一个unicode字符最高会占用到4字节。但是对于西方人来说，明明一个字符就够用了，为啥需要那么多。于是又出现了utf-8，它是为unicode提供的新一个新的编码规则，具有可变长的功能。对于1个ASCII字符那么会使用一个字节存储，对于非ASCII字符会使用3个字节存储。</strong></p>
<p><strong>但Python3中表示unicode字符串时，使用的却不是utf-8，至于原因我们下面来分析一下。国外有一篇文章，题目翻译过来说的是”Python在存储字符串的时候如何节省内存”，写的非常好，我们来看看。</strong></p>
<h3 id="Python在存储字符串的时候如何节省内存"><a href="#Python在存储字符串的时候如何节省内存" class="headerlink" title="Python在存储字符串的时候如何节省内存"></a>Python在存储字符串的时候如何节省内存</h3><p><strong>从Python3开始，str类型使用的是Unicode。而根据编码的不同，Unicode的每个字符最大可以占到4字节，从内存的角度来说， 这种编码有时会比较昂贵。</strong></p>
<p><strong>为了减少内存消耗并且提高性能，python的内部使用了三种编码方式表示Unicode。</strong></p>
<ul>
<li><code>Latin-1 编码：每个字符一字节;</code></li>
<li><code>UCS2 编码：每个字符两字节;</code></li>
<li><code>UCS4 编码：每个字符四字节;</code></li>
</ul>
<p><strong>在Python编程中，所有字符串的行为都是一致的，而且大多数时间我们都没有注意到差异。然而在处理大文本的时候，这种差异就会变得异常显著、甚至有些让人出乎意料。</strong></p>
<p><strong>为了看到内部表示的差异，我们使用<code>sys.getsizeof</code>函数，返回一个对象所占的字节数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 50</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 76</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 80</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到都是一个字符，但是它们占用的内存却是不一样的。</strong></p>
<p><strong>正如你所见，Python面对不同的字符会采用不同的编码。需要注意的是，Python中的每一个字符串都需要额外占用49-80字节，因为要存储一些额外信息，比如：哈希、长度、字节长度、编码类型等等。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于ASCII字符，显然一个占1字节，显然此时编码是Latin-1编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;ab&quot;</span>) - sys.getsizeof(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于汉字，日文等等，一个占用2字节，此时是UCS2编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨憨&quot;</span>) - sys.getsizeof(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;です&quot;</span>) - sys.getsizeof(<span class="string">&quot;で&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 像emoji，则是一个占4字节 ，此时是UCS4编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;💻💻&quot;</span>) - sys.getsizeof(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p><strong>而采用不同的编码，那么底层结构体实例额外的部分也会占用不同大小的内存。如果编码是Latin-1，那么这个结构体实例额外的部分会占49个字阶；编码是UCS2，占74个字节；编码是UCS4，占76个字节。然后字符串所占的字节数就等于：<code>额外的部分 + 字符个数 \* 单个字符所占的字节</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以一个空字符串占用49个字节, 此时会采用占用内存最小的Latin-1编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;&quot;</span>))  <span class="comment"># 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时使用UCS2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨&quot;</span>) - <span class="number">2</span>)  <span class="comment"># 74</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UCS4</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴&quot;</span>) - <span class="number">4</span>)  <span class="comment"># 76</span></span><br></pre></td></tr></table></figure>

<h4 id="为什么python底层存储字符串不使用utf-8编码"><a href="#为什么python底层存储字符串不使用utf-8编码" class="headerlink" title="为什么python底层存储字符串不使用utf-8编码"></a>为什么python底层存储字符串不使用utf-8编码</h4><p><strong>我们先来抛出一个问题：****首先我们知道Python支持通过索引查找一个字符串中指定位置的字符，而且Python中默认是以</strong>字符<strong>为单位的，不是</strong>字节**<code>(我们后面还会提)</code>，比如s[2]搜索的就是字符串s中的第3个字符。**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;My姫様&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>])  <span class="comment"># 姫</span></span><br></pre></td></tr></table></figure>

<p><strong>那么问题来了，我们知道Python中通过索引查找字符串的指定字符，时间复杂度为O(1)，那么Python是怎么通过索引、比如这里的s[2]，一下子就跳到第3个字符呢？显然是通过指针的偏移，用索引乘上每个字符占的字节数，得到偏移量，然后从头部向后偏移指定数量的字节即可，这样就能在定位到指定字符的同时保证时间复杂度为O(1)，但是这就需要一个前提：字符串中每个字符所占的大小必须是相同的，如果字符占的大小不同<code>(比如有的占用1字节、有的占用3字节)</code>，显然无法通过指针偏移的方式了，这个时候还想准确定位的话，只能按顺序对所有字符都逐个扫描，但这样的话时间复杂度肯定不是O(1)，而是O(n)。</strong></p>
<p><strong>我们以golang为例，golang中的字符串默认就是使用的utf-8。</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200807233641141-741445258.png" alt="img"></p>
<blockquote>
<p><strong>惊了，我们看到打印的并不是我们希望的结果。因为golang底层使用的是utf-8，不同的字符可能会占用不同的编码。但是golang中通过索引定位的时候，时间复杂度是O(1)，所以golang它就无法定位到准确的字符。</strong></p>
<p><strong>golang的字符串在通过索引定位的时候，比如这里的s[2]，会跳转两个字节，因为不同字符占的字节可能是不同的，因此在计算偏移量的时候只能以占用最小的、ASCII字符所占的字节为单位，即1个字节，所以计算的。只不过前面两个字符碰巧都是英文，每个占1字节，所以跳到了”姫”这个位置上。如果出现了非ASCII字符，那么是绝对跳不准的。而且在获取的时候，也只能获取1个字节。但是使用utf-8的话，非ASCII字符是占3个字节，显然一个字节是无法表示的。</strong></p>
</blockquote>
<p><strong>所以Python会使用3个编码，对应编码的字符分别是1、2、4字节。因此Python在创建字符串的时候，会先扫描。或者尝试使用占字节数最少的Latin1编码存储，但是范围肯定有限。如果发现了存储不下的字符，只能改变编码，使用UCS2，继续扫描。但是又发现了新的字符，这个字符UCS2也无法存储，因为两个字节最多存储65535个不同的字符，所以会再次改变编码，使用ucs4存储。ucs4占四个字节，肯定能存下了。</strong></p>
<p><strong>一旦改变编码，字符串中的所有字符都会使用同样的编码，因为它们不具备可变长功能。比如这个字符串：”hello古明地觉”，肯定都会使用UCS2，不存在说”hello”使用Latin1，”古明地觉”使用UCS2，因为一个字符串只能有一个编码。当通过索引获取的时候，会将索引乘上每个字符占的字节数，这样就能跳到准确位置上，因为字符串里面的所有字符占用的字节都是一样的，然后获取也会获取指定的字节数。比如：使用UCS2编码，那么定位到某个字符的时候，会取两个字节，这样才能表示一个完整的字符。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时全部是ascii字符，那么Latin1编码可以存储</span></span><br><span class="line"><span class="comment"># 所以结构体实例额外的部分占49个字节</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># 有5个字符，一个字符一个字节，所以加一起是54个字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s1))  <span class="comment"># 54</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现了汉字，那么Latin肯定存不下，于是使用UCS2</span></span><br><span class="line"><span class="comment"># 所以此时结构体实例额外的部分占74个字节</span></span><br><span class="line"><span class="comment"># 但是别忘了此时的英文字符也是ucs2，所以也是一个字符两字节</span></span><br><span class="line">s2 = <span class="string">&quot;hello憨&quot;</span></span><br><span class="line"><span class="comment"># 6个字符，74 + 6 * 2 = 86</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s2))  <span class="comment"># 86</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个牛逼了，ucs2也存不下，只能ucs4存储了</span></span><br><span class="line"><span class="comment"># 所以结构体实例额外的部分占76个字节</span></span><br><span class="line">s3 = <span class="string">&quot;hello憨💻&quot;</span></span><br><span class="line"><span class="comment"># 此时所有字符一个占4字节，7个字符</span></span><br><span class="line"><span class="comment"># 76 + 7 * 4 = 104</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s3))  <span class="comment"># 104</span></span><br></pre></td></tr></table></figure>

<p><strong>除此之外，我们再举一个例子更形象地证明这个现象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;a&quot;</span> * <span class="number">1000</span></span><br><span class="line">s2 = <span class="string">&quot;a&quot;</span> * <span class="number">1000</span> + <span class="string">&quot;💻&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到s2只比s1多了一个字符</span></span><br><span class="line"><span class="comment"># 但是两者占的内存，s2却将近是s1的四倍。</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s1), sys.getsizeof(s2))  <span class="comment"># 1049 4080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们知道s2和s1的差别只是s2比s1多了一个字符，但就是这么一个字符导致s2比s1多占了3031个字节</span></span><br><span class="line"><span class="comment"># 显然这多出来的3031个字节不可能是多出来的字符所占的大小，什么字符一个会占到三千多个字节</span></span><br><span class="line"><span class="comment"># 尽管如此，但它也是罪魁祸首，不过前面的1000个字符也是共犯</span></span><br><span class="line"><span class="comment"># 我们说Python会根据字符串选择不同的编码，s1全部是ascii字符，所以Latin1能存下，因此一个字符只占一个字节</span></span><br><span class="line"><span class="comment"># 所以大小就是49 + 1000 = 1049 </span></span><br><span class="line"><span class="comment"># 但是对于s2，python发现前1000个字符Latin1能存下，但是不幸的是，最后一个字符发现存不下了，只能使用UCS4</span></span><br><span class="line"><span class="comment"># 而字符串的所有字符只能有一个编码，为了保证索引查找的时候，时间复杂度为O(1)，这是Python的设计策略</span></span><br><span class="line"><span class="comment"># 因此导致前面一个字节就能存下的字符，每一个也变成了4个字节。</span></span><br><span class="line"><span class="comment"># 而我们说使用UCS4，结构体额外的内存会占76个字节</span></span><br><span class="line"><span class="comment"># 因此s2的大小就是：76 + 1001 * 4 = 76 + 4004 = 4080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相信下面你肯定能分析出来</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;爷的青春回来了&quot;</span>))  <span class="comment"># 88</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴的青春回来了&quot;</span>))  <span class="comment"># 104</span></span><br></pre></td></tr></table></figure>

<p><strong>所以如果字符串中的所有字符对应的ASCII码都在0~255范围内，则使用1字节Latin1对其进行编码。基本上，Latin1能表示前256个Unicode字符。它支持多种拉丁语，如英语、瑞典语、意大利语、挪威语。但是它们不能存储非拉丁语言，比如汉语、日语、希伯来语、西里尔语。这是因为它们的代码点(数字索引)定义在1字节(0-255)范围之外。</strong></p>
<p><strong>大多数流行的自然语言都可以采用2字节(UCS2)编码。当字符串包含特殊符号、emoji或稀有语言时，使用4字节(UCS4)编码。Unicode标准有将近300个块(范围)。你可以在0XFFFF块之后找到4字节块。假设我们有一个10G的ASCII文本，我们想把它加载到内存中，但如果我们在文本中插入一个表情符号，那么字符串的大小将增加4倍。这是一个巨大的差异，你可能会在实践当中遇到，比如处理NLP问题。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 25000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 128187</span></span><br></pre></td></tr></table></figure>

<p><strong>所以最著名和最流行的Unicode编码都是utf-8，但是python不在内部使用它，而是使用Latin1、UCS2、UCS4。至于原因我们上面已经解释的很清楚了，主要是Python的索引是基于字符：</strong></p>
<blockquote>
<p><strong>当一个字符串使用utf-8编码存储时，根据它所表示的字符，每个字符会根据自身选择一个合适的编码。这是一种存储效率很高的编码，但是它有一个明显的缺点。由于每个字符的字节长度可能不同，因此就导致无法按照索引瞬间定位到单个字符，即便能定位，也无法定位准确。如果想准，那么只能逐个扫描所有字符。</strong></p>
<p><strong>因此要对使用utf-8编码的字符串执行一个简单的操作，比如s[5]，就意味着Python需要扫描每一个字符，直到找到需要的字符，这样效率是很低的。但如果是固定长度的编码就没有这样的问题，所以当Latin 1存储的”hello”，在和”憨色儿”组合之后，整体每一个字符都会向大的方向扩展、变成了2字节。这样定位字符的时候，只需要将”索引 *  2”计算出偏移的字节数、然后跳转该字节数即可。但如果原来的”hello”还是一个字节、而汉字是2字节，那么只通过索引是不可能定位到准确字符的，因为不同类型字符的编码不同，必须要扫描整个字符串才可以。但是扫描字符串，效率又比较低。所以python内部才会使用这个方法，而不是使用utf-8。</strong></p>
</blockquote>
<p><strong>所以对于golang来讲，如果想像Python一样，那么需要这么做：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;My姫様&quot;</span></span><br><span class="line">	<span class="comment">//我们看到长度为8, 因为它使用utf-8编码</span></span><br><span class="line">	<span class="comment">//底层一个非ascii字符占3字节, 所以总共8字节</span></span><br><span class="line">	fmt.Println(s, <span class="built_in">len</span>(s))  <span class="comment">// My姫様 8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果想像Python一样,那么golang中提供了一个rune, 相当于int32, 此时直接使用4个字节</span></span><br><span class="line">	r := []<span class="type">rune</span>(s)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(r), <span class="built_in">len</span>(r))  <span class="comment">// My姫様 4</span></span><br><span class="line">	<span class="comment">//虽然打印的内容是一样的，但是此时每个字符都使用4字节存储</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时跳转会和Python一样偏移 2 * 4 个字节, 然后获取也会获取4个字节, 因为一个字符占4个字节</span></span><br><span class="line">	<span class="comment">//所以不光索引跳转会将索引乘上4, 在获取的时候也会一次获取4个字节</span></span><br><span class="line">	<span class="comment">//因为都知道一个字符占4字节了,所以肯定获取指定数量的字节，这样才能表示完整字符</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(r[<span class="number">2</span>]))  <span class="comment">//姫</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实可以想一下C中的数组，比如int类型的数组，那么数组指针在往后偏移一个单位的时候，偏移的也是1个int<code>(4字节)</code>，而不是1个字节，这是显然的；然后获取的时候也会一次获取4个字节，因为这样才能表示一个int。但是utf-8表示的unicode字符串里面的字符可能占用不同的字节，那么显然没办法实现Python中字符串的索引查找效果，所以Python内部的字符串没有使用utf-8。</strong></p>
<p><strong>因此Python才会提供了三种编码，先使用占用最小的Latin1，不行的话再使用UCS2、UCS4，总之会确保每个字符占用的字节是一样的，原因的话我们上面分析的很透彻了。并且无论是索引还是切片、还是计算长度等等，都是基于字符的，显然这也符合人类的思维习惯。</strong></p>
<p>​        <strong>然后字符串还有intern机制，原文中也提到了，但是我们会在本文的后面介绍。下面先看字符串底层的结构，以及支持的相关操作是如何实现的。</strong>    </p>
<h3 id="字符串的底层实现"><a href="#字符串的底层实现" class="headerlink" title="字符串的底层实现"></a>字符串的底层实现</h3><p><strong>我们之前提到了，字符串采用不同的编码，底层的结构体实例所占用的额外内存是不一样的。其实本质上是，字符串会根据内容的不同，而选择不同的存储单元。</strong></p>
<p><strong>至于到底是怎么做到的，我们只能去源码中寻找答案了，与str相关的源码：<code>Include/unicodeobject.h</code>和<code>Objects/unicodeobject.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/unicodeobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PyUnicode_Kind</span> &#123;</span></span><br><span class="line"><span class="comment">/* String contains only wstr byte characters.  This is only possible</span></span><br><span class="line"><span class="comment">   when the string was created with a legacy API and _PyUnicode_Ready()</span></span><br><span class="line"><span class="comment">   has not been called yet.  */</span></span><br><span class="line">    PyUnicode_WCHAR_KIND = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* Return values of the PyUnicode_KIND() macro: */</span></span><br><span class="line">    PyUnicode_1BYTE_KIND = <span class="number">1</span>,</span><br><span class="line">    PyUnicode_2BYTE_KIND = <span class="number">2</span>,</span><br><span class="line">    PyUnicode_4BYTE_KIND = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们在unicodeobject.h中看到，str对象根据底层存储会根据unicode的不同而分为以下几类：</strong></p>
<ul>
<li><code>PyUnicode_1BYTE_KIND：所有字符码位均在 U+0000 到 U+00FF 之间</code></li>
<li><code>PyUnicode_2BYTE_KIND：所有字符码位均在 U+0000 到 U+FFFF 之间，且至少一个大于 U+00FF(否则每个字符就用1字节了)</code></li>
<li><code>PyUnicode_4BYTE_KIND：所有字符码位均在 U+0000 到 U+10FFFF 之间，且至少一个大于 U+FFFF</code></li>
</ul>
<p><strong>如果文本字符码位均在 *U+0000* 到 *U+00FF* 之间，单个字符只需 *1* 字节来表示；而码位在 *U+0000* 到 *U+FFFF* 之间的文本，单个字符则需要 2 字节才能表示；以此类推。这样一来，根据文本码位范围，便可为字符选用尽量小的存储单元，以最大限度节约内存。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Py_UCS4; <span class="comment">//我们看到4字节使用的是无符号32位整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Py_UCS2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> Py_UCS1;  <span class="comment">//Latin-1</span></span><br></pre></td></tr></table></figure>

<p><strong>既然unicode内部的存储结构会因字符而异，那么unicode底层就必须有成员来维护相应的信息，所以Python内部定义了若干标志位：</strong></p>
<ul>
<li><code>interned：是否被intern机制维护，这个机制我们会在本文后面介绍</code></li>
<li><code>kind：类型，用于区分字符底层存储单元的大小。如果是Latin1编码,那么就是1;UCS2编码则是2;UCS4编码则是4</code></li>
<li><code>compact：内存分配方式，对象与文本缓冲区是否分离</code></li>
<li><code>ascii：字符串是否是纯ASCII字符串, 如果是1就是1, 否则就是0。注意:  虽然每个字符都会对应ASCII码，但是只有对应的ASCII码为0~127之间的才是ASCII字符。所以虽然一个字节可表示的范围是0~255，但是128~255之间的并不是ASCII字符。</code></li>
</ul>
<p><strong>而为unicode字符串申请空间，底层可以调用一个叫PyUnicode_New的函数，这也是一个特型API。比如：元组申请空间可以使用PyTuple_New，列表申请空间可以使用PyList_New等等，会传入一个整型，创建一个能够容纳指定数量元素的结构体实例。而PyUnicode_New则接受一个字符个数以及最大字符maxchar初始化unicode字符串对象，之所以会多出一个maxchar，是因为要根据它来为unicode字符串对象选择最紧凑的字符存储单元，以及结构体。</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200807233651483-1686148361.png" alt="img"></p>
<p><strong>下面我们就来分析字符串底层对应的结构体。</strong></p>
<h4 id="PyASCIIObject"><a href="#PyASCIIObject" class="headerlink" title="PyASCIIObject"></a>PyASCIIObject</h4><p><strong>如果 *str* 对象保存的文本均为 *ASCII* ，即 maxchar&lt;128，则底层由 PyASCIIObject 结构进行存储：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject</span></span><br><span class="line"><span class="comment">   structure. state.ascii and state.compact are set, and the data</span></span><br><span class="line"><span class="comment">   immediately follow the structure. utf8_length and wstr_length can be found</span></span><br><span class="line"><span class="comment">   in the length field; the utf8 pointer is equal to the data pointer. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          <span class="comment">/* Number of code points in the string */</span></span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* Hash value; -1 if not set */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> interned:<span class="number">2</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> kind:<span class="number">3</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> compact:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ascii:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ready:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> :<span class="number">24</span>;</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="type">wchar_t</span> *wstr;              <span class="comment">/* wchar_t representation (null-terminated) */</span></span><br><span class="line">&#125; PyASCIIObject;</span><br></pre></td></tr></table></figure>

<p><strong>PyASCIIObject结构体也是其他 *Unicode* 底层结构体的基础，所有字段均为 *Unicode* 公共字段：</strong></p>
<ul>
<li><code>ob_refcnt：引用计数</code></li>
<li><code>ob_type：类型指针</code></li>
<li><code>length：字符串长度</code></li>
<li><code>hash：字符串的哈希值</code></li>
<li><code>state：unicode对象标志位，包括intern、kind、ascii、compact等</code></li>
<li><code>wstr：一个指针，指向由宽字符组成的字符数组。字符串和字节序列一样，底层都是通过字符数组来维护具体的值。</code></li>
</ul>
<p><strong>以字符串”abc”为例，看看它在底层的存储结构：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001754094-209875044.png" alt="img"></p>
<p><strong>注意：state 成员后面有一个 4  字节的空洞，这是结构体字段内存对齐造成的现象。在 64 位机器上，指针大小为 8 字节，为优化内存访问效率，必须以 8  字节对齐。现在我们知道一个空字符串为什么占据49个字节了，因为ob_refcnt、ob_type、length、hash、wstr 都是 8  字节，所以总共 40 字节；而 state 是 4 字节，但是留下了 4 字节的空洞，加起来也是 8 字节，所以总共占 40 + 8 &#x3D; 48  个字节，但是 Python 的 unicode 字符串在 C 中也是使用字符数组来存储的，只不过此时的字符不再是 char 类型，而是  wchar_t。但是它的内部依旧有一个 ‘\0’，所以还要加上一个 1，总共 49 字节。</strong></p>
<p><strong>对于 “abc” 这个 unicode 字符串来说，占的总字节数就是 49 + 3 &#x3D; 52。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># 52</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度为n的ASCII字符串, 大小就是49 + n</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;a&quot;</span> * <span class="number">1000</span>))  <span class="comment"># 1049</span></span><br></pre></td></tr></table></figure>

<h4 id="PyCompactUnicodeObject"><a href="#PyCompactUnicodeObject" class="headerlink" title="PyCompactUnicodeObject"></a>PyCompactUnicodeObject</h4><p><strong>如果文本不全是 *ASCII* ，Unicode 对象底层便由 *PyCompactUnicodeObject* 结构体保存：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Non-ASCII strings allocated through PyUnicode_New use the</span></span><br><span class="line"><span class="comment">  PyCompactUnicodeObject structure. state.compact is set, and the data</span></span><br><span class="line"><span class="comment">  immediately follow the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   PyASCIIObject _base;</span><br><span class="line">   Py_ssize_t utf8_length;     <span class="comment">/* Number of bytes in utf8, excluding the</span></span><br><span class="line"><span class="comment">                                * terminating \0. */</span></span><br><span class="line">   <span class="type">char</span> *utf8;                 <span class="comment">/* UTF-8 representation (null-terminated) */</span></span><br><span class="line">   Py_ssize_t wstr_length;     <span class="comment">/* Number of code points in wstr, possible</span></span><br><span class="line"><span class="comment">                                * surrogates count as two code points. */</span></span><br><span class="line">&#125; PyCompactUnicodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyCompactUnicodeObject是在PyASCIIObject的基础上增加了3个字段。</strong></p>
<ul>
<li><code>utf8_length：字符串的utf-8编码长度</code></li>
<li><code>utf8：字符串使用utf-8编码的结果，这里是缓存起来从而避免重复的编码运算</code>  <font color="red">这里为什么占四个字节呢？不理解</font></li>
<li><code>wstr_length：宽字符的数量</code></li>
</ul>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221004825671-1176090938.png" alt="img"></p>
<p><strong>我们说 PyCompactUnicodeObject  只是多了3个字段，显然多出了 24 字节。那么之前的 49+24 等于 73，咦不对啊，我们不是说一个是 74 一个 76 吗？你忘记了  ‘\0’，如果使用 UCS2，那么 ‘\0’ 也占两个字节，所以应该是 73 -1 + 2 &#x3D; 74；同理 UCS4 是 73 - 1 + 4 &#x3D; 76，所以此时 unicode 字符串所占内存我们算是分析完了。然后我们再来看看这几种不同编码下对应的字符串结构吧。</strong></p>
<h4 id="PyUnicode-1BYTE-KIND"><a href="#PyUnicode-1BYTE-KIND" class="headerlink" title="PyUnicode_1BYTE_KIND"></a>PyUnicode_1BYTE_KIND</h4><p><strong>如果 <code>128 &lt;= maxchar &lt; 256</code>，虽然一个字节可以存储的下，但*Unicode* 对象底层也会由 *PyCompactUnicodeObject* 结构体保存，字符存储单元为 *Py_UCS1*<code>(Latin-1)</code> ，大小为 *1* 字节。以字符串 “sator¡” 为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001807029-644388608.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然此时所有的字符都占一个 1 字节，但是只有当 maxchar &lt; 128 的时候，才会使用 PyASCIIObject</span></span><br><span class="line"><span class="comment"># 如果大于等于 128, 那么会使用 PyCompactUnicodeObject 存储, 只不过内部字符依旧每个占一字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;sator¡&quot;</span>))  <span class="comment"># 79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们知道对于使用 UCS2 的 PyCompactUnicodeObject 来说, 空字符串会占 74 字节</span></span><br><span class="line"><span class="comment"># 而 \0 占了两个字节，所以除去 \0，额外部分是 72 字节</span></span><br><span class="line"><span class="comment"># 而这里是 Latin-1，\0 是一个字节，所以一个空字符串应该占 73 字节，加上这里的 6 个字符，总共是 79 字节。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此当使用 Latin1 编码的时候，不一定就是 PyASCIIObject, 只有当 0 &lt; maxchar &lt; 128 的时候才会使用 PyASCIIObject</span></span><br><span class="line"><span class="comment"># 所以如果将上面的 &quot;sator¡&quot; 改成 &quot;satori&quot;，那么就会使用 PyASCIIObject 存储了。</span></span><br><span class="line"><span class="comment"># 此外还要注意所占的内存, 因为 Latin1 和 UCS2、UCS4 三个编码都可以对应 PyCompactUnicodeObject</span></span><br><span class="line"><span class="comment"># 而不包括 \0 的话，那么一个 PyCompactUnicodeObject 是占据72字节的，如果算上 \0</span></span><br><span class="line"><span class="comment"># 那么使用 Latin1 编码的空字符串就是 73 字节，使用 UCS2 编码的空字符串就是 74 字节，使用 UCS4 编码的空字符串就是 76 字节，因为 \0 分别占 1、2、4 字节</span></span><br></pre></td></tr></table></figure>

<h4 id="PyUnicode-2BYTE-KIND"><a href="#PyUnicode-2BYTE-KIND" class="headerlink" title="PyUnicode_2BYTE_KIND"></a>PyUnicode_2BYTE_KIND</h4><p><strong>如果 <code>256 &lt;= maxchar &lt; 65536</code>，*Unicode* 对象底层同样由 *PyCompactUnicodeObject* 结构体保存，但字符存储单元为 *UCS2* ，大小为 *2* 字节。以字符串 “My姫様” 为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001812326-402012918.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 74 + 4 * 2, 或者72 + 5 * 2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;My姫様&quot;</span>))  <span class="comment"># 82</span></span><br></pre></td></tr></table></figure>

<p><strong>当文本中包含了 Latin1 无法存储的字符时，会使用两字节的 UCS  保存，但是连前面的英文字符也变成两字节了。至于原因我们上面已经分析的很透彻了，因为定位的时候是获取的字符，但如果采用变长的 utf-8  方式存储导致不同字符占的内存大小不一，那么就无法在 O(1) 的时间内取出准确的字符了，只能从头到尾依次遍历。而 Go 基于  utf-8，因此它无法获取准确的字符，只能转成 rune，此时内部一个字符直接占4字节。</strong></p>
<h4 id="PyUnicode-4BYTE-KIND"><a href="#PyUnicode-4BYTE-KIND" class="headerlink" title="PyUnicode_4BYTE_KIND"></a>PyUnicode_4BYTE_KIND</h4><p><strong>如果 <code>65536 &lt;= maxchar &lt; 429496296</code>，便只能使用4字节存储单元的UCS4了，以字符串”👴青回”为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001819534-1633513290.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 76 + 3 * 4, 或者72 + 4 * 4</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴青回&quot;</span>))  <span class="comment"># 88</span></span><br></pre></td></tr></table></figure>

<p><strong>因此此时每个字符都采用UCS4编码，因此每个字符占四个字节，这是Python内部采取的策略。</strong></p>
<p><strong>我们后面通过分析字符串的一些操作的时候，会更加深刻的体会到。</strong></p>
<h4 id="PyUnicodeObject"><a href="#PyUnicodeObject" class="headerlink" title="PyUnicodeObject"></a>PyUnicodeObject</h4><p><strong>不是说Python中字符串底层对应PyUnicodeObject吗？目前出现了PyASCIIObject和PyCompactUnicodeObject，那么PyUnicodeObject呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyCompactUnicodeObject _base;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *any;</span><br><span class="line">        Py_UCS1 *latin1;</span><br><span class="line">        Py_UCS2 *ucs2;</span><br><span class="line">        Py_UCS4 *ucs4;</span><br><span class="line">    &#125; data;                     <span class="comment">/* Canonical, smallest-form Unicode buffer */</span></span><br><span class="line">&#125; PyUnicodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这便是 PyUnicodeObject 的定义了，里面 data 是一个共同体，这里我们没有必要关注，我们直接把它当成 PyCompactUnicodeObject 来用即可。</strong></p>
<h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><p><strong>先来看看str类型对象在底层的定义吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/unicodeobject.c</span></span><br><span class="line">PyTypeObject PyUnicode_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;str&quot;</span>,              	    <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyUnicodeObject),    <span class="comment">/* tp_size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    unicode_repr,           	<span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;unicode_as_number,         <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;unicode_as_sequence,       <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;unicode_as_mapping,        <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>首先哈希操作<code>(unicode_hash)</code>之类的肯定是支持的，然后我们关注一下tp_as_number、tp_as_sequence、tp_as_mapping，我们看到三个操作簇居然都满足。不过有了bytes的经验，我们知道tp_as_number里面的实际上只有取模，也就是格式化<code>(bytes和str在很多行为上都是相似的,但是这两者的区别我们后面会说,目前认为str对象可以编码成bytes对象,bytes对象可以解码成str对象即可)</code>。</strong></p>
<p><strong>我们来看一下这几个操作簇吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不出我们所料, 只有一个取模</span></span><br><span class="line"><span class="type">static</span> PyNumberMethods unicode_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    unicode_mod,    <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到这个和bytes对象是几乎一样的，因为我们说了str对象和bytes都是不可变的变长对象,并且可以相互转化</span></span><br><span class="line"><span class="comment">//它们的行为时高度相似的</span></span><br><span class="line"><span class="type">static</span> PySequenceMethods unicode_as_sequence = &#123;</span><br><span class="line">    (lenfunc) unicode_length,       	 <span class="comment">/* sq_length */</span></span><br><span class="line">    PyUnicode_Concat,           		 <span class="comment">/* sq_concat */</span></span><br><span class="line">    (ssizeargfunc) unicode_repeat,  	 <span class="comment">/* sq_repeat */</span></span><br><span class="line">    (ssizeargfunc) unicode_getitem,      <span class="comment">/* sq_item */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_slice */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_ass_item */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_ass_slice */</span></span><br><span class="line">    PyUnicode_Contains,        			 <span class="comment">/* sq_contains */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也和bytes对象一样</span></span><br><span class="line"><span class="type">static</span> PyMappingMethods unicode_as_mapping = &#123;</span><br><span class="line">    (lenfunc)unicode_length,        <span class="comment">/* mp_length */</span></span><br><span class="line">    (binaryfunc)unicode_subscript,  <span class="comment">/* mp_subscript */</span></span><br><span class="line">    (objobjargproc)<span class="number">0</span>,           <span class="comment">/* mp_ass_subscript */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们先来重点看一下PyUnicode_Concat这个操作，它是用来将两个字符串相加、组合成一个新的字符串。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyUnicode_Concat</span><span class="params">(PyObject *left, PyObject *right)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//参数left和right显然指向两个unicode字符串</span></span><br><span class="line">    <span class="comment">//result则是指向相加之后的字符串</span></span><br><span class="line">    PyObject *result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还记得这个Py_UCS4吗, 它是相当于一个无符号32位整型</span></span><br><span class="line">    Py_UCS4 maxchar, maxchar2;</span><br><span class="line">    <span class="comment">//显然是left的长度、right的长度、相加之后的长度</span></span><br><span class="line">    Py_ssize_t left_len, right_len, new_len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测是否是PyUnicodeObject</span></span><br><span class="line">    <span class="keyword">if</span> (ensure_unicode(left) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(right)) &#123;</span><br><span class="line">        <span class="comment">//如果右边不是str对象的话，报错</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;can only concatenate str (not \&quot;%.200s\&quot;) to str&quot;</span>,</span><br><span class="line">                     right-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//属性的初始化, ensure_unicode实际上是调用了PyUnicode_Check和PyUnicode_READY这两部</span></span><br><span class="line">    <span class="comment">//当然这些都是Python内部做的检测，我们不用太关心</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_READY(right) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里快分支</span></span><br><span class="line">    <span class="comment">//如果其中一方为空的话，那么直接返回另一方即可，显然这里的快分支命中率就没那么高了，但还是容易命中的</span></span><br><span class="line">    <span class="keyword">if</span> (left == unicode_empty)</span><br><span class="line">        <span class="keyword">return</span> PyUnicode_FromObject(right);</span><br><span class="line">    <span class="keyword">if</span> (right == unicode_empty)</span><br><span class="line">        <span class="keyword">return</span> PyUnicode_FromObject(left);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//计算left的长度和right的长度</span></span><br><span class="line">    left_len = PyUnicode_GET_LENGTH(left);</span><br><span class="line">    right_len = PyUnicode_GET_LENGTH(right);</span><br><span class="line">    <span class="comment">//如果相加超过PY_SSIZE_T_MAX，那么会报错, 因为要维护字符串的长度，显然长度是有范围的</span></span><br><span class="line">    <span class="comment">//但是几乎不存在字符串的长度会超过PY_SSIZE_T_MAX的</span></span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; PY_SSIZE_T_MAX - right_len) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;strings are too large to concat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的长度</span></span><br><span class="line">    new_len = left_len + right_len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//计算存储单元占用的字节数</span></span><br><span class="line">    maxchar = PyUnicode_MAX_CHAR_VALUE(left);</span><br><span class="line">    maxchar2 = PyUnicode_MAX_CHAR_VALUE(right);</span><br><span class="line">    <span class="comment">//取大的那一方，因为一个是UCS2一个是UCS4，那么相加之后肯定会选择UCS4</span></span><br><span class="line">    maxchar = Py_MAX(maxchar, maxchar2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过PyUnicode_New申请能够容纳new_len宽字符的PyUnicodeObject, 并且字符的存储单元是大的那一方</span></span><br><span class="line">    result = PyUnicode_New(new_len, maxchar);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将left拷进去</span></span><br><span class="line">    _PyUnicode_FastCopyCharacters(result, <span class="number">0</span>, left, <span class="number">0</span>, left_len);</span><br><span class="line">    <span class="comment">//将right拷进去</span></span><br><span class="line">    _PyUnicode_FastCopyCharacters(result, left_len, right, <span class="number">0</span>, right_len);</span><br><span class="line">    assert(_PyUnicode_CheckConsistency(result, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和bytes对象一样，+的效率非常低下，所以官方建议通过join的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyUnicode_Join</span><span class="params">(PyObject *separator, PyObject *seq)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    PyObject *fseq;</span><br><span class="line">    Py_ssize_t seqlen;</span><br><span class="line">    PyObject **items;</span><br><span class="line"></span><br><span class="line">    fseq = PySequence_Fast(seq, <span class="string">&quot;can only join an iterable&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items = PySequence_Fast_ITEMS(fseq);</span><br><span class="line">    seqlen = PySequence_Fast_GET_SIZE(fseq);</span><br><span class="line">    res = _PyUnicode_JoinArray(separator, items, seqlen);</span><br><span class="line">    Py_DECREF(fseq);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyUnicode_JoinArray(PyObject *separator, PyObject *<span class="type">const</span> *items, Py_ssize_t seqlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码比较长，但是逻辑不难理解，这里就不贴了。就是获取列表或者元组里面的每一个unicode字符串对象的长度，然后加在一起，并取最大的存储单元，然后一次性申请对应的空间，再逐一进行拷贝。所以拷贝是避免不了的，+这种方式导致低效率的主要原因就在于大量PyUnicodeObject的创建和销毁。</strong></p>
<p><strong>因此如果我们要拼接大量的PyUnicodeObject，那么使用join列表或者元组的方式；如果数量不多，还是可以使用+的，毕竟维护一个列表也是需要资源的。使用join的方式，只有在PyUnicodeObject的数量非常多的时候，优势才会凸显出来。</strong></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​        <strong>然后我们在看看PyUnicodeObject的初始化，Python很多方式，从C中原生的字符串创建PyUnicodeObject对象。比如：PyUnicode_FromString、PyUnicode_FromStringAndSize、PyUnicode_FromUnicodeAndSize、PyUnicode_FromUnicode、PyUnicode_FromWideChar等等</strong>     </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyUnicode_FromString(<span class="type">const</span> <span class="type">char</span> *u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">strlen</span>(u);</span><br><span class="line">    <span class="comment">// PY_SSIZE_T_MAX是一个与平台相关的数值，在64位系统下是4GB</span></span><br><span class="line">    <span class="comment">//如果创建的字符串的长度超过了这个值，那么会报错</span></span><br><span class="line">    <span class="comment">//个人觉得这种情况应该不会发生，就跟变量的引用计数一样</span></span><br><span class="line">    <span class="comment">//只要不是吃饱了撑的，写恶意代码，基本不会超过这个阈值</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">&quot;input too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会进行检测字符串是哪种编码格式，从而决定分配几个字节</span></span><br><span class="line">    <span class="keyword">return</span> PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串对象的intern机制"><a href="#字符串对象的intern机制" class="headerlink" title="字符串对象的intern机制"></a>字符串对象的intern机制</h3><p><strong>如果字符串的interned标识位为1，那么Python虚拟机将为其开启interned机制。那么，什么是interned机制呢？</strong></p>
<blockquote>
<p><strong>在Python中，某些字符串也可以像小整数对象池中的整数一样，共享给所有变量使用，从而通过避免重复创建来降低内存使用、减少性能开销，这便是intern机制。</strong></p>
</blockquote>
<p><strong>Python的做法是在内部维护一个全局字典，所有开启intern机制的字符串均会保存在这里，后续如果需要使用的话，会先尝试在全局字典中获取，从而实现避免重复创建的功能。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/unicodeobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyUnicode_InternInPlace</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *s = *p;</span><br><span class="line">    PyObject *t;</span><br><span class="line">    <span class="comment">//对PyUnicodeObjec进行类型和状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(s))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//检测interned标识位, 判断是否开启intern机制</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CHECK_INTERNED(s))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//创建intern机制的dict</span></span><br><span class="line">    <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear(); <span class="comment">/* Don&#x27;t leave an exception */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_ALLOW_RECURSION</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面的内容单独分析</span></span><br><span class="line">    t = PyDict_SetDefault(interned, s, s);</span><br><span class="line">    Py_END_ALLOW_RECURSION</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(t == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != s) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</span><br><span class="line">    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>PyDict_SetDefault</code>函数中首先会进行一系列的检查，包括类型检查、因为intern共享机制只能用在字符串对象上，所以检查传入的对象是否已经被intern机制处理过了。</strong></p>
<p><strong>我们在代码中看到了<code>interned = PyDict_New()</code>，这个<code>PyDict_New()</code>是python中的dict对象，因此可以发现在程序中有一个key、value映射关系的集合。</strong></p>
<p><strong>intern机制中的PyUnicodObject采用了特殊的引用计数机制，将一个PyUnicodeObject对象a的PyObject指针作为key和valu添加到intered中时，PyDictObjec对象会通过这两个指针对a的引用计数进行两次+1操作。这会造成a的引用计数在python程序结束前永远不会为0，这也是最后面<code>Py_REFCNT(s) -= 2;</code> 要将计数减2的原因。</strong></p>
<p><strong>Python在创建一个字符串时，会首先检测是否已经有该字符串对应的PyUnicodeObject对象了，如果有，就不用创建新的，这样可以节省空间。但其实不是这样的，事实上，节省内存空间是没错的，可Python并不是在创建PyUnicodeObject的时候就通过intern机制实现了节省空间的目的。从PyUnicode_FromString中我们可以看到，无论如何一个合法的PyUnicodeObject总是会被创建的，而intern机制也只对PyUnicodeObject起作用。</strong></p>
<p><strong>对于任何一个字符串，Python总是会为它创建对应的PyUnicodeObject，尽管创建出来的对象所维护的字符数组，在intern机制中已经存在了<code>(有另外的PyUnicodeObject也维护了相同的字符数组)</code>。而这正是关键所在，通常Python在运行时创建了一个PyUnicodeObject对象temp之后，基本上都会调用PyUnicode_InternInPlace对temp进行处理，如果维护的字符数组有其他的PyUnicodeObject维护了，或者说其他的PyUnicodeObject对象维护了一个与之一模一样的字符数组，那么temp的引用计数就会减去1。temp由于引用计数为0而被销毁，只是昙花一现，然后归于湮灭。</strong></p>
<blockquote>
<p><strong>所以现在我们就明白了intern机制，并不是说先判断是否存在，如果存在，就不创建。而是先创建，然后发现已经有其他的PyUnicodeObject维护了一个与之相同的字符数组，于是intern机制将引用计数减一，导致引用计数为0，最终被回收。</strong></p>
</blockquote>
<p><strong>但是这么做的原因是什么呢？为什么非要创建一个PyUnicodeObject来完成intern操作呢？这是因为PyDictObject必须要求必须以PyObject *作为key。</strong></p>
<p><strong>关于PyUnicodeObject对象的intern机制，还有一点需要注意。实际上，被intern机制处理过后的字符串分为两类，一类处于<code>SSTATE_INTERNED_IMMORTAL</code>，另一类处于<code>SSTATE_INTERNED_MORTAL</code>状态，这两种状态的区别在<code>unicode_dealloc</code>中可以清晰的看到，<code>SSTATE_INTERNED_IMMORTAL</code>状态的PyUnicodeObject是永远不会被销毁的，它与python解释器共存亡。</strong></p>
<p><strong>PyUnicode_InternInPlace只能创建<code>SSTATE_INTERNED_MORTAL</code>的PyUnicodeObject对象，如果想创建<code>SSTATE_INTERNED_IMMORTAL</code>对象，必须通过另外的接口来强制改变PyUnicodeObject的intern状态。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyUnicode_InternImmortal</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyUnicode_InternInPlace(p);</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) &#123;</span><br><span class="line">        _PyUnicode_STATE(*p).interned = SSTATE_INTERNED_IMMORTAL;</span><br><span class="line">        Py_INCREF(*p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>但是问题来了，什么样的字符才会开启intern机制呢？</strong>     </p>
<p><strong>在Python3.8中，如果一个字符串的所有字符都位于0 ~ 127之间，那么会开启intern机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;abc&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;abc&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 之前的话是不超过20个字符，但是在Python3.8中这个限制被扩大了很多</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;abc&quot;</span> * <span class="number">2000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;abc&quot;</span> * <span class="number">2000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span>  <span class="comment"># 显然3 * 2000,6000个字符是不会开启intern机制的，所以长度限制是多少，有兴趣可以自己试一下</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在Python3.8中，如果一个字符串只有一个字符，并且位于0~255之间，那么会开启intern机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">chr</span>(<span class="number">255</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">chr</span>(<span class="number">255</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 不位于0~127之间，所以不是ASCII字符，因此没有开启intern机制</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">chr</span>(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">chr</span>(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 但如果只有一个字符的话，则会开启</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 另外，空字符串也会开启</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>实际上，存储单个字符这种方式有点类似于bytes对象中的缓存池。是的，正如整数有小整数对象池、bytes对象有字符缓存池一样，字符串也有其对应的PyUnicodeObject缓存池。</strong></p>
<p><strong>在Python中的整数对象中，小整数的对象池是在Python初始化的时候被创建的，而字符串对象体系中的缓存池则是以静态变量的形式存在的。在Python初始化完成之后，缓冲池的所有PyUnicodeObject指针都为空。</strong></p>
<p><strong>当创建一个PyUnicodeObject对象时，如果字符串只有一个字符，且位于0~255。那么会先对该字符串进行intern操作，再将intern的结果缓存到池子当中。同样当再次创建PyUnicodeObject对象时，检测维护的是不是只有一个字符，然后检查字符是不是存在于缓存池中，如果存在，直接返回。</strong></p>
<h3 id="str对象和bytes对象之间的关系"><a href="#str对象和bytes对象之间的关系" class="headerlink" title="str对象和bytes对象之间的关系"></a>str对象和bytes对象之间的关系</h3><p><strong>首先str对象我们称之为字符串，bytes对象我们称之为字节序列，把字符串中的每一个字符都转成对应的编码，那么得到就是字节序列了。因为计算机存储和网络通讯的基本单位都是字节，所以字符串必须以字节序列的形式进行存储或传输。</strong></p>
<p><strong>那么如何转化呢？首先我们需要清楚两个概念：字符集和编码。</strong></p>
<blockquote>
<p><strong>字符集顾名思义就是由字符组成的集合，每个字符在集合中都有唯一编号，像ASCII、unicode都是字符集。只不过 ASCII 能够容纳的字符是有限的，而 unicode 可以容纳世界上所有的字符。</strong></p>
<p><strong>而编码则负责告诉你字符在字符集中对应的编号，编码有：gbk、utf-8等等</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;姫様&quot;</span></span><br><span class="line"><span class="comment"># 采用utf-8编码, encode成bytes对象</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># b&#x27;\xe5\xa7\xab\xe6\xa7\x98&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> s.encode(<span class="string">&quot;utf-8&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">229</span></span><br><span class="line"><span class="string">167</span></span><br><span class="line"><span class="string">171</span></span><br><span class="line"><span class="string">230</span></span><br><span class="line"><span class="string">167</span></span><br><span class="line"><span class="string">152</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 说明&quot;姫&quot;对应的ASCII码是: 229 167 171, 因为utf-8编码的话, 一个汉字占3个字节</span></span><br><span class="line"><span class="comment"># 我们使用utf-8解码, 也能得到对应的字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 姫様</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytearray</span>([<span class="number">229</span>, <span class="number">167</span>, <span class="number">171</span>, <span class="number">230</span>, <span class="number">167</span>, <span class="number">152</span>]).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 姫様</span></span><br></pre></td></tr></table></figure>

<p><strong>因此字符串和字节序列在某种程度上是很相似的，字符串按照指定的编码进行encode即可得到字节序列<code>(将字符转成ASCII码)</code>，字节序列按照相同的编码decode即可得到字符串<code>(将ASCII码转成字符)</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如我有一个gbk编码的字节序列，但是在传输的时候需要utf-8编码的字节序列</span></span><br><span class="line">b = <span class="string">b&#x27;\xc4\xe3\xba\xc3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们就按照gbk解码成字符串，因为不同的编码会得到不同的ASCII码</span></span><br><span class="line"><span class="comment"># 因此encode和decode都要使用同一种编码, 如果前后使用了不同的编码，那么在decode的时候会因为无法正确解析而报错</span></span><br><span class="line">s = b.decode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 你好</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我们使用utf-8进行encode</span></span><br><span class="line">b = s.encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;我很可爱&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用utf-8进行decode</span></span><br><span class="line"><span class="built_in">print</span>(b.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 你好我很可爱</span></span><br></pre></td></tr></table></figure>

<p><strong>但是对于ASCII字符来说，由于不管采用哪一种编码，它们得到的ASCII码都是固定的，所以在显示的时候直接以字符本身显示了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># a对应的ASCII码是97, 所以你在C中写char c = &#x27;a&#x27;和char c = 97是完全等价的</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># b&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytearray</span>([<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们创建一个字节序列的时候，也可以这么做</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;abc&quot;</span>)  <span class="comment"># b&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是我们不可以b&#x27;憨&#x27;, 因为&#x27;憨&#x27;这个字符不是ASCII字符, ASCII字符要求对应的ASCII码唯一、并且小于128</span></span><br><span class="line"><span class="comment"># 所以在不同的编码下会对应不同的ASCII码,比如gbk编码的话对应两个ASCII码, utf-8对应三个ASCII码</span></span><br><span class="line"><span class="comment"># 因此b&#x27;憨&#x27;的话，由于不知道使用哪一种编码, 所以Python不允许这么做，而是通过&#x27;憨&#x27;.encode的方式来手动指定编码</span></span><br><span class="line"><span class="comment"># 而&#x27;abc&#x27;都是纯ASCII字符，不管采用哪一种编码都会得到相同的ASCII码，所以Python允许这么做</span></span><br><span class="line"><span class="comment"># 当然对ASCII字符使用ASCII码也是可以的</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>字符串的内容还是比较多的，在源码中有一万六千多行，显然我们没办法一步一步地全部分析完，有兴趣的可以自己深入研究一下。其实我们能把字符串的存储搞明白，其实已经是前进了一大步了。</strong></p>
]]></content>
      <tags>
        <tag>CPython源码阅读</tag>
      </tags>
  </entry>
</search>
