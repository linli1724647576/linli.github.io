<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级刷题指南</title>
    <url>/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="PAT甲级刷题指南"><a href="#PAT甲级刷题指南" class="headerlink" title="PAT甲级刷题指南"></a>PAT甲级刷题指南</h1><h2 id="《算法笔记》C-标准模板库-STL-介绍"><a href="#《算法笔记》C-标准模板库-STL-介绍" class="headerlink" title="《算法笔记》C++标准模板库(STL)介绍"></a>《算法笔记》C++标准模板库(STL)介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>变长数组</p>
<h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、vector&lt;int&gt; v(size,0);  //初始化为0</span><br><span class="line">2、vector&lt;int&gt; v;  v.resize(n,0);  //resize一个大小为n，初值为0的可变数组</span><br><span class="line">3、vector&lt;type&gt; v;   //不初始化,type可以是一个结构体</span><br><span class="line">4、vector&lt;int&gt; ilist2(v);  vector&lt;int&gt; ilist2  = v;   //两种方式等价，都是深拷贝</span><br><span class="line">5、vector&lt;int&gt; ilist = &#123;1,2,3.0,4,5,6,7&#125;;   //和数组初始化方法一样</span><br><span class="line">6、vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1);   //迭代器初始化</span><br></pre></td></tr></table></figure>

<h5 id="访问："><a href="#访问：" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、随机访问数组下标访问 v[i]</span><br><span class="line">2、迭代器访问数组</span><br><span class="line">    vector&lt;int&gt;::iterator iter;</span><br><span class="line">    for(iter = vi.begin();iter != vi.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a><strong>常用函数</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、插入push_back  v.push_back(i);</span><br><span class="line">2、删除pop_back   v.pop_back();  //删除最后一个元素，回溯的时候常用</span><br><span class="line">3、大小size    v.size();  //获取数组大小</span><br><span class="line">4、清空clear   v.clear(); //清空数组</span><br><span class="line">5、插入insert  //尽量不要频繁使用这个函数，会引起大量数据移动，降低程序效率</span><br><span class="line">    v.insert(v.begin(),8);//在最前面插入新元素</span><br><span class="line">    v.insert(v.begin()+3,1);//在迭代器中下标为3的元素前插入新元素</span><br><span class="line">    v.insert(v.end(),3);//在向量末尾追加新元素</span><br><span class="line">    v.insert(v.end(),3,0);//在尾部插入3个0</span><br><span class="line">6、删除erase  //erase函数有两种函数原型，一种是给定要删除的位置，另一种是给定删除的区域。</span><br><span class="line">	有两种函数原型，c.erase (p),c.erase(b,e);第一个删除迭代器p所指向的元素，第二个删除迭代器b,e所标记的范围内的元素，c为容器对象，返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点）</span><br><span class="line">	应用一：删除连续数字</span><br><span class="line">	//但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); iter++)  </span><br><span class="line">	&#123;</span><br><span class="line">      if(*iter == 3)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">	&#125;</span><br><span class="line">	//可以删除连续的数字3</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">     if( *iter == 3)</span><br><span class="line">          iter = veci.erase(iter);//当删除时erase函数自动指向下一个位置，就不需要进行++</span><br><span class="line">      else</span><br><span class="line">            iter ++ ;    //当没有进行删除的时候，迭代器++</span><br><span class="line">	&#125;</span><br><span class="line">	//另一种解决无法删除连续的数字的方法</span><br><span class="line">	我们先介绍一下remove函数:</span><br><span class="line">    remove是个stl的通用算法std::remove(first,last,val)移除[first, last)范围内等于val的元素在vector里面用就类似于 iter=std::remove(vec.begin(), vec.end(), val)但这个函数只是把val移到vec的末尾，并不真正删除,真正删除还是要调用一次erase函数</span><br><span class="line">    veci.erase(remove(vec.begin(),vec.end(),3),vec.end());</span><br><span class="line">    </span><br><span class="line">    应用二：删除重复数字，顺序不发生变化</span><br><span class="line">    如果不要求顺序的话，我们可以直接调用unique函数进行操作，这里介绍一下unique函数：从头到尾，判断当前元素是否等于上一个元素，将不重复的元素移到前面来(赋值操作)，而不是将重复的元素移动到后面去。</span><br><span class="line">    vec.erase(unique(vec.begin(),vec.end()),vec.end())  //将重复的区域删除，顺序会改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a><strong>常见错误</strong>：</h5><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814163126705.png" alt="image-20210814163126705"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>是一个内部自动有序且不含重复元素的容器</p>
<p>unordered_set 无序 其余和set的用法一样，效率更高</p>
<h5 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s(b, e);</span><br><span class="line">比如：</span><br><span class="line">int arr[]=&#123;1,2,3,4,3,2,1&#125;;</span><br><span class="line">set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-1"><a href="#访问：-1" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、迭代器访问</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt;::iterator it</span><br><span class="line">for(it = st.begin();it != st.end();it++)&#123;</span><br><span class="line">	printf(&quot;%d &quot;,*it);</span><br><span class="line">&#125; </span><br><span class="line">2、随机访问   在set中查找2，返回其迭代器</span><br><span class="line">set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">printf(&quot;%d &quot;,*it);</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	set&lt;int&gt; st;</span><br><span class="line">1、插入 insert()</span><br><span class="line">	st.insert(3);</span><br><span class="line">2、查找 find()</span><br><span class="line">	set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">	if(st.find(2)==st.end()) printf(&quot;没找到&quot;);</span><br><span class="line">3、删除  erase()</span><br><span class="line">st.erase(it) it为需要删除元素的迭代器，复杂度O(1)</span><br><span class="line">st.erase(value) value为要删除元素的值，复杂度O(logN)</span><br><span class="line">	st.erase(st.find(2));</span><br><span class="line">	st.erase(2)，效果一致，两种用法</span><br><span class="line">4、获取元素个数 size()</span><br><span class="line">	cout&lt;&lt;&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">5、清空 clear()</span><br><span class="line">	st.clear(); </span><br><span class="line">6、判空 empty()</span><br><span class="line">	st.empty()</span><br></pre></td></tr></table></figure>





<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>字符串</p>
<h5 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string s1;  s1为空字符串</span><br><span class="line">2、string s2(&quot;ABC&quot;);  用字符串字面值初始化s2</span><br><span class="line">3、string s3(s2);  用s3初始化为s2的一个副本</span><br><span class="line">4、string s4(n,&#x27;c&#x27;);  将s4初始化为字符&#x27;c&#x27;的n个副本</span><br></pre></td></tr></table></figure>

<h5 id="访问：-2"><a href="#访问：-2" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过下标访问</span><br><span class="line">    string str = &quot;abcd&quot;;</span><br><span class="line">    for(int i=0;i &lt; str.length();i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,str[i]);</span><br><span class="line">    &#125; </span><br><span class="line">2、通过迭代器访问</span><br><span class="line">    cout&lt;&lt;&quot;通过迭代器访问如下：&quot;&lt;&lt;endl;</span><br><span class="line"> for(string::iterator;it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,*it);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-2"><a href="#常用函数：-2" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、判空 s.empty()</span><br><span class="line">2、统计字符个数  s.size()  /   s.length()</span><br><span class="line">3、拼接字符串 += </span><br><span class="line">	str3 = str1+str2;  //拼接后再赋值</span><br><span class="line">	str1 += str2;  //直接接在后面，效率更高</span><br><span class="line">4、字符串比较大小 == != &gt;=等等</span><br><span class="line">5、插入 insert()</span><br><span class="line"> insert(pos,string) 在pos位置插入string</span><br><span class="line"> insert(it,it2,it3) 在it位置插入 [it2,it3)的串，it2,it3为待插字符串的首尾迭代器</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line"> 	str2 = &quot;opq&quot;;     //insert(pos,string)</span><br><span class="line">	str1.insert(3,str2);</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.insert(str1.begin()+3,str2.begin(),str2.end());     //insert(it,it2,it3)</span><br><span class="line">	cout&lt;&lt;&quot;abcopqxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">6、删除单个元素、区间元素 erase()</span><br><span class="line"> 删除单个元素 str.erase(it)  it为删除元素的迭代器</span><br><span class="line"> 删除一个区间内的所有元素 str.erase(first,last) [first,last)</span><br><span class="line"> str.erase(pos,length) pos为开始位置，length为长度</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcopqopqxyz&quot;;</span><br><span class="line"> 	str1.erase(str1.begin()+3);//str.erase(it)删除4号位o </span><br><span class="line">	cout&lt;&lt;&quot;abcopqopqxyz字符串删除第四个位置o字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(str1.begin()+3,str1.end()-3);//str.erase(first,last)</span><br><span class="line">	cout&lt;&lt;&quot;abcpqopqxyz字符串删除第4~8位置字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(3,3);//str.erase(ipos,length)</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串删除从第4位置开始的3个字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">7、清空 clear()</span><br><span class="line">	str1.clear();</span><br><span class="line">8、子串 substr()</span><br><span class="line"> substr(pos,len) 返回从pos号开始，长度为len子串</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串从下标2开始长度为3的子串为：&quot;&lt;&lt;str1.substr(2,3)&lt;&lt;endl;</span><br><span class="line">9、查找 find()</span><br><span class="line"> str.find(str2) 当str2是str的子串时，返回其在str中第一次出现的位置，如果str2不是str的子串，返回string::npos（常数）</span><br><span class="line"> str.find(str2,pos) 从str的pos号位置开始匹配str2，返回指相同</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;,str2=&quot;xyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;xyz子串在abcxyz中第一次出现的位置为：&quot;&lt;&lt;str1.find(str2)&lt;&lt;endl;  </span><br><span class="line">	</span><br><span class="line">	position = s.find(&quot;jk&quot;);</span><br><span class="line">	if (position != s.npos) printf(&quot;position is : %d\n&quot; ,position);  //查找成功</span><br><span class="line">	else printf(&quot;Not found the flag\n&quot;);  //查找失败</span><br><span class="line"> 10、替换 replace()</span><br><span class="line">  str.replace(pos,len,str2) 把str从pos号开始，长度为len的子串替换为str2</span><br><span class="line">  str.replace(it1,it2,str) 把str的迭代器[it1,it2)返回的子串替换为str2</span><br><span class="line">  	str1 = &quot;Maybe you will turn around.&quot;;</span><br><span class="line">	str2 = &quot;will not&quot;;str3 = &quot;surely&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will turn around.字符串从第10位开始的4位替换为str2后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(10,4,str2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will not turn around.字符串从起始位开始的5位替换为str3后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(str1.begin(),str1.begin()+5,str3)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h5 id="string和char-的转换"><a href="#string和char-的转换" class="headerlink" title="string和char[]的转换"></a>string和char[]的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、string转char*</span><br><span class="line">printf(&quot;%s&quot;,str.c_str());</span><br><span class="line">2、char* 转string</span><br><span class="line">	char* p = &quot;abc&quot;;</span><br><span class="line">    string s = p;</span><br></pre></td></tr></table></figure>

<h5 id="string和int等类型的转换"><a href="#string和int等类型的转换" class="headerlink" title="string和int等类型的转换"></a>string和int等类型的转换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转string:</span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br><span class="line">转Int</span><br><span class="line">stoi(str1);  //int</span><br><span class="line">stof(str1);  //float</span><br><span class="line">stoll(str1);  //long long </span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string strA = &quot;yasaken@126.com&quot;;</span><br><span class="line">    string strB = &quot;LURY@LENOVO.com&quot;;</span><br><span class="line">    printf(&quot;Before transform:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::toupper);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::toupper);</span><br><span class="line">    printf(&quot;After transform to toupper:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::tolower);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::tolower);</span><br><span class="line">    printf(&quot;After transform to lower:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>map即映射，是常用的STL容器，它可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<p>uordered_map无序容器，效率更高</p>
<h5 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、直接赋值</span><br><span class="line">map&lt;string, int&gt; m1;</span><br><span class="line">m1[string(&quot;abc&quot;)] ++;</span><br><span class="line">//如果“abc&quot;已经存在，会在原来的基础上++，如果不存在，则会创建一个hash_key</span><br><span class="line"></span><br><span class="line">2、用insert添加</span><br><span class="line">map&lt;string, int&gt; m2;</span><br><span class="line">m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-3"><a href="#访问：-3" class="headerlink" title="访问："></a>访问：</h5><p>map会以键从小到大的顺序自动排序，unordered_map则不会排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过key访问value</span><br><span class="line">	map&lt;char,int&gt; mp;</span><br><span class="line">	//通过下标访问 </span><br><span class="line">	mp[&#x27;c&#x27;] = 20;</span><br><span class="line">	mp[&#x27;c&#x27;] = 30;//20被覆盖</span><br><span class="line">	printf(&quot;%d\n&quot;,mp[&#x27;c&#x27;]);//输出30</span><br><span class="line">2、通过迭代器访问</span><br><span class="line">	for(map&lt;char,int&gt;::iterator it = mp.begin();it != mp.end();it++)&#123;</span><br><span class="line">		//it-&gt;first是当前映射的键；it-&gt;second是当前映射的值 </span><br><span class="line">		printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-3"><a href="#常用函数：-3" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查找  find()</span><br><span class="line">     if(M.find(exponent)!=M.end())&#123;</span><br><span class="line">     	printf(&quot;%d&quot;,M[exponent]);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	printf(&quot;没找到&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	map&lt;char,int&gt;::iterator it = mp.find(&#x27;b&#x27;);</span><br><span class="line">	printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">2、删除 erase</span><br><span class="line"> mp.erase(key);  key为想要删除的键</span><br><span class="line"> mp.erase(first,last); 删除一个区间内的元素，first,last为迭代器</span><br><span class="line"> 	it = mp.find(&#x27;m&#x27;);</span><br><span class="line">	mp.erase(it);//删除b 2</span><br><span class="line">	mp.erase(&#x27;r&#x27;);//删除b 2</span><br><span class="line">3、获取大小 size()</span><br><span class="line">	cout&lt;&lt;&quot;此时map的长度为：&quot;&lt;&lt;mp.size();</span><br><span class="line">4、清空 clear()</span><br><span class="line">	mp.clear();</span><br></pre></td></tr></table></figure>

<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap:"></a>multimap:</h5><p>multimap 和 map 很相似，但是 multimap 允许重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multimap&lt;int, string&gt; multi_map;		// 可实现多重映射</span><br><span class="line"></span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng1&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng2&quot; &#125;);</span><br><span class="line">for (auto&amp; i: multi_map)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; &quot;  &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">520  huameng</span><br><span class="line">520  huameng1</span><br><span class="line">520  huameng2</span><br></pre></td></tr></table></figure>



<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>Queue翻译为队列，理解为一个先进先出的容器</p>
<h5 id="queue初始化："><a href="#queue初始化：" class="headerlink" title="queue初始化："></a>queue初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; first;                 // empty queue</span><br></pre></td></tr></table></figure>

<h5 id="访问：-4"><a href="#访问：-4" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问队首元素：如q.front()</span><br><span class="line">访问队尾元素，如q.back();</span><br><span class="line">printf(&quot;%d %d\n&quot;,q.front(),q.back());</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-4"><a href="#常用函数：-4" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size()-容器大小</span><br><span class="line">empty()-容器判空</span><br><span class="line">push()尾部增加元素</span><br><span class="line">pop()删除尾部元素</span><br></pre></td></tr></table></figure>

<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue:"></a>priority_queue:</h5><p>在&lt; queue&gt;头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</p>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义priority_queue对象</span><br><span class="line">priority_queue&lt;int &gt;q1;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q2;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;//定义小的先出队</span><br><span class="line">//其中第二个参数( vector )，是来承载底层数据结构堆的容器，第三个参数( less )，则是一个比较类，</span><br><span class="line">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span><br></pre></td></tr></table></figure>

<p>priority_queue的基本操作均与queue相同，<strong>优先队列没有back（）操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>

<p>操作示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//---1---push()</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---2---top()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;优先队列341的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());  <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//---3---pop()</span></span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;弹出队首元素后优先队列的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());   <span class="comment">//3</span></span><br><span class="line">	<span class="comment">//---4---empty()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列为空吗？&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;Not Empty\n&quot;</span>);</span><br><span class="line">	<span class="comment">//---5---size()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列大小为：&quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级操作示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级队列优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//---1---基本数据类型：设置优先级队列总是把最小的元素放在队首 </span></span><br><span class="line">	<span class="comment">// priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //小顶堆</span></span><br><span class="line">    <span class="comment">//注意&lt;int&gt; &gt;之间的空格 </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//大顶堆</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体优先级的设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;  <span class="comment">//价格大的优先</span></span><br><span class="line">        <span class="comment">//return f1.price &gt; f2.price; //价格小的优先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"><span class="comment">//需要重载小于号，只能重载小于号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;fruit&gt; q;  <span class="comment">//价格大的优先</span></span><br><span class="line">    <span class="comment">//这边就不能再加greater或less了</span></span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似Cmp写在外面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//重载优先级结构体进行排序 </span></span><br><span class="line">	priority_queue&lt;fruit&gt; q;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//梨子 4</span></span><br><span class="line">    <span class="comment">//用cmp函数优先级排序 </span></span><br><span class="line">	priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; qq;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	qq.<span class="built_in">push</span>(f1);</span><br><span class="line">	qq.<span class="built_in">push</span>(f2);</span><br><span class="line">	qq.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;qq.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;qq.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//苹果 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>stack即栈，是一种先进后出的容器，区别于queue；</p>
<h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stk;</span><br></pre></td></tr></table></figure>

<h5 id="访问：-5"><a href="#访问：-5" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问栈顶元素 stk.top()</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-5"><a href="#常用函数：-5" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push() 压栈</span><br><span class="line">top() 取栈顶元素</span><br><span class="line">pop() 出栈</span><br><span class="line">empty() 判空</span><br><span class="line">size() 获取大小</span><br><span class="line">//---1、2、3---push()、top()、pop() </span><br><span class="line">for(int i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line">	st.push(i);//将i压入栈 </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;入栈12345的栈顶为：&quot;;</span><br><span class="line">cout&lt;&lt;st.top()&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i &lt;= 3;i++)&#123;</span><br><span class="line">	st.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;出栈3个元素后栈顶为：&quot;;</span><br><span class="line">printf(&quot;%d\n&quot;,st.top());</span><br><span class="line">//---4---empty()</span><br><span class="line">cout&lt;&lt;&quot;此时栈为空吗？&quot;&lt;&lt;endl;</span><br><span class="line">if(st.empty() == true)  printf(&quot;Empty\n&quot;);</span><br><span class="line">else printf(&quot;Not Empty\n&quot;);</span><br><span class="line">//---5---size()</span><br><span class="line">cout&lt;&lt;&quot;此时队列大小为：&quot;&lt;&lt;st.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>Pair可以看作一个内部有两个元素的结构体，且这两个元素的类型可以指定</p>
<h5 id="初始化：-5"><a href="#初始化：-5" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">pair&lt;int, double&gt; p2(1, 2.4);  //用给定值初始化</span><br><span class="line">pair&lt;int, double&gt; p3(p2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<h5 id="访问：-6"><a href="#访问：-6" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &#x27; &#x27; &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-6"><a href="#常用函数：-6" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、比较操作数 &lt;.&gt;,&lt;=,==</span><br><span class="line">//比较规则是先比较first，再比较second</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; p1(5,10);</span><br><span class="line">	pair&lt;int,int&gt; p2(5,15);</span><br><span class="line">	pair&lt;int,int&gt; p3(10,5);</span><br><span class="line">	if(p1 &lt; p3)	printf(&quot;p1 &lt; p3\n&quot;);</span><br><span class="line">	if(p1 &lt;= p3)	printf(&quot;p1 &lt;= p3\n&quot;);</span><br><span class="line">	if(p1 &lt; p2)	printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2、make_pair 赋值</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line"> </span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line"> </span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br></pre></td></tr></table></figure>

<h5 id="常用于作为map的键值对进行插入："><a href="#常用于作为map的键值对进行插入：" class="headerlink" title="常用于作为map的键值对进行插入："></a>常用于作为map的键值对进行插入：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">//pair作为map键值对进行插入 </span><br><span class="line">mp.insert(make_pair(&quot;heihei&quot;,5));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,10));</span><br></pre></td></tr></table></figure>



<h3 id="algorithm常用函数"><a href="#algorithm常用函数" class="headerlink" title="algorithm常用函数"></a>algorithm常用函数</h3><h5 id="max-、min-、abs"><a href="#max-、min-、abs" class="headerlink" title="max()、min()、abs()"></a>max()、min()、abs()</h5><p>最大值、最小值、绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=-2;</span><br><span class="line">printf(&quot;%d %d\n&quot;,max(x,y),min(x,y));</span><br><span class="line">printf(&quot;%d %d\n&quot;,abs(x),abs(y));</span><br></pre></td></tr></table></figure>

<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换两个元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1,y=2;</span><br><span class="line">swap(x,y);</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>1.会将区间内的元素全部逆序。常用于数组，字符串，容器等，其本身的函数参数也不复杂。<br>2.容器类型的要用begin()和end()来指定反转的区域，数组类型的直接用int类型即可。<br>3.reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;</span><br><span class="line">reverse(v.begin(),v.end());//v的值为1,2,3,4,5</span><br><span class="line">string str=&quot;www.mathor.top&quot;;</span><br><span class="line">reverse(str.begin(),str.end());//str结果为pot.rohtam.wwww</span><br></pre></td></tr></table></figure>

<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>1.按照单元赋值，将一个区间的元素都赋同一个值<br> 2.fill(arr, arr + n, 要填入的内容);<br> fill(vector.begin(), vector.end(), val);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">fill(arr, arr + 10, 2);</span><br><span class="line">vector&lt;int&gt;  v&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">fill(v.begin(), v.end(), -1);</span><br><span class="line">vector&lt;int&gt; myvector (8);// myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">fill (myvector.begin(),myvector.begin()+4,5);</span><br><span class="line">// myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">fill (myvector.begin()+3,myvector.end()-2,8);</span><br><span class="line">// myvector: 5 5 5 8 8 8 0 0</span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>1.Sort函数有三个参数：<br>（1）第一个是要排序的数组的起始地址。<br>（2）第二个是结束的地址（最后一位要排序的地址的下一地址）<br>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。<br>2.Sort函数使用模板:Sort(start,end,排序方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组排序</span><br><span class="line">int IntValue[5] = &#123;1,4,3,8,5&#125;;</span><br><span class="line">sort(IntValue,IntValue+5);</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">	cout&lt;&lt;IntValue[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">2、vector排序</span><br><span class="line">vector&lt;int&gt; v = &#123;2,6,4,9,6,0,3&#125;;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">vector&lt;int&gt;::iterator  start;</span><br><span class="line">for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">	cout&lt;&lt;(*start)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">3、自定义排序</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">linli1 20</span><br><span class="line">linli2 24</span><br><span class="line">linli6 8</span><br><span class="line">linli3 8</span><br><span class="line"> * */</span><br><span class="line">typedef struct stu&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;stu;</span><br><span class="line">bool cmp(stu u,stu g)&#123;  //&lt;表示升序排序</span><br><span class="line">    if(u.age==g.age)&#123;</span><br><span class="line">        return u.name&lt;g.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.age&lt;g.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;stu&gt; v;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        stu c ;</span><br><span class="line">        cin&gt;&gt;c.name&gt;&gt;c.age;</span><br><span class="line">        v.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end(),cmp);</span><br><span class="line">    vector&lt;stu&gt;::iterator  start;</span><br><span class="line">    for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">        cout&lt;&lt;(*start).name&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h5><p><strong>lower_bound：</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于或等于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;lower_bound(a+l,a+r,key)-a；(a是数组)。</p>
<p><strong>upper_bound:</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（同样这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;upper_bound(a+l,a+r,key)-a；(a是数组)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int board[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int t1 = lower_bound(board,board+5,3)-board; //2</span><br><span class="line">int t2 = upper_bound(board,board+5,3)-board; //3</span><br></pre></td></tr></table></figure>



<h2 id="PAT真题模拟"><a href="#PAT真题模拟" class="headerlink" title="PAT真题模拟"></a>PAT真题模拟</h2><h3 id="PAT-1001"><a href="#PAT-1001" class="headerlink" title="PAT 1001"></a>PAT 1001</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330182108486.png" alt="image-20210330182108486"></p>
<p>我的做法，难点在于如何3位3位加一个逗号，我用栈来存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="type">int</span> cishu;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(c);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">3</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;s[i];</span></span><br><span class="line">    <span class="comment">// 	if(s[i]!=&#x27;-&#x27;&amp;&amp;(i!=s.length()-1)&amp;&amp;(s.length()-i-1)%3==0) cout&lt;&lt;&quot;,&quot;;//后面剩下3n个数时 要加&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大神的做法见注释，好像比较难想到。</p>
<h3 id="PAT-1002"><a href="#PAT-1002" class="headerlink" title="PAT 1002"></a>PAT 1002</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330183857126.png" alt="image-20210330183857126"></p>
<p>多项式加法，通过第一个测试点不是很难。</p>
<p>注意点： <strong>系数为0时不进行输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line">    <span class="type">int</span> n,m;   cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a; <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">find</span>(a)!=M.<span class="built_in">end</span>()) M[a] += b;</span><br><span class="line">        <span class="keyword">else</span> M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330190215218.png" alt="image-20210330190215218"></p>
<p>具体还有两个未通过也不知道是怎么回事</p>
<p>map的倒叙遍历需要掌握</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1003-dijstra"><a href="#PAT-1003-dijstra" class="headerlink" title="PAT 1003 (dijstra)"></a>PAT 1003 (dijstra)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155146524.png" alt="image-20210401155146524"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155200043.png" alt="image-20210401155200043"></p>
<p> 题目翻译：</p>
<p>你是一个救援队长，你要救援有危险的城市，你需要尽可能快的到达有危险的城市，并且带尽可能多的人。</p>
<p>输入：</p>
<p>第1行：4个正整数： 城市数量N、 路数量M、你在的城市、你要救援的城市。</p>
<p>第2行：N个整数，第i个数表示第i个城市的救援队数量。</p>
<p>然后M行：每一行表示一条路，三个数字分别是起点、终点、距离。</p>
<p>保证至少有一条路让你去你要救援的城市。</p>
<p>输出：</p>
<p>最短路径条数  可带的最多人数  (我输出理解成了最短路径长度…)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *dist;   <span class="comment">//保存最短路径</span></span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//s集合，表示已经访问过</span></span><br><span class="line"><span class="type">int</span> *rescue;    <span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> **e;      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> *pre;     <span class="comment">//pre记录路径</span></span><br><span class="line"><span class="type">int</span> *rm;      <span class="comment">//能够到达i点的最多人数</span></span><br><span class="line"><span class="type">int</span> *num_of_shortest;  <span class="comment">//能够到达i点的最短路径条数</span></span><br><span class="line"><span class="type">int</span> N,M,C1,C2;</span><br><span class="line"><span class="type">int</span> maxrescue = <span class="number">0</span>;  <span class="comment">//最大救援队数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    rescue = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    pre = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    rm = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(rm,<span class="number">0</span>,<span class="built_in">sizeof</span>(rm));</span><br><span class="line">    num_of_shortest = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  <span class="comment">//初始化城市救援队数量</span></span><br><span class="line">        cin&gt;&gt;rescue[i];</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">new</span> <span class="type">int</span>*[N];     <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> e[i][j]=<span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c1,c2,length;  </span><br><span class="line">        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length;</span><br><span class="line">        e[c1][c2] = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;N;j++)</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;&quot;e[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]&quot;&lt;&lt;e[i][j]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[C1] = <span class="number">1</span>;</span><br><span class="line">    num_of_shortest[C1] = <span class="number">1</span>;</span><br><span class="line">    rm[C1] = rescue[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dist[i] = e[C1][i];</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&lt;<span class="number">9999</span>)&#123;   <span class="comment">//能够到达</span></span><br><span class="line">            pre[i]=C1;</span><br><span class="line">            rm[i] = rescue[C1]+rescue[i];</span><br><span class="line">            num_of_shortest[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;e[C1][4]&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; :&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">99999</span>,u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//选出下一次要加入s集合的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[i]&lt;min)&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//更新dist数组</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]&lt;dist[i])&#123;</span><br><span class="line">                dist[i] = dist[u] + e[u][i];</span><br><span class="line">                pre[i]=u;</span><br><span class="line">                rm[i] = rm[u]+rescue[i];</span><br><span class="line">                num_of_shortest[i] = num_of_shortest[u];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]==dist[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(rm[u]+rescue[i]&gt;rm[i])&#123;</span><br><span class="line">                    pre[i]=u;</span><br><span class="line">                    rm[i] = rm[u]+rescue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num_of_shortest[i] += num_of_shortest[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dijstra</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num_of_shortest[C2]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rm[C2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401160800655.png" alt="image-20210401160800655"></p>
<p>dijstra的套路算法，关键是需要增加几个判别的数组，一个是有多少条最短路径num_of_shortest，另一个是当前可以到达的最多救援队数量rm。</p>
<h3 id="PAT-1004（按层统计树的叶子节点）"><a href="#PAT-1004（按层统计树的叶子节点）" class="headerlink" title="PAT 1004（按层统计树的叶子节点）"></a>PAT 1004（按层统计树的叶子节点）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405155805312.png" alt="image-20210405155805312"></p>
<p>题意：按照每一层统计树的叶子节点个数</p>
<p>第一行输入 N&#x3D;2 树的节点       M&#x3D;1 非叶子节点个数</p>
<p>下面M行表示非叶子节点所跟的孩子  01 1 02    01表示 01号节点 ，1表示有一个孩子，02表示01的孩子的ID。</p>
<p><strong>题解</strong>：</p>
<p>第一步当然是想数据结构，用什么数据结构来存储这棵树呢？由于树的度不确定，我们很难使用二叉树的链式结构来存储，最初想到的是使用孩子兄弟链表进行存储，但最后发现构造这一棵树并不是太容易，而且我们只是需要统计每一层的非叶子节点数而已。我们不如直接使用结构体数组来存储这棵树，结构体包括ID，节点的孩子vector<int> child ，layer层数，这样我们统计每个节点是否是叶子节点的时候就可以使用child.size()来判断。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br></pre></td></tr></table></figure>

<p>其次就是有几个注意点：在分配内存空间的时候需要注意 如果是new，在堆上分配，内存的数据可以是任意的，意味着我们需要额外的初始化。如果使用Tseq[N+1]这种在栈上分配内存的状况，就可以不用初始化，这也导致我几个测试点过不了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">Tree_Node Tseq[N+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>还有一个坑点是，我们统计每一个节点的层数是，利用双亲节点的层数+1，这样有一个问题，要是先输入孩子节点，再输入双亲节点统计就有问题。<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20210405160649369.png" alt="image-20210405160649369" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以需要对输入的结点ID的大小进行排序，确保上层的节点先被统计进来。这样做法虽然有点蠢，但最后得了27分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">next_input</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numvec;</span><br><span class="line">&#125;next_input;</span><br><span class="line">vector&lt;next_input&gt; input_vector;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(next_input a,next_input b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;   cin&gt;&gt;N&gt;&gt;M;    <span class="comment">//N节点数  M非叶子节点数  </span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// Tree_Node* Tseq; </span></span><br><span class="line">    <span class="type">int</span> maxlayer;  <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">    Tree_Node Tseq[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        Tseq[i].ID = i;  <span class="comment">//分配序号</span></span><br><span class="line">    Tseq[<span class="number">1</span>].layer = <span class="number">1</span>;  <span class="comment">//01节点为根节点，层数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//把输入变成一个vector，然后再排序，以免计算层数时出错</span></span><br><span class="line">        next_input input;</span><br><span class="line">        <span class="type">int</span> id,num,child;  </span><br><span class="line">        cin&gt;&gt;id&gt;&gt;num;</span><br><span class="line">        input.id = id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;child;  input.numvec.<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        input_vector.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(input_vector.<span class="built_in">begin</span>(),input_vector.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//统计节点的层数和孩子</span></span><br><span class="line">        <span class="type">int</span> id,num,childnum;</span><br><span class="line">        id = input_vector[i].id;</span><br><span class="line">        num = input_vector[i].numvec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            childnum = input_vector[i].numvec[j];</span><br><span class="line">            Tseq[id].child.<span class="built_in">push_back</span>(childnum);</span><br><span class="line">            Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        maxlayer = <span class="built_in">max</span>(maxlayer,Tseq[i].layer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;  <span class="comment">//第i层有几个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxlayer;i++)&#123;</span><br><span class="line">        Map[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Tseq[i].child.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;   <span class="comment">//是叶子节点</span></span><br><span class="line">            Map[Tseq[i].layer]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ::iterator iter;</span><br><span class="line">    cout&lt;&lt;Map.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    iter = Map.<span class="built_in">begin</span>(); iter++;</span><br><span class="line">    <span class="keyword">for</span>(;iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405160805791.png" alt="image-20210405160805791"></p>
<p>最后一个测试点有点懵</p>
<p>如果考虑到只有一个节点的情况，if(N&#x3D;&#x3D;1){ cout&lt;&lt;”1”&lt;&lt;endl;return 0;} 这句话会根据出现在不同的位置而产生不同的结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405161716830.png" alt="image-20210405161716830"></p>
<h3 id="PAT-1005"><a href="#PAT-1005" class="headerlink" title="PAT 1005"></a>PAT 1005</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404205053583.png" alt="image-20210404205053583"></p>
<p>计算一个数的个位数字之和，英文输出。比较简单，十分钟搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string Map[] = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        count += (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ss = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ss;</span></span><br><span class="line">    cout&lt;&lt;Map[ss[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ss.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Map[ss[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1006"><a href="#PAT-1006" class="headerlink" title="PAT 1006"></a>PAT 1006</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404211724478.png" alt="image-20210404211724478"></p>
<p>水题，比较来上班最早的和来上班最晚的，直接写一个结构体比较就好了，二十分钟能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    string early;</span><br><span class="line">    string later;</span><br><span class="line">&#125;person;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpearly</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.early);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.early);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&lt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmplater</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.later);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.later);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&gt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt;  vec_person;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        person p;</span><br><span class="line">        cin&gt;&gt;p.id&gt;&gt;p.early&gt;&gt;p.later;</span><br><span class="line">        vec_person.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmpearly);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmplater);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1007（动态规划）"><a href="#PAT-1007（动态规划）" class="headerlink" title="PAT 1007（动态规划）"></a>PAT 1007（动态规划）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404222558427.png" alt="image-20210404222558427"></p>
<p>leetcode经典题，最大连续子序列和，一想就知道使用动态规划。</p>
<p>坑点1： output the one with the smallest indices i and j (as shown by the sample case). 这句话的意思是输出开始的数，而不是下标，整了一小时。</p>
<p>坑点2： If all the K numbers are negative, then its maximum sum is defined to be 0, and you  are supposed to output the first and the last numbers of the whole  sequence.  这句话记得看就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; seq.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[seq.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="type">int</span> pre[seq.<span class="built_in">size</span>()];</span><br><span class="line">    dp[<span class="number">0</span>] = seq[<span class="number">0</span>];  pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>,maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;seq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+seq[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = seq[i];</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsub)&#123;</span><br><span class="line">            maxsub = dp[i];  maxi = pre[i]; maxj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxsub&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxsub&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxi]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxj];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这儿的dp定义的略有不同，不过无伤大雅，dp[i]是指以i结尾的最大连续子序列和。</p>
<h3 id="PAT-1008"><a href="#PAT-1008" class="headerlink" title="PAT 1008"></a>PAT 1008</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404223852830.png" alt="image-20210404223852830"></p>
<p>水题。电梯上升一层6s，下降一层4s，每层有需要停留5s，求电梯所需要时间。十分钟解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; v.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//代表现在电梯到哪一层了</span></span><br><span class="line">    <span class="type">int</span> total_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((v[i]-temp)&gt;=<span class="number">0</span>)&#123;  <span class="comment">//上升</span></span><br><span class="line">            total_time += (v[i]-temp)*<span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//下降</span></span><br><span class="line">            total_time += (temp-v[i])*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = v[i];</span><br><span class="line">        total_time += <span class="number">5</span>; <span class="comment">//停留</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total_time;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1009"><a href="#PAT-1009" class="headerlink" title="PAT 1009"></a>PAT 1009</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210409154552498.png" alt="image-20210409154552498"></p>
<p>和pat1002类似，这里做的是乘法A * B,可以采用暴力法二重循环。</p>
<p>注意的是如果系数等于0则不输出。</p>
<p>不能使用cout&lt;&lt;M.size();  来统计输出的个数，因为会把系数为0的统计进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n]; <span class="type">double</span> b[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k; cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> ai; <span class="type">double</span> bi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> exponent = ai+a[j];</span><br><span class="line">            <span class="type">double</span> coefficient = bi*b[j];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(exponent)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                M[exponent] += coefficient;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                M[exponent] = coefficient;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;M.size();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1010（数学题）"><a href="#PAT-1010（数学题）" class="headerlink" title="PAT 1010（数学题）"></a>PAT 1010（数学题）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202035024.png" alt="image-20210410202035024"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202048687.png" alt="image-20210410202048687"></p>
<p>题目大意：N1 N2 tag radix</p>
<p>N1 N2 为两个数，基数未定，范围从[0-9] [a-z]，radix表示一个数的基数（tag&#x3D;1，则表示N1 的基数，tag&#x3D;2则表示N2的基数）我们要求另一个数的基数，使得N1&#x3D;N2。若不存在则输出”Impossible”。</p>
<p>最初的想法是把一个数的十进制算出来，另一个数从2 一直往上遍历，遍历到什么时候是个头呢，无从知晓。看了答案之后方才明白。</p>
<p><strong>进制范围的确定</strong>   （关键步骤+二分查找）</p>
<p>进制的最小取值为：各个位数最大值+1 如123的最小进制一定大于3， abc的最小进制一定大于12  （这个比较好理解）</p>
<p>现在来讨论进制的上限（max_radix）  (这个不好理解)<br>　　那么现在在题目中，给出了两个数，一个数记为a是已知进制的，另一个记为b未知，假设a&#x3D;675,为10进制，b&#x3D;1，未知进制<br>　　很显然，b的最低进制min_radix是2<br>　　那么b的最高进制max_radix 是多少呢<br>　　我们的目的是让a&#x3D;b，b不可过小也不可过大<br>　　<br>　　假设 max_radix&#x3D;1000<br>　　很显然b &#x3D; 1(1000) &#x3D; 1000 &gt; a &#x3D; 675<br>　　所以，发现了吗<br>　　想让a&#x3D;b，b的最大进制就是a的值,即675<br>　　因为我举的例子比较特殊，如果b不为1，那么就很难直接得到b的精确的最高进制max_radix<br>　　但是 ，可以肯定的是，当b为1 的时候，max_radix是最大的（因为此时b最小）<br>　　因此，我们虽然不知道b&#x3D;10,20,80,13671…时，对应的max_radix是多少，但是，他们一定比b&#x3D;1对应的max_radix小<br>　　那么我们就可以用最大的max_radix作为进制的上限，在min_radix 到max_radix中二分查找<br>　　同时需要注意，max_radix&gt;&#x3D;min_radix<br>　　故有 max_radix &#x3D; max(a,min_radix);</p>
<p><strong>坑点</strong>：</p>
<p>计算过程中会出现数据溢出。<br> 举个极端例子：<br> 一亿进制的zzzzzzzzzz转化为十进制。 即使用long long也无法保存。<br> 那么应该怎么判断呢？ 可以判断计算结束后的值是否小于0，因为溢出后的值一定小于0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202935463.png" alt="image-20210410202935463"></p>
<p>这一句显得至关重要，有6个测试点来自这。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">transfer_to_ten</span><span class="params">(string a,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll total=<span class="number">0</span>;</span><br><span class="line">    ll basement = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) total += (a[i]-<span class="string">&#x27;0&#x27;</span>)*basement;</span><br><span class="line">        <span class="keyword">else</span> total += (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>)*basement;</span><br><span class="line">        basement *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_base</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// if(a[i]&lt;=&#x27;9&#x27;) min_base = max(min_base,a[i]-&#x27;0&#x27;+1);</span></span><br><span class="line">        <span class="comment">// else min_base = max(min_base,a[i]-&#x27;a&#x27;+11);</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) min_base = min_base&gt;(a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>) ? min_base : (a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> min_base = min_base&gt;(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>) ? min_base : (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search_base</span><span class="params">(string a,<span class="type">int</span> min_base,<span class="type">int</span> max_base,<span class="type">long</span> <span class="type">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_base&lt;<span class="number">2</span>) min_base = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_base&gt;max_base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll mid_base = min_base + (max_base-min_base)/<span class="number">2</span>;</span><br><span class="line">    ll temp = <span class="built_in">transfer_to_ten</span>(a,mid_base);</span><br><span class="line">    <span class="keyword">if</span>(temp==target) <span class="keyword">return</span> mid_base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target || temp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">search_base</span>(a,min_base,mid_base<span class="number">-1</span>,target);  <span class="comment">//关键 temp可能会溢出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search_base</span>(a,mid_base+<span class="number">1</span>,max_base,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    string cc;</span><br><span class="line">    ll tag,radix;</span><br><span class="line">    ll target;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(a,radix);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;radix;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;target: &quot;&lt;&lt;target&lt;&lt;endl;</span></span><br><span class="line">        cc = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(b,radix);</span><br><span class="line">        cc = a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll min_base = <span class="built_in">find_min_base</span>(cc);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;min_base: &quot;&lt;&lt;min_base&lt;&lt;endl;</span></span><br><span class="line">    ll max_base = target&gt;min_base ? target : min_base;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;max_base: &quot;&lt;&lt;max_base&lt;&lt;endl;</span></span><br><span class="line">    ll mid_base = <span class="built_in">search_base</span>(cc,min_base,max_base,target);</span><br><span class="line">    <span class="keyword">if</span>(mid_base) cout&lt;&lt;mid_base;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410203111819.png" alt="image-20210410203111819"></p>
<p>第10个测试点据说是：10测试点是输入为0<br> 当其中一个输入为0时，base若等于最大数字加1则为1，但我们知道进制的最小值为2，故在搜索前需要进行检查。（不太清楚）</p>
<h3 id="PAT-1011"><a href="#PAT-1011" class="headerlink" title="PAT 1011"></a>PAT 1011</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153118330.png" alt="image-20210422153118330"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153134396.png" alt="image-20210422153134396"></p>
<p>给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大。每一场都选最大的。无脑题，关键在于读懂题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ca</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> pro;</span><br><span class="line">&#125;ca;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ca a,ca b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pro&gt;b.pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>]=&#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"><span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ca&gt;&gt; <span class="built_in">v</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            ca d; </span><br><span class="line">            cin&gt;&gt;d.pro;</span><br><span class="line">            d.a = a[j];</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        res *= v[i][<span class="number">0</span>].pro;</span><br><span class="line">        cout&lt;&lt;v[i][<span class="number">0</span>].a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1012"><a href="#PAT-1012" class="headerlink" title="PAT 1012"></a>PAT 1012</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163238958.png" alt="image-20210422163238958"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163249988.png" alt="image-20210422163249988"></p>
<p>这一题竟然解决了一个小时。</p>
<p>题目大意：输入学生 以及三门课的成绩，然后每输入一个学生的id就打印最高的排名和对应排名的分类。排名分成三门课的单独排名和平均分的排名。排名也有优先级，A&gt;C&gt;M&gt;E。还算模拟题吧。</p>
<p>我的思路是建立一个学生表Map[string , stu]；stu包含学生的信息，包括成绩，排名等等。在第一波输入的时候，我们可以将成绩信息，填入学生表，同时将每科的成绩分门别列进行排序，第二轮遍历学生表Map时我们按照成绩查找对应的排名，本来想用二分查找，（但也必须是改进的二分查找，查找目标&#x3D;&#x3D;target的最小边界）。然后printinfo函数输出每个学生的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    string ID;</span><br><span class="line">    <span class="type">int</span> C,M,E,A;  <span class="comment">//成绩</span></span><br><span class="line">    <span class="type">int</span> rC,rM,rE,rA;  <span class="comment">//排名</span></span><br><span class="line">&#125;stu;</span><br><span class="line">map&lt;string,stu&gt; Map;  <span class="comment">//学生表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; CC;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; MM;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; EE;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AA;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int binary_search(vector&lt;int&gt; A,int target,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">//     if(l&gt;r) return -2;</span></span><br><span class="line"><span class="comment">//     int mid = (l+r)/2;</span></span><br><span class="line"><span class="comment">//     if(A[mid]==target) return mid+1;</span></span><br><span class="line"><span class="comment">//     if(A[mid]&gt;target) return binary_search(A,target,mid+1,r);</span></span><br><span class="line"><span class="comment">//     else return binary_search(A,target,l,mid-1);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]==target) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstu</span><span class="params">(stu S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.rA&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rA&lt;&lt;<span class="string">&quot; A&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rC&lt;=<span class="built_in">min</span>(S.rA,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rC&lt;&lt;<span class="string">&quot; C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rM&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rA)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rM&lt;&lt;<span class="string">&quot; M&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rE&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rA,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rE&lt;&lt;<span class="string">&quot; E&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string a; <span class="type">int</span> b,c,d;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        CC.<span class="built_in">push_back</span>(b);   MM.<span class="built_in">push_back</span>(c);  </span><br><span class="line">        EE.<span class="built_in">push_back</span>(d); </span><br><span class="line">        <span class="type">int</span> aver = (<span class="type">int</span>)((<span class="type">double</span>)(b+c+d)/<span class="number">3.0</span>+<span class="number">0.5</span>);</span><br><span class="line">        AA.<span class="built_in">push_back</span>(aver);</span><br><span class="line">        stu temp; </span><br><span class="line">        temp.ID = a; temp.C=b; temp.M=c; temp.E=d; temp.A=aver;</span><br><span class="line">        Map[a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(CC.<span class="built_in">begin</span>(),CC.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(EE.<span class="built_in">begin</span>(),EE.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(MM.<span class="built_in">begin</span>(),MM.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(AA.<span class="built_in">begin</span>(),AA.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    map&lt;string,stu&gt; :: iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="comment">// int a = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rA = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rC = binary_search(CC,iter-&gt;second.C,0,CC.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rE = binary_search(EE,iter-&gt;second.E,0,EE.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rM = binary_search(MM,iter-&gt;second.M,0,MM.size()-1);</span></span><br><span class="line">        iter-&gt;second.rA = <span class="built_in">search</span>(AA,iter-&gt;second.A);</span><br><span class="line">        iter-&gt;second.rC = <span class="built_in">search</span>(CC,iter-&gt;second.C);</span><br><span class="line">        iter-&gt;second.rE = <span class="built_in">search</span>(EE,iter-&gt;second.E);</span><br><span class="line">        iter-&gt;second.rM = <span class="built_in">search</span>(MM,iter-&gt;second.M);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string s;  cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(s)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printstu</span>(Map[s]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163816564.png" alt="image-20210422163816564"></p>
<h3 id="PAT-1013（连通分量）"><a href="#PAT-1013（连通分量）" class="headerlink" title="PAT 1013（连通分量）"></a>PAT 1013（连通分量）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172221670.png" alt="image-20210422172221670"></p>
<p>题意：给出城市个数为N，连接城市间的道路的条数为M，以及询问次数为K</p>
<p>然后输入这M条道路连接的两个端点城市的编号Ａ和Ｂ</p>
<p>然后是K次询问，每次询问的方法是：给出一个编号为Q城市，然后将这个城市和与其相连的道路从网络中删除，要求让你求出添加多少条道路，才能使得被删除了编号为Q的城市的网络仍然联通</p>
<p>转化成求连通分量个数。即图的遍历，我这里使用广度优先搜索遍历图，求连通分量k。</p>
<p>bfs(int node)；除去node结点的连通分量，从1..N遍历结点，设置一个visited数组表示该结点是否访问过。如果访问过则记作1.k++，然后是用一个栈广度优先搜索该连通分量中可以到达的结点。</p>
<p>最后需要增加的路径&#x3D;连通分量个数-1</p>
<p>注意：每一次考虑新的结点的时候visited必须复位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//1..N 0不用</span></span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">int</span> k;  <span class="comment">//连通分量个数</span></span><br><span class="line"><span class="type">int</span> **Graph;   <span class="comment">//Graph  1..N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;   <span class="comment">//不考虑node结点,求连通分量个数k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==node) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==node) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Graph[top][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                    visited[j]=<span class="number">1</span>;</span><br><span class="line">                    S.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="comment">//visited数组初始化，表示没有访问过</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph初始化</span></span><br><span class="line">    Graph = <span class="keyword">new</span> <span class="type">int</span>*[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Graph[i] = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(Graph[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(Graph[i]));  <span class="comment">//Graph[i][u] = 0代表i,u之间没有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">        Graph[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// memset(visited,0,sizeof(visited));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) visited[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(a);</span><br><span class="line">        cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=K<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 5 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">2 1 3 4 5 6 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172806405.png" alt="image-20210422172806405"></p>
<h3 id="PAT-1014-队列模拟"><a href="#PAT-1014-队列模拟" class="headerlink" title="PAT 1014 (队列模拟)"></a>PAT 1014 (队列模拟)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174327230.png" alt="image-20210422174327230"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174337754.png" alt="image-20210422174337754"></p>
<p><strong>题目大意</strong>：银行有N个窗口，每个窗口划分成两部分，黄线内的和黄线外的</p>
<p>顾客排队有以下几个要求：</p>
<p>1、每个窗口黄线内可以站M个人，第（MN+1)个人得排在黄线外</p>
<p>2、每个顾客选择最短的队伍，（队伍长度相同选择序号小的）</p>
<p>3、顾客i将花费 Ti 的时间处理问题</p>
<p>3、每个窗口的第一位顾客将于8:00被服务</p>
<p>给定每个顾客的处理问题的时间，求每位顾客解决问题的时间点。</p>
<p>输入：第一行 N(窗口）、M（黄线内的人数）、K（顾客人数）、Q（要求的顾客完成时间）  五点之前下班</p>
<p><strong>思路</strong>：用一个vector表示一个窗口，窗口里是一个queue<int>表示窗口队列，首先初始化窗口，之后模拟每一次完成（查找所有窗口剩余时间最少的出队，如果还有人在黄线外等候则加入该窗口的队列，然后更新每个窗口front元素的剩余时间）。持续下去直到所有窗口都为空。 用一个变量nowtime记录当前时间，也即每个顾客的完成时间。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M,K,Q;  <span class="comment">//N 窗口  M 黄线内人数  K 顾客人数  Q 询问时间</span></span><br><span class="line"><span class="type">int</span> Time[<span class="number">1001</span>];   <span class="comment">//表示第i位顾客还剩多少时间完成</span></span><br><span class="line"><span class="type">int</span> process[<span class="number">1001</span>];   <span class="comment">//最多有1001个顾客，time表示第i个顾客的完成时间，单位分钟</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Custom;  <span class="comment">//顾客队列,按照编号进行</span></span><br><span class="line">vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; Window; <span class="comment">//窗口vector，每个窗口维护一个队列，队列长度不超过M</span></span><br><span class="line"><span class="type">int</span> nowtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断所有窗口是否还有人在排队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isemptyWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最早出队的窗口号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mintime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_time = <span class="number">9999</span>; </span><br><span class="line">    <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>() &amp;&amp; Time[Window[i].<span class="built_in">front</span>()]&lt;min_time)&#123;</span><br><span class="line">            min_time = Time[Window[i].<span class="built_in">front</span>()];</span><br><span class="line">            min_i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新每个窗口的出队时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> subtime,<span class="type">int</span> t)</span></span>&#123;  <span class="comment">//subtime减去的时间，t除外</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=t &amp;&amp; !Window[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Time[Window[i].<span class="built_in">front</span>()] -= subtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_to_clock</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour = time/<span class="number">60</span>+<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> minn = time%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;<span class="number">17</span> || (hour==<span class="number">17</span>&amp;&amp;minn&gt;<span class="number">0</span>)) cout&lt;&lt;<span class="string">&quot;Sorry&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>,hour,minn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> pCustom = <span class="number">1</span>;  <span class="comment">//顾客指针，在pCustom之前的都已经安排到Windows黄线内去了</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Time[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//初始化窗口</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;  Window.<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口队列</span></span><br><span class="line">    <span class="keyword">while</span>(pCustom&lt;=N*M &amp;&amp; pCustom&lt;=K)&#123;</span><br><span class="line">        Window[(pCustom+<span class="number">1</span>)%M].<span class="built_in">push</span>(pCustom);  <span class="comment">//按照顺序每个窗口依次安排人</span></span><br><span class="line">        pCustom++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isemptyWindow</span>())&#123;</span><br><span class="line">        <span class="type">int</span> min_i = <span class="built_in">mintime</span>();  <span class="comment">//最早出队的窗口号</span></span><br><span class="line">        <span class="type">int</span> subtime = Time[Window[min_i].<span class="built_in">front</span>()];  <span class="comment">//需要更新的时间</span></span><br><span class="line">        nowtime += subtime;   <span class="comment">//更新当前时间</span></span><br><span class="line">        process[Window[min_i].<span class="built_in">front</span>()] = nowtime;   <span class="comment">//记录该顾客已经完成</span></span><br><span class="line">        Window[min_i].<span class="built_in">pop</span>();  <span class="comment">//当前窗口出队</span></span><br><span class="line">        <span class="keyword">if</span>(pCustom&lt;=K)&#123;</span><br><span class="line">            Window[min_i].<span class="built_in">push</span>(pCustom);   <span class="comment">//加入新元素</span></span><br><span class="line">            pCustom++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(subtime,min_i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">time_to_clock</span>(process[a]);</span><br><span class="line">        <span class="keyword">if</span>(i!=Q<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193023153.png" alt="image-20210422193023153"></p>
<p>看答案发现五点前还没处理完的不可能赶人家走吧，所以修改了一下代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193841669.png" alt="image-20210422193841669"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193858472.png" alt="image-20210422193858472"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193918612.png" alt="image-20210422193918612"></p>
<p>参考了网上的AC代码，还是没看出来自己为什么错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> win_num, win_len, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;win_num, &amp;win_len, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">times</span>(win_num); <span class="comment">//times按顺序记录每个窗口中排队的人的结束时间，用以标示下一个进入的人的开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n)</span>, <span class="title">start_time</span><span class="params">(n)</span></span>; <span class="comment">//data记录每个用户的耗时，start_time记录每个用户的开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i&lt;win_num*win_len; i++)&#123;  <span class="comment">//先把黄线内的人排队排好</span></span><br><span class="line">        <span class="type">int</span> t = i%win_num; <span class="comment">//第t个窗口</span></span><br><span class="line">        start_time[i] = i&lt;win_num?<span class="number">0</span>:times[t][i/win_num<span class="number">-1</span>]; <span class="comment">//第一排的开始时间是0，之后的开始时间是前一排的结束时间，从times中获取</span></span><br><span class="line">        times[t].<span class="built_in">push_back</span>(start_time[i]+data[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=win_num*win_len; i&lt;n; i++)&#123;  <span class="comment">//黄线外的人进入队伍</span></span><br><span class="line">        <span class="type">int</span> mint=<span class="number">540</span>, w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;win_num; j++)&#123;  <span class="comment">//选择队伍，按队伍中size()-win_len个人的最早开始时间选择</span></span><br><span class="line">            <span class="type">int</span> st = times[j][times[j].<span class="built_in">size</span>()-win_len];</span><br><span class="line">            <span class="keyword">if</span>(st&lt;mint)&#123;</span><br><span class="line">                mint = st;</span><br><span class="line">                w = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">-1</span>) start_time[i] = <span class="number">540</span>; <span class="comment">//没窗口选，全都已经超时，按540计</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start_time[i] = times[w][times[w].<span class="built_in">size</span>()<span class="number">-1</span>]; <span class="comment">//计算开始时间</span></span><br><span class="line">            times[w].<span class="built_in">push_back</span>(start_time[i]+data[i]); <span class="comment">//排队进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(start_time[x]&gt;=<span class="number">540</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (start_time[x]+data[x])/<span class="number">60</span>+<span class="number">8</span>, (start_time[x]+data[x])%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PAT-1015"><a href="#PAT-1015" class="headerlink" title="PAT 1015"></a>PAT 1015</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210426090709927.png" alt="image-20210426090709927"></p>
<p>最初这题题目没看懂</p>
<p>题目大意：给出一个素数，判断在d进制下反转后在十进制下是否是素数，如果是，则输出”Yes”，否，则输出”No”。</p>
<p>Sample input:</p>
<p>73 在十进制下反转 37</p>
<p>23(10111) 在2进制下反转(11101) 29 是质数</p>
<p>23在10进制下反转32不是质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//判断n是否是素数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>) <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> zNum = <span class="number">0</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//转换为p进制</span></span><br><span class="line">        z[zNum++] = n % d;</span><br><span class="line">        n /=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zNum; ++i) &#123;<span class="comment">//逆序转为10进制</span></span><br><span class="line">        n = n * d + z[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">true</span>)&#123;<span class="comment">//是素数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;<span class="comment">//是负数，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Check</span>(n, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1016"><a href="#PAT-1016" class="headerlink" title="PAT 1016"></a>PAT 1016</h3><p>题目大意： 打长途电话每分钟要花一定的费用，这取决于一天中打电话的时间。当客户开始连接长途电话时，时间会被记录下来，客户挂断电话的时间也会被记录下来。每个日历月，每一分钟都会向客户发送一张账单（按一天中的时间确定的费率）。你的工作是准备每个月的账单，给你一套电话记录。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210429204459301.png" alt="image-20210429204459301"></p>
<h3 id="PAT-1039"><a href="#PAT-1039" class="headerlink" title="PAT 1039"></a>PAT 1039</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182936179.png" alt="image-20210420182936179"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182949322.png" alt="image-20210420182949322"></p>
<p>题目大意：有一个表保存了学生的选课信息，根据学生姓名来查询信息，输出该名学生选课情况。</p>
<p>样例解释，有11个学生，共5门课，接下来10行表示每门课的选课情况，例如2,3行，第4门课（4是课程号），7个人选，选课名单BOB5…</p>
<p>最后一行按顺序输出学生的名单。结果输出每个学生的名字，选课门数和课程号。</p>
<p>思路比较清楚，我定义的数据结构还算比较复杂</p>
<p>Query_List 代表学生的选课列表（索引就代表学号），Course_List代表课程的学生列表。</p>
<p>我们先把数据读入课程列表中，再用一个Map将学生的名字和学号一一对应。然后遍历Course_List，查到Course_List的学生选的哪门课就往Query_List中添加。最后将Query_List中的list排序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br></pre></td></tr></table></figure>

<p>坑点：最后一个测试数据比较大，据说要用scanf和printf，或者用char</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;Course_List&gt; CList;</span><br><span class="line">    vector&lt;Query_List&gt; QList;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> i1,i2;  </span><br><span class="line">        string i3;  </span><br><span class="line">        cin&gt;&gt;i1&gt;&gt;i2;</span><br><span class="line">        Course_List C; </span><br><span class="line">        C.cno = i1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;i2;i++)&#123;</span><br><span class="line">            cin&gt;&gt;i3;  </span><br><span class="line">            C.name.<span class="built_in">push_back</span>(i3);</span><br><span class="line">        &#125;</span><br><span class="line">        CList.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name;  cin&gt;&gt;name;</span><br><span class="line">        M[name] = i;</span><br><span class="line">        Query_List Q;  Q.name = name;</span><br><span class="line">        QList.<span class="built_in">push_back</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;CList[i].name.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//M[CList[i].name[j]].list.push_back(CList[i].cno);</span></span><br><span class="line">            QList[M[CList[i].name[j]]].list.<span class="built_in">push_back</span>(CList[i].cno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;QList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(QList[i].list.<span class="built_in">begin</span>(),QList[i].list.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;QList[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;QList[i].list.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=QList.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420183645306.png" alt="image-20210420183645306"></p>
<h3 id="PAT-1040（dp"><a href="#PAT-1040（dp" class="headerlink" title="PAT 1040（dp)"></a>PAT 1040（dp)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420235614633.png" alt="image-20210420235614633"></p>
<p>题目大意：查询长度最长的对称串</p>
<p>动态规划，dp[i] [j] 表示从 i 开始到 j 结束的对称串。（ i&lt;&#x3D;j ） </p>
<p>dp[i] [i] &#x3D; 1;</p>
<p>dp [i] [i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</p>
<p>dp[i] [i+k] &#x3D; (s[i] &#x3D;&#x3D; s[i+k] &amp;&amp; dp[i+1] [i+k-1] )</p>
<p>i，j的状态取决于 i+1,j-1是不是对称串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> dp[length][length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="built_in">memset</span>(dp[i],<span class="literal">false</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    <span class="type">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//Initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) &#123;dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>; maxlength=<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;length;k++)&#123;  <span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length &amp;&amp; i+k&lt;length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+k] &amp;&amp; dp[i+<span class="number">1</span>][i+k<span class="number">-1</span>]==<span class="literal">true</span>)&#123; </span><br><span class="line">                dp[i][i+k]=<span class="literal">true</span>;</span><br><span class="line">                maxlength=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="PAT-1041"><a href="#PAT-1041" class="headerlink" title="PAT 1041"></a>PAT 1041</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233542571.png" alt="image-20210420233542571"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233553640.png" alt="image-20210420233553640"></p>
<p>题目大意，找到最近的一个不重复的数，如果找不到输出none。</p>
<p>直接一个map存放出现的次数，之后再从前往后遍历。无脑题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> unicode;</span><br><span class="line">    <span class="type">int</span> Map[<span class="number">50000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">0</span>,<span class="built_in">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a ;cin&gt;&gt;a;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a);</span><br><span class="line">        Map[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(!unique &amp;&amp; j&lt;A.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[A[j]]==<span class="number">1</span>)&#123;</span><br><span class="line">            unique = <span class="literal">true</span>;</span><br><span class="line">            unicode = A[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unique) cout&lt;&lt;unicode;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1081"><a href="#PAT-1081" class="headerlink" title="PAT 1081"></a>PAT 1081</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210423091333960.png" alt="image-20210423091333960"></p>
<p>简单题，模拟分数乘法操作。</p>
<p>注意点：题目准确说明数的范围是Long ing型，第四个测试点出现浮点错误，需要判断一下分母为0的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fenzi[N]; <span class="type">long</span> <span class="type">long</span> fenmu[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,&amp;fenzi[i],&amp;fenmu[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> denominator = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) denominator *= fenmu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) numerator += denominator/fenmu[i]*fenzi[i];</span><br><span class="line">    <span class="keyword">if</span>(denominator==<span class="number">0</span>)&#123;  <span class="comment">//这里一定要判断一下，第四个测试点可能会出现浮点错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> interger = numerator/denominator;</span><br><span class="line">    <span class="keyword">if</span>(interger) cout&lt;&lt;interger;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re_numerator = numerator - interger*denominator;</span><br><span class="line">    <span class="keyword">if</span>(re_numerator)&#123;</span><br><span class="line">        <span class="keyword">if</span>(interger) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(re_numerator,denominator);</span><br><span class="line">        re_numerator /= g;    denominator/= g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,re_numerator,denominator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2021-7-10"><a href="#2021-7-10" class="headerlink" title="2021.7.10"></a>2021.7.10</h2><h3 id="PAT-1152"><a href="#PAT-1152" class="headerlink" title="PAT 1152"></a>PAT 1152</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153004327.png" alt="image-20210710153004327"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153023441.png" alt="image-20210710153023441"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153032898.png" alt="image-20210710153032898"></p>
<p>题目大意：给定一个N位的数，寻找第一次出现的m位素数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(LL t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL s = <span class="number">2</span>; s&lt;<span class="built_in">sqrt</span>(t) ;s++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i++)&#123;</span><br><span class="line">        res = s.<span class="built_in">substr</span>(i,n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issushu</span>(<span class="built_in">stoi</span>(res)))&#123;</span><br><span class="line">            cout&lt;&lt;res;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153216499.png" alt="image-20210710153216499"></p>
<h3 id="PAT-1153"><a href="#PAT-1153" class="headerlink" title="PAT 1153"></a>PAT 1153</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210514325.png" alt="image-20210710210514325"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210537819.png" alt="image-20210710210537819"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210558121.png" alt="image-20210710210558121"></p>
<p>题目大意：给出一组学生的准考证号和成绩，准考证号包含了等级(乙甲顶)，考场号，日期，和个人编号信息，并有三种查询方式<br>查询一：给出考试等级，找出该等级的考生，按照成绩降序，准考证升序排序<br>查询二：给出考场号，统计该考场的考生数量和总得分<br>查询三：给出考试日期，查询改日期下所有考场的考试人数，按照人数降序，考场号升序排序<br><strong>修改前的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;p1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    <span class="keyword">if</span>(M.<span class="built_in">find</span>(cc)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        M[cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        M[cc] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">dic1</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;dic1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;N<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710211717494.png" alt="image-20210710211717494"></p>
<p>改后发现格式不需要那么复杂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1.second==o2.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.first&lt;o2.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; </span><br><span class="line">                    total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    M[cc] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; dic1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : M) dic1.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it.first, it.second));</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一格多一个换行也没关系</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710220609566.png" alt="image-20210710220609566"></p>
<p><strong>修改后的AC代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testees</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;testees;</span><br><span class="line">vector&lt;testees&gt; t;</span><br><span class="line"><span class="type">int</span> N,M,type;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(testees a,testees b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,t[i].id.<span class="built_in">c_str</span>(),t[i].score);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>))&#123;</span><br><span class="line">                sum += t[i].score;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>))&#123;</span><br><span class="line">                mp[t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">vec_mp</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec_mp.<span class="built_in">begin</span>(),vec_mp.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec_mp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,vec_mp[i].first.<span class="built_in">c_str</span>(),vec_mp[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        testees ta;</span><br><span class="line">        cin&gt;&gt;ta.id&gt;&gt;ta.score;</span><br><span class="line">        t.<span class="built_in">push_back</span>(ta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>,i,type,s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">deal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710215520857.png" alt="image-20210710215520857"></p>
<h3 id="PAT-1154"><a href="#PAT-1154" class="headerlink" title="PAT 1154"></a>PAT 1154</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222438518.png" alt="image-20210710222438518"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222450152.png" alt="image-20210710222450152"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222458698.png" alt="image-20210710222458698"></p>
<p>题目大意：</p>
<p>相邻的两边不能同色，不用邻接矩阵，直接用边进行判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Graph</span><span class="params">(V,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> query; cin&gt;&gt;query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;query;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">            Graph[i] = a;</span><br><span class="line">            M[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[Edge[i].first] == Graph[Edge[i].second])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;-coloring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222553175.png" alt="image-20210710222553175"></p>
<h3 id="PAT-1155（回溯）"><a href="#PAT-1155（回溯）" class="headerlink" title="PAT 1155（回溯）"></a>PAT 1155（回溯）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230530365.png" alt="image-20210710230530365"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230546043.png" alt="image-20210710230546043"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230612772.png" alt="image-20210710230612772"></p>
<p>题目大意：给定一个二叉树，判断是不是大顶堆或小顶堆，并且输出路径，从右到左输出，可以利用回溯法解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> MAX_OR_MIN;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&gt;N)&#123;   <span class="comment">//到头了，输出路径</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    V.<span class="built_in">resize</span>(N+<span class="number">1</span>);  <span class="comment">//下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;  <span class="comment">//确定大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&gt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&lt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(V[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">backtrace</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==res[i].<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230634645.png" alt="image-20210710230634645"></p>
<h2 id="2021-7-17"><a href="#2021-7-17" class="headerlink" title="2021.7.17"></a>2021.7.17</h2><h3 id="PAT-1148"><a href="#PAT-1148" class="headerlink" title="PAT 1148"></a>PAT 1148</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174748111.png" alt="image-20210717174748111"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174800947.png" alt="image-20210717174800947"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174812459.png" alt="image-20210717174812459"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174821796.png" alt="image-20210717174821796"></p>
<p>题目大意：狼人杀，给出N个人，其中只有两个是狼人，找出狼人，其中所有人中有两个人说谎，说谎的人里包含一个狼人。</p>
<p>本来是想通过假设说谎的人数 i,j  来找到狼人，后来发现通过假定狼人i,j来验证是否成立来得更加方便。整了一个半小时了都。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Data</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> istrue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;   <span class="comment">//i,j是werewolf,其他是human</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i || k==j) output[k] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> output[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始验证</span></span><br><span class="line">            <span class="type">int</span> fa = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> wefa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[k] * output[<span class="built_in">abs</span>(Data[k])]&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">                     fa++;</span><br><span class="line">                     <span class="keyword">if</span>(k==i || k==j) wefa++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa==<span class="number">2</span> &amp;&amp; wefa==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717175023186.png" alt="image-20210717175023186"></p>
<h3 id="PAT-1149"><a href="#PAT-1149" class="headerlink" title="PAT 1149"></a>PAT 1149</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193857126.png" alt="image-20210717193857126"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193908755.png" alt="image-20210717193908755"></p>
<p>题目大意：集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No～</p>
<p>分析：用map存储每一个货物的所有不兼容货物～在判断给出的一堆货物是否是相容的时候，判断任一货物的不兼容货物是否在这堆货物中～如果存在不兼容的货物，则这堆货物不能相容～如果遍历完所有的货物，都找不到不兼容的两个货物，则这堆货物就是兼容的～</p>
<p>用map存储每一个货物的所有不相容货物，然后逐一进行比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(a)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(b);</span><br><span class="line">            Map[a] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(b)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(a);</span><br><span class="line">            Map[b] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(Q)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;Q;k++)&#123;</span><br><span class="line">            cin&gt;&gt;res[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;res.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jj=<span class="number">0</span>;jj&lt;res.<span class="built_in">size</span>();jj++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ii==jj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Map.<span class="built_in">find</span>(res[ii])== Map.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vector&lt;string&gt; temp = Map[res[ii]];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> zz=<span class="number">0</span>;zz&lt;temp.<span class="built_in">size</span>();zz++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp[zz]==res[jj])&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193955512.png" alt="image-20210717193955512"></p>
<p>修改后，在查找是否兼容这一部分，需要通过map定位到该值所在的结点，然后往节点后的链表顺序查找，这样可能比较浪费时间。</p>
<p>牺牲空间的方法，首先开辟一个大空间res，存放所有可能的物品，每遍历一个物品，就往res中添入不可兼容的物品，之后再查找时，如果在res中，则不可兼容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(res[x]==<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            res[x] = <span class="number">1</span>;   <span class="comment">//表示不兼容  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Map[x].<span class="built_in">size</span>();j++)</span><br><span class="line">                res[Map[x][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717202436733.png" alt="image-20210717202436733"></p>
<h3 id="PAT-1150"><a href="#PAT-1150" class="headerlink" title="PAT 1150"></a>PAT 1150</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210722721.png" alt="image-20210717210722721"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210738857.png" alt="image-20210717210738857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210750029.png" alt="image-20210717210750029"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210800815.png" alt="image-20210717210800815"></p>
<p>题目大意：旅行商问题，给定一个图，并给定路径，判断该路径是否满足一下条件：</p>
<p>Ts a simple cycle 每个城市只访问一次，并且回到远点</p>
<p>Not a TS cycle 没有访问到每个城市，或者没有回到原点</p>
<p>NA not a TS cycle  路径不可达</p>
<p>TS cycle  多次访问每个城市</p>
<p>然后求距离最短的路径。</p>
<p>思路：构建邻接矩阵，一个visited数组判断是否访问过，按照路径一次模拟一遍即可，水题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> shortest = INT_MAX;  <span class="comment">//存放最短路径</span></span><br><span class="line">    <span class="type">int</span> shortestindex = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d1,d2,dist; cin&gt;&gt;d1&gt;&gt;d2&gt;&gt;dist;</span><br><span class="line">        Graph[d1][d2] = dist;</span><br><span class="line">        Graph[d2][d1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T; cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=T;kk++)&#123;</span><br><span class="line">        <span class="type">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//0 可达性  1 是否都访问过  2  是否多次访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> C;  cin&gt;&gt;C;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(C+<span class="number">1</span>)</span></span>;   <span class="comment">//路径也从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visited[path[1]] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[path[i]][path[i+<span class="number">1</span>]]==<span class="number">0</span>) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total_cost += Graph[path[i]][path[i+<span class="number">1</span>]];</span><br><span class="line">                visited[path[i]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;visited.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) flag[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//没有访问过,flag=1 Not a TS cycle</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]&gt;<span class="number">1</span>) flag[<span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//多次访问  TS cycle;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="keyword">if</span>(!flag[<span class="number">0</span>] &amp;&amp; !flag[<span class="number">1</span>] &amp;&amp; !flag[<span class="number">2</span>] &amp;&amp; path[<span class="number">1</span>]==path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>,kk);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">1</span>] || path[<span class="number">1</span>]!=path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest Dist(%d) = %d&quot;</span>,shortestindex,shortest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210659132.png" alt="image-20210717210659132"></p>
<h3 id="PAT-1151"><a href="#PAT-1151" class="headerlink" title="PAT 1151"></a>PAT 1151</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190008683.png" alt="image-20210718190008683"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190019702.png" alt="image-20210718190019702"></p>
<p>题目大意：给出中序序列和先序序列，再给出两个点，求这两个点的最近公共祖先～</p>
<p>柳神题解：不用建树～已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。中序加先序可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点，在此时并入lca算法可以确定两个结点的公共祖先～</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,<span class="type">int</span> node1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> pre_right,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,pre_left+<span class="number">1</span>,mid_position,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,mid_position+<span class="number">1</span>,pre_right,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190202986.png" alt="image-20210718190202986"></p>
<p>问题出在递归过程中变量设置太多，导致递归栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(vector&lt;int&gt; preorder,vector&lt;int&gt; inorder,int node1,</span><br><span class="line">    int node2,int pre_left,int pre_right,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>改成，将preorder,inorder设置成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void search_ancestor(int node1,int node2,int pre_left,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,pre_left+<span class="number">1</span>,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,mid_position+<span class="number">1</span>,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(node1,node2,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190952587.png" alt="image-20210718190952587"></p>
<h2 id="2021-7-24"><a href="#2021-7-24" class="headerlink" title="2021.7.24"></a>2021.7.24</h2><h3 id="PAT-1144"><a href="#PAT-1144" class="headerlink" title="PAT 1144"></a>PAT 1144</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103108325.png" alt="image-20210724103108325"></p>
<p>题目大意：给一个数串，找到数串中没有出现的最小正整数</p>
<p>思路：用一个长度为N的哈希表就可以了，因为最小整数不可能超过N，符合条件就放入，不符合条件就跳过，最后从1开始遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(N+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;=<span class="number">1</span> &amp;&amp; L[i]&lt;=N)</span><br><span class="line">            M[L[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103224067.png" alt="image-20210724103224067"></p>
<h3 id="PAT-1145"><a href="#PAT-1145" class="headerlink" title="PAT 1145"></a>PAT 1145</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724143956305.png" alt="image-20210724143956305"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144007126.png" alt="image-20210724144007126"></p>
<p>题目大意：</p>
<p>（quadratic：平方的）</p>
<p><strong>给定一个序列，用平方探测法（只用正数）解决哈希冲突，然后给出m个数字（皆为正数），如果这个数字不能够被插入就输出”X cannot be inserted.”，然后输出这m个数字的平均查找次数</strong></p>
<p>思路：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144235052.png" alt="image-20210724144235052"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//0  1  2  3  4</span></span><br><span class="line"><span class="comment">//10 6  11    4</span></span><br><span class="line"><span class="comment">//11 2次  4 1次  15 6次  2 2次</span></span><br><span class="line"><span class="comment">//11/4 = 2.8</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Msize,N,M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;Msize&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isprime</span>(Msize)) Msize++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Hash</span><span class="params">(Msize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构建哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断插入不成功？</span></span><br><span class="line">            <span class="keyword">if</span>(Hash[(a+j*j)%Msize]==<span class="number">0</span>)&#123;</span><br><span class="line">                Hash[(a+j*j)%Msize] = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==Msize) <span class="built_in">printf</span>(<span class="string">&quot;%d cannot be inserted.\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均查找次数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断找不到?</span></span><br><span class="line">            <span class="type">int</span> t = (b+j*j)%Msize;</span><br><span class="line">            <span class="keyword">if</span>(Hash[t]==b || Hash[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">        sum += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum/M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144253395.png" alt="image-20210724144253395"></p>
<h3 id="PAT-1146"><a href="#PAT-1146" class="headerlink" title="PAT 1146"></a>PAT 1146</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150143550.png" alt="image-20210724150143550"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150158871.png" alt="image-20210724150158871"></p>
<p>题目大意：判断一个序列是不是拓扑序列。</p>
<p>思路：构建邻接矩阵，计算入度，根据给出序列判断入度是否为0，然后将以该顶点为起点的边的终点的入度—1,依次判断下一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  <span class="comment">//N:定点数 M：边数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个顶点的入度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[j][i]==<span class="number">1</span>) in++;</span><br><span class="line">        &#125;</span><br><span class="line">        indegree[i] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为拓扑序列</span></span><br><span class="line">    <span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree1</span><span class="params">(indegree)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree1[seq[j]]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Graph[seq[j]][k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        indegree1[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150354679.png" alt="image-20210724150354679"></p>
<h3 id="PAT-1147"><a href="#PAT-1147" class="headerlink" title="PAT 1147"></a>PAT 1147</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153528563.png" alt="image-20210724153528563"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153541846.png" alt="image-20210724153541846"></p>
<p>题目大意：给定一个完全二叉树，要求判断是否是大顶堆或小顶堆，并给出该二叉树的后序遍历。</p>
<p>判断大顶堆或小顶堆只需要遍历整个序列，判断seq[i] 和 seq[2<em>i] 和 seq[2</em>i+1]的关系即可。</p>
<p>后序遍历采用栈进行模拟，</p>
<p>如果有左节点且左节点没被访问过，左节点入栈，</p>
<p>如果左节点被访问过且右节点没被访问过，右节点入栈</p>
<p>如果是叶子节点，且左右节点都被访问过，则出栈，visited设1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHEAP -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; seq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = seq.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">//第0个结点不用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(size+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node = S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node*<span class="number">2</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>+<span class="number">1</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>&gt;size || (node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>+<span class="number">1</span>])  <span class="comment">//访问该结点的条件 1、没有孩子结点 </span></span><br><span class="line">         || (node*<span class="number">2</span>+<span class="number">1</span>&gt;size &amp;&amp; node*<span class="number">2</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>]))&#123;   <span class="comment">//2、如果有右节点，且被访问过 3、如果没有右结点且左节点被访问过</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            visited[node] = <span class="number">1</span>;  <span class="comment">//标志该结点以访问过</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(seq[node]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)  cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_or_min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(seq[<span class="number">1</span>]&gt;seq[M]) max_or_min = MAX;</span><br><span class="line">        <span class="keyword">else</span> max_or_min = MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_or_min==MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&gt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&gt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&lt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&lt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_or_min==MAX) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN) cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==NOTHEAP) cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="built_in">postorder</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724154312977.png" alt="image-20210724154312977"></p>
<h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021.7.31"></a>2021.7.31</h2><h3 id="PAT-1140"><a href="#PAT-1140" class="headerlink" title="PAT 1140"></a>PAT 1140</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731211941856.png" alt="image-20210731211941856"></p>
<p>题目大意：</p>
<p>题意：后面一个数是前面一个数的描述，一般第一个数是d，代表0-9的任意一个数，第二 数是第一个数的描述，就是将d+d的个数。同样，第三个数是第二个数的描述，依次，例如:1   11(前一个1是第一个数，后一个1是第一个中1的个数)    12（代表前一个数中有2个1）  1121（前面一个数中有1个1，1个2，数放前，个数放后）  122111   112213  12221131  1123123111 。</p>
<p>思路：采用模拟的方法，c表示当前字符，如果遍历到的字符不是c，则输出到temp中，如果是c，则c的个数size++.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731212418772.png" alt="image-20210731212418772"></p>
<p>原因在于<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225304119.png" alt="image-20210731225304119"></p>
<p>使用&#x3D;是深拷贝，需将temp重新拷贝一份再赋值给temp</p>
<p>使用+&#x3D; 是直接在后面append。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225217330.png" alt="image-20210731225217330"></p>
<h3 id="PAT-1141"><a href="#PAT-1141" class="headerlink" title="PAT 1141"></a>PAT 1141</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225429215.png" alt="image-20210731225429215"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225444048.png" alt="image-20210731225444048"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225453525.png" alt="image-20210731225453525"></p>
<p>问题描述：给定每个考生的成绩和学校，统计该学校的总成绩并排序。</p>
<p>思路：用一个Map用于查找学校信息，便于统计学校总成绩，然后扔到vector进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total==b.total &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.total==b.total)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.total&gt;b.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].total),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231308137.png" alt="image-20210731231308137"></p>
<p>sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231840300.png" alt="image-20210731231840300"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231858291.png" alt="image-20210731231858291"></p>
<p>正确代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231804410.png" alt="image-20210731231804410"></p>
<h3 id="PAT-1142"><a href="#PAT-1142" class="headerlink" title="PAT 1142"></a>PAT 1142</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231938095-1677591493747.png" alt="image-20210731231938095"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231950482-1677591493747.png" alt="image-20210731231950482"></p>
<p>题目大意：问题描述：给定一个无向图，和一些顶点，判断这些顶点是否组成了集合（每两个顶点都相连）</p>
<p>Yes 是一个团，每两个顶点都相邻</p>
<p>Not Maximal  是一个团，但是可以再加入一个顶点，使得每两个顶点相连</p>
<p>Not a Clique  不是每两个顶点都相连。</p>
<p>思路：构造邻接矩阵，对给定序列依次判断是否是一个团，然后再尝试加入其他顶点，判断是否是最大团。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232208835-1677591493747.png" alt="image-20210731232208835"></p>
<h3 id="PAT-1143"><a href="#PAT-1143" class="headerlink" title="PAT 1143"></a>PAT 1143</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232235278.png" alt="image-20210731232235278"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232247776.png" alt="image-20210731232247776"></p>
<p>题目大意：用先序遍历的方式给出一棵排序二叉树。让你回答n个询问。<br> 找出每个询问的最近公共祖先。</p>
<p>用TreeMap存树的每个结点，第一步判断是否存在  否则not found</p>
<p>第二部查找最近的公共祖孙，这里利用二叉排序树的特点，如果n1 和 n2 一个大于根节点 一个小于根节点，则根节点必定是公共祖先，否则递归进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLCA</span><span class="params">(vector&lt;<span class="type">int</span>&gt; Tree,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = Tree[left];</span><br><span class="line">    <span class="keyword">if</span>((n1&lt;t &amp;&amp; n2&gt;t) || (n1&gt;t &amp;&amp; n2&lt;t) || (n1==t||n2==t)) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left+<span class="number">1</span>;  <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(Tree[i]&lt;t) i++;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;t &amp;&amp; n2&lt;t) <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,left+<span class="number">1</span>,i<span class="number">-1</span>,n1,n2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,i,right,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Tree</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; TreeMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;Tree[i];</span><br><span class="line">        TreeMap[Tree[i]]++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>() &amp;&amp; TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.&quot;</span>,n1,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> lca = <span class="built_in">searchLCA</span>(Tree,<span class="number">0</span>,N<span class="number">-1</span>,n1,n2);</span><br><span class="line">            <span class="keyword">if</span>(lca==n1)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n1,n2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lca==n2)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n2,n1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.&quot;</span>,n1,n2,lca);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232946850.png" alt="image-20210731232946850"></p>
<p>佬们的代码：他是直接利用先序遍历的特点，按顺序判断是否是祖先</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232910793.png" alt="image-20210731232910793"></p>
<h2 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021.8.7"></a>2021.8.7</h2><h3 id="PAT-1136"><a href="#PAT-1136" class="headerlink" title="PAT 1136"></a>PAT 1136</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112248715.png" alt="image-20210807112248715"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112302487.png" alt="image-20210807112302487"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112313001.png" alt="image-20210807112313001"></p>
<p>题目大意：一个数加它的翻转能否在10次内得到一个回文数</p>
<p>思路：模拟大数加法，并且模拟反转过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> benwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c = a[i]-<span class="string">&#x27;0&#x27;</span> + b[i]-<span class="string">&#x27;0&#x27;</span> + jinwei;</span><br><span class="line">        benwei = c%<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(benwei) + res;</span><br><span class="line">        jinwei = c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jinwei!=<span class="number">0</span>) res = <span class="built_in">to_string</span>(jinwei) + res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispalindromic</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ispalindromic</span>(a) &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s + &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        string c = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        a = <span class="built_in">add</span>(a,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Not found in 10 iterations.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s is a palindromic number.&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112447331.png" alt="image-20210807112447331"></p>
<h3 id="PAT-1137"><a href="#PAT-1137" class="headerlink" title="PAT 1137"></a>PAT 1137</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162201003.png" alt="image-20210807162201003"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162215605.png" alt="image-20210807162215605"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162226330.png" alt="image-20210807162226330"></p>
<p>题目大意：</p>
<p>判断一个学生是否有资格获得整数的条件有2个：1.学生是否能编程&gt;&#x3D;200题 2.学生的总评成绩是否&gt;&#x3D;60</p>
<p>由于题目是分开给出各项成绩，而且Id唯一，所以我们可以使用Map方便查找。最后进行判断，判断完后排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162636845.png" alt="image-20210807162636845"></p>
<p><strong>大坑</strong>：</p>
<p>题目中的-1的意思表示的是没有学生的某一项没有分数（而非分数为0！没有分数代表没来考试，而分数为0代表考试考了0分！）</p>
<p>所以mid的初值应该设为-1 而不应该设为0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162728149.png" alt="image-20210807162728149"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">-1</span>;  <span class="comment">//-1代表没有成绩，不代表0分</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;=<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162753507.png" alt="image-20210807162753507"></p>
<h3 id="PAT-1138"><a href="#PAT-1138" class="headerlink" title="PAT 1138"></a>PAT 1138</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162840383.png" alt="image-20210807162840383"></p>
<p>题目大意：给出数的前序、中序，求后序输出的第一个值</p>
<p>思路：按照前序、中序序列构造树的方法，采用递归，中间需要用到Map来查找中序序列的位置。</p>
<p>如果有左子树，后序遍历的第一个序列在左子树中寻找，否则在右子树中寻找。只有一个节点，则Return；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(preorder,inorder,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807163415544.png" alt="image-20210807163415544"></p>
<p>改进方法：函数传值的时候尽量不要把整个vector都传进去，否则会出现爆内存的情况。需要把vector设置成全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192348410.png" alt="image-20210807192348410"></p>
<h3 id="PAT-1139"><a href="#PAT-1139" class="headerlink" title="PAT 1139"></a>PAT 1139</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192751253.png" alt="image-20210807192751253"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192805065.png" alt="image-20210807192805065"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192815264.png" alt="image-20210807192815264"></p>
<p><strong>题意</strong>：如果一个男孩子A对一个女孩子B有好感，那么他需要跟他的好哥们C说，然后C再去找B的闺蜜，让闺蜜给B带话。</p>
<p>思路就是从A的同性朋友中找出C，再从B的同性朋友中找出D，然后C，D是好朋友的话，这个话就带到了。</p>
<p>但是输出那里规定A，B可以是同性，</p>
<p>If they are of the same gender, then both friends must be in the same gender as theirs.</p>
<p>emmmmmmm，这道题gay里gay气的。</p>
<p><strong>思路</strong>：Person结构体存储自己的Id,还有男朋友，女朋友（其实也可以一起存储），然后用一个Map&lt;id,Person&gt;方便使用Id找到相对应的朋友。</p>
<p>然后给定两个朋友A，朋友B，根据Map找到对应的A的男朋友或女朋友，and 找到B的男朋友或女朋友，最后写一个函数判断这两人之间是否存在关系，然后将存在关系的朋友排好序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; boyfriend;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; girlfriend;</span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfriend</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    Person p = Map[id];</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.boyfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.girlfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(id2&gt;<span class="number">0</span>) Map[id1].boyfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">else</span> Map[id1].girlfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span>) Map[id2].boyfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        <span class="keyword">else</span> Map[id2].girlfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807193412853.png" alt="image-20210807193412853"></p>
<p>参考了以下柳神的代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807200903777.png" alt="image-20210807200903777"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a != y.a ? x.a &lt; y.a : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> asa = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(a)),asb = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(b));</span><br><span class="line">        <span class="comment">// A/B ID 作为下标记录同性边数据，arr记录关系</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v[asa].<span class="built_in">push_back</span>(asb);</span><br><span class="line">            v[asb].<span class="built_in">push_back</span>(asa);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[asa * <span class="number">10000</span> + asb] = arr[asb * <span class="number">10000</span> + asa] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[<span class="built_in">abs</span>(c)].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v[<span class="built_in">abs</span>(d)].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// A在寻找同性朋友时，需要避免找到他想要的伴侣B，所以当前朋友就是B或B的同性朋友就是A时舍弃该结果</span></span><br><span class="line">                <span class="keyword">if</span> (v[<span class="built_in">abs</span>(c)][j] == <span class="built_in">abs</span>(d) || <span class="built_in">abs</span>(c) == v[<span class="built_in">abs</span>(d)][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// A/B，先找A的所有同性朋友C，再找B的所有同性朋友D，当C和D两人是朋友的时候则可以输出C和D</span></span><br><span class="line">                <span class="keyword">if</span> (arr[v[<span class="built_in">abs</span>(c)][j] * <span class="number">10000</span> + v[<span class="built_in">abs</span>(d)][k]] == <span class="literal">true</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node&#123;v[<span class="built_in">abs</span>(c)][j], v[<span class="built_in">abs</span>(d)][k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(ans.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进后</strong>，重新捋一下<strong>思路</strong>：</p>
<p><font color="red">重点!!!</font></p>
<ul>
<li><p>题目简化后为A寻找同性伴侣B，D寻找同性伴侣A，然后A和B是朋友，则添加到结果中。</p>
</li>
<li><p>由于数据错综复杂，所以不适合采用邻接矩阵，我们只需要记录他们之间的关系即可，数据结构可以直接采用 map&lt;pair&lt;int,int&gt;,bool&gt;来存储两者间的关系，其中make_pair&lt;int,int&gt;可以使用哈希映射，比如make_pair&lt;a,b&gt;可以等价为 a*10000+b,同时不会导致哈希冲突。</p>
</li>
<li><p>如何寻找同性朋友呢，可以使用结构体Person, Person下有一个vector用于存储同性朋友，为了快速找到 id 对应的结构体Person，我们可以用map将id直接映射到Person中。</p>
</li>
<li><p>如果用Int接收朋友，会出现+0000和-0000的情况，不能判断是否为同性朋友，题目说we use a negative sign to represent girls. 用一个符号代表女性朋友，我们可以先用string接收，然后stoi(s)转成Int形，用s.length是否相同来判断是否为同性朋友。  (对应2、3个测试点)</p>
</li>
<li><p>输出的数据必须从小到大排序</p>
</li>
<li><p>A在寻找同性朋友时应该避免找到他的同性伴侣D，坑点（对应4、5、6测试点）</p>
</li>
<li><p>输出要保留4位小数  %04d  对应（2、3测试点）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gayfriend;  <span class="comment">//同性朋友</span></span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;pair&lt;int,int&gt;,bool&gt; isfriend;  key不能是pair类型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; isfriend;   <span class="comment">//可以建立Int,Int的哈希映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string sd1,sd2;  cin&gt;&gt;sd1&gt;&gt;sd2;</span><br><span class="line">        <span class="type">int</span> id1 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd1)),id2 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建朋友关系</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id1,id2)]=true;</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id2,id1)]=true;</span></span><br><span class="line">        isfriend[id1*<span class="number">10000</span>+id2]=<span class="literal">true</span>;</span><br><span class="line">        isfriend[id2*<span class="number">10000</span>+id1]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是同性朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(sd1.<span class="built_in">length</span>()==sd2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            Map[id1].gayfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">            Map[id2].gayfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        id1 = <span class="built_in">abs</span>(id1); id2 = <span class="built_in">abs</span>(id2);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        Person p1 = Map[id1];</span><br><span class="line">        Person p2 = Map[id2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p1.gayfriend.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p2.gayfriend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> fri1 = p1.gayfriend[i];</span><br><span class="line">                <span class="type">int</span> fri2 = p2.gayfriend[j];</span><br><span class="line">                <span class="keyword">if</span>(fri1==id2 || fri2==id1) <span class="keyword">continue</span>;  <span class="comment">// A在寻找同性朋友时，需要避免直接找到他想要的伴侣B</span></span><br><span class="line">                <span class="keyword">if</span>(isfriend[fri1*<span class="number">10000</span>+fri2] &amp;&amp; fri1!=fri2)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(fri1,fri2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807205353302.png" alt="image-20210807205353302"></p>
<h2 id="2021-8-14"><a href="#2021-8-14" class="headerlink" title="2021.8.14"></a>2021.8.14</h2><h3 id="PAT-1132"><a href="#PAT-1132" class="headerlink" title="PAT 1132"></a>PAT 1132</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125130500.png" alt="image-20210814125130500"></p>
<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20210814125141745.png" alt="image-20210814125141745" style="zoom:150%;">

<p>题目大意：<strong>一个偶数个位的正整数num，把它从中间分成左右两个整数a、b，问num能不能被a和b的乘积整除，能的话输出yes，不能的话输出no</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125236517.png" alt="image-20210814125236517"></p>
<p>因为没有判断c1*c2能不能是0，正确的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>((c1*c2) &amp;&amp;c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125323306.png" alt="image-20210814125323306"></p>
<h3 id="PAT-1133"><a href="#PAT-1133" class="headerlink" title="PAT 1133"></a>PAT 1133</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125357711.png" alt="image-20210814125357711"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125410450.png" alt="image-20210814125410450"></p>
<p>题目大意：给出一个链表，将链表分为三部分，第一部分小于0的数，第二部分小于&#x3D;K的数，第三部分，大于K的数。</p>
<p>思路：数据结构，一个结构体，存放地址address,数number，下一跳nextaddress，再采用map使得可以方便地根据address查找结点所在的位置，然后获取下一跳，以此类推。最后通过三次查找把合适的部分取出来放到vector中，这样就排好序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string address;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string nextaddress;</span><br><span class="line">    <span class="type">bool</span> isvisited = <span class="literal">false</span>;</span><br><span class="line">&#125;node;</span><br><span class="line">unordered_map&lt;string,node&gt; M;</span><br><span class="line">vector&lt;node&gt; res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string fadd;  cin&gt;&gt;fadd;</span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        node n; </span><br><span class="line">        cin&gt;&gt;n.address&gt;&gt;n.number&gt;&gt;n.nextaddress;</span><br><span class="line">        M[n.address] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    string nextaddress = fadd;</span><br><span class="line">    <span class="comment">//第一遍寻找负数</span></span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一遍寻找小于K的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;=K) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三遍加入剩余的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=res.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number,res[i+<span class="number">1</span>].address.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d -1&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125702974.png" alt="image-20210814125702974"></p>
<h3 id="PAT-1134"><a href="#PAT-1134" class="headerlink" title="PAT 1134"></a>PAT 1134</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125742396.png" alt="image-20210814125742396"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125753908.png" alt="image-20210814125753908"></p>
<p>题目大意：n个顶点和m条边的图，分别给出m条边的两端顶点，然后对其进行k次查询，每次查询输入一个顶点集合，要求判断这个顶点集合是否能完成顶点覆盖，即图中的每一条边都至少有一个顶点在这个集合中。</p>
<p>思路：很简单，将顶点集合用map存，然后遍历边，判断是否有一个顶点在map中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edgeset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        edgeset.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e1,e2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> c;  cin&gt;&gt;c; Map[c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;edgeset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> e1 = edgeset[j].first, e2 = edgeset[j].second;</span><br><span class="line">            <span class="keyword">if</span>(Map.<span class="built_in">find</span>(e1)==Map.<span class="built_in">end</span>() &amp;&amp; Map.<span class="built_in">find</span>(e2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125924885.png" alt="image-20210814125924885"></p>
<h3 id="PAT-1135"><a href="#PAT-1135" class="headerlink" title="PAT 1135"></a>PAT 1135</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145832177.png" alt="image-20210814145832177"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145853993.png" alt="image-20210814145853993"></p>
<p><strong>题目大意</strong>：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</p>
<p>1、非红即黑</p>
<p>2、根结点是否为黑色       </p>
<p>3、将NULL看成1个叶子节点，为黑<code>black</code>色</p>
<p>4、如果1个结点是红色，它的孩子节点是否都为黑色       </p>
<p>5、从任意结点到叶子结点的路径中，黑色结点的个数是否相同       </p>
<p><strong>考场错误思路一</strong>：由于是二叉排序树加上先序序列，可以递归构造二叉树。然后dfs的过程中判断第4个条件，并统计第5个条件（黑色结点个数是否相同）</p>
<p>一开始理解错了，从根节点到叶子结点的路径中，黑色结点个数相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; black_num;   <span class="comment">//统计路径上的黑色结点的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,<span class="type">int</span> black)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&gt;<span class="number">0</span>) black++;   <span class="comment">//黑色结点+1</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        black_num.<span class="built_in">push_back</span>(black);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    black_num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="type">bool</span> dfs = <span class="built_in">DFS</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfs==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;black_num.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(black_num[i]!=black_num[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814150547067.png" alt="image-20210814150547067"></p>
<p>第3个结点段错误，建树过程中存在一些问题。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814154047150.png" alt="image-20210814154047150"></p>
<p><strong>考场错误思路二</strong>：为了使得每一层到叶子结点的黑色结点数相同，我私自认为</p>
<p>&#x2F;&#x2F;判断是否为红黑树</p>
<p>&#x2F;&#x2F;1、红黑树一定是一棵平衡二叉树</p>
<p>&#x2F;&#x2F;2、红黑树一定层次分明,一层黑一层白</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lefthigh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> righhigh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lefthigh,righhigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh-rh&gt;<span class="number">1</span> || rh-lh&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">levelsearch</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> black = <span class="number">1</span>;  <span class="comment">//第一层是black</span></span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> lsize = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsize;i++)&#123;</span><br><span class="line">            TreeNode* p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val*black&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        black*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">levelsearch</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然是错误的，所以红黑树不是平衡二叉树</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155039169.png" alt="image-20210814155039169"></p>
<p><strong>正确思路</strong>：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155458247.png" alt="image-20210814155458247"></p>
<p>这里是判断平衡二叉树的变体，算高度时只统计黑色结点的个数</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155547670.png" alt="image-20210814155547670"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? <span class="built_in">max</span>(l, r) + <span class="number">1</span> : <span class="built_in">max</span>(l, r);</span><br><span class="line">    <span class="comment">// return 1+max(l,r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh!=rh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">DFS</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155614848.png" alt="image-20210814155614848"></p>
<h2 id="2021-8-20"><a href="#2021-8-20" class="headerlink" title="2021.8.20"></a>2021.8.20</h2><h3 id="PAT-1128"><a href="#PAT-1128" class="headerlink" title="PAT 1128"></a>PAT 1128</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184132575.png" alt="image-20210820184132575"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184145438.png" alt="image-20210820184145438"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184157300.png" alt="image-20210820184157300"></p>
<p>判断同一行同一列对角线上有无N皇后，同一列题目已经保证了，同一行用map保证，对角线判断j-i&#x3D;&#x3D;abs(row[j]-row[i] ） O(n*n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> K;   cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//第一个元素不用，下标表示col，数值表示row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;row[i];</span><br><span class="line">            <span class="keyword">if</span>(map[row[i]]==<span class="number">1</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> map[row[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;row.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;row.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="built_in">abs</span>(row[j]-row[i])) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184442560.png" alt="image-20210820184442560"></p>
<h3 id="PAT-1129"><a href="#PAT-1129" class="headerlink" title="PAT 1129"></a>PAT 1129</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184523153.png" alt="image-20210820184523153"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184533785.png" alt="image-20210820184533785"></p>
<p><strong>题目大意</strong>：给定一个序列，求目前出现次数最多的k个数字。如果数字出现次数相同，升序排列。</p>
<p><strong>解题思路</strong>：类似LRU，寻找出现次数最多的三个。</p>
<p>数据结构的设计，一个vector&lt;pair&lt;int,int&gt;&gt; KWindow;   存放出现次数最多的K个数字,pair-&gt;first代表数字，pair-&gt;second代表出现的次数，每加入一个数字，我们就要判断是否要更新KWindow.采用unordered_map存放这个数字在目前出现了几次。</p>
<p>判断是否需要更新KWindow? </p>
<p>情况一：新加入的数字在KWindow中，直接在KWindow中更新就好了，然后排序。</p>
<p>情况二：新加入的数字不在KWindow中，而且KWindow还没满，直接加入，然后排序。</p>
<p>情况三：新加入的数字不在KWindow中，而且KWindow满了，判断是否需要替换，由于之前已经排好序了，只要和最后一个比较，如果次数&lt;最后一个，或者次数相同，数字小于最后一个，则替换掉最后一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;    <span class="comment">//统计在j之前出现的次数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; KWindow;  <span class="comment">//存放出现次数最多的K个数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">finda</span><span class="params">(<span class="type">int</span> target,<span class="type">int</span> fre)</span></span>&#123;  <span class="comment">//查找当前数字是不是在KWindow中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(KWindow[i].first==target)&#123;</span><br><span class="line">            KWindow[i].second = fre;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Min = <span class="number">0</span>;  <span class="comment">//当前最小的次数</span></span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp; cin&gt;&gt;temp;</span><br><span class="line">        input.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Map[input[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">finda</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]))&#123;  <span class="comment">//本来就在窗口里面，不用处理</span></span><br><span class="line">            <span class="keyword">if</span>(KWindow.<span class="built_in">size</span>()&lt;K)&#123;  <span class="comment">//窗口还有容量</span></span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]&gt;Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]==Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].first&gt;input[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                    KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(KWindow.<span class="built_in">begin</span>(),KWindow.<span class="built_in">end</span>(),cmp);  <span class="comment">//将窗口排好序</span></span><br><span class="line">        Min = KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;KWindow[i].first;</span><br><span class="line">            <span class="keyword">if</span>(i!=KWindow.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185242648.png" alt="image-20210820185242648"></p>
<h3 id="PAT-1130"><a href="#PAT-1130" class="headerlink" title="PAT 1130"></a>PAT 1130</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185308171.png" alt="image-20210820185308171"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185322504.png" alt="image-20210820185322504"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185334088.png" alt="image-20210820185334088"></p>
<p><strong>题目大意</strong>：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级</p>
<p><strong>解题思路</strong>：给定的输入建树的过程我感觉比较复杂。在输入的第一遍建立TreeNode，然后将string映射到TreeNode中，但这样会有一个问题，就是string的值可能相同，所以我给每个输入结点设置了一个id，第二遍结点全部都创建好了，我们就可以根据左子树所在的行数，和右子树所在的行数 所 映射到的结点建立连接。  最后就是寻找根节点的过程，用set就可以了，把有父节点的加入set，最后不在set的那个就是根节点。</p>
<p>后面就是中序遍历，很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; Set;  <span class="comment">//用来寻找没有前驱的结点,寻找根节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; MM;  <span class="comment">//建立id到TreeNode的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">input</span></span><br><span class="line">&#123;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">&#125;input;</span><br><span class="line">vector&lt;input&gt; I;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        TreeNode* r = MM[I[i].id];</span><br><span class="line">        <span class="keyword">if</span>(I[i].left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* left = MM[I[I[i].left].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].left].id);</span><br><span class="line">            r-&gt;left = left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(I[i].right!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* right = MM[I[I[i].right].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].right].id);</span><br><span class="line">            r-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(I[i].id)==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> MM[I[i].id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)  <span class="comment">//如果不是叶子结点则加括号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    I.<span class="built_in">push_back</span>(input&#123;&#125;);  <span class="comment">//第一个数不用</span></span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        input ii;  cin&gt;&gt;ii.val&gt;&gt;ii.left&gt;&gt;ii.right;</span><br><span class="line">        ii.id=i;</span><br><span class="line">        I.<span class="built_in">push_back</span>(ii);</span><br><span class="line">        TreeNode* r = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ii.val);</span><br><span class="line">        MM[ii.id] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185818116.png" alt="image-20210820185818116"></p>
<h3 id="PAT-1131"><a href="#PAT-1131" class="headerlink" title="PAT 1131"></a>PAT 1131</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181205412.png" alt="image-20210820181205412"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181223417.png" alt="image-20210820181223417"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181241538.png" alt="image-20210820181241538"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181255465.png" alt="image-20210820181255465"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181307918.png" alt="image-20210820181307918"></p>
<p><strong>题目大意</strong>：</p>
<p>给出各地铁线所经过的站点，构成一张地铁交通图。再给出起点和终点，让你找出最快的一条路径，<strong>如果路径不唯一就选择中转次数最少的那一条</strong>。 </p>
<p><strong>解题思路</strong>：</p>
<p>我没有考虑到这一点，所以2，4测试点没有过。</p>
<p>1、本来想用Floyd算法，但是发线每条边权值都为1，所以用BFS搜索即可。</p>
<p>2、构造邻接矩阵有一个问题，就是要解决0000四位整数映射问题，不然开辟10000*10000个空间未免太大了，我的做法是读入是写到set中，然后遍历set建立string-int的映射，还有int-string的映射。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181854943.png" alt="image-20210820181854943"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181916383.png" alt="image-20210820181916383"></p>
<p>3、建图，采用邻接矩阵，这里存储的是无向图，因此根据线路构造的时候要存储两次，邻接矩阵存储的边值代表线路（几号线）而不是代价。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182051111.png" alt="image-20210820182051111"></p>
<p>4、BFS寻找最短路径，用path来存储路径，path[i] &#x3D; j表示，从j-&gt;i，方便往回寻找</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182130533.png" alt="image-20210820182130533"></p>
<p>5、找到后需要输出路径，顺着path往回寻找，将结果放到path_中。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182243168.png" alt="image-20210820182243168"></p>
<p>6、最后在把path带入到Graph中构造出所要的线路结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182317542.png" alt="image-20210820182317542"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; input;   <span class="comment">//input[i]表示i+1号线的站点</span></span><br><span class="line">unordered_set&lt;string&gt; Set;  <span class="comment">//实现站点映射</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; MapStoI; <span class="comment">//相互映射</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,string&gt; MapItoS; <span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;   <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> kkk=<span class="number">0</span>;  <span class="comment">//结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(string start,string destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> begin = MapStoI[start];</span><br><span class="line">    <span class="type">int</span> end = MapStoI[destination];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(kkk,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(kkk,<span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(begin);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   <span class="comment">//BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kkk;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span> &amp;&amp; Graph[t][i])&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">//访问过</span></span><br><span class="line">                path[i] = t;  <span class="comment">//记录从t-i的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="type">int</span> p = end;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path_;  path_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(p!=begin)&#123;</span><br><span class="line">        <span class="type">int</span> temp = path[p];</span><br><span class="line">        path_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;path_.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(path_.<span class="built_in">begin</span>(),path_.<span class="built_in">end</span>());  <span class="comment">//反转</span></span><br><span class="line">    <span class="type">int</span> bbbb = path_[<span class="number">0</span>];  <span class="type">int</span> eeee = path_[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> xianlu = Graph[path_[<span class="number">0</span>]][path_[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[path_[i]][path_[i<span class="number">-1</span>]]==xianlu) eeee = path_[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[eeee].<span class="built_in">c_str</span>());</span><br><span class="line">            xianlu = Graph[path_[i]][path_[i<span class="number">-1</span>]];</span><br><span class="line">            bbbb = eeee;</span><br><span class="line">            eeee = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[end].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph.<span class="built_in">resize</span>(kkk,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(kkk,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;input[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            Graph[MapStoI[input[i][j<span class="number">-1</span>]]][MapStoI[input[i][j]]] = i+<span class="number">1</span>;  <span class="comment">//后面的数字代表几号线 ,0 表示不连通</span></span><br><span class="line">            Graph[MapStoI[input[i][j]]][MapStoI[input[i][j<span class="number">-1</span>]]] = i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="comment">//1  处理输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">C</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;C[j];</span><br><span class="line">            Set.<span class="built_in">insert</span>(C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        input.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 站点映射</span></span><br><span class="line">    unordered_set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Set.<span class="built_in">begin</span>();iter!=Set.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        MapItoS[kkk] = *iter;</span><br><span class="line">        MapStoI[*iter]=kkk++;</span><br><span class="line">    &#125;<span class="comment">//映射完后共有Kkk个结点，从0..kkk-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 建图</span></span><br><span class="line">    <span class="built_in">BuildGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 广度优先搜索寻找最短路径</span></span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        string start,end; cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182348064.png" alt="image-20210820182348064"></p>
<p><strong>答案正解</strong>：</p>
<p>1、使用邻接表存储     2、使用line的键为a*10000+b,建立边到线路的映射      3、dfs暴力深搜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[<span class="number">10000</span>],minCnt,minTransfer;  <span class="comment">//是否访问过 最小代价  最小中转次数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10000</span>);  <span class="comment">//采用邻接表存储</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path,tempPath;<span class="comment">//路径vector</span></span><br><span class="line"><span class="type">int</span> start,end1;<span class="comment">//起点 终点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; line;  <span class="comment">//结点到路线的映射</span></span><br><span class="line"><span class="comment">/*unordered_map&lt;int,int&gt;line存储两个结点的边所属的路线</span></span><br><span class="line"><span class="comment">假设边两端为a到b，line的键为a*10000+b,值为这条边所属的路线*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transferCnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//传入临时路径，传出中转站个数</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">-1</span>,preLine=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]] != preLine) </span><br><span class="line">			cnt++;<span class="comment">//换乘数cnt+1</span></span><br><span class="line">		preLine=line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;<span class="comment">//输出换乘数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> cnt)</span></span>&#123; <span class="comment">//cnt为换乘数</span></span><br><span class="line">    <span class="comment">//搜索到路径，需要更新</span></span><br><span class="line">	<span class="keyword">if</span>(node==end1 &amp;&amp; (cnt&lt;minCnt || (cnt ==minCnt&amp;&amp;<span class="built_in">transferCnt</span>(tempPath) &lt;minTransfer))) &#123;</span><br><span class="line">		minCnt=cnt;<span class="comment">//更新cnt</span></span><br><span class="line">		minTransfer=<span class="built_in">transferCnt</span>(tempPath);<span class="comment">//更新最小换乘次数</span></span><br><span class="line">		path=tempPath;<span class="comment">//更新路径vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node == end1) <span class="keyword">return</span>;<span class="comment">//搜索到，但不需要更新</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[node].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//dfs寻找路径</span></span><br><span class="line">		<span class="keyword">if</span>(visit[v[node][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">			visit[v[node][i]]=<span class="number">1</span>;<span class="comment">//加锁</span></span><br><span class="line">			tempPath.<span class="built_in">push_back</span>(v[node][i]);</span><br><span class="line">			<span class="built_in">dfs</span>( v[node][i] ,cnt+<span class="number">1</span>); <span class="comment">//cnt+1，进入下一层dfs</span></span><br><span class="line">			visit[v[node][i] ]=<span class="number">0</span>;<span class="comment">//解锁  类似回溯，只对这一层dfs有效</span></span><br><span class="line">			tempPath.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	<span class="type">int</span> n,m,k,pre,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//地铁路线数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;pre);<span class="comment">//pre为m线路的首站</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;<span class="comment">//for循环剩下的m-1个站</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">			v[pre].<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="comment">//首站为pre的线路(vector里)加上temp站</span></span><br><span class="line">			v[temp].<span class="built_in">push_back</span>(pre);</span><br><span class="line">			<span class="comment">//temp站的vector里加入首站(pre)</span></span><br><span class="line">			line[pre*<span class="number">10000</span>+temp]=line[temp*<span class="number">10000</span>+pre]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//pre到temp的线路=temp到pre的线路+1</span></span><br><span class="line">			pre=temp;<span class="comment">//首站为temp</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);<span class="comment">//k次查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;end1);</span><br><span class="line">		<span class="comment">//查询start站到end1站</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//minCnt为最小换乘数，minTransfer为换乘站</span></span><br><span class="line">		minCnt=<span class="number">99999</span>,minTransfer=<span class="number">99999</span>;<span class="comment">//初始化</span></span><br><span class="line">		tempPath.<span class="built_in">clear</span>();</span><br><span class="line">		tempPath.<span class="built_in">push_back</span>(start);<span class="comment">//把start压入临时路径vector</span></span><br><span class="line">		visit[start]=<span class="number">1</span>; <span class="comment">//加锁</span></span><br><span class="line">		<span class="built_in">dfs</span>(start,<span class="number">0</span>); <span class="comment">//递归DFS！！！！！！！！！</span></span><br><span class="line">		visit[start]=<span class="number">0</span>; <span class="comment">//解锁</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//以下为output</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minCnt);<span class="comment">//起点&amp;终点之间的min站数</span></span><br><span class="line">		<span class="type">int</span> preLine=<span class="number">0</span>,preTransfer=start;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;path.<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]] != preLine)&#123;</span><br><span class="line">				<span class="keyword">if</span>(preLine != <span class="number">0</span>) <span class="comment">//每当line和preline不等则输出这句话</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>,</span><br><span class="line">					preLine,preTransfer,path[j<span class="number">-1</span>] );</span><br><span class="line">				preLine=line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]];<span class="comment">//更新上一条线路号</span></span><br><span class="line">				preTransfer = path[j<span class="number">-1</span>];<span class="comment">//更新上一个换乘站</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, </span><br><span class="line">				preLine,preTransfer,end1);<span class="comment">//输出最后一小截线路</span></span><br><span class="line">				<span class="comment">//preLine路线 从preTransfer站到end1站</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820183834493.png" alt="image-20210820183834493"></p>
<h2 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h2><p>1h40min搞定  98分</p>
<h3 id="PAT-1124"><a href="#PAT-1124" class="headerlink" title="PAT 1124"></a>PAT 1124</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105622634.png" alt="image-20210829105622634"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105636286.png" alt="image-20210829105636286"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105648351.png" alt="image-20210829105648351"></p>
<p><strong>题目大意</strong>：明PAT考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔N个人就发出一个红包。请你编写程序帮助他确定中奖名单。注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出“Keep going…”</p>
<p><strong>思路</strong>：只要读懂题目，没有任何头脑的题，一个while循环，加一个set判断重复轻松搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> M,N,S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;S;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">L</span><span class="params">(M+<span class="number">1</span>,<span class="string">&quot;&quot;</span>)</span></span>; </span><br><span class="line">    set&lt;string&gt; Set;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = S;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(L[cur])==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(L[cur]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(L[cur]);</span><br><span class="line">            cur += N;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Keep going...&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105856839.png" alt="image-20210829105856839"></p>
<h3 id="PAT-1125"><a href="#PAT-1125" class="headerlink" title="PAT 1125"></a>PAT 1125</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105926511.png" alt="image-20210829105926511"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105937843.png" alt="image-20210829105937843"></p>
<p>题目大意：　绳子每次打结长度都会减小到原来的一半，那么打结的顺序会影响到最终的长度。求最终长度不超过的数。</p>
<p>刚开始都没太懂题目的意思…最后想想应该是排序+模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = <span class="built_in">double</span>(possible)/<span class="number">2</span> + <span class="built_in">double</span>(Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">    <span class="comment">// printf(&quot;%.0f&quot;,possible);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110128163.png" alt="image-20210829110128163"></p>
<p>注意：只需排序一次，觉得要每次有新绳子就要排序一下，比你小的两个数的平均数肯定也是最小的呀！</p>
<p>测试点1是只有一段绳子，开始的两段绳子要特殊处理，总长度初值应该是最小绳子长度，而不是0</p>
<p>稍加修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = Input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = (possible+Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110627305.png" alt="image-20210829110627305"></p>
<h3 id="PAT-1126"><a href="#PAT-1126" class="headerlink" title="PAT 1126"></a>PAT 1126</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110921087.png" alt="image-20210829110921087"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110935002.png" alt="image-20210829110935002"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110945243.png" alt="image-20210829110945243"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110956289.png" alt="image-20210829110956289"></p>
<p>题目大意：</p>
<p>对于无向图来说：</p>
<ol>
<li>是欧拉图，连通且所有节点的度为偶数</li>
<li>是半欧拉图，连通且只有两个节点的度为奇数</li>
</ol>
<p>转化为统计图的度，然后判断几个节点的度是奇数，如果仅仅只是这样简单处理测试点3过不去，后向仔细看题看到了<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111134310.png" alt="image-20210829111134310"></p>
<p>需要是连通图才可以。</p>
<p>由于懒得构造邻接矩阵再进行遍历，这里使用并查集来判断是不是完全连通图、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *parents;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> total)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;total = total;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="type">int</span>[total+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">find</span>(node1);</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">find</span>(node2);</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;</span><br><span class="line">            parents[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents[node]!=node)&#123;</span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(node1)==<span class="built_in">find</span>(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEurn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isConnected</span>(i,i+<span class="number">1</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    UnionFind* uf = <span class="keyword">new</span> <span class="built_in">UnionFind</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        degree[n1]++; degree[n2]++;</span><br><span class="line">        uf-&gt;<span class="built_in">Union</span>(n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==N) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">if</span>(degree[i]%<span class="number">2</span>) oddnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uf-&gt;<span class="built_in">isEurn</span>()==<span class="literal">false</span>) &#123;cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(oddnum==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oddnum==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Semi-Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111235971.png" alt="image-20210829111235971"></p>
<h3 id="PAT-1127"><a href="#PAT-1127" class="headerlink" title="PAT 1127"></a>PAT 1127</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111310015.png" alt="image-20210829111310015"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111320873.png" alt="image-20210829111320873"></p>
<p><strong>题目大意</strong>：给定中序和后序序列，建立一棵树，然后对这棵树进行Z型层序遍历。</p>
<p><strong>思路</strong>：就是在层序遍历的时候需要把层数分出来，然后设置一个flag，需要的时候把序列翻转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorder;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> inleft,<span class="type">int</span> inright,<span class="type">int</span> postleft,<span class="type">int</span> postright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inleft&gt;inright) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;postright&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> curnode = postorder[postright];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(curnode);</span><br><span class="line">    <span class="type">int</span> mid = M[curnode];</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(inleft,mid<span class="number">-1</span>,postleft,postleft+mid<span class="number">-1</span>-inleft);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(mid+<span class="number">1</span>,inright,postleft+mid<span class="number">-1</span>-inleft+<span class="number">1</span>,postright<span class="number">-1</span>);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> yinzi = <span class="number">-1</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(yinzi==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        yinzi *= <span class="number">-1</span>;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; inorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">        M[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; postorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ZigZag</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111516703.png" alt="image-20210829111516703"></p>
<h2 id="2021-9-5"><a href="#2021-9-5" class="headerlink" title="2021.9.5"></a>2021.9.5</h2><h3 id="PAT-1120"><a href="#PAT-1120" class="headerlink" title="PAT 1120"></a>PAT 1120</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154114163.png" alt="image-20210905154114163"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154125395.png" alt="image-20210905154125395"></p>
<p>题意：统计数的各位数字之和，并升序输出</p>
<p>用set啥的就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:15-8:25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            count += s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[count]++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154408271.png" alt="image-20210905154408271"></p>
<h3 id="PAT-1121"><a href="#PAT-1121" class="headerlink" title="PAT 1121"></a>PAT 1121</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154431389.png" alt="image-20210905154431389"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154440477.png" alt="image-20210905154440477"></p>
<p>题目大意：给N对夫妻编号，再给M个派对里的参与人的编号，输出单身的人的编号（包括夫妻没全部到场的也算单身）</p>
<p>用map统计夫妻配对的情况，再用一个map[10000]统计到场情况，最后一一排除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154613535.png" alt="image-20210905154613535"></p>
<p>改用set存储M个人的信息，就可以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">insert</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=res.<span class="built_in">begin</span>();it!=res.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it!=res.<span class="built_in">begin</span>())<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155315203.png" alt="image-20210905155315203"></p>
<h3 id="PAT-1122"><a href="#PAT-1122" class="headerlink" title="PAT 1122"></a>PAT 1122</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155357857.png" alt="image-20210905155357857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155408391.png" alt="image-20210905155408391"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155419998.png" alt="image-20210905155419998"></p>
<p>判断是否是哈密顿回路，随便写写就AC了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8:40-9:00</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E; cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        graph[e1][e2]=<span class="number">1</span>; graph[e2][e1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Input[i];</span><br><span class="line">        <span class="keyword">if</span>(Input.<span class="built_in">size</span>()!=V+<span class="number">1</span> || Input[<span class="number">0</span>]!=Input[V])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[Input[j]][Input[j+<span class="number">1</span>]]==<span class="number">1</span>)&#123;</span><br><span class="line">                Set.<span class="built_in">insert</span>(Input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==V) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155456226.png" alt="image-20210905155456226"></p>
<h3 id="PAT-1123"><a href="#PAT-1123" class="headerlink" title="PAT 1123"></a>PAT 1123</h3>]]></content>
      <tags>
        <tag>算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubAction+Hexo搭建个人博客</title>
    <url>/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="GithubAction-Hexo搭建个人博客"><a href="#GithubAction-Hexo搭建个人博客" class="headerlink" title="GithubAction+Hexo搭建个人博客"></a>GithubAction+Hexo搭建个人博客</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信很多小伙伴们都在使用 Hexo + Github Page 的方式，先在本地生成自己博客的静态页面，然后再推送到 Github Page 来实现页面的更新。Github 近些年推出了 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a>，这是一个非常强大的 Workflow 自动化工作流，它可以帮助我们完成很多自动化部署任务。今天就来利用 <a href="https://docs.github.com/en/actions/learn-github-actions">Actions</a> 自动化部署 Hexo 到 Github Page。</p>
<p>本来想使用 Travis CI 自动部署 Hexo 博客，一个私人仓库用于备份博客源码，另一个公开仓库用于托管静态页面，但是最近将修改的文章推送到私人仓库时没有触发 Travis CI 的工作流， Travis CI持续集成部署麻烦，而且还需付费，所以考虑了GIthub Action这种简单免费的部署方式。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>Node.JS</li>
<li>Git</li>
</ul>
<h3 id="Hexo本地博客搭建"><a href="#Hexo本地博客搭建" class="headerlink" title="Hexo本地博客搭建"></a>Hexo本地博客搭建</h3><h4 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h4><p>首先全局安装Hexo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Hexo</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，创建一个project文件夹，然后在该文件夹下初始化，（下面所有命令都是在该文件夹里执行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化 Hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>创建文章命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo new &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会发现在source&#x2F;_post文件夹里出现了”文章名字”.md的文件，Hexo采用markdown编辑。</p>
<p>在本地启动文章，就可以在<a href="http://localhost:4000/">http://localhost:4000/</a> 访问该博客了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo s   # 本地服务启动server</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228215744193.png" alt="image-20230228215744193"></p>
<p>Hexo常用的配置以及目录结构</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228220622909.png" alt="image-20230228220622909"></p>
<p>source&#x2F;_post用于存放用户文章 , _config.yml用于存放配置文件</p>
<h4 id="一些配置修改"><a href="#一些配置修改" class="headerlink" title="一些配置修改"></a>一些配置修改</h4><p>主题配置，在Hexo的官方网站上有许多可以选择的样式 <a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p>
<p>选择一个主题，按照主题里面提示的方法进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在Hexo目录下Clone这个主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"># 修改 Hexo 根目錄下的 _config.yml，把主題改為butterfly</span><br><span class="line">theme: butterfly</span><br><span class="line"></span><br><span class="line"># 安裝插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>





<p>在博客搭建完成之后会发现图片无法显示，</p>
<p>安装一个图片显示的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml的配置文件，然后把 _config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。将图片存放在这个文件夹里引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder = true</span><br></pre></td></tr></table></figure>





<h3 id="Hexo博客发布"><a href="#Hexo博客发布" class="headerlink" title="Hexo博客发布"></a>Hexo博客发布</h3><p>在github下创建一个 linli1724647576.github.io 的仓库，目前github采用的令牌代替密码，所以需要在 devoloper setting的设置里new 一个 Tokens，勾上所有的权限。</p>
<p><img src="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230228221853162.png" alt="image-20230228221853162"></p>
<p>然后，在_config.yml 的配置文件里做以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: &quot;https://github.com/linli1724647576/linli1724647576.github.io.git&quot;</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>执行上传命令，会提示输入github的用户名和密码，密码用令牌代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo d  #上传博客 deploy</span><br></pre></td></tr></table></figure>

<p>上传成功后就可以在github Pages里访问了。</p>
<h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;  等价于 hexo new &quot;我的第一篇文章&quot;  还等价于</span><br><span class="line">hexo p 等价于 hexo publish</span><br><span class="line">hexo g 等价于 hexo generate  </span><br><span class="line">hexo s等价于 hexo server     </span><br><span class="line">hexo d 等价于 hexo deploy</span><br></pre></td></tr></table></figure>

<p>下次发布时先运行hexo g生成静态网页，然后再hexo d </p>
<p>也可以采用admin模式自动发布,需要安装插件</p>
<p>npm install –save hexo-admin</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/BV1mU4y1j72n/">https://www.bilibili.com/video/BV1mU4y1j72n/</a></p>
<p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/2023/03/01/tags/</url>
    <content><![CDATA[<p>硕士在读，计算机技术专业，分享一些论文和一些技术，强迫自己以更加系统和严谨的态度梳理问题，也希望对他人有所帮助。</p>
]]></content>
  </entry>
  <entry>
    <title>PLUMBER</title>
    <url>/2023/03/04/PLUMBER/</url>
    <content><![CDATA[<h1 id="PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem"><a href="#PLUMBER-Boosting-the-Propagation-of-Vulnerability-Fixes-in-the-npm-Ecosystem" class="headerlink" title="PLUMBER: Boosting the Propagation of Vulnerability Fixes in the npm Ecosystem"></a>PLUMBER: Boosting the Propagation of Vulnerability Fixes in the <em>npm</em> Ecosystem</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><ul>
<li>npm是JavaScript编程语言中最大的生态系统，截至2022年1月，它拥有超过180万个第三方软件包。</li>
<li>2017年11月2日的npm快照进行的调查显示，在610,097个包中，其中21.9%直接依赖于易受攻击的包。如果考虑到传递性依赖关系，这种脆弱性对npm生态系统的脆弱性影响可能会显著增加。</li>
<li>我们对npm包的3948个漏洞报告的初步研究发现，在发现漏洞后，60.6%涉及的包及时发布了修复版本。</li>
<li>漏洞修复工具例如 <em>npm</em> audit [6] and Dependabot [7] 来提醒那些直接地或过渡性地依赖于脆弱的软件包版本的项目。</li>
<li>我们对传播漏洞修复的滞后的原因进行了两个观察：大多数包只修复了其最高主要版本中的漏洞，而没有将修复移植到早期的流行版本中。由于缺乏生态系统级依赖图的完整概图，包开发人员几乎没有意识到它们是阻止修复程序传播到其许多下游包的关键因素。</li>
</ul>
<h2 id="2-Motivation-Example"><a href="#2-Motivation-Example" class="headerlink" title="2.Motivation Example"></a>2.Motivation Example</h2><p><img src="/2023/03/04/PLUMBER/image-20230226104613081.png" alt="image-20230226104613081"></p>
<ul>
<li>我们将阻止修复在依赖路径上传播的包称为阻塞包。上图中browser-sync和graphql为阻塞包。</li>
<li>从阻塞包到脆弱包的依赖路径被称为阻塞链。 上图中 browser-sync-&gt;socket.io -&gt;engine.io为一条阻塞链</li>
</ul>
<h2 id="3-Introduction"><a href="#3-Introduction" class="headerlink" title="3.Introduction"></a>3.Introduction</h2><h3 id="3-1-相关工作"><a href="#3-1-相关工作" class="headerlink" title="3.1 相关工作"></a>3.1 相关工作</h3><p>(1)脆弱性对生态系统的影响[2、10、10-16]；</p>
<p>(2)减少报告易受攻击的依赖项[17–22]的误报；</p>
<p>(3)易受攻击的程序包更新中的滞后[1,23-28]</p>
<p>[1] 他们进行了一项实证调查，以确定在脆弱的包发布和固定发布之间可能出现的滞后。为了确保快速采用和传播包含修复程序的版本，他们为开发人员和研究人员提供了可操作的建议：开发者要有更好的意识，以便更快地规划依赖项更新。</p>
<p>然而，现有的工作都没有探索生态系统中阻塞包和阻塞链的特征。如何设计一种技术来加速漏洞的修复仍然是一项主要问题。</p>
<h3 id="3-2-目标和挑战"><a href="#3-2-目标和挑战" class="headerlink" title="3.2 目标和挑战"></a>3.2 目标和挑战</h3><p>为关键软件包提供可行的补救策略，促进脆弱性修复的传播。</p>
<ul>
<li>获取最新的漏洞元数据和npm依赖元数据。</li>
<li>了解阻塞链的演化特征及其对脆弱性修复传播的影响。</li>
</ul>
<h3 id="3-3-方法和结果"><a href="#3-3-方法和结果" class="headerlink" title="3.3 方法和结果"></a>3.3 方法和结果</h3><p><strong>Empirical Study:</strong></p>
<p>（RQ1）含有漏洞的包的规模及其对其他项目的影响；</p>
<p>（RQ2）在连续npm快照上的阻塞链的演化特征；</p>
<p>（RQ3）对传播漏洞修复有更好效果的补救策略。</p>
<p><strong>Technique:</strong></p>
<p>(1)对漏洞和npm依赖元数据进行建模，并逐步更新其演化过程；</p>
<p>(2)识别阻碍漏洞修复通过依赖路径传播的关键阻塞链；</p>
<p>(3)分析阻塞链上的软件包的特性，定制修复方案。</p>
<p><strong>Evaluation:</strong></p>
<p>我们应用PLUMBER为最具影响力的阻塞链生成了268份修复报告。47.4%的补救报告得到了积极的反馈。PLUMBER生成的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个活跃的npm项目中。</p>
<p><strong>Contributions:</strong></p>
<ul>
<li>我们进行了第一个实证研究，以描述软件包在生态系统中阻碍脆弱性修复的传播的情况。</li>
<li>我们开发了PLUMBER工具，通过纠正关键的阻塞链，来促进npm生态系统中脆弱性修复的传播。</li>
<li>一个大规模的漏洞修复传播实验。我们的报告通过92,469个依赖路径将漏洞修复程序传播到16,403个根包中。</li>
</ul>
<h2 id="4-Empirical-Study"><a href="#4-Empirical-Study" class="headerlink" title="4.Empirical Study"></a>4.Empirical Study</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2023/03/04/PLUMBER/image-20230227101417121.png" alt="image-20230227101417121"></p>
<p>搜集漏洞元数据：<em>GitHub Advisory DB</em>, <em>Snyk Vul</em> <em>nerability DB</em> and <em>NPM Security Advisories</em>. </p>
<p>收集npm依赖项元数据：（V，E，C） V版本集合， E依赖边 （最新版本）<em>E</em> &#x3D; <em>{<strong>p</strong>i*@<em>va</em> <em>→</em> <em>pj</em>@<em>v*<em>b</em></em>|<strong>p</strong>i*@<em>v*<em>a</em></em>, pj</em>@<em>vb</em> <em>∈</em></p>
<p><em>V</em> <em>}</em>.   C  依赖关系 <em>c</em>(<em>pi</em>@<em>v*<em>a</em></em>, pj* ) <em>∈</em> <em>C</em></p>
<p>识别易受攻击的路径：通过将漏洞元数据映射到npm依赖元数据G &#x3D;（V，E，C），在集合V中，我们定位了所有带有详细漏洞信息的脆弱包版本。通过可达性分析来识别所有的脆弱路径。</p>
<p>VP模型统计： Table 2</p>
<p><img src="/2023/03/04/PLUMBER/image-20230227102441166.png" alt="image-20230227102441166"></p>
<h3 id="RQ1（阻塞包的规模）："><a href="#RQ1（阻塞包的规模）：" class="headerlink" title="RQ1（阻塞包的规模）："></a>RQ1（阻塞包的规模）：</h3><p>在npm生态系统中阻止漏洞修复传播的包的规模是多少？它们在多大程度上影响了其他项目？</p>
<p>在npm生态系统的356283个活跃根系项目中，有20.0%)中有320个仍然通过1065723个脆弱路径直接或过渡地依赖于这些脆弱包。平均而言，每个根项目都会受到4.4个±7.5漏洞的影响。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228090108772.png" alt="image-20230228090108772"></p>
<p>在npm生态系统的快照中，有45,148个阻塞包和358,422个阻塞链导致983,336个依赖路径的漏洞修复传播滞后。在有影响力的阻塞软件包和阻塞链上都有明显的中心地位。20%的阻塞软件包和阻塞链影响了绝大多数脆弱的路径。</p>
<h3 id="RQ2（阻塞链的进化）："><a href="#RQ2（阻塞链的进化）：" class="headerlink" title="RQ2（阻塞链的进化）："></a>RQ2（阻塞链的进化）：</h3><p>阻断链在npm生态系统中是如何进化的？它们在npm的生态系统中存在了多久了？</p>
<p>方法：每隔两个月爬取一次npm快照，(a)通过比较快照si（1 &lt; i≤7）与s1的统计数据，我们研究了s1中阻塞链、脆弱路径和受影响的根项目的规模，这些项目在一年的进化过程中进行了修复。(b)通过比较两个连续快照si−1和si的统计数据，我们统计了每两个月间隔内修复的阻塞链、脆弱路径和受影响的根项目的数量。此外，我们还关注了与si−1相比，si是否引入了新的案例。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228091129135.png" alt="image-20230228091129135"></p>
<p>在2020年8月1日的npm快照中，经过一年的进化，77.0%的阻断链仍然存在。在此期间，受这些阻塞链影响的脆弱路径和根项目的数量分别下降了37.1%和17.3%。9,904个活动根项目通过17,612条脆弱路径仍然引用了9,808个与更高级漏洞捆绑的阻塞链。</p>
<h3 id="RQ3（补救模式）："><a href="#RQ3（补救模式）：" class="headerlink" title="RQ3（补救模式）："></a>RQ3（补救模式）：</h3><p>阻塞链如何从脆弱路径中去除？是否可以提炼出常见的补救模式，以促进漏洞修复的传播？</p>
<p>我们实证研究了在快照s1-s7（在RQ2中收集）和提炼的常见修复模式中，包更新是如何通过包更新进行修复的。我们关注两种类型的阻塞链，它们通过包更新进行了修复，具有传播漏洞修复的显著效果：</p>
<p><strong>Type A</strong>。阻断链存在于快照s1-si−1（1&lt;i≤7）中，而在快照si中被修复。</p>
<p><strong>Type B</strong>。快照s1-s7中存在的阻塞链，而在进化过程中受其影响的脆弱路径的数量显著减少。</p>
<p><strong>Remediation pattern A.</strong>  阻塞包在其最高主要版本中发布了一个新版本，其中升级了直接依赖以过渡引入漏洞修复。通过最终将直接依赖项升级到安全版本，它们最终修复了其最高可用版本中的漏洞。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093517214.png" alt="image-20230228093517214"></p>
<p><strong>Remediation pattern B</strong> 中间包在其较低的主要版本中发布一个新版本，其中升级直接依赖，使非活动的阻塞包过渡地引入漏洞修复（100%的Type A阻塞链实例）。</p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093534796.png" alt="image-20230228093534796"></p>
<p><strong>Remediation pattern C</strong> </p>
<p><img src="/2023/03/04/PLUMBER/image-20230228093801859.png" alt="image-20230228093801859"></p>
<p>这三种模式的<strong>补救成本</strong>标记如下：模式A&lt;模式B&lt;模式C</p>
<p>我们提炼了三种常见的修复模式及其传播漏洞修复的先决条件。对于由主动阻塞包引起的阻塞链，这种阻塞包可以纠正其最高可用版本（模式A）中的漏洞。对于由非活动阻塞包引起的阻塞链，中间包可以纠正其较低主要版本序列中的漏洞，使非活动阻塞包能够过渡地引入漏洞修复（模式B）。此外，受阻塞链影响的包也可以不弃用不活动的阻塞包，并迁移到其他维护良好的包，以修复漏洞（模式C）。</p>
<h2 id="5、Approach"><a href="#5、Approach" class="headerlink" title="5、Approach"></a>5、Approach</h2><p><img src="/2023/03/04/PLUMBER/image-20230301174303414.png" alt="image-20230301174303414"></p>
<p>和DTResolver有区别的点：</p>
<p>识别阻塞链：对于每个脆弱路径，PLUMBER从脆弱包pu开始，迭代计算每个包的安全版本µt，直到阻塞包的安全版本为空。最后，PLUMBER根据通过它们的脆弱路径的数量对识别出的阻塞链进行排序。排名最高的阻塞链被认为是关键的阻塞链，应该进行修复，以使漏洞修复能够传播到大量的包中。</p>
<p>我们的实证研究结果表明，三种策略的补救成本通常遵循：策略A&lt;策略B&lt;策略 C. 因此，对于由积极维护的软件包引起的阻塞链，水管工高度建议了补救策略 A. 对于由非活动阻塞包引起的阻塞链，在中间包（即阻塞包和脆弱包之间的包）被开放版本约束指定的情况下，水管工建议补救策略B，如果它们可以返回到较低版本的序列。否则，水管工将采用补救策略C来迁移非活性的阻塞链。</p>
<h2 id="6、Evaluation"><a href="#6、Evaluation" class="headerlink" title="6、Evaluation"></a>6、Evaluation</h2><h3 id="RQ4（PLUMBER的有效性）："><a href="#RQ4（PLUMBER的有效性）：" class="headerlink" title="RQ4（PLUMBER的有效性）："></a>RQ4（PLUMBER的有效性）：</h3><p>水管工制定的补救策略与开发人员是否一致？</p>
<p>方法：选择开发人员已经修复的一些包作为基准，将我们的修复方案和开发人员的修复方案进行比较。</p>
<p>结果：由水管工提出的362种补救策略中，有289种（79.8%）与我们的基准策略一致。对于73种不一致的补救策略，我们的工具通过平衡漏洞修复的补救成本和传播效果来生成建议。</p>
<h3 id="RQ5（补救挑战）："><a href="#RQ5（补救挑战）：" class="headerlink" title="RQ5（补救挑战）："></a>RQ5（补救挑战）：</h3><p>补救npm生态系统中的阻塞链有多具有挑战性？</p>
<p>方法：为了回答RQ5，对于在最近2021年8月1日的npm快照上确定的358,422条阻塞链，我们将它们分为不同的修复难度级别。此外，我们还观察了它们的分布情况，并讨论了补救方面的挑战。</p>
<p>结果：对于影响npm生态系统中大多数脆弱路径的前20%的关键阻断链，其中46.1%的关键阻断链难以修复。它们要么需要迁移非活动的阻塞包，要么需要升级其依赖项的主要版本，以引入漏洞修复，这需要更多的代码更改和测试工作。37.0%的顶级关键阻塞链可以通过所涉及的中间包的反向移植实践进行修复。只有16.9%的顶级关键阻塞链可以通过将主动阻塞包的依赖关系升级到安全的版本来轻松修复。</p>
<h3 id="RQ6（LUMBER的有用性）："><a href="#RQ6（LUMBER的有用性）：" class="headerlink" title="RQ6（LUMBER的有用性）："></a>RQ6（LUMBER的有用性）：</h3><p>水管工能否促进npm生态系统中脆弱性修复程序的传播，并为开发人员提供有用的补救策略？</p>
<p>方法：向开发人员提出Bug  report，挑选了前300个关键的阻塞软件包，并人工验证受影响的下游项目是否可以引入相关的漏洞修复程序</p>
<p>结果：47.4%的补救报告收到了来自许多著名的npm项目的积极反馈。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h2><p>出发点不同，DTResolver是根据root package构造依赖树，并检测依赖树中的漏洞和一些修复策略。 PLUMBER更注重npm生态系统的平衡，检测npm生态系统的Block Chain，并对包开发人员提出修复建议。</p>
<p>和DTResolver一样，都对npm漏洞的影响进行了研究，DTResolver注重于npm3正确依赖树的构造，Plumber更注重实证研究和漏洞的修复。</p>
<p>DTResolver的DTReme的修复有点突兀，没有前因后果，Plumber的修复是基于他的实证研究的结果，根据开发人员的建议制定的策略。</p>
<p>论文的组织模式和Watchman, Nufix很像，都是先实证研究，将问题进行分类，探索开发人员的修复策略； 再根据我们的工具进行分类检测，并提出修复策略，最后让开发人员确认。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</title>
    <url>/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<h1 id="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"><a href="#通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱" class="headerlink" title="通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱"></a>通过NPM生态系统中的依赖树揭开脆弱性传播及其演化的神秘面纱</h1><p><code>本文实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包之间的依赖关系。</code></p>
<p><a href="https://www.secrss.com/articles/43424">https://www.secrss.com/articles/43424</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/594160921">https://zhuanlan.zhihu.com/p/594160921</a></p>
<p><a href="https://sites.google.com/view/npm-vulnerability-study/">https://sites.google.com/view/npm-vulnerability-study/</a></p>
<p><a href="https://www.youtube.com/watch?v=CErMF3CgSc8">https://www.youtube.com/watch?v=CErMF3CgSc8</a></p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>NPM上发布了170多万个Node.js库，以促进软件开发。正如对比安全所揭示的，第三方库出现在当今软件的大多数（79%）中。然而，任何事物都有两面性。虽然使用库可以减少开发成本和时间，但这些集成库在实践中对软件生态系统构成了新的安全威胁，这些库中的漏洞可能会使依赖它们的软件不断面临安全风险。之前的工作已经调查了整个NPM生态系统的脆弱性影响，而他们的方法要么只是静态地考虑直接依赖性，或者基于依赖关系进行间接依赖的可达性分析，这可能会引入不准确的传递依赖关系，从而导致误报漏洞警告。现存的研究方法还没有提供一个精确的依赖关系。尤其是软件依赖关系之间的内部复杂关系，在很大程度上削弱了其分析的影响，并限制了进一步的解决方案（即精确修复）的提出。尽管一些现有的SCA工具（如Snyk和Blackduck）支持对用户项目进行NPM依赖性分析，但大多数工具都是从实际安装中检索依赖树，而不是从静态推理中检索依赖树。此外，由于语义版本控制的灵活性，依赖关系以及依赖关系中的漏洞实际上会随着时间的推移而发生动态变化。因此，尽管现有工作也调查了漏洞的影响，在没有静态和精确的依赖关系解决方案的情况下，大规模分析依赖关系中存在的漏洞传播的演变仍然是一个挑战，更不用说在防止漏洞动态引入依赖项方面获得实用的解决方案。</p>
<h2 id="2-论文主要成果"><a href="#2-论文主要成果" class="headerlink" title="2. 论文主要成果"></a>2. 论文主要成果</h2><ul>
<li>实现了一个依赖约束解析器来解决NPM依赖约束的多样性，并在此基础上构建了一个完整的依赖漏洞知识图（DVGraph），以捕获所有NPM包（超过114万个库和1094万个版本）之间的依赖关系，以及来自NVD的800多个已知CVE（常见漏洞和暴露），进一步的支持对漏洞传播的分析</li>
<li>提出了一种基于DVGraph的新算法（DTResolver），可以静态、精确地解析任意安装时间的依赖树，精度高达90%以上，并通过大约100k个代表性软件包进行了验证</li>
<li>进一步对依赖树中的脆弱性传播进行了实证研究。首先，我们研究了NPM依赖解析带来的依赖树的特征，在此基础上，我们分析了依赖树中漏洞传播的影响和特征，特别是传递依赖的漏洞。此外，我们还将研究扩展到时间维度，以研究依赖树中漏洞传播随时间的演变，揭示依赖树中引入漏洞的原因，以及可能的解决方案</li>
</ul>
<h2 id="3-实验架构"><a href="#3-实验架构" class="headerlink" title="3. 实验架构"></a>3. 实验架构</h2><p>包括依赖漏洞知识图构建、依赖树解析、漏洞路径识别及其验证、大规模实证研究以及对经验教训和解决方案的讨论，以及可能的研究方向</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1ed5572cf3d56e315f7e865590c7f9ac.png" alt="img"></p>
<h2 id="4-DVGraph的构建"><a href="#4-DVGraph的构建" class="headerlink" title="4. DVGraph的构建"></a>4. DVGraph的构建</h2><p>为了支持高精度和高效率的大规模依赖漏洞分析，我们设计并实现了一套数据处理平台，以构建和维护完整而精确的依赖漏洞图DVGraph（基于neo4j）。</p>
<p>下图为改数据处理平台的框架：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/5d6447824371e7607b366407f7aad9fa.png" alt="img"></p>
<p><strong>Metadata Pipeline：</strong>将数据保存在元数据库中</p>
<p><strong>CVE Pipeline：</strong>从NVD数据集收集CVE数据</p>
<p><strong>CVE Triage Pipeline：</strong>手工标记CVE数据的对应的受影响的库和版本</p>
<p><strong>Graph Pipeline：</strong>解析新来的元数据和映射的CVE数据，计算要在DVGraph上执行的操作（即添加、更改和删除节点和边），并最终执行这些操作</p>
<h2 id="5-依赖树解析和脆弱路径识别"><a href="#5-依赖树解析和脆弱路径识别" class="headerlink" title="5. 依赖树解析和脆弱路径识别"></a>5. 依赖树解析和脆弱路径识别</h2><h3 id="5-1-依赖树解析"><a href="#5-1-依赖树解析" class="headerlink" title="5.1 依赖树解析"></a>5.1 依赖树解析</h3><p>目前还没有一个考虑到特定于平台的依赖关系解决规则，可能导致不准确的依赖关系解析。本文目标是实现静态解析与NPM在实际安装过程中动态解析和安装的依赖树一致的依赖树，以便我们能够准确有效地识别依赖树中的漏洞和脆弱路径，而无需实际安装。</p>
<p>为了提高精度，同时保持效率，我们提出了一种基于DVGraph的依赖解析算法（DTResolver），可以在不安装的情况下，对任意数据软件包依赖解析的过程中，识别并找出所有依赖中含有安全漏洞的组件及相应的依赖引入路径</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/0fffc83b26b8297bd142c0061a005fb8.png" alt="img"></p>
<p>Dependency Tree Resolution</p>
<p>此外由于NPM中广泛使用依赖约束条件（版本范围）而不是固定版本进行依赖定义，导致依赖安装结果随着时间可能发生变化</p>
<p>如下图中，在<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#46;&#49;">&#66;&#64;&#49;&#46;&#x30;&#46;&#49;</a>发布后，<a href="mailto:&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#x41;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>的安装过程中，对B的依赖将解析成新发布的版本而不是原有的<a href="mailto:&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#66;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>, 图中<a href="mailto:&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;">&#x43;&#x40;&#49;&#x2e;&#48;&#x2e;&#x31;</a>的发布亦是如此。因此我们在DTResolver的基础上进一步增加了时间约束，使其能够支持在给定项目从其发布前到DVGraph更新时间内任意时刻的依赖树模拟解析。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/cb04b86c4aafea8676a467c495666079.jpg" alt="img"></p>
<h3 id="5-2-脆弱路径识别"><a href="#5-2-脆弱路径识别" class="headerlink" title="5.2 脆弱路径识别"></a>5.2 脆弱路径识别</h3><p>给出了脆弱点和路径的示例 通过反向深度优先搜索（DFS）实现了一个脆弱路径提取器，以彻底查找依赖树中从脆弱点到根节点的依赖关系</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/aed9b3b573cfcee4c57b966475f78199.png" alt="img"></p>
<h3 id="5-3-评估验证"><a href="#5-3-评估验证" class="headerlink" title="5.3 评估验证"></a>5.3 评估验证</h3><p>通过比较DTResolver解析的依赖树与实际安装的依赖树来验DTResolver。此外，我们将npm-remote-ls作为比较时的方法，这是一种广泛使用的公共API，在实践中无需实际安装即可获得依赖树，并且它完全遵循依赖范围来派生依赖树。</p>
<p>数据选择我们的验证基于两个标准收集的数据：（1）流行度，对于每个流行度指标（即过去、过去3年和去年下载量最多的明星、分叉、下载量多），我们分别选择了前2000个库。（2）中心性，对于每个中心性度量（即最大出入度），我们还选择了前2000个库和前20K个版本。分别地对于库，我们采用每个次要版本的最高补丁版本。最后，整理了15673个库中的103609个版本。</p>
<p><strong>DTResolver解析器的评估。</strong>根据结果，90.58%的图树在忽略无法计算的情况（例如，具有捆绑的依赖项并且包含没有时间的依赖项）后与安装树完全匹配。而只有53.33%的远程树与安装树完全匹配，这是因为npm远程ls错过了一些官方的解决规则（例如，未弃用版本的优先级选择）。此外，我们进一步确定了不匹配依赖树的两个主要原因：1）在npm ls的输出中消除了依赖，这省略了一些包和依赖关系以简化树视图。2） 由于环境问题，依赖项可能无法完全安装（例如，当缺少所需的操作系统支持时，某些程序包可能无法安装）。此外，缺少库版本（即不在NPM注册表中或爬网失败）也会导致依赖关系树中缺少一些包。</p>
<p><strong>漏洞检测和漏洞路径识别评估。</strong>除了DTResolver的评估，我们还扩展到比较检测到的漏洞和易受攻击的路径。由于从实际安装中检索到的安装树可能不完整（例如，依赖关系中的某些包由于环境问题而未安装），我们通过调用Graph Tree和Remote Tree中已识别的漏洞和漏洞路径来评估漏洞检测的准确性。我们发现DTResolver（98.1%）和npm远程ls（97.7%）在检测易受攻击组件方面具有相似的高覆盖率，但在识别易受攻击路径方面存在差异（92.60%对78.31%）。这可能是因为大多数依赖性约束都被解析为最满意的版本，并且依赖性范围也遵循这一规则，因此，仍然可以识别最脆弱的包。然而，通过依赖关系到达解决依赖关系忽略了NPM特定的解决规则，这会影响识别依赖关系路径的准确性。</p>
<h2 id="6-大规模实证研究"><a href="#6-大规模实证研究" class="headerlink" title="6. 大规模实证研究"></a>6. 大规模实证研究</h2><p>以下两个方面分析NPM中安全漏洞的影响：</p>
<ul>
<li>漏洞如何影响NPM生态系统？漏洞如何通过依赖关系树传播影响根包(root packages)？</li>
<li>漏洞传播如何在依赖树中发展？依赖关系树的变化如何影响漏洞传播的演变？</li>
</ul>
<h3 id="6-1-通过依赖树传播漏洞"><a href="#6-1-通过依赖树传播漏洞" class="headerlink" title="6.1 通过依赖树传播漏洞"></a>6.1 通过依赖树传播漏洞</h3><ul>
<li>据统计证明，漏洞广泛存在于NPM包的依赖关系中（整个生态系统中有19.96%的库的四分之一版本）</li>
<li>第三方库的最新版本（16.17%）仍然存在通过依赖关系受到漏洞影响的潜在风险。</li>
<li>其他用户使用的易受攻击的库中，有相当一部分（超过100个）仍然有易受攻击的最新版本</li>
<li>一些有影响力的已知CVE广泛存在于大部分包的依赖树中</li>
<li>包通常受到多个漏洞的影响，每个漏洞通过多个漏洞路径影响根包（平均一个漏洞引入8个漏洞路径）</li>
<li>漏洞仍然广泛存在于受影响库版本的直接依赖关系中（超过30%），即使是最新版本</li>
<li>在易受攻击的路径上也存在中心性，即大多数易受攻击的路径都会通过有限的直接依赖关系，这可以用来切断易受攻击的路径</li>
</ul>
<h3 id="6-2-依赖树中的漏洞传播演化"><a href="#6-2-依赖树中的漏洞传播演化" class="headerlink" title="6.2 依赖树中的漏洞传播演化"></a>6.2 依赖树中的漏洞传播演化</h3><ul>
<li>随着时间的推移，已知的漏洞正在对NPM生态系统造成更大的影响。它们不仅影响到更多的库版本，而且还影响到依赖树中更脆弱的点</li>
<li>大多数CVE（93%）在被发现之前已经被引入依赖树，这些CVE的固定版本（87%）也大多在CVE发布之前发布</li>
<li>依赖树中只有60%的CVE被DTC自动删除，即使如此，每个CVE删除仍需要一年以上的时间</li>
<li>过时的维护（提供者）和不合适的依赖约束（使用者）是阻碍依赖树中漏洞自动移除的主要原因。应该采取更多的对策和解决方案来避免、监控甚至纠正这些不良做法</li>
</ul>
<p>DTReme</p>
<p>添加了1)<strong>前向漏洞检查</strong>，在解析新的依赖关系的版本时（算法1中的第13行和第17行），只解析每个依赖关系的干净版本；2)<strong>向后安装的包跟踪</strong>，一旦没有干净版本可以解决，回滚到父节点的解析，并找到替代版本，以避免没有干净版本的情况。因此，我们可以彻底遍历所有可能的解决方案，找到可能的干净依赖树，并且可以为整个依赖树生成一个新的package-lock.json文件作为修复解决方案。</p>
<h2 id="7、有限性"><a href="#7、有限性" class="headerlink" title="7、有限性"></a>7、有限性</h2><p>首先，依赖关系中的漏洞可能永远不会影响根包，因为可能永远无法访问这些易受攻击的功能。这只能通过基于依赖树和调用图分析易受攻击的函数调用路径来进一步解决。我们将此作为我们未来的工作。其次，CVE和库版本的映射是手动标记的，这可能会导致数据错误标记，合作的作者已将数据与现有CVE交叉验证，以缓解此类威胁。第三，我们无法区分包含缺失依赖项的安装，这可能会使基本事实不准确，我们只接受依赖项中成功安装的包作为验证中的基本事实。第四，由于计算成本过高，在分析漏洞传播时，我们忽略了具有超过1k条漏洞路径的版本。总的来说，这样的版本只占2.01%，这只能对我们的结果造成有限的偏差。</p>
<h2 id="附录1-Npm依赖解析规则"><a href="#附录1-Npm依赖解析规则" class="headerlink" title="附录1 Npm依赖解析规则"></a>附录1 Npm依赖解析规则</h2><p><a href="https://docs.npmjs.com/cli/v9/commands/npm-install">https://docs.npmjs.com/cli/v9/commands/npm-install</a></p>
<p><a href="https://www.cnblogs.com/penghuwan/p/6970543.html">【npm】详解npm的模块安装机制 - 外婆的 - 博客园 (cnblogs.com)</a></p>
<p><font color="red"><strong>依赖树表面的逻辑结构与依赖树真实的物理结构</strong> </font></p>
<p>这里要先提到两个命令：tree -d（linux）和npm ls（npm）</p>
<p>在一个npm项目下：</p>
<p><strong>tree -d命令</strong>以树状图的方式列出一个项目下所有依赖的物理结构</p>
<p><strong>npm ls命令</strong>以树状图的方式列出一个项目下所有依赖的逻辑结构</p>
<p>以官方文档为例子：</p>
<p>项目example1有两个依赖模块：mod-a模块和mod-c模块；</p>
<p>mod-a模块有一个依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;">&#x6d;&#x6f;&#100;&#45;&#98;&#64;&#49;&#x2e;&#48;&#x2e;&#48;</a>模块</p>
<p>mod-c模块有一个依赖模块<a href="mailto:&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#109;&#111;&#x64;&#x2d;&#x62;&#64;&#50;&#x2e;&#x30;&#x2e;&#x30;</a>模块</p>
<p>tree -d 和npm ls运行结果如下：（注意npm版本为npm3而非npm2）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092200262-641835535.png" alt="img"></p>
<p>先看看下面那个红框的结果，这应该是“最符合我们理解”的依赖树，首先项目下形成了一级依赖——mod-a模块和mod-b模块，然后以这两个模块为父模块再追加二级依赖模块<a href="mailto:&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#x6d;&#x6f;&#100;&#x2d;&#98;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a>和<a href="mailto:mod-b@2.0.0">mod-b@2.0.0</a></p>
<p>但是！这却并不是物理上真实形成的依赖树的模样，物理上真实形成的依赖树是上面的那个红色框。<strong>mod-a,mod-c和mod-b竟然同为同一级</strong>的依赖。</p>
<p>你可能会问，为什么会形成这样的依赖树呢？下面我就来解释一番</p>
<p>【注意】：下面的图示全部为依赖树的物理结构，而不是逻辑结构</p>
<p><font color="red"><strong>关于npm模块安装机制的一点猜想</strong></font></p>
<p>安装模块时，可能的方式有两种：<strong>平级式</strong>的安装或<strong>嵌套式</strong>的安装（此处仅仅是猜想和假设）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092352262-1548398831.png" alt="img"></p>
<p>能不能完全采取平级的安装方式呢？——不能</p>
<p>我们取和上面相似的一个例子：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块Cv2.0。显然，它们并不能同时存在于同一个node_modules下，当安装的时候，由于npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092426950-802407609.png" alt="img"></p>
<p>但如果我们仅仅只安装一个版本的C依赖模块，将可能会导致A模块和B模块不兼容</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092458231-782438150.png" alt="img"></p>
<p><strong>基于以上原因，npm2选择了嵌套的安装方式——</strong></p>
<p><font color="red"><strong>npm2下的模块安装机制</strong></font></p>
<p>npm2安装多级的依赖模块采用嵌套的安装方式：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092546575-1188239142.png" alt="img"></p>
<p><strong>优点和弊端</strong></p>
<p><strong>优点：</strong>解决了版本单一时存在的存在的不兼容问题，实现多版本兼容</p>
<p><strong>弊端：</strong>可能造成相同模块大量冗余的问题，如下：</p>
<p>以上面例子为例，下面这种情况也是合理存在的：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092618981-1003798029.png" alt="img"></p>
<p>凭感觉也知道，这绝不是什么好现象，那我们如何能在实现依赖间多版本兼容的前提下，减少这种模块冗余呢？于是npm3做了一下改进</p>
<p><font color="red"><strong>npm3下的模块安装机制：</strong></font></p>
<p>npm3和npm2的不同主要体现在二级模块的安装上：</p>
<p>npm3会**”尽量”<strong>把逻辑上某个层级的模块在物理结构上</strong>“全部”**放在项目的第一层级里，具体我概括为以下三种情况：</p>
<p>1.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>还没有相同名称的模块</strong>，便<strong>把这第二层级的模块放在第一层级</strong></p>
<p>2.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，相同版本的模块</strong>，便<strong>直接复用那个模块</strong></p>
<p>3.在安装某个二级模块时，若发现第<strong>一</strong>层级<strong>有相同名称，但版本不同的模块</strong>，便<strong>只能嵌套在自身的父模块下方</strong></p>
<p>这一开始可能有些难理解，所以让我们看图说话吧！</p>
<p><strong>先说1：在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</strong></p>
<p>我们先简化一下上面的例子：现在项目APP下只有一个一级依赖模块A，它下面有一个二级依赖模块C，但npm install的时候，项目下安装依赖的</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092737903-1235721353.png" alt="img"></p>
<p>npm3中的二级模块（C v1.0),在项目的一级目录（node_modules）下没有相同名称的模块时，会被安装到一级目录下，从而跟它的父模块A同级。<strong>这就是本文一开始中依赖树的逻辑结构和物理结构不同的起因</strong>。</p>
<p>也就是说：</p>
<p><strong>在npm2中，依赖树的逻辑结构和它的物理结构相同</strong></p>
<p><strong>在npm3中，依赖树的逻辑结构和它的物理结构可能不同</strong></p>
<p><strong>再说2:在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</strong></p>
<p>在1的基础上，我们把1的例子还原回之前的复杂一些的场景：：项目APP下有两个依赖模块A和B；A又有一个依赖模块Cv1.0；而B也有一个依赖模块C v1.0（两个C模块版本相同）</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609092859168-1795479456.png" alt="img"></p>
<p>对npm2,两个C包是相同的，造成模块冗余</p>
<p>在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块</p>
<p><strong>npm3就是用这种方式，部分地解决了npm2的痛点（部分）</strong></p>
<p>【从1，2到3的过渡】我在这一小节的开始说：“npm3会”尽量”把逻辑上某个层级的模块”全部”放在项目的第一层级里”，我想你看完1，2后应该多少有些理解了**<em>“尽量”*<strong>的含义了，但我说了</strong></em>“尽量”***，同时也就意味着npm3存在着不能把二级依赖放在第一层级的情况。对此，请看3:</p>
<p><strong>最后说3:在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方</strong></p>
<p>在2中，A，B所依赖的两个C模块是相同的，<strong>但如果两个C模块的版本不同呢？</strong>，项目npm install情况如下：</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093023575-1842293712.png" alt="img"></p>
<p>在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块</p>
<p><strong>（看到这里我想应该能解答你对文章开头那个例子的疑惑了吧，这个例子和那个例子是几乎完全一样的哦）</strong></p>
<p>看到这里，你对npm2和npm3下的模块工作机制，以及npm3针对npm2的优化有个大体的了解了吧，但请思考一个问题：n<strong>pm3是否已经把npm2的模块冗余的缺陷优化到极致了呢？</strong> ———答案是<strong>没有</strong>，请往下看：</p>
<p>实际上：<strong>npm3中仍然可能出现模块冗余的情况</strong>，因为一级目录下已经有v1.0的C模块了，<strong>所以所有的v2.0只能作为二级依赖模块被安装</strong>，这样你就会看到如下的情况</p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093147262-345050329.png" alt="img"></p>
<p>并且在上图所示的这种特殊情况里，npm3和npm2表现得似乎并没什么区别</p>
<p>【过渡】那么这有没有什么解决的方式呢？当然是有的，当A模块下的C v1.0模块被更新至C v2.0的前提下，我们可以<strong>通过npm dedupe把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0</strong></p>
<p><font color="red"><strong>利用npm dedupe去除冗余模块</strong></font></p>
<p><strong>npm dedupe做了什么？****它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块</strong></p>
<p><img src="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/1060770-20170609093125700-1173491575.png" alt="img"></p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>01-编译Cpython</title>
    <url>/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/</url>
    <content><![CDATA[<h1 id="01-编译CPython"><a href="#01-编译CPython" class="headerlink" title="01-编译CPython"></a>01-编译CPython</h1><h3 id="CPython的目录结构"><a href="#CPython的目录结构" class="headerlink" title="CPython的目录结构"></a>CPython的目录结构</h3><p>源码中文件夹的大致含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpython/</span><br><span class="line">│</span><br><span class="line">├── Doc      ← Source for the documentation</span><br><span class="line">├── Grammar  ← The computer-readable language definition</span><br><span class="line">├── Include  ← The C header files</span><br><span class="line">├── Lib      ← Standard library modules written in Python</span><br><span class="line">├── Mac      ← macOS support files</span><br><span class="line">├── Misc     ← Miscellaneous files</span><br><span class="line">├── Modules  ← Standard Library Modules written in C</span><br><span class="line">├── Objects  ← Core types and the object model</span><br><span class="line">├── Parser   ← The Python parser source code</span><br><span class="line">├── PC       ← Windows build support files</span><br><span class="line">├── PCbuild  ← Windows build support files for older Windows versions</span><br><span class="line">├── Programs ← Source code for the python executable and other binaries</span><br><span class="line">├── Python   ← The CPython interpreter source code</span><br><span class="line">└── Tools    ← Standalone tools useful for building or extending Python</span><br></pre></td></tr></table></figure>

<ul>
<li>Grammar记录了关于python的语法定义，如tokens,grammar，CPython有专门的代码读取这些文件，再生成词法解析和语法解析的代码。</li>
<li>Objects目录里有Python的核心内置类型，与python的对象模型息息相关</li>
<li>Parser里包含了Python语言的前端，即词法解析，语法解析</li>
<li>Programs包含了Python可执行文件的入口和相关实现</li>
<li>Python目录包含了Python解释器的实现</li>
</ul>
<h3 id="编译CPython"><a href="#编译CPython" class="headerlink" title="编译CPython"></a>编译CPython</h3><p>首先在CPython的目录下运行configure脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure CFLAGS=&quot;-g -O0&quot;</span><br></pre></td></tr></table></figure>

<p>继续make指令编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>编译成功后会有一个Python可执行文件。</p>
<h3 id="CPython2-GEF插件让GDB更好用"><a href="#CPython2-GEF插件让GDB更好用" class="headerlink" title="CPython2-GEF插件让GDB更好用"></a>CPython2-GEF插件让GDB更好用</h3><p>gdb .&#x2F;python调试python,想看源码用list指令就可以了，想要看反汇编用disassemble命令就可以了，但是它的风格是AT&amp;T风格的，想要看内存用x，想要看寄存器用info命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -tui ./python</span><br></pre></td></tr></table></figure>

<p>GEF <a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(curl -fsSL https://gef.blah.cat/sh)&quot;</span><br></pre></td></tr></table></figure>

<p>可以使用hexdump命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexdump byte &amp;argc</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/image-20230329102126435.png" alt="image-20230329102126435"></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>02-一切对象皆PyObject</title>
    <url>/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/</url>
    <content><![CDATA[<h2 id="02-一切皆对象PyObject"><a href="#02-一切皆对象PyObject" class="headerlink" title="02-一切皆对象PyObject"></a>02-一切皆对象PyObject</h2><h3 id="一切皆对象PyObject"><a href="#一切皆对象PyObject" class="headerlink" title="一切皆对象PyObject"></a>一切皆对象PyObject</h3><p>Python中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230308194406865.png" alt="image-20230308194406865"></p>
<p>Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自object。因此，object是所有类型对象的”基类”、或者说”父类”。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144138069.png" alt="image-20230310144138069"></p>
<p><strong>我们说可以使用type和__class__查看一个对象的类型，并且还可以通过isinstance来判断该对象是不是某个已知类型的实例对象；那如果想查看一个类型对象都继承了哪些类该怎么做呢？我们目前都是使用issubclass来判断某个类型对象是不是另一个已知类型对象的子类，那么可不可以直接获取某个类型对象都继承了哪些类呢？</strong></p>
<p><strong>答案是可以的，方法有三种，我们分别来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先D继承自B和C, C又继承A, 我们现在要来查看D继承的父类</span></span><br><span class="line"><span class="comment"># 方法一: 使用__base__</span></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 使用__bases__</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三: 使用__mro__</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__base__: 如果继承了多个类, 那么只显示继承的第一个类, 没有显示继承则返回一个&lt;class &#39;object&#39;&gt;;</code></li>
<li><code>__bases__: 返回一个元组, 会显示所有直接继承的父类, 如果没有显示的继承, 则返回(&lt;class &#39;object&#39;&gt;,);</code></li>
<li><code>__mro__: mro表示Method Resolution Order, 表示方法查找顺序, 会从自身除法, 找到最顶层的父类, 因此返回自身、继承的基类、以及基类继承的基类, 一直找到object;</code></li>
</ul>
<p>最后我们来看一下type和object，估计这两个老铁之间的关系会让很多人感到困惑。</p>
<p>我们说type是所有类的元类，而object是所有的基类，这就说明type是要继承自object的，而object的类型是type。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144509108.png" alt="image-20230310144509108"></p>
<p>这就怪了，这难道不是一个先有鸡还是先有蛋的问题吗？其实不是的，这两个对象是共存的，它们之间的定义其实是互相依赖的。至于到底是怎么肥事，我们后面在看解释器源码的时候就会很清晰了。</p>
<p><strong>总之目前记住两点：</strong></p>
<ul>
<li><code>1. type站在类型金字塔的最顶端, 任何的对象按照类型追根溯源, 最终得到的都是type;</code></li>
<li><code>2. object站在继承金字塔的最顶端, 任何的类型对象按照继承追根溯源, 最终得到的都是object;</code></li>
</ul>
<p>我们说type的类型还是type，但是object的基类则不再是object，而是一个None。为什么呢？其实答案很简单，我们说Python在查找属性或方法的时候，会回溯继承链，自身如果没有的话，就会按照__mro__指定的顺序去基类中查找。所以继承链一定会有一个终点，否则就会像没有出口的递归一样出现死循环了。</p>
<p>最后将上面那张关系图再完善一下的话：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144643701.png" alt="image-20230310144643701"></p>
<h3 id="实现对象机制的基石-PyOBject"><a href="#实现对象机制的基石-PyOBject" class="headerlink" title="实现对象机制的基石-PyOBject"></a>实现对象机制的基石-PyOBject</h3><p><strong>根据对象的不同特点还可以进一步分类：</strong></p>
<ul>
<li><code>可变对象：对象创建之后可以本地修改;</code></li>
<li><code>不可变对象：对象创建之后不可以本地修改;</code></li>
<li><code>定长对象：对象所占用的内存大小固定;</code></li>
<li><code>不定长对象：对象所占用的内存大小不固定;</code></li>
</ul>
<p>但是”对象”在Python的底层是如何实现的呢？我们知道标准的Python解释器是C语言实现的CPython，但C并不是一个面向对象的语言，那么它是如何实现Python中的面向对象的呢？</p>
<p>首先对于人的思维来说，对象是一个比较形象的概念，但对于计算机来说，对象却是一个抽象的概念。它并不能理解这是一个整数，那是一个字符串，计算机所知道的一切都是字节。通常的说法是：对象是数据以及基于这些数据的操作的集合。在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的。</p>
<p><strong>而Python中的任何对象在C中都对应一个结构体实例，在Python中创建一个对象，等价于在C中创建一个结构体实例。所以Python中的对象本质上就是C中malloc函数为结构体实例在堆区申请的一块内存。</strong></p>
<p>Python中一切皆对象，而所有的对象都拥有一些共同的信息(也叫头部信息)，这些信息就在PyObject中，PyObject是Python整个对象机制的核心，我们来看看它的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>PyObject_HEAD_EXTRA</strong></font>    </p>
<p>PyObject_HEAD_EXTRA 定义了两个双向链表，用于指向堆上创建的活着的对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_next;           \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_prev;</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>Ob_refcnt</strong></font></p>
<p>ob_refcnt定义了引用计数器</p>
<p>当一个对象被引用时，那么ob_refcnt会自增1；引用解除时，ob_refcnt自减1。而一旦对象的引用计数为0时，那么这个对象就会被回收。</p>
<p>那么在哪些情况下，引用计数会加1呢？哪些情况下，引用计数会减1呢？</p>
<p><strong>导致引用计数加1的情况：</strong></p>
<ul>
<li><code>对象被创建：比如name = &quot;古明地觉&quot;, 此时对象就是&quot;古明地觉&quot;这个字符串, 创建成功时它的引用计数为1</code></li>
<li><code>变量传递使得对象被新的变量引用：比如Name = name</code></li>
<li><code>引用该对象的某个变量作为参数传到一个函数或者类中：比如func(name)</code></li>
<li><code>引用该对象的某个变量作为元组、列表、集合等容器的一个元素：比如lst = [name]</code></li>
</ul>
<p><strong>导致引用计数减1的情况：</strong></p>
<ul>
<li><code>引用该对象的变量被显示的销毁：del name</code></li>
<li><code>对象的引用指向了别的对象：name = &quot;椎名真白&quot;</code></li>
<li><code>引用该对象的变量离开了它的作用域，比如函数的局部变量在函数执行完毕的时候会被销毁</code></li>
<li><code>引用该对象的变量所在的容器被销毁，或者被从容器里面删除</code></li>
</ul>
<p>所以我们使用del删除一个对象，并不是删除这个对象，我们没有这个权力，del只是使对象的引用计数减一，至于到底删不删是解释器判断对象引用计数是否为0决定的。为0就删，不为0就不删，就这么简单。</p>
<p>而ob_refcnt的类型是<strong>Py_ssize_t</strong>，在64位机器上直接把这个类型看成long即可<code>(话说这都2020年了，不会还有人用32位机器吧)</code>，因此一个对象的引用计数不能超过long所表示的最大范围。但是显然，如果不是吃饱了撑的写恶意代码，是不可能超过这个范围的。</p>
<p><font color="red"><strong>ob_type：类型指针</strong></font></p>
<p>我们说一个对象是有类型的，类型对象描述实例对象的数据和行为，而ob_type存储的便是对应类型对象的指针，所以类型对象在底层对应的是struct  _typeobject实例。从这里我们可以看出，所有的类型对象在底层都是由同一个结构体实例化得到的，因为PyObject是所有的对象共有的，它们的ob_type指向的都是struct _typeobject。</p>
<blockquote>
<p><strong>所以不同的实例对象对应不同的结构体，但是类型对象对应的都是同一个结构体。</strong></p>
</blockquote>
<p>因此我们看到PyObject的定义非常简单，就是一个引用计数和一个类型指针，所以Python中的任意对象都必有：引用计数和类型这两个属性。</p>
<h3 id="实现变长对象的基石–PyVarObject"><a href="#实现变长对象的基石–PyVarObject" class="headerlink" title="实现变长对象的基石–PyVarObject"></a>实现变长对象的基石–PyVarObject</h3><p>我们说PyObject是所有对象的核心，它包含了所有对象都共有的信息，但是还有那么一个属性虽然不是每个对象都有，但至少有一大半的对象会有，能猜到是什么吗？</p>
<p>我们说Python中的对象根据所占的内存是否固定可以分为定长对象和变长对象，而变长对象显然有一个长度的概念，比如字符串、列表、元组等等，即便是相同的实例对象，但是长度不同，所占的内存也是不同的。比如：字符串内部有多少个字符、元组、列表内部有多少个元素，显然这里的多少*也是Python中很多对象的共有特征，虽然不像引用计数和类型那样是每个对象都必有的，但也是相当大一部分对象所具有的。</p>
<p><strong>所以针对变长对象，Python底层也提供了一个结构体，因为Python很多都是变长对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>所以我们看到PyVarObject实际上是PyObject的一个扩展，它在PyObject的基础上提供了一个ob_size字段，用于记录内部的元素个数。比如列表，列表<code>(PyListObject实例)</code>中的ob_size维护的就是列表的元素个数，插入一个元素，ob_size会加1，删除一个元素，ob_size会减1。所以我们使用len获取列表的元素个数是一个时间复杂度为O(1)的操作，因为ob_size是时刻都和内部的元素个数保持一致，使用len获取元素个数的时候会直接访问ob_size。</p>
<p><font color="green">因此在Python中，所有的变长对象都拥有PyVarObject，而所有的对象都拥有PyObject，这就使得在Python中，对”对象”的引用变得非常统一，我们只需要一个PyObject  *就可以引用任意一个对象，而不需要管这个对象实际是一个什么对象。所以在Python中，所有的变量、以及容器内部的元素，本质上都是一个PyObject *。</font></p>
<p>由于PyObject和PyVarObject要经常被使用，所以Python提供了两个宏，方便定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD          PyObject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure>

<p><strong>比如定长对象浮点数，在底层对应的结构体为PyFloatObject，只需在头部PyObject的基础上再加上一个double即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>而对于变长对象列表，在底层对应的结构体是PyListObject，所以它需要在PyVarObject的基础上再加上一个指向数组的二级指针和一个容量即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/listobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>这上面的每一个成员都代表什么，我们之前已经分析过了。ob_item就是指向指针数组的二级指针，而allocated表示已经分配的容量，一旦添加元素的时候发现ob_size自增1之后会大于allocated，那么解释器就会对ob_item指向的指针数组进行扩容了。更准确的说，是申请一个容量更大数组，然后将原来指向的指针数组内部的元素按照顺序一个一个地拷贝到新的数组里面去，并让ob_item指向新的数组，这一点在分析PyListObject的时候会细说。所以我们看到列表在添加元素的时候，地址是不会改变的，即使容量不够了也没有关系，直接让ob_item指向新的数组就好了，至于PyListObject对象本身的地址是不会变化的。</strong></p>
<p>最后再来<font color="green">介绍两个宏定义</font>，这个是针对于类型对象的，我们后面在介绍类型对象的时候会经常见到这两个宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Include/object.h</span><br><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>

<p>先看PyObject_HEAD_INIT，里面的_PyObject_EXTRA_INIT是用来实现refchain这个双向链表的，我们目前不需要管。里面的1指的是引用计数，我们看到刚创建的时候默认是设置为1的，至于type就是该类型对象的类型了，这个是作为宏的参数传进来的；而PyVarObject_HEAD_INIT，则是在PyObject_HEAD_INIT的基础之上，增加了一个size，显然我们从名字也能看出来这个size是什么。当然目前只是介绍这两个宏，先有个印象，类型对象的实现我们下面就会说。</p>
<h3 id="实现类型对象的基石–PyTypeObject"><a href="#实现类型对象的基石–PyTypeObject" class="headerlink" title="实现类型对象的基石–PyTypeObject"></a>实现类型对象的基石–PyTypeObject</h3><p>通过PyObject和PyVarObject，我们看到了Python中所有对象的共有信息以及变长对象的共有信息。对于任何一个对象，不管它是什么类型，内部必有引用计数<code>(ob_refcnt)</code>和类型指针<code>(ob_type)</code>；对于任意一个变长对象，不管它是什么类型，除了引用计数和类型指针之外，内部还有一个表示元素个数的ob_size。</p>
<p><strong>然目前是没有什么问题，一切都是符合我们的预期的，但是当我们顺着时间轴回溯的话，就会发现端倪。比如：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</p>
<p>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的PyObject中的ob_type，也就是类型指针。我们通过对象的ob_type成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</p>
<p>下面我们来看看类型对象在底层是怎么定义的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject; <span class="comment">//_typeobject正是PyObject里面的一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/Cpython/object.h</span></span><br><span class="line"><span class="comment">// 类型对象对应的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类型对象在底层对应的是struct _typeobject，当然也是PyTypeObject，它里面的成员非常非常多，我们暂时挑几个重要的说，因为有一部分成员并不是那么重要，我们在后续会慢慢说。</strong></p>
<p><strong>目前我们了解到Python中的类型对象在底层就是一个PyTypeObject实例，它保存了实例对象的元信息，描述对象的类型。</strong></p>
<blockquote>
<p><strong>Python中的实例对象在底层对应不同的结构体实例，而类型对象则是对应同一个结构体实例，换句话说无论是int、str、dict等等等等，它们在C的层面都是由PyTypeObject这个结构体实例化得到的，只不过成员的值不同PyTypeObject这个结构体在实例化之后得到的类型对象也不同。</strong></p>
</blockquote>
<p><font color="green"><strong>我们看一下PyTypeObject内部几个非常关键的成员：</strong></font></p>
<ul>
<li><code>PyObject_VAR_HEAD：我们说这是一个宏，对应一个PyVarObject，所以类型对象是一个变长对象。而且类型对象也有引用计数和类型，这与我们前面分析的是一致的。</code></li>
<li><code>tp_name：类型的名称，而这是一个char *，显然它可以是int、str、dict之类的。</code></li>
<li><code>tp_basicsize, tp_itemsize：创建对应实例对象时所需要的内存信息。</code></li>
<li><code>tp_dealloc：其实例对象执行析构函数时所作的操作。</code></li>
<li><code>tp_print：其实例对象被打印时所作的操作。</code></li>
<li><code>tp_as_number：其实例对象为数值时，所支持的操作。这是一个结构体指针，指向的结构体中的每一个成员都是一个函数指针，其函数就是整型对象可以执行的操作，比如：四则运算、左移、右移、取模等等</code></li>
<li><code>tp_as_sequence：其实例对象为序列时，所支持的操作。同样是一个结构体指针。</code></li>
<li><code>tp_as_mapping：其实例对象为映射时，所支持的操作。也是一个结构体指针。</code></li>
<li><code>tp_base：继承的基类。</code></li>
</ul>
<p><strong>我们暂时就挑这么几个，事实上从名字上你也能看出来这每一个成员代表的含义。而且这里面的成员虽然多，但并非每一个类型对象都具备，比如int类型它就没有tp_as_sequence和tp_as_mapping，所以int类型的这两个成员的值都是0。</strong></p>
<p><strong>具体的我们就在分析具体的类型对象的时候再说吧，然后先来看看Python对象在底层都叫什么名字吧。</strong></p>
<ul>
<li><code>整型 -&gt; PyLongObject结构体实例,  int -&gt; PyLong_Type(PyTypeObject结构体实例)</code></li>
<li><code>字符串 -&gt; PyUnicodeObject结构体实例,  str -&gt; PyUnicode_Type(PyTypeObject结构体实例)</code></li>
<li><code>浮点数 -&gt; PyFloatObject结构体实例,  float -&gt; PyFloat_Type(PyTypeObject结构体实例)</code></li>
<li><code>复数 -&gt; PyComplexObject结构体实例,  complex -&gt; PyComplex_Type(PyTypeObject结构体实例)</code></li>
<li><code>元组 -&gt; PyTupleObject结构体实例,  tuple -&gt; PyTuple_Type(PyTypeObject结构体实例)</code></li>
<li><code>列表 -&gt; PyListObject结构体实例,  list -&gt; PyList_Type(PyTypeObject结构体实例)</code></li>
<li><code>字典 -&gt; PyDictObject结构体实例,  dict -&gt; PyDict_Type(PyTypeObject结构体实例)</code></li>
<li><code>集合 -&gt; PySetObject结构体实例,  set -&gt; PySet_Type(PyTypeObject结构体实例)</code></li>
<li><code>不可变集合 -&gt; PyFrozenSetObject结构体实例,  frozenset -&gt; PyFrozenSet_Type(PyTypeObject结构体实例)</code></li>
<li><code>元类：PyType_Type(PyTypeObject结构体实例)</code></li>
</ul>
<p><strong>所以Python中的对象在底层的名字都遵循一定的标准，包括解释器提供的Python&#x2F;C API也是如此。</strong></p>
<p><font color="green"><strong>下面以浮点数为例，考察一下类型对象和实例对象之间的关系。</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; pi = 3.14</span><br><span class="line">&gt;&gt;&gt; e = 2.71</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; type(pi) is type(e) is float</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312165701421.png" alt="image-20230312165701421"></p>
<p><strong>两个变量均指向了浮点数(PyFloatObject结构体实例)，除了公共头部字段ob_refcnt和ob_type，专有字段ob_fval保存了对应的数值；浮点类型float则对应PyTypeObject结构体实例(PyFloat_Type)，保存了类型名、内存分配信息以及浮点数相关操作。而将这两者关联起来的就是ob_type这个类型指针，它位于PyObject中，是所有对象共有的，而Python便是根据这个ob_type来判断该对象的类型，进而获取该对象的元信息。</strong></p>
<blockquote>
<p><strong>我们说变量只是一个指针，那么int、float、dict这些是不是变量，显然是的，函数和类也是一个变量，所以它们在底层也是一个指针。只不过这些变量是内置的，直接指向了具体的PyTypeObject实例。只是为了方便，有时我们用int、float等等，来代指指向的对象。比如：float指向了底层的PyFloat_Type，所以它其实是PyFloat_Type的指针，但为了表述方便我们会直接用float来代指PyFloat_Type。</strong></p>
<p><strong>而且类型对象在解释器启动的时候就已经是创建好了的，不然的话我们怎么能够直接用呢？类型对象创建完毕之后，直接让float指向相应的类型对象。</strong></p>
</blockquote>
<p><strong>我们来看一下float对应的类型对象在底层是怎么定义的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    .tp_vectorcall = (vectorcallfunc)float_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyFloat_Type在源码中就直接被创建了，这是必须的，否则我们就没有办法直接访问float这个变量了，然后先看结构体中的第4行，我们看到tp_name被初始化成了”float”；第5行表示实例对象所占的字节数，我们看到就是一个PyFloatObject实例所占的内存大小，并且显然这个值是不会变的，说明无论创建多少个实例对象，它们的大小都是不变的，这也符合我们之前的测试结果，都是24字节。</strong></p>
<p><strong>再往下就是一些各种操作对应的函数指针，最后我们来看一下第3行，显然它接收的是一个PyVarObject，PyVarObject_HEAD_INIT这个宏无需赘言，但重点是里面的&amp;PyType_Type，说明了float被设置成了type类型。</strong></p>
<p><strong>而且所有的类型对象(还有元类)在底层都被定义成了静态的全局变量，因为它们的声明周期是伴随着整个解释器的，并且在任意地方都可以访问。</strong></p>
<p><font color="red"><strong>模改CPython如何修改Type的打印信息？</strong></font></p>
<p>例如，修改float的打印信息，进入到floatobject.h中，进入 PyAPI_DATA(PyTypeObject) PyFloat_Type; 中，进入(reprfunc)float_repr</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105008756.png" alt="image-20230309105008756"></p>
<p>重新编译CPython，发现打印的结果为：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105144313.png" alt="image-20230309105144313"></p>
<h3 id="类型对象的类型–PyType-Type"><a href="#类型对象的类型–PyType-Type" class="headerlink" title="类型对象的类型–PyType_Type"></a>类型对象的类型–PyType_Type</h3><p>我们考察了float类型对象，知道它在C的层面是PyFloat_Type这个静态全局变量，它的类型是type，包括我们自定义的类的类型也是type。而type在Python中是一个至关重要的对象，它是所有类型对象的类型，我们称之为元类型<code>(meta class)</code>，或者元类。借助元类型，我们可以实现很多神奇的高级操作。那么type在C的层面又长啥样呢？</p>
<p>在介绍PyFloat_Type的时候我们知道了type在底层对应PyType_Type，而它在”Object&#x2F;typeobject.c”中定义，因为我们说所有的类型对象加上元类都是要预先定义好的，所以要源码中就必须要以静态全局变量的形式出现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们所有的类型对象加上元类都是PyTypeObject这个结构体实例化得到的，所以它们内部的成员都是一样的，只不过传入的值不同，实例化之后的结果也不同，可以是PyLong_Type、可以是PyFloat_Type，也可以是这里的PyType_Type。</p>
<p><strong>PyType_Type的内部成员和PyFloat_Type是一样的，但是我们还是要重点看一下里面的宏PyVarObject_HEAD_INIT，我们看到它传递的是一个&amp;PyType_Type，说明它把自身的类型也设置成了PyType_Type，换句话说，PyType_Type里面的ob_type成员指向的还是PyType_Type。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type.__class__.__class__.__class__.__class__.__class__ is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(type(type(type(type(type))))) is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然不管我们套娃多少次，最终的结果都是True，显然这也是符合我们的预期的。</strong></p>
<h3 id="类型对象的基类–PyBaseObject-Type"><a href="#类型对象的基类–PyBaseObject-Type" class="headerlink" title="类型对象的基类–PyBaseObject_Type"></a>类型对象的基类–PyBaseObject_Type</h3><p>我们说Python中有两个类型对象比较特殊，一个是站在类型金字塔顶端的type，一个是站在继承金字塔顶端的object。说完了type，我们来说说object，我们说类型对象内部的tp_base表示继承的基类，对于PyType_Type来讲，它内部的tp_base肯定是PyBaseObject_Type。</p>
<p><strong>但令我们吃鲸的是，它的tp_base居然是个0，如果为0的话则表示没有这个属性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,                                          /* tp_base */</span><br></pre></td></tr></table></figure>

<p><strong>不是说type的基类是object吗？为啥tp_base是0，事实上如果你去看PyFloat_Type的话，它内部的tp_base也是0。为0的原因就在于我们目前看到的类型对象是一个半成品，因为Python的动态性，显然不可能在定义的时候就将所有成员属性都设置好、然后解释器一启动就会得到我们平时使用的类型对象。目前看到的类型对象是一个半成品，有一部分成员属性是在解释器启动之后再进行动态完善的。</strong></p>
<blockquote>
<p><strong>至于是怎么完善的，都有哪些成员需要解释器启动之后才能完善，我们后续系列会说。</strong></p>
</blockquote>
<p><font color="green">而PyBaseObject_Type位于Object&#x2F;object.c中，我们来一睹其芳容。</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/object.c</span></span><br><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;object&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject),                           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    object_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object_repr,                                <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyBaseObject_Type的类型也被设置成了PyType_Type，而PyType_Type类型在被完善之后，它的tp_base也会指向PyBaseObject_Type。所以之前我们说Python中的type和object是同时出现的，它们的定义是需要依赖彼此的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：解释器在完善PyBaseObject_Type的时候，是不会设置其tp_base的，因为继承链必须有一个终点，否对象沿着继承链进行属性查找的时候就会陷入死循环，而object已经是继承链的顶点了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object -&gt; PyBaseObject_Type</code></li>
<li><code>object() -&gt; PyBaseObject</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312171839520.png" alt="image-20230312171839520"></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>04-浮点数的底层实现</title>
    <url>/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="04-浮点数的底层实现"><a href="#04-浮点数的底层实现" class="headerlink" title="04-浮点数的底层实现"></a>04-浮点数的底层实现</h2><p>从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。</p>
<p>除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p><strong>float实例对象定义在Include&#x2F;floatobject.h中，结构非常简单：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了PyObject这个公共的头部信息之外，只有一个额外的ob_fval，用于存储具体的值，而且直接使用的C中的double。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195351664-171093404.png" alt="img"></p>
<p>​        <strong>那么float类型对象在底层长啥样子呢？</strong>    </p>
<p><strong>与实例对象不同，float类型对象全局唯一，因此可以作为全局变量定义。底层对应PyFloat_Type，位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PyFloat_Type中保存了很多关于浮点数对象的元信息，关键字段包括：</strong></p>
<ul>
<li><code>tp_name字段保存了类型名称，是一个char *，显然是&quot;float&quot;；</code></li>
<li><code>tp_dealloc、tp_init、tp_alloc和 tp_new字段是与对象创建销毁相关的函数；</code></li>
<li><code>tp_repr字段对应__repr__方法，生成语法字符串；</code></li>
<li><code>tp_str字段对应__str__方法，生成普通字符串；</code></li>
<li><code>tp_as_number字段对应数值对象支持的操作簇；</code></li>
<li><code>tp_hash字段是哈希值生成函数；</code></li>
</ul>
<p><strong>PyFloat_Type很重要，作为浮点类型对象，它决定了浮点数的生死和行为。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>在上一篇博客中，我们初步了解到创建实例对象的一般过程。对于内置类型的实例对象，可以使用Python&#x2F;C API创建，也可以通过调用类型对象创建。</strong></p>
<p><strong>调用类型对象float创建实例对象，Python执行的是type类型对象中的tp_call函数。tp_call中会先调用类型对象的tp_new为该对象的实例对象申请一份空间，申请完毕之后该对象就已经被创建了。然后会再调用tp_init，并将实例对象作为参数传递进去，进行初始化，也就是设置属性。</strong></p>
<p><strong>但是对于float来说，它内部的tp_init成员是0，从PyFloat_Type的定义我们也可以看到。说明float没有__init__函数，原因是float是一种很简单的类型对象，初始化操作只需要一个赋值语句，所以在tp_new中就可以完成。</strong></p>
<p>​        <strong>除了通过调用类型对象创建实例对象这种通用型方法之外，CPython还为内置类型对象提供了一些Python&#x2F;C  API来创建对应的实例对象。可以简化调用，提高效率。关于为什么可以提高效率，我们之前已经分析过了，我们说通过Python&#x2F;C  API创建的话，会直接解析成底层对应的数据结构，而通过类型对象调用的话则会有一些额外的开销。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromString</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>以上是底层提供的两个创建浮点数的C API，当然还有其它的。</strong></p>
<ul>
<li><code>PyFloat_FromDouble：通过C中的double创建float对象；</code></li>
<li><code>PyFloat_FromString：通过字符串对象创建float对象；</code></li>
</ul>
<p><strong>以PyFloat_FromDouble为例，我们看看底层是怎么创建的？该函数同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们之前在介绍引用计数的时候，说过引用计数为0了，那么对象会被销毁</span></span><br><span class="line">    <span class="comment">//但是对象所占的内存则不一定回收、或者说还给操作系统，而是会缓存起来</span></span><br><span class="line">    <span class="comment">//所以从这行代码我们就看到了，创建浮点数对象的时候会优先从缓存池里面获取</span></span><br><span class="line">    <span class="comment">//而缓存池是使用链表实现的，free_list(指针)指向的链表的第一个对象</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="comment">//op不是NULL，说明缓存池中有对象，成功获取</span></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//一旦获取了，那么要将free_list指向链表中当前获取的对象的下一个对象</span></span><br><span class="line">        <span class="comment">//但是Py_TYPE不是一个宏吗？它获取的应该是对象的ob_type啊，那么Py_TYPE(op)获取的不是PyFloat_Type指针吗？别急这一点我们后面会说</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        <span class="comment">//并且将缓存池的内部可以使用的浮点数对象的数量减1</span></span><br><span class="line">        <span class="comment">//关于缓存池, 以及为什么要使用缓存池下面也会细说</span></span><br><span class="line">        <span class="comment">//目前先知道Python在分配浮点数对象的时候会先从缓存池里面获取就可以了</span></span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，调用PyObject_MALLOC申请内存，PyObject_MALLOC是基于malloc的一个封装</span></span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="comment">//申请失败的话，证明内存不够了</span></span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//走到这里说明内存分配好了，PyFloatObject也创建了，但是不是还少了点啥呢？显然内部的成员还没有初始化</span></span><br><span class="line">    <span class="comment">//还是那句话内置类型的实例对象该分配多少空间，解释器了如指掌，因为通过PyFloatObject内部的成员一算就出来了。</span></span><br><span class="line">    <span class="comment">//因此虽然对象创建了，但是此时内部的ob_refcnt、ob_type、以及ob_fval三个成员还没有被初始化。</span></span><br><span class="line">    <span class="comment">//所以还要将其ob_refcnt设置为1(因为对于刚创建的对象来说,内部的引用计数显然为1)，将ob_type设置为指向PyFloat_Type的指针</span></span><br><span class="line">    <span class="comment">//而PyObject_INIT是一个宏，它就是专门用来设置ob_type以及ob_refcnt的，我们后面看这个宏的定义就知道了</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line">    <span class="comment">//将内部的ob_fval成员设置为fval，所以此时三个成员都已经初始化完毕</span></span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="comment">//将其转成PyObject *返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以整体流程如下：</strong></p>
<ul>
<li><code>1. 为实例对象分配内存空间，空间分配完了对象也就创建了，不过会优先使用缓存池；</code></li>
<li><code>2. 初始化实例对象内部的引用计数和类型指针；</code></li>
<li><code>3. 初始化ob_fval为指定的浮点值；</code></li>
</ul>
<p><strong>然后我们看一下PyObject_INIT这个宏，它位于Include&#x2F;objimpl.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_INIT(op, typeobj) \</span></span><br><span class="line"><span class="meta">    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</span></span><br><span class="line"><span class="comment">//这个宏接收两个参数，分别是：实例对象的指针和指向的类型对象的指针</span></span><br><span class="line"><span class="comment">//然后Py_TYPE(op)表示获取其内部的ob_type, 将其设置为typeobj, 而typeobj在源码中传入的就是&amp;PyFloat_Type</span></span><br><span class="line"><span class="comment">//然后是_Py_NewReference, 这个宏我们在上一篇博客中已经说过了，它用于将对象的引用计数初始化为1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p><strong>当删除一个变量时，Python会通过宏Py_DECREF或者Py_XDECREF来减少该变量指向的对象的引用计数；当引用计数为0时，就会回收该对象。而回收该对象会调用其类型对象中的tp_dealloc指向的函数。当然啦，CPython依旧为回收对象提供了一个宏，我们上一篇中也说过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">// _Py_Dealloc(op)会调用op指向的对象的类型对象中的析构函数，同时将op自身作为参数传递进去，表示将op指向的对象回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>而PyFloat_Type中的tp_dealloc成员被初始化为float_dealloc，所以析构函数最终执行的是float_dealloc，关于它的源代码我们会在一会儿介绍缓存池的时候细说。</strong></p>
<p><strong>总结一下的话，浮点数对象从创建到销毁整个生命周期所涉及的关键函数、宏、调用关系可以如下图所示：</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195401032-229146894.png" alt="img"></p>
<p><strong>我们看到通过类型对象调用的方式来创建实例对象，最终也是要走Python&#x2F;C API的，肯定没有直接通过Python&#x2F;C API创建的方式快，因为前者多了几个步骤。</strong></p>
<blockquote>
<p><strong>所以如果是float(3.14)，那么最终也会调用PyFloat_FromDouble(3.14)；如果是float(“3.14”)，那么最终会调用PyFloat_FromString(“3.14”)。所以调用类型对象的时候，会先兜个圈子再去使用Python&#x2F;C API，肯定没有直接使用Python&#x2F;C API的效率高。</strong></p>
</blockquote>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p><strong>我们说浮点数这种对象是经常容易被创建和销毁的，如果每创建一个就分配一次内存、每销毁一个就回收一次内存的话，那效率会低到可想而知了。我们知道Python在操作系统之上封装了一个内存池，可以用于小内存对象的快速创建和销毁，这便是Python的内存池机制。但浮点数使用的频率很高，我们有时会创建和销毁大量的临时对象，所以如果每一次对象的创建和销毁都伴随着内存相关的操作的话，这个时候即便是有内存池机制，效率也是不高的。</strong></p>
<p><strong>考虑如下代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi = <span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pi * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">12.56</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个语句首先计算半径r的平方，然后根据结果创建一个临时对象，假设是t；然后再将pi和t进行相乘，得到最终结果并赋值给s；最终销毁临时变量t，所以这背后是隐藏着一个临时对象的创建和删除的。</strong></p>
<p><strong>当然这里一行代码可能感觉不到啥，假设我们要计算很多很多个半径对应的面积呢？显然需要写for循环，如果循环一万次就意味着要创建和销毁临时对象各一万次。</strong></p>
<p>因此，如果每一次创建对象都需要分配内存，销毁对象时需要回收内存的话，那么大量临时对象的创建和销毁就意味着要伴随大量的<font color="red">内存分配以及回收操作</font>，这显然是无法忍受的，更何况Python的for循环本身就已经够慢了。</p>
<p>​        <strong>因此Python在浮点数对象被销毁后，并不急着回收对象所占用的内存，换句话说其实对象还在，只是将该对象放入一个空闲的链表中。因为我们说对象可以理解为就是一片内存空间，对象如果被销毁，那么理论上内存空间要归还给操作系统，或者回到内存池中；但Python考虑到效率，并没有真正的销毁对象，而是将对象放入到链表中，占用的内存还在；后续如果再需要创建新的浮点数对象时，那么从链表中直接取出之前放入的对象(我们认为被回收的对象)，根据新的浮点数对象重新初始化对应的成员即可，这样就避免了内存分配造成的开销。而这个链表就是我们说的缓存池，当然不光浮点数对象有缓存池，Python中的很多其它对象也有对应的缓存池，比如列表。</strong>    </p>
<p><strong>浮点对象的空闲链表同样在 Objects&#x2F;floatobject.c中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyFloat_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST    100  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;  </span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PyFloat_MAXFREELIST：缓存池中能容纳float实例对象的最大数量, 显然不可能将所有要销毁的对象都放入到缓存池中, 这里是100个;</code></li>
<li><code>numfree：表示当前缓存池(链表)中的已经存在的float实例对象的数量, 初始为0;</code></li>
<li><code>free_list: 指向链表头结点的指针, 链表里面存储的都是PyFloatObject, 所以头节点的指针就是PyFloatObject *</code></li>
</ul>
<p><strong>但是问题来了，如果是通过链表来存储的话，那么对象肯定要有一个指针，来指向下一个对象，但是浮点数对象内部似乎没有这样的指针啊。是的，因为Python是使用内部的ob_type来指向下一个对象，本来ob_type指向的应该是PyFloat_Type，但是在链表中指向的是下一个PyFloatObject。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195410257-1986378240.png" alt="img"></p>
<p><strong>所以我们再回过头来看看PyFloat_FromDouble：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然op是缓存池中第一个PyFloatObject的指针</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个时候链表中的第一个对象已经被取出来重新分配了，显然free_list要指向下一个PyFloatObject</span></span><br><span class="line">        <span class="comment">//我们说在链表中，ob_type被用于指向链表中的下一个PyFloatObject，换言之ob_type保存的是下一个PyFloatObject的地址</span></span><br><span class="line">        <span class="comment">//但ob_type虽然保存的是PyFloatObject的地址，但它的类型仍是struct _typeobject *, 或者说PyTypeObject *</span></span><br><span class="line">        <span class="comment">//所以在存储的时候，下一个PyFloatObject *一定是先转成了struct _typeobject *之后，再交给的ob_type,因为对于指针来说，是可以任意转化的</span></span><br><span class="line">        <span class="comment">//所以Py_TYPE(op)获取下一个对象的指针之后，还要再转成PyFloatObject *，然后交给free_list保存</span></span><br><span class="line">        <span class="comment">//如果没有下一个对象了，那么free_list就是NULL</span></span><br><span class="line">        <span class="comment">//因此在下一次分配的时候，上面if (op != NULL)就不成立了，因此会走下面的else，使用PyObject_MALLOC重新分配内存</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说对象创建时，会先从缓存池中获取。既然创建时可以从缓存池获取，那么销毁的时候，肯定要放入到缓存池中。而销毁对象会调用类型对象的析构函数tp_dealloc，对于浮点数而言就是float_dealloc，我们看一下源代码，同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">        <span class="comment">//如果numfree(当前缓存池中float实例对象的数量)达到了缓存池的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            <span class="comment">//那么调用PyObject_FREE回收对象所占内存</span></span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则的话，说明没有达到最大容量限制，显然此时不会真的销毁对象，而是将其放入缓存池中</span></span><br><span class="line">        <span class="comment">//将numfree加1</span></span><br><span class="line">        numfree++;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表的第一个元素，而这里是获取了op的ob_type,让其等于free_list，说明该对象内部的ob_type也指向了链表中的第一个元素</span></span><br><span class="line">        <span class="comment">//那么说明了什么，是不是意味着链表中第一个元素就变成该对象了。因此在将对象放入链表中的时候，是放在链表的头部位置</span></span><br><span class="line">        <span class="comment">//但我们说ob_type的类型是struct _typeobject *，所以还要将free_list进行转化</span></span><br><span class="line">        <span class="comment">//那么显然在获取的时候，还要再转成PyFloatObject *，这在上面的PyFloat_FromDouble中我们已经看到了</span></span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表中的第一个元素，但现在第一个元素变了</span></span><br><span class="line">        <span class="comment">//所以要让free_list = op, 指向新添加的PyFloatObject，因为它被插入到了链表的第一个位置上</span></span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则的话，说明PyFloat_CheckExact(op)为假, PyFloat_CheckExact(op)是用于检测op是不是指向PyFloatObject</span></span><br><span class="line">    <span class="comment">//说明此时op可能指向的其实不是PyFloatObject *，所以通过Py_TYPE(op)-&gt;tp_free直接获取对应的类型对象的tp_free，然后释放掉op指向的对象所占的内存。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>这便是Python的浮点数对象(或者浮点数空闲对象)缓存池的全部秘密，由于对象缓存池在提高对象分配效率方面发挥着至关重要的作用，所以Python中很多其它内置对象的实例对象也都实现了缓存池，我们后续在分析其它对象的时候会经常看到它的身影。</strong>    </p>
<p><strong>看一个思考题：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.414</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.732</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到两个对象的id是一样的，相信你肯定知道原因。因为a在del之后，指向对象被放入到缓存池中，然后创建b的时候会从缓存池中获取，所以a指向的对象被重新利用了，内存还是原来的那一块内存，所以前后地址没有变化。</strong></p>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p><strong>PyFloat_Type中定义了很多的函数指针，比如：type_repr、tp_str、tp_hash等等，这些函数指针将一起决定float实例对象的行为，例如：tp_hash决定float实例对象的哈希值是如何计算的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(e)</span><br><span class="line"><span class="number">1637148536541722626</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>tp_hash指向的是float_hash，还是那句话Python底层的函数命名以及API都是很有规律的，相信你能慢慢发现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_hash_t</span><br><span class="line"><span class="title function_">float_hash</span><span class="params">(PyFloatObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到调用了_Py_HashDouble，计算的就是ob_fval成员哈希值</span></span><br><span class="line">    <span class="keyword">return</span> _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>由于加减乘除等数值操作很常见， Python 将其抽象成数值操作簇 PyNumberMethods，并让内部成员tp_as_number指向。数值操作集 PyNumberMethods 在头文件 Include&#x2F;object.h 中定义：</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/object.h </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">    arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">    in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p><strong>PyNumberMethods定义了各种数学算子的处理函数，数值计算最终由这些函数执行。 处理函数根据参数个数可以分为： 一元函数(unaryfunc) 、 二元函数(binaryfunc) 和 三元函数(ternaryfunc )。</strong></p>
<p><strong>然后我们回到Objects&#x2F;floatobject.c中观察一下PyFloat_Type是如何初始化的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    (unaryfunc)float_neg, <span class="comment">/* nb_negative */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>以加法为例，显然最终执行float_add，源码位于Objects&#x2F;floatobject.c中，显然它是一个二元函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">float_add</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然两个Python对象相加，一定是先将其转成C的对象相加，加完之后再根据结果创建新的Python对象</span></span><br><span class="line">    <span class="comment">//所以声明了两个double</span></span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="comment">//CONVERT_TO_DOUBLE是一个宏，不用想，功能肯定是将PyFloatObject里面的ob_fval抽出来给double变量，从名字上也能看出来</span></span><br><span class="line">    <span class="comment">//这个宏有兴趣可以去源码中看一下，也在当前文件中</span></span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);  <span class="comment">// 将ob_fval赋值给a</span></span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);  <span class="comment">// 将ob_fval赋值给b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PyFPE_START_PROTECT和下面的PyFPE_END_PROTECT也都是宏，作用我们一会儿说。</span></span><br><span class="line">    PyFPE_START_PROTECT(<span class="string">&quot;add&quot;</span>, <span class="keyword">return</span> <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//将a和b相加赋值给a</span></span><br><span class="line">    a = a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line">    <span class="comment">//根据相加后的结果创建新的PyFloatObject对象，当然返回的是泛型指针PyObject *</span></span><br><span class="line">    <span class="keyword">return</span> PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以上就是float实例对象的运算，核心就是：</strong></p>
<ul>
<li><code>1. 定义两个double变量：a、b</code></li>
<li><code>2. 将用来相加的两个float实例对象中ob_fval维护的值抽出来赋值给a和b</code></li>
<li><code>3. 让a和b相加，将相加结果传入PyFloat_FromDouble中创建新的PyFloatObject，然后返回其PyObject *</code></li>
</ul>
<p><strong>所以如果是C中的两个浮点数相加，直接a +  b就可以了，编译之后就是一条简单的机器指令，然而Python则需要额外做很多其它工作。并且在介绍整型的时候，你会发现Python中的整型的相加会更麻烦，但对于C而言同样是一条简单的机器码就可以搞定。当然啦，因为Python3中的整型是不会溢出的，所以需要额外的一些处理，等介绍整型的时候再说吧。所以这里我们也知道Python为什么会比C慢几十倍了，从一个简单的加法上面就可以看出来。</strong></p>
<blockquote>
<p><strong>最后我们再说一下PyFPE_START_PROTECT和PyFPE_END_PROTECT这两个宏，其实它们对于我们了解浮点数在底层的计算没有什么意义。首先浮点数计算一般都遵循IEEE-754标准，如果计算时出现了错误，那么需要将IEEE-754异常转换成Python中的异常，而这两个宏就是用来干这件事情的。</strong></p>
<p><strong>所以我们不需要管它，这两个宏定义在Include&#x2F;pyfpe.h中，并且Python3.9的时候会被删除掉。</strong></p>
</blockquote>
<p>​        <strong>最后我们说一下Python解释器源代码的结构吧，因为我们每一次介绍函数的时候，都会说该函数定义在哪个文件里。所以突然想起来，介绍一下源代码的组织结构也是有必要的。</strong>    </p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195419135-1770620855.png" alt="img"></p>
<p><strong>我们从官网上将源代码下载下来之后，大概长这样，里面有几个目录是我们需要关注的。</strong></p>
<ul>
<li><code>Include：该目录包含了Python所提供的所有头文件，主要包含了一些实例对象在底层的定义，比如listobject.h、dictobject.h等等。如果用户需要自己使用C或者C++来编写自定义模块扩展Python，那么也需要用到这里的头文件。</code></li>
<li><code>Lib：这个无需多说，该目录包含了python自带的所有标准库，Lib中的库基本上都是使用python编写的。</code></li>
<li><code>Modules：该目录中包含了所有用C语言编写的模块，比如_random、_io等，而且gc也在里面。Modules中的模块是那些对速度要求非常严格的模块，而有一些对速度没有太严格要求的模块，比如os，就是用Python编写，并且是放在Lib目录下的。</code></li>
<li><code>Parser：该目录中包含了python解释器中的Scanner和Parser部分，即对python源代码进行词法分析和语法分析的部分。除了这些，Parser还包含了一些有用的工具，这些工具能够根据Python语言的语法自动生成Python语言的词法和语法分析器，与YACC非常类似。</code></li>
<li><code>Objects：该目录包含了所有Python的内置类型对象的实现，以及其实例对象相关操作的实现，比如浮点数相关操作就位于文件floatobject.c中、列表相关操作就位于文件listobject.c中，文件名也很有规律。同时，该目录还包含了Python在运行时需要的所有内部使用对象的实现，因为有很多对象比如&lt;class &#39;function&#39;&gt;是没有暴露给Python的，但是在底层它们是实现了的。</code></li>
<li><code>Python：虚拟机的实现相关，是python运行的核心所在。</code></li>
</ul>
<h3 id="PyFloatObjectに侵入し"><a href="#PyFloatObjectに侵入し" class="headerlink" title="PyFloatObjectに侵入し"></a>PyFloatObjectに侵入し</h3><p><strong>最后我们修改一下源码：当对象放入到缓冲池中，我们打印一下放入的浮点数对象的地址；当对象从缓存池中取出时，我们打印一下取出的浮点数对象的地址。</strong></p>
<p>对象从内存池中取出的时候加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line">    op = state-&gt;free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">        <span class="comment">// PyFloat_FromDouble() must not be called after _PyFloat_Fini()</span></span><br><span class="line">        assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        state-&gt;free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        state-&gt;numfree--;</span><br><span class="line">        OBJECT_STAT_INC(from_freelist);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Object gets from the memory pool,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        op = PyObject_Malloc(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _PyObject_Init((PyObject*)op, &amp;PyFloat_Type);</span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象放入内存池中加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyFloat_ExactDealloc(PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(PyFloat_CheckExact(obj));</span><br><span class="line">    PyFloatObject *op = (PyFloatObject *)obj;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">    <span class="comment">// float_dealloc() must not be called after _PyFloat_Fini()</span></span><br><span class="line">    assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">        PyObject_Free(op);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;numfree++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Objects are put back into the memory poo,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    Py_SET_TYPE(op, (PyTypeObject *)state-&gt;free_list);</span><br><span class="line">    state-&gt;free_list = op;</span><br><span class="line">    OBJECT_STAT_INC(to_freelist);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PyObject_Free(op);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195427317-1430841014.png" alt="img"></p>
<p><strong>我们看到在解释器刚启动的时候，内部就已经创建出很多对象了，然后我们自己来创建一个对象吧。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195432078-602851272.png" alt="img"></p>
<p><strong>我们第一次创建对象的时候，居然是从缓存池里面获取的，说明在解释器启动的时候那个链表中就已经有空闲对象了。然后我们使用Python获取其id，由于得到的是十进制整型，所以转成16进制，发现地址是一样的。然后放入到缓存池中，放入的对象的地址也是相同的，这和我们得到结论是一致的。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195437415-553253163.png" alt="img"></p>
<p><strong>我们再创建新的变量a、b并打印地址，然后删除a、b变量，再重新创建a、b变量、打印地址，结果发现它们存储的对象的地址在删除前后正好是相反的。至于原因，如果思考一下将对象放入缓存池、以及从缓存池获取对象的时候所采取的策略，那么很容易就明白了。</strong></p>
<p><strong>因为del a,  b的时候会先删除a，再删除b。删除a的时候，会将a指向的对象作为链表中的第一个元素，然后删除b的时候，会将b指向的对象作为链表中的第一个元素，所以之前a指向的对象就变成了链表中的第二个元素。而获取的时候，也会从链表的头部开始获取，所以当重新创建变量a的时候，其指向的对象实际上使用的是之前变量b指向的对象所占的内存，而一旦获取，那么free_list指针会向后移动；因此创建变量b的时候，其指向的对象显然使用的是之前变量a指向的对象所占的内存。因此前后打印的地址是相反的，所以我们算是通过实践从另一个角度印证了之前分析的结论。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        <strong>这一篇我们分析了Python中的浮点数在底层的实现方式，之所以选择浮点数是因为浮点数是最简单的了。至于整数，其实并没有那么简单，因为它的值底层是通过数组存储的，而浮点型底层是用一个double存储对应的值，所以更简单一些，我们就先拿浮点数”开刀了”。</strong>    </p>
<p>​        <strong>然后我们还介绍浮点数的创建和销毁，会调用类型对象内部的tp_dealloc，浮点数的话就是float_dealloc。当然为了保证效率，避免内存的创建和回收，Python底层为浮点数引入了缓存池机制，我们也分析了它的机制。当然浮点数还支持相关的数值型操作，PyFloat_Type中的tp_as_number指向了PyNumberMethods结构体，里面有大量的函数指针，每个指针指向了具体的函数，专门用于浮点数的运算。当然整型也有，只不过指针指向的函数是用于整型运算的。比如相加：对于浮点数来说，PyNumberMethods结构体成员nb_add指向了函数float_add；对于整数来说，nb_add则是指向了long_add。然后我们也以相加为例，看了float_add函数的实现，核心就是将Python中对象的值抽出来，转成C的类型，然后运算，最后再根据运算的结果，创建Python中的对象、返回。当然除了加法，它的减法、乘法、除法都是类似的，有兴趣可以”杀入”floatobject.c中，大肆探索一番。</strong>    </p>
<p>​        <strong>最后我们修改了PyFloatObject的部分源码，其实就是加上了两个printf语句，对float实例对象的缓存池机制进行了实践，并用之前的结论对结果进行了合理的解释。</strong>    </p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Bytes对象的底层操作</title>
    <url>/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="06-Bytes对象的底层操作"><a href="#06-Bytes对象的底层操作" class="headerlink" title="06-Bytes对象的底层操作"></a>06-Bytes对象的底层操作</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p>不少编程语言中的”字符串”都是使用字符数组(或者称字符序列)来表示，比如C语言和go语言就是这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;komeiji satori&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>一个字节最多能表示256个字符，所以对于英文来说足够了，因此一个英文字符占一个字节即可，然而对于那些非英文字符便力不从心了。因此为了表示这些非英文编码，于是多字节编码应运而生—-通过多个字节来表示一个字符。但由于原始字节序列不维护编码信息，因此操作不慎便导致各种乱码现象。</p>
<p>而Python提供的解决方案是使用unicode<code>(在Python3中等价于str)</code>表示字符串，因为unicode可以表示各种字符，不需要关心编码的问题。但在存储或网络通讯时，字符串不可避免地要序列化成字节序列。为此，Python除了提供字符串对象之外，还额外提供了字节序列对象—-bytes。</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223900719-724141880.png" alt="img"></p>
<p><strong>如上图，str对象统一表示一个字符串，不需要关心编码；计算机通过字节序列和存储介质、网络介质打交道，字节序列由bytes对象表示；在存储和传输str对象的时候，需要将其序列化成字节序列，序列化也是编码的过程。</strong></p>
<p><strong>下面我们就来看看bytes对象在底层的数据结构。</strong></p>
<h3 id="PyBytesObject"><a href="#PyBytesObject" class="headerlink" title="PyBytesObject"></a>PyBytesObject</h3><p><strong>我们说bytes对象是由若干个字节组成的，显然这是一个变长对象，有多少个字节说明其长度是多少。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/bytesobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyBytesObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下里面的成员对象：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD：变长对象的公共头部</code></li>
<li><code>ob_shash：保存该字节序列的哈希值，之所以选择保存是因为在很多场景都需要bytes对象的哈希值。而Python在计算字节序列的哈希值的时候，需要遍历每一个字节，因此开销比较大。所以会提前计算一次并保存起来，这样以后就不需要算了，可以直接拿来用，并且bytes对象是不可变的，所以哈希值是不变的。</code></li>
<li><code>ob_sval：这个和PyLongObject中的ob_digit的声明方式是类似的，虽然声明的时候长度是1,  但具体是多少则取决于bytes对象的字节数量。这是C语言中定义&quot;变长数组&quot;的技巧, 虽然写的长度是1, 但是你可以当成n来用,  n可取任意值。显然这个ob_sval存储的是所有的字节，因此Python中的bytes的值，底层是通过字符数组存储的。而且通过注释，我们发现会多申请一个空间，用于存储\0，因为C中是通过\0来表示一个字符数组的结束，但是计算ob_size的时候不包括\0。</code></li>
</ul>
<p>​        <strong>我们创建几个不同的bytes对象，然后通过画图感受一下：</strong>    </p>
<p><strong>val &#x3D; b””</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223908475-1596108760.png" alt="img"></p>
<p><strong>我们看到一个空的字节序列，底层的ob_savl也是需要一个’\0’的，那么这个结构体实例占多大内存呢？我们说上面ob_sval之外的四个成员，显然每个都是8字节，而ob_savl每个成员都是一个char、也就是占1字节，所以Python中bytes对象占的内存等于32 +  ob_sval的长度。而ob_sval里面至少有一个’\0’，因此对于一个空的字节序列，显然占33个字节。注意：ob_size统计的是ob_sval中有效字节的个数，不包括’\0’，但是计算占用内存的时候，显然是需要考虑在内的，因为它确实多占用了一个字节的空间。或者说bytes对象占的内存等于33 + ob_size也是可以的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>val &#x3D; b”abc”</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223922037-1082582124.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(val)</span><br><span class="line"><span class="number">36</span>  <span class="comment"># 32 + 4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="bytes对象的行为"><a href="#bytes对象的行为" class="headerlink" title="bytes对象的行为"></a>bytes对象的行为</h3><p><strong>介绍bytes对象在底层的数据结构之后，我们要考察bytes对象的行为。我们说实例对象的行为由其类型对象决定，所以bytes对象具有哪些行为，就看bytes类型对象本身定义了哪些操作。bytes类型对象，显然对应PyBytes_Type，根据我们之前介绍的规律，也可以猜出来，它定义在Object&#x2F;bytesobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/bytesobject.c</span></span><br><span class="line">PyTypeObject PyBytes_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &amp;bytes_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;bytes_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;bytes_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)bytes_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>到了现在，相信你对类型对象的结构肯定非常熟悉了，因为类型对象都是由PyTypeObject结构体实例化得到的。我们看到tp_as_number，它居然不是0，而是传递了一个指针，说明确实指向了一个PyNumberMethods结构体实例。难道bytes支持数值运算，这显然是不可能的啊，所以我们需要进入bytes_as_number中一探究竟。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods bytes_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    bytes_mod,      <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到它只定义了一个取模操作，也就是%</span></span><br><span class="line"><span class="comment">//看到%估计有人已经明白了，这是格式化</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">bytes_mod(PyObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyBytes_Check(self)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，bytes对象只是借用了%运算实现了格式化，谈不上数值运算，虚惊一场。不过由此也看到了Python的动态特性，即使是相同的操作，但如果是不同类型的对象执行的话，也会有不同的表现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>info = <span class="string">b&quot;name: %s, age: %d&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>info % (<span class="string">b&quot;satori&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;name: satori, age: 16&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>​        <strong>除了tp_as_number，PyBytes_Type还给tp_as_sequence成员传递了bytes_as_sequence指针，说明bytes对象支持序列操作。显然这是肯定的，而且bytes对象显然是序列型对象，所以序列型操作才是我们的研究的重点，下面看看bytes_as_sequence的定义。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>根据定义我们看到，bytes对象支持的序列型操作一共有5个：</strong></p>
<ul>
<li><code>sq_length：查看序列的长度</code></li>
<li><code>sq_concat：将两个序列合并为一个</code></li>
<li><code>sq_repeat：将序列重复多次</code></li>
<li><code>sq_item：根据索引获取指定的下表, 得到一个整型;如果是切片，那么还会得到一个bytes对象</code></li>
<li><code>sq_contains：判断某个序列是不是在该序列中，显然它等价于Python中的in操作</code></li>
</ul>
<p><strong>查看序列长度：</strong></p>
<p><strong>显然这是最简单的，直接获取ob_size即可，比如：val &#x3D; b”abcde”，那么长度就是5。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">bytes_length</span><span class="params">(PyBytesObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将两个序列合并为一个：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&quot;def&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line"><span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而且我们看到这里相当于是加法运算，我们很容易想到会是PyNumberMethods中的nb_add，比如：PyLongObject对应的long_add、PyFloatObject对应的float_add，但对于bytes对象而言，加法操作对应PySequenceMethods的sq_concat。所以我们看到Python中的同一个操作符，在底层会对应不同的函数，比如：long_add和float_add、以及这里的bytes_concat，在Python的层面都是+这个操作符。然后我们看看底层是怎么对两个字节序列进行相加的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_concat</span><span class="params">(PyObject *a, PyObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//两个局部变量，用于维护缓冲区</span></span><br><span class="line">    Py_buffer va, vb;</span><br><span class="line">    <span class="comment">//result用于保存结果</span></span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将缓冲区的长度设置为-1, 可以认为此时缓冲区啥也没有</span></span><br><span class="line">    va.len = <span class="number">-1</span>;</span><br><span class="line">    vb.len = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将a、b中ob_sval拷贝到缓冲区中，拷贝成功返回0，拷贝失败返回非0</span></span><br><span class="line">    <span class="comment">//如果下面的条件不成功, 就意味着拷贝失败了, 说明至少有一个老铁不是bytes类型</span></span><br><span class="line">    <span class="keyword">if</span> (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) != <span class="number">0</span> ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//然后设置异常，PyExc_TypeError表示TypeError(类型错误)，专门用来指对一个对象执行了它所不支持的操作</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;can&#x27;t concat %.100s to %.100s&quot;</span>,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//比如：&quot;123&quot; + 123, 会得到: TypeError: can&#x27;t concat int to bytes, 和这里设置的异常信息是一样的</span></span><br><span class="line">        <span class="comment">//这里直接跳转到done</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是判断是否有一方长度为0, 如果a长度为0，那么相加之后结果就是b</span></span><br><span class="line">    <span class="keyword">if</span> (va.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(b)) &#123;</span><br><span class="line">        <span class="comment">//将b拷贝给result</span></span><br><span class="line">        result = b;</span><br><span class="line">        <span class="comment">//增加result的引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和上面同理，如果b长度为0，那么相加之后的结果就是a</span></span><br><span class="line">    <span class="keyword">if</span> (vb.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//将a拷贝给result</span></span><br><span class="line">        result = a;</span><br><span class="line">        <span class="comment">//增加引用计数</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是判断两个字节序列合并之后，长度是否超过限制，因为不允许超过PY_SSIZE_T_MAX</span></span><br><span class="line">    <span class="comment">//所以更直观的写法应该是 if (va.len + vb.len &gt; PY_SSIZE_T_MAX), 但是这个条件基本不可能满足，除非你写恶意代码</span></span><br><span class="line">    <span class="keyword">if</span> (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话，声明指定容量PyBytesObject</span></span><br><span class="line">    result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, va.len + vb.len);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//将缓冲区va里面内容拷贝到result的ob_sval中，拷贝的长度为va.len</span></span><br><span class="line">        <span class="comment">//PyBytes_AS_STRING是一个宏，用于获取PyBytesObject中的ob_sval</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        <span class="comment">//然后将缓冲区vb里面的内容拷贝到result的ob_sval中，拷贝的长度为vb.len，但是从va.len的位置开始拷贝, 不然会把内容覆盖掉</span></span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="comment">//如果长度不会-1，那么要将缓冲区里面的内容释放掉，否则可能导致内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (va.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    <span class="keyword">if</span> (vb.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    <span class="comment">//返回result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虽然代码很长，但是不难理解。不过可能有人认为为什么非要先将a、b的内容拷贝到Py_buffer里面，再通过Py_buffer拷贝到result里面去呢？直接拷贝不可以吗？答案是Py_buffer提供了一套操作对象缓冲区的统一接口，屏蔽不同类型对象的内部差异。</strong></p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/1229382-20200805223933085-875268687.png" alt="img"></p>
<p><strong>将序列重复多次：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">b&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * <span class="number">3</span></span><br><span class="line"><span class="string">b&#x27;abcabcabc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * -<span class="number">1</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span>  <span class="comment"># 如果乘上一个负数，等于乘上0，那么会得到一个空的字节序列</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_repeat</span><span class="params">(PyBytesObject *a, Py_ssize_t n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    Py_ssize_t j;</span><br><span class="line">    Py_ssize_t size;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="type">size_t</span> nbytes;</span><br><span class="line">    <span class="comment">//如果n小于0, 那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里条件写成Py_SIZE(a) * n &gt; PY_SSIZE_T_MAX更容易理解</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; Py_SIZE(a) &gt; PY_SSIZE_T_MAX / n) &#123;</span><br><span class="line">        <span class="comment">//先计算相乘之后字节序列的长度是否超过最大限制，如果超过了，直接报错</span></span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算Py_SIZE(a) * n得到size</span></span><br><span class="line">    size = Py_SIZE(a) * n;</span><br><span class="line">    <span class="keyword">if</span> (size == Py_SIZE(a) &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        <span class="comment">//如果两者相等，那么证明n = 1，直接增加引用计数，然后返回a即可</span></span><br><span class="line">        Py_INCREF(a);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型转化，此时是size_t类型，相当于无符号64位整型</span></span><br><span class="line">    nbytes = (<span class="type">size_t</span>)size;</span><br><span class="line">    <span class="comment">//PyBytesObject_SIZE是一个宏，表示PyBytesObject的基本大小</span></span><br><span class="line">    <span class="comment">//它是一个宏，等价于(offsetof(PyBytesObject, ob_sval) + 1), 显然是33</span></span><br><span class="line">    <span class="comment">//所以nbytes + PyBytesObject_SIZE就是bytes对象所需要的空间</span></span><br><span class="line">    <span class="comment">//如果nbytes + PyBytesObject_SIZE还小于等于nbytes, 所以相加之后size_t类型存不下了</span></span><br><span class="line">    <span class="comment">//说明超过所占内存的极限了</span></span><br><span class="line">    <span class="keyword">if</span> (nbytes + PyBytesObject_SIZE &lt;= nbytes) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;repeated bytes are too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请空间，大小为PyBytesObject_SIZE + nbytes</span></span><br><span class="line">    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + nbytes);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//返回NULL，表示申请失败</span></span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//PyObject_INIT_VAR是一个宏，设置ob_type和ob_size</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size);</span><br><span class="line">    <span class="comment">//设置ob_shash为-1</span></span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将ob_sval最后一位设置为&#x27;\0&#x27;</span></span><br><span class="line">    op-&gt;ob_sval[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然这里是在a对应的bytes对象长度为1时，所走的逻辑</span></span><br><span class="line">        <span class="comment">//直接将op-&gt;ob_sval里面元素设置a-&gt;ob_sval[0], 设置n个</span></span><br><span class="line">        <span class="built_in">memset</span>(op-&gt;ob_sval, a-&gt;ob_sval[<span class="number">0</span>] , n);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则将a -&gt; ob_sval拷贝到op -&gt; ob_sval中, 拷贝n次, 因为size = Py_SIZE(a) * n;</span></span><br><span class="line">    <span class="comment">//这里是先拷贝了一次</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval, a-&gt;ob_sval, Py_SIZE(a));</span><br><span class="line">        i = Py_SIZE(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后拷贝n - 1次</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">        j = (i &lt;= size-i)  ?  i  :  size-i;</span><br><span class="line">        <span class="built_in">memcpy</span>(op-&gt;ob_sval+i, op-&gt;ob_sval, j);</span><br><span class="line">        i += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据索引获取指定元素：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>], <span class="built_in">type</span>(val[<span class="number">1</span>])</span><br><span class="line">(<span class="number">98</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>val[<span class="number">1</span>: <span class="number">4</span>], <span class="built_in">type</span>(val[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">(<span class="string">b&#x27;bcd&#x27;</span>, &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看底层的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_item</span><span class="params">(PyBytesObject *a, Py_ssize_t i)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果i &lt; 0或者 i &gt;= a的ob_size，那么会报错:索引越界</span></span><br><span class="line">    <span class="comment">//但是我们记得Python支持负数索引的啊，是的，只不过会手动帮你变成正的</span></span><br><span class="line">    <span class="comment">//因为C是不支持负数索引的，所以通过C的索引获取，那么索引一定是正的</span></span><br><span class="line">    <span class="comment">//因此我们填上的负数，Python会帮你加上长度。比如：长度为5，但是我们写的索引为-1, 那么Python会帮你变成4之后再获取</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= Py_SIZE(a)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们看到获取第i个元素之后直接转成了PyLongObject，然后返回指针</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)a-&gt;ob_sval[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那切片呢？切片的话对应bytes_subscript，但它不是在PySequenceMethods tp_as_sequence里面，而是在PyMappingMethods bytes_as_mapping里面，它是一个映射操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到映射操作，bytes对象中只有两个，一个bytes_length获取长度，这个在bytes_as_sequence中已经实现了，还有一个就是bytes_subscript进行切片操作</span></span><br><span class="line"><span class="type">static</span> PyMappingMethods bytes_as_mapping = &#123;</span><br><span class="line">    (lenfunc)bytes_length,</span><br><span class="line">    (binaryfunc)bytes_subscript,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>因为映射操作只有两个，一个是重复的，还有一个是必须要在这里说的，所以映射操作我们就放在这里介绍了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject*</span><br><span class="line"><span class="title function_">bytes_subscript</span><span class="params">(PyBytesObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//参数是self和item，那么在Python的层面上就类似于self[item]</span></span><br><span class="line">    <span class="comment">//检测item，看它是不是一个整型</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//如果是转成Ssize_t</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果i小于0，那么将i加上序列的长度，得到正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyBytes_GET_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= PyBytes_GET_SIZE(self)) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                            <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到整型</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong((<span class="type">unsigned</span> <span class="type">char</span>)self-&gt;ob_sval[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测是否是一个切片</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//起始、终止、步长、拷贝的字节个数、循环变量</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, i;</span><br><span class="line">        <span class="type">size_t</span> cur; <span class="comment">//拷贝的字节所在的位置</span></span><br><span class="line">        <span class="comment">//两个缓存</span></span><br><span class="line">        <span class="type">char</span>* source_buf;</span><br><span class="line">        <span class="type">char</span>* result_buf;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        <span class="comment">//这里是会将item解包</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到拷贝的字节个数比如：ob_sval长度为9, 但是未必拷贝9个，所以这个slicelength是计算的拷贝的字节个数</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(PyBytes_GET_SIZE(self), &amp;start,</span><br><span class="line">                                            &amp;stop, step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//slicelength小于等于0的话，直接返回空的字节序列，比如val[3: 2]，显然此时是不循环的，因为start对应的位置在end之后，而且步长为正</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果起始位置为0，步长为1，且拷贝的字节个数等于字节序列的长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start == <span class="number">0</span> &amp;&amp; step == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                 slicelength == PyBytes_GET_SIZE(self) &amp;&amp;</span><br><span class="line">                 PyBytes_CheckExact(self)) &#123;</span><br><span class="line">            <span class="comment">//那么增加引用计数，直接返回</span></span><br><span class="line">            Py_INCREF(self);</span><br><span class="line">            <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果步长是1，那么从start开始拷贝，拷贝slicelength个字字节</span></span><br><span class="line">            <span class="keyword">return</span> PyBytes_FromStringAndSize(</span><br><span class="line">                PyBytes_AS_STRING(self) + start,</span><br><span class="line">                slicelength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里，说明步长不是1，只能一个一个拷贝了</span></span><br><span class="line">            source_buf = PyBytes_AS_STRING(self);</span><br><span class="line">            <span class="comment">//创建PyBytesObject对象，空间为slicelength</span></span><br><span class="line">            result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, slicelength);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//拿到内部的ob_sval</span></span><br><span class="line">            result_buf = PyBytes_AS_STRING(result);</span><br><span class="line">            <span class="comment">//从start开始然后一个字节一个字节的拷贝过去</span></span><br><span class="line">            <span class="comment">//start开始拷贝，依旧循环slicelength，通过cur记录拷贝的位置，然后每次循环都加上步长step</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += step, i++) &#123;</span><br><span class="line">                result_buf[i] = source_buf[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//item要么是整数、要么是切片，走到这里说明不满足条件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//比如：item我们传递了一个字符串，显然此时在通过这种方式获取的话，这属于字典的操作</span></span><br><span class="line">        <span class="comment">//所以抛出TypeError异常</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;byte indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     Py_TYPE(item)-&gt;tp_name);</span><br><span class="line">        <span class="comment">//返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以从底层我们可以看到，Python为我们做的事情是真的不少，我们通过一个简单的切片，在底层要这么多行代码。不过在我们分析完逻辑之后，会发现其实也不过如此，毕竟逻辑很好理解。</strong></p>
<p><strong>但是在Python中，索引操作和切片操作，我们都可以通过__getitem__实现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">123</span>])  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])  <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>])  <span class="comment"># slice(1, 5, None)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">5</span>: <span class="number">2</span>])  <span class="comment"># slice(1, 5, 2)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;yo&quot;</span>: <span class="string">&quot;ha&quot;</span>: <span class="string">&quot;哼哼&quot;</span>])  <span class="comment"># slice(&#x27;yo&#x27;, &#x27;ha&#x27;, &#x27;哼哼&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过__getitem__，我们可以同时实现切片、索引获取，但是当item为字符串时，我们还可以实现字典操作</span></span><br><span class="line"><span class="comment"># 当然这部分内容，我们会在后面系列中分析类的时候介绍。</span></span><br></pre></td></tr></table></figure>

<p><strong>判断一个序列是否在指定的序列中：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>val = <span class="string">b&quot;abcdef&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;abc&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&quot;cbd&quot;</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果让你来实现的话，显然是两层for循环，那么Python是怎么做的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bytes_contains</span><span class="params">(PyObject *self, PyObject *arg)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//比如: b&quot;abc&quot; in b&quot;abcde&quot;会调用这里的bytes_contains</span></span><br><span class="line">    <span class="comment">//self就是b&quot;abcde&quot;对应的PyBytesObject的指针,arg是b&quot;abc&quot;对应的PyBytesObject的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显然这里调用了_Py_bytes_contains, 传入了self -&gt; ob_sval, self -&gt; ob_size, arg</span></span><br><span class="line">    <span class="keyword">return</span> _Py_bytes_contains(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的源码没有说明，显然是在bytesobject.c中</span></span><br><span class="line"><span class="comment">//但是_Py_bytes_contains位于bytes_methods.c中</span></span><br><span class="line">_Py_bytes_contains(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t len, PyObject *arg)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//将arg转成整型, 但是显然只有当arg -&gt; ob_savl的有效字节为1时才可以这么做</span></span><br><span class="line">    Py_ssize_t ival = PyNumber_AsSsize_t(arg, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ival == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="comment">//所以如果ival == -1 &amp;&amp; PyErr_Occurred()，说明arg -&gt; ob_sval的有效字节数大于1</span></span><br><span class="line">        Py_buffer varg;<span class="comment">//缓冲区</span></span><br><span class="line">        Py_ssize_t pos;<span class="comment">//遍历位置</span></span><br><span class="line">        PyErr_Clear();<span class="comment">//这里将异常清空</span></span><br><span class="line">        <span class="comment">//将arg -&gt; ob_sval设置到缓存区中</span></span><br><span class="line">        <span class="keyword">if</span> (PyObject_GetBuffer(arg, &amp;varg, PyBUF_SIMPLE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//调用stringlib_find找到其位置，里面也是使用了循环</span></span><br><span class="line">        pos = stringlib_find(str, len,</span><br><span class="line">                             varg.buf, varg.len, <span class="number">0</span>);</span><br><span class="line">        PyBuffer_Release(&amp;varg); <span class="comment">//释放缓冲区</span></span><br><span class="line">        <span class="comment">//如果pos大于0确实找到了，否则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> pos &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明字节不合法</span></span><br><span class="line">    <span class="keyword">if</span> (ival &lt; <span class="number">0</span> || ival &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;byte must be in range(0, 256)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明是单个字节，直接调用C中memchr去寻找即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memchr</span>(str, (<span class="type">int</span>) ival, len) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p><strong>我们知道Python中对于不可变对象运算的处理方式就是，再创建一个新的。所以三个bytes对象a、b、c相加时，那么会先根据a + b创建新的临时对象，然后再根据”临时对象+c”创建新的对象，返回指针。所以：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> bytes_list:</span><br><span class="line">    result += _</span><br></pre></td></tr></table></figure>

<p><strong>这是一种效率非常低下的做法，因为涉及大量临时对象的创建和销毁，不仅是这里bytes，后面即将分析的字符串也是同样的道理。官方推荐的做法是，使用join，字符串和字节序列都可以对一个列表进行join，将列表里面的多个字符串或者字节序列join在一起。</strong></p>
<p><strong>举个Python中的例子，我们以字符串为例，字节序列同样如此：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad</span>():</span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        s += <span class="built_in">str</span>(_)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">good</span>():</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        l.append(<span class="built_in">str</span>(_))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">better</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">best</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<p>+号在拼接字符串的时候，会先开辟一块空间，把+号左边的字符串和+号右边的字符串合起来放在新开辟的空间内，这样有几个+号，就会开辟几次空间。<br>加号操作符</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210306369.png" alt="image-20230315210306369"></p>
<p>join拼接字符串也需要开辟空间，但是会提前算好总共需要开辟多大的空间，一次性把内存申请好，然后把所有的字符串合起来放在这个新的空间中，这样就不用频繁申请空间了。节约空间又节约时间。<br>join连接</p>
<p><img src="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/image-20230315210318179.png" alt="image-20230315210318179"></p>
<p>从上面的例子中，可以看到join比+少申请了一块a+b的空间。</p>
<h3 id="字节序列缓冲池"><a href="#字节序列缓冲池" class="headerlink" title="字节序列缓冲池"></a>字节序列缓冲池</h3><p><strong>为了优化单字节bytes对象的创建效率，Python底层内部维护了一个缓冲池。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyBytesObject *characters[UCHAR_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>Python内部创建单字节bytes对象时，先检查目标对象是否已在缓冲池中。PyBytes_FromStringAndSize函数是负责创建bytes对象的通用接口，同样位于 Objects&#x2F;bytesobject.c 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyBytesObject对象的指针</span></span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//显然size不可以小于0</span></span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;Negative size passed to PyBytes_FromStringAndSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size为1表名创建的是单字节对象，当然str不可以为NULL, 而且获取到的字节必须要在characters里面</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        _Py_one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	</span></span><br><span class="line">        <span class="comment">//增加引用计数，返回指针</span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则话创建新的PyBytesObject，此时是个空</span></span><br><span class="line">    op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//不管size是多少，都直接拷贝即可</span></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line">    <span class="comment">//但是size是1的话，除了拷贝还会放到缓存池characters中</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回其指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，当 Python 程序开始运行时，字符缓冲池是空的。随着单字节 bytes*对象的创建，缓冲池中的对象慢慢多了起来。</strong></p>
<p><strong>这样一来，字符对象首次创建后便在缓冲池中缓存起来；后续再次使用时，  Python 直接从缓冲池中取，避免重复创建和销毁。与前面章节介绍的小整数对象池一样，字符对象只有为数不多的 256  个，但使用频率非常高。缓冲池技术作为一种以时间换空间的优化手段，只需较小的内存为代价，便可明显提升执行效率。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">b&quot;ab&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> a2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然此时不需要我解释了，单字节bytes对象会缓存起来，不是单字节则不会缓存。</strong></p>
<h3 id="bytearray对象"><a href="#bytearray对象" class="headerlink" title="bytearray对象"></a>bytearray对象</h3><p><strong>除了bytes对象之外，Python中还有一个bytearray对象，它和bytes对象类似，只不过bytes对象是不可变的，而bytearray对象是可变的。所以就不单独分析了，这里简单提一嘴。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入一个整型组成的列表创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>([<span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;cde&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个bytes对象创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个字符串，同时指定encoding编码创建bytearray对象</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">&quot;古明地觉&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们对s进行decode会直接得到字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：bytearray对象是可以变的</span></span><br><span class="line"><span class="comment"># 如果是中文，为了防止出现乱码，所以一次要改变3个字节</span></span><br><span class="line">s[-<span class="number">3</span>:] = <span class="string">&quot;恋&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># bytearray(b&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe6\x81\x8b&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(s.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地恋</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们同样可以根据索引、切片获取</span></span><br><span class="line">s = <span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>)</span><br><span class="line"><span class="comment"># 获取单个元素也会得到整型，这一点和bytes对象是一样的</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>])  <span class="comment"># 97 98 99</span></span><br><span class="line"><span class="comment"># 通过切片得到bytearray</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">2</span>])  <span class="comment"># bytearray(b&#x27;ab&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对多个bytearray对象进行join, 会得到一个bytes对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;--&quot;</span>.join([<span class="built_in">bytearray</span>(<span class="string">b&quot;abc&quot;</span>), <span class="built_in">bytearray</span>(<span class="string">b&quot;def&quot;</span>)]))  <span class="comment"># b&#x27;abc--def&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此把bytearray对象想象成可变的bytes对象即可，它的使用和bytes对象非常类似，一些操作的行为也是一样的，所以就不单独分析了，下一篇将会分析Python中的字符串。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们分析了bytes对象的底层实现，我们说：</strong></p>
<ul>
<li><code>bytes对象是一个变长、不可变对象，内部的值是通过一个C的字符数组来维护的;</code></li>
<li><code>bytes也是序列型操作，它支持的操作在bytes_as_sequence中;</code></li>
<li><code>Python内部维护字符缓冲池来优化单字节bytes对象的创建和销毁操作;</code></li>
<li><code>缓冲池是一种常用的以空间换时间的优化技术;</code></li>
</ul>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Python引用计数器和底层对象管理</title>
    <url>/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="03-Python引用计数器以及底层对象管理"><a href="#03-Python引用计数器以及底层对象管理" class="headerlink" title="03-Python引用计数器以及底层对象管理"></a>03-Python引用计数器以及底层对象管理</h2><p>在上一篇中我们说到了Python中的对象在底层的数据结构，我们知道Python底层通过<strong>PyObject</strong>和<strong>PyTypeObject</strong>完成了C++所提供的对象的多态特性。在Python中创建一个对象，会分配内存并进行初始化，然后Python会用一个PyObject *来保存和维护这个对象，当然所有对象都是如此。因为指针是可以相互转化的，所以变量在保存一个对象的指针时，会将该指针转成PyObject *之后再交给变量保存。因此在Python中，变量的传递<code>(包括函数的参数传递)</code>实际上传递的都是一个泛型指针：PyObject *。这个指针具体是指向的什么类型我们并不知道，只能通过其内部的ob_type成员进行动态判断，而正是因为这个ob_type，Python实现了多态机制。</p>
<p>比如：a.pop()，我们不知道这个a指向的对象到底是什么类型，但只要a可以调用pop方法即可，因此a可以是一个列表、也可以是一个字典、或者是我们实现了pop方法的类的实例对象。所以如果a的ob_type是一个PyList_Type  *，那么就调用PyList_Type中定义的pop操作；如果a的ob_type是一个PyDict_Type，那么就调用PyDict_Type中定义的pop操作。</p>
<blockquote>
<p><strong>所以变量a在不同的情况下，会表现出不同的行为，这正是Python多态的核心所在。</strong></p>
</blockquote>
<p>再比如列表，其内部的元素都是PyObject *，当我们通过索引获取到该指针进行操作的时候，会先通过ob_type获取其类型指针，然后再获取该操作对应的C一级的函数、进行执行，如果不支持相应的操作便会报错。</p>
<p><strong>从这里我们也能看出来Python为什么慢了，因为有相当一部分时间浪费在类型和属性的查找上面。</strong></p>
<blockquote>
<p><strong>以变量a +  b为例，这个a和b指向的对象可以是整型、浮点型、字符串、列表、元组、甚至是我们自己实现了某个魔法方法的类的实例对象，因为我们说Python中的变量都是一个PyObject *，所以它可以指向任意的对象，因此Python它就无法做基于类型方面的优化。</strong></p>
<p><strong>首先Python要通过ob_type判断变量到底指向的是什么类型，这在C级至少需要一次属性查找。然后Python将每一个操作都抽象成了一个魔法方法，所以实例相加时要在对应的类型对象中找到该方法对应的函数指针，这又是一次属性查找。找到了之后将a、b作为参数传递进去，这会发生一次函数调用，会将a和b中维护的值拿出来进行运算，然后根据相加结果创建一个新的对象，再返回其对应的PyObject *指针。</strong></p>
<p><strong>而对于C来讲，由于已经规定好了类型，所以a + b在编译之后就是一条简单的机器指令，所以两者在效率上差别很大。</strong></p>
</blockquote>
<p><strong>当然我们不是来吐槽Python效率的问题的，因为任何语言都擅长的一面和不擅长的一面，只是通过回顾前面的知识来解释为什么Python效率慢。</strong></p>
<blockquote>
<p><strong>因此当别人问你Python为什么效率低的时候，希望你能从这个角度来回答它。不要动不动就GIL，那是在多线程情况下才需要考虑的问题，所以有时真的很反感那些在没涉及到多线程的时候还提Python GIL的人。</strong></p>
</blockquote>
<p><strong>简单回顾了一下前面的内容，下面我们说一说Python中的对象从创建到销毁的过程，了解一下Python中对象的生命周期。</strong></p>
<h3 id="Python-x2F-C-API"><a href="#Python-x2F-C-API" class="headerlink" title="Python&#x2F;C API"></a>Python&#x2F;C API</h3><p>当我们在控制台敲下这个语句的时候，Python内部是如何从无到有创建一个浮点数对象的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; e = 2.71</span><br></pre></td></tr></table></figure>

<p>另外Python又是怎么知道该如何将它打印到屏幕上面呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(e)</span><br><span class="line">2.71</span><br></pre></td></tr></table></figure>

<p>对象使用完毕时，Python还要将其销毁，那么销毁的时机又该如何确定呢？带着这些问题，我们来探寻一个对象从创建到销毁整个生命周期中的行为表现，然后从中寻找答案。</p>
<p>不过在探寻对象的创建之前，先介绍Python提供的C API，也叫Python&#x2F;C API。</p>
<p>Python对外提供了C API，让用户可以从C环境中与其交互。实际上，由于Python解释器是用C写成的，所以Python内部本身也在大量使用这些C API。为了更好的研读源码，系统地了解这些API的组成结构是很有必要的，而C API分为两类：<font color="red">泛型API和特型API</font></p>
<p><font color="red"><strong>泛型API</strong></font></p>
<p>“泛型API”与类型无关，属于”抽象对象层(Abstract Object Layer，AOL)”，这类API的第一个参数是PyObject  *，可以处理任意类型的对象，API内部会根据对象的类型进行区别处理。而且泛型API名称也是有规律的，具有PyObject_xxx这种形式。</p>
<p>以对象打印函数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PyObject_Print</span><span class="params">(PyObject *op, FILE *fp, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<p>接口的第一个参数为待打印的对象的指针，可以是任意类型的对象的指针，因此参数类型是PyObject *。而我们说PyObject  *是Python底层的一个泛型指针，通过这个泛型指针来实现多态的机制。第二个参数是文件句柄，表示输出的位置，默认是stdout、即控制台；而flags表示是要以<code>__str__</code>打印还是要以<code>__repr__</code>打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有两个PyObject *, fo和lo</span></span><br><span class="line"><span class="comment">// fo指向PyFloatObject, lo指向PyLongObject, 但是它们在打印的时候都可以调用这个相同的打印方法</span></span><br><span class="line">PyObject_Print(fo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">PyObject_Print(lo, <span class="built_in">stdout</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PyObject_Print接口内部会根据对象类型，决定如何输出对象。</strong></p>
<p><font color="red"><strong>特型API</strong></font></p>
<p>特型API与类型相关，属于”具体对象层(Concrete Object Layer，COL)”。这类API只能作用于某种具体类型的对象，比如：浮点数PyFloatObject，而Python内部为每一种内置对象的实例对象都提供了很多的特型API。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过C的中double创建PyFloatObject</span></span><br><span class="line">PyObject* <span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过C中的long创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromLong</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="comment">// 通过C中的char *来创建PyLongObject</span></span><br><span class="line">PyObject* <span class="title function_">PyLong_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **pend, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure>

<p><strong>特型API也是有规律的，尤其是关于C类型和Python类型互转的时候，会用到以下两种特型API：</strong></p>
<ul>
<li><code>Py###_From@@@: 根据C的对象创建Python的对象，###表示Python的类型， @@@表示C的类型，比如PyFloat_FromDouble表示根据C中的double创建Python的float。</code></li>
<li><code>Py###_As@@@: 根据Python的对象创建C的对象,  ###表示Python的类型，@@@表示C的类型，比如PyFloat_AsDouble表示根据Python的float创建C的double;  PyLong_AsLong表示根据Python中的int创建C中的long，因为Python中的int是没有长度限制的，所以在底层使用的是PyLongObject，而不是PyIntObject。</code></li>
</ul>
<p><strong>了解了Python&#x2F;C API之后，我们看对象是如何创建的。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>经过前面的理论学习，我们知道对象的 ** <font color="red">元数据</font>保存在对应的<font color="red">类型对象</font>，元数据当然也包括对象如何创建等信息。</strong></p>
<blockquote>
<p><strong>比如执行pi &#x3D; 3.14，那么这个过程都发生了什么呢？首先解释器会根据3.14推断出要创建的对象是浮点数，所以会创建出维护的值为3.14的PyFloatObject，并将其指针转化成PyObject *交给变量pi。</strong></p>
<p><strong>另外需要注意的是，我们说对象的元数据保存在对应的类型对象中，这就意味着对象想要被创建是需要借助对应的类型对象的，但是这是针对于创建我们自定义的类的实例对象而言。创建内置类型的实例对象是直接创建的，至于为什么，我们下面会说。</strong></p>
</blockquote>
<p><strong>而创建对象的方式有两种，一种是通过”泛型API”创建，另一种是通过”特型API”创建。比如创建一个浮点数：</strong></p>
<p><font color="cornflowerblue"><strong>使用泛型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyObject_New(PyObject, &amp;PyFloat_Type);</span><br></pre></td></tr></table></figure>

<p><font color="cornflowerblue"><strong>使用特型API创建：</strong></font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* pi = PyFloat_FromDouble(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyTupleObject</span></span><br><span class="line">PyObject* tpl = PyTuple_New(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//创建一个内部可以容纳5个元素的PyListObject, 当然了这是初始容量, 列表可以扩容的</span></span><br><span class="line">PyObject* tpl = PyList_New(<span class="number">5</span>);    </span><br></pre></td></tr></table></figure>

<p>但不管采用哪种方式创建，最终的关键步骤都是分配内存，而创建内置类型的实例对象，Python是可以直接分配内存的。因为它们有哪些成员在底层都是写死的，而Python对它们了如指掌，因此可以通过Python&#x2F;C  API直接分配内存并初始化。以PyFloat_FromDouble为例，直接在接口内部为PyFloatObject结构体实例分配内存，并初始化相关字段即可。</p>
<blockquote>
<p><strong>比如：pi &#x3D; 3.14，解释器通过3.14知道要创建的对象是PyFloatObject，那么直接根据PyFloatObject里面的成员算一下就可以了，一个引用计数<code>(ob_refcnt)</code> + 一个指针<code>(ob_type)</code> + 一个double<code>(ob_fval)</code> 显然是24个字节，所以直接就分配了。然后将ob_refcnt始化为1，ob_type设置为&amp;PyFloat_Type，ob_fval设置为3.14即可。</strong></p>
<p><strong>同理可变对象也是一样，因为成员都是固定的，类型、以及内部容纳的元素有多少个也可以根据赋的值得到，所以内部的所有元素<code>(PyObject \*)</code>占用了多少内存也是可以算出来的，因此也是可以直接分配内存的。</strong></p>
</blockquote>
<p>但对于我们自定义的类型就不行了，假设我们通过class Girl:定义了一个类，显然实例化的时候不可能通过<code>PyGirl_New</code>、或者<code>PyObject_New(PyObject, &amp;PyGirl_Type)</code>这样的API去创建，因为根本就没有PyGirl_New这样的API，也没有PyGirl_Type这个类型对象。这种情况下，创建Girl的实例对象就需要Girl这个类型对象来创建了。因此自定义类的实例对象如何分配内存、如何进行初始化，答案是需要在对应的类型对象里面寻找的。</p>
<p><strong>总的来说：Python内部创建一个对象的方法有两种：</strong></p>
<ul>
<li><code>通过Python/C API，可以是泛型API、也可以是特型API，用于内置类型；</code></li>
<li><code>通过对应的类型对象去创建，多用于自定义类型；</code></li>
</ul>
<p>​        抛出个问题: e &#x3D; 2.71 和 e &#x3D; float(2.71)得到的结果都是2.71，但它们之间有什么不同呢。或者说列表: lst &#x3D; [] 和 lst &#x3D; list()得到的lst也都是一个空列表，但这两种方式有什么区别呢？    </p>
<p>我们说创建实例对象可以通过Python&#x2F;C API，用于内置类型；也可以通过对应的类型对象去创建，多用于自定义类型。但是通过对应类型对象去创建实例对象其实是一个更加通用的流程，因为它除了支持自定义类型之外、还支持内置类型。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst = []  # 通过Python/C API创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; lst = list()  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; e = 2.71  # 通过Python/C API创建 </span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt; e = float(2.71)  # 通过类型对象创建</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">2.71</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到了对象的两种创建方式，我们写上2.71、或者[]，Python会直接解析成底层对应的数据结构；而float(2.71)、或者list()，虽然结果是一样的，但是我们看到这是一个调用，因此要进行参数解析、类型检测、创建栈帧、销毁栈帧等等，所以开销会大一些。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = []</span><br><span class="line">t2 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t2 - t1)  <span class="comment"># 0.5595989</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t3 = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    lst = <span class="built_in">list</span>()</span><br><span class="line">t4 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(t4 - t3)  <span class="comment"># 1.1722419999999998</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>通过[]的方式创建一千万次空列表需要0.56秒，但是通过list()的方式创建一千万次空列表需要1.17秒，主要就在于list()是一个调用，而[]直接会被解析成底层对应的PyListObject，因此[]的速度会更快一些。同理3.14和float(3.14)也是如此。</strong></p>
</blockquote>
<p><strong>虽说使用Python&#x2F;C API的方式创建的速度会更快一些，但这是针对内置类型而言。以我们上面那个自定义了Girl为例，如果想创建一个Girl的实例对象，除了通过Girl这个类型对象去创建，你还能想到其它方式吗？</strong></p>
<blockquote>
<p><strong>列表的话：可以list()、也可以[]；元组：可以tuple()、也可以()；字典：可以dict()、也可以{}，前者是通过类型对象去创建的，后者是通过Python&#x2F;C API创建，会直接解析为对应的C一级数据结构。因为这些结构在底层都是已经实现好了的，是可以直接用的，无需通过调用的方式。</strong></p>
<p><strong>但是显然自定义类型就没有这个待遇了，它的实例对象只能通过它自己去创建，比如：Girl这个类，Python不可能在底层定义一个PyGirlObject、然后把API提供给我们。所以，我们只能通过Girl()这种方式去创建Girl的实例对象。</strong></p>
</blockquote>
<p><strong>所以我们需要通过Girl这个类来创建它的实例对象，也就是调用Girl这个类，而一个对象可以是可调用的，也可以是不可调用的。如果一个对象可以被调用，那么这个对象就是callable，否则就不是callable。</strong></p>
<p><strong>而决定一个对象是不是callable，就取决于其对应的类型对象中是否定义了某个方法。如果从Python的角度看的话，这个方法就是<code>__call__</code>，从解释器角度看的话，这个方法就是tp_call。</strong></p>
<p><font color="red"><strong>1. 从Python的角度来看对象的调用：</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int可以调用, 那么它的类型对象(type)内部一定有__call__方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(<span class="built_in">type</span>, <span class="string">&quot;__call__&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 因为我们自定义的类A里面没有__call__, 所以a是不可以被调用的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 告诉我们A的实例对象不可以被调用</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;A&#x27; object is not callable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们给A设置了一个__call__</span></span><br><span class="line"><span class="built_in">type</span>.__setattr__(A, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="comment"># 发现可以调用了</span></span><br><span class="line"><span class="built_in">print</span>(a())  <span class="comment"># 这是__call__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这就是动态语言的特性, 即便在类创建完毕之后, 依旧可以通过type进行动态设置</span></span><br><span class="line"><span class="comment"># 而这在静态语言中是不支持的, 所以type是所有类的元类, 它控制了我们自定义类的生成过程</span></span><br><span class="line"><span class="comment"># type这个古老而又强大的类可以让我们玩出很多新花样</span></span><br><span class="line"><span class="comment"># 但是对于内置的类type是不可以对其动态增加、删除或者修改的，因为内置的类在底层是静态定义好的</span></span><br><span class="line"><span class="comment"># 因为从源码中我们看到, 这些内置的类、包括元类，它们都是PyTypeObject对象, 在底层已经被声明为全局变量了</span></span><br><span class="line"><span class="comment"># 所以type虽然是所有类型对象的元类，但是只有在面对我们自定义的类的时候，type具有增删改的能力</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">type</span>.__setattr__(<span class="built_in">dict</span>, <span class="string">&quot;__call__&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;这是__call__&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;dict&#x27;</span></span><br><span class="line"><span class="comment"># 我们看到抛异常了, 提示我们&quot;不可以给内置/扩展类型dict设置属性&quot;</span></span><br><span class="line"><span class="comment"># 而dict属于内置类型，至于扩展类型是我们在编写扩展模块中定义的类</span></span><br><span class="line"><span class="comment"># 内置类和扩展类是等价的，它们直接就指向了C一级的数据结构, 不需要经历被解释器解释这一步</span></span><br><span class="line"><span class="comment"># 而动态特性是解释器在解释执行字节码(翻译成C级代码执行)的时候动态赋予的</span></span><br><span class="line"><span class="comment"># 而内置类/扩展类它们本身就已经是指向C一级的数据结构了，绕过了解释器解释执行这一步, 所以它们的属性不能被动态设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__dict__[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 它们的属性字典也是不可以设置的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>: </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line">g.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="comment"># 实例对象我们也可以手动设置属性</span></span><br><span class="line"><span class="built_in">print</span>(g.a)  <span class="comment"># xx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 但是内置类型的实例对象是不可以的</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;list&#x27; object has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># 可能有人奇怪了，为什么不行呢？</span></span><br><span class="line"><span class="comment"># 答案是内置类型的实例对象没有__dict__属性字典, 有多少属性或方法底层已经定义好了，不可以动态添加</span></span><br><span class="line"><span class="comment"># 如果我们自定义类的时候，设置了__slots__, 那么效果和内置的类是相同的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(lst, <span class="string">&quot;__dict__&quot;</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>2. 从解释器的角度来看对象的调用：</strong></font></p>
<p><strong>我们以内置类型float为例，我们说创建一个PyFloatObject，可以通过3.14或者float(3.14)的方式。前者使用Python&#x2F;C  API创建，3.14直接被解析为C一级数据结构PyFloatObject的对象；后者使用类型对象创建，通过对float进行一个调用、将3.14作为参数，最终也得到指向C一级数据结构PyFloatObject的对象。Python&#x2F;C API的创建方式我们已经很清晰了，就是根据值来推断在底层应该对应哪一种数据结构，然后直接创建即可。我们重点看一下通过调用来创建实例对象的方式。</strong></p>
<p><strong>如果一个对象可以被调用，我们说它的类型对象中一定要有tp_call<code>(更准确的说成员tp_call的值一定一个是函数指针, 不可以是0)</code>，而PyFloat_Type是可以调用的，这就说明PyType_Type内部的tp_call是一个函数指针，这在Python的层面是上我们已经验证过了，下面我们就来看看。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="comment">//...                                          /* tp_hash */</span></span><br><span class="line">    (ternaryfunc)type_call,                     <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="green"><strong>我们看到在实例化PyType_Type的时候PyTypeObject内部的成员tp_call被设置成了type_call，这是一个函数指针，当我们调用PyFloat_Type的时候，会触发这个type_call指向的函数。</strong></font></p>
<p>因此float(3.14)在C层面上等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFloat_Type.ob_type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">//即：</span></span><br><span class="line">PyType_Type.tp_call(&amp;PyFloat_Type, args, kwargs);</span><br><span class="line"><span class="comment">// 而在创建PyType_Type的时候，给tp_call成员传递的是type_call, 因此最终相当于</span></span><br><span class="line">type_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>

<p><strong>调用参数通过args和kwargs两个对象传递，关于参数传递暂时先不展开，留到函数机制中再详细介绍。</strong></p>
<p><strong>然后我们围观一下type_call函数，它位于Object&#x2F;typeobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 如果我们调用的是float，那么显然这里的type就是&amp;PyFloat_Type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是声明一个PyObject *，显然这是要返回的实例对象的指针</span></span><br><span class="line">    PyObject *obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里的tp_new是什么估计有人已经猜到了，我们说__call__对应底层的tp_call</span></span><br><span class="line">    <span class="comment">//那么这里tp_new呢？然后对应Python中的__new__方法，这里是为实例对象分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;cannot create &#x27;%.100s&#x27; instances&quot;</span>,</span><br><span class="line">                     type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过tp_new分配空间，此时实例对象就已经创建完毕了，这里会返回其指针</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line">    <span class="comment">//类型检测，暂时不用管</span></span><br><span class="line">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断参数的，我们说这里的参数type是类型对象，但也可以是元类，元类也是由PyTypeObject结构体实例化得到的</span></span><br><span class="line">    <span class="comment">//元类在调用的时候执行的依旧是type_call，所以这里是检测type指向的是不是PyType_Type</span></span><br><span class="line">    <span class="comment">//如果是的话，那么实例化得到的obj就不是实例对象了，而是类型对象，要单独检测一下</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span><br><span class="line">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (kwds == <span class="literal">NULL</span> ||</span><br><span class="line">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="number">0</span>)))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，后面为了方便在Python层面就不提指针了，直接用实例对象代替了</span></span><br><span class="line">    <span class="comment">//但如果返回的不是，那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//拿到obj的类型</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//执行tp_init，显然这个tp_init就是__init__函数，这与Python中类的实例化过程是一致的。</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//执行tp_init, 设置参数</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//执行失败，将引入计数减1，然后将obj设置为NULL</span></span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回obj</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此从上面我们可以看到关键的部分有两个：</strong></p>
<ul>
<li><code>调用类型对象的tp_new函数指针指向的函数为实例对象申请内存。</code></li>
<li><code>调用tp_init函数指针指向的函数为实例对象进行初始化，也就是设置属性。</code></li>
</ul>
<p><strong>所以这对应Python中的<code>__new__</code>和<code>__init__</code>，我们说<code>__new__</code>是为实例对象开辟一份内存，然后返回指向这片内存<code>(对象)</code>的指针，会自动传递给<code>__init__</code>中的self。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        <span class="comment"># 写法非常固定，调用object.__new__(cls)就会创建Girl的实例对象</span></span><br><span class="line">        <span class="comment"># 因此这里的cls指的就是这里的Girl, 但是一定要返回, 因为__new__会将自己的返回值交给__init__中的self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl(<span class="string">&quot;古明地觉&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(g.name, g.age)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">__init__方法执行啦</span></span><br><span class="line"><span class="string">古明地觉 16</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>*<em>但是注意：__new__里面的参数要和__init__里面的参数保持一致，因为我们会先执行__new__，然后解释器会将__new__的返回值和我们传递的参数组合起来一起传递给self。因此__new__里面的参数位置除了cls之外，一般都会写*args和*<em>kwargs。</em></em></p>
<p><strong>然后再回过头来看一下type_call中的这几行代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//tp_new应该返回相应类型对象的实例对象(的指针)，但如果返回的不是</span></span><br><span class="line">    <span class="comment">//那么就不会执行tp_init，而是直接将这里的obj返回</span></span><br><span class="line">    <span class="comment">//这里不理解的话，我们后面会细说</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说tp_new应该返回该类型对象的实例对象指针，而且一般情况下我们是不写__new__的，会默认执行。但是我们一旦重写了，那么必须要手动返回object.<strong>new</strong>(cls)，那么如果我们不返回，或者返回其它的话，会怎么样呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__方法执行啦&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="comment"># 打印看看instance到底是个什么东东</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;instance:&quot;</span>, instance)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;type(instance):&quot;</span>, <span class="built_in">type</span>(instance))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正确做法是将instance返回, 但是我们不返回, 而是返回个123</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__方法执行啦</span></span><br><span class="line"><span class="string">instance: &lt;__main__.Girl object at 0x000002C0F16FA1F0&gt;</span></span><br><span class="line"><span class="string">type(instance): &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里面有很多可以说的点，首先就是__init__里面需要两个参数，但是我们没有传，却还不报错。原因就在于这个__init__压根就没有执行，因为__new__返回的不是Girl的实例对象。</strong></p>
<p><strong>通过打印instance，我们知道了object.<strong>new</strong>(cls)返回的就是cls的实例对象，而这里的cls就是Girl这个类本身，我们必须要返回instance，才会执行对应的__init__，否则__new__直接就返回了。我们来打印一下其返回值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法执行啦&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g, <span class="built_in">type</span>(g))  <span class="comment"># 123 &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到直接打印的就是123，所以再次总结一些tp_new和tp_init之间的区别，当然也对应__new__和__init__的区别：</strong></p>
<ul>
<li><code>tp_new：为该类型对象的实例对象申请内存，在Python的__new__方法中通过object.__new__(cls)的方式申请，然后将其返回。</code></li>
<li><code>tp_init：tp_new的返回值会自动传递给self，然后为self绑定相应的属性，也就是执行构造函数进行初始化。</code></li>
</ul>
<blockquote>
<p><strong>但如果tp_new返回的不是对应类型的实例对象指针，比如type_call中第一个参数接收的&amp;PyFloat_Type，但是tp_new中返回的却是PyLongObject类型的指针，所以此时就不会执行tp_init。</strong></p>
<p><strong>以Python为例，我们Girl中的__new__应该返回Girl的实例对象才对，但实际上返回了整型，因此类型不一致，所以不会执行__init__。</strong></p>
</blockquote>
<p><strong>所以通过类型对象去创建实例对象的整体流程如下：</strong></p>
<ul>
<li><code>1. 获取类型对象的类型对象，说白了就是元类，执行元类中的type_call指向的函数；</code></li>
<li><code>2.  tp_call会调用该类型对象的tp_new指向的函数，如果tp_new为NULL(实际上肯定不会NULL，但是我们假设为NULL)，那么会到tp_base指定的父类里面去寻找tp_new。在新式类当中，所有的类都继承自object，因此最终会找到一个不为NULL的tp_new。然后通过tp_new会访问对应类型对象中的tp_basicsize信息，继而完成申请内存的操作。这个信息记录着一个该对象的实例对象需要占用多大内存。在为实例对象分配空间之后，会将指向这片空间的指针交给tp_init；</code></li>
<li><code>3. 在调用type_new完成创建对象之后，流程就会转向PyLong_Type的tp_init，完成初始化对象的工作。当然这个tp_init也可能不被调用，原因我们上面已经分析过了；</code></li>
</ul>
<p><strong>所以我们说Python中__new__调用完了会自动调用__init__，而且还会将其返回值传递给__init__中的第一个参数。那是因为在type_call中先调用的tp_new，然后再调用的tp_init，同时将tp_new的返回值传进去了。从源码的角度再分析一遍：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//当我们创建一个类的实例对象的时候，会去调用元类的__call__方法，所以是这里的tp_call</span></span><br><span class="line">    <span class="comment">//比如Girl(&quot;古明地觉&quot;, 16) 等价于 type.__call__(Girl, &quot;古明地觉&quot;, 16)</span></span><br><span class="line">    <span class="comment">//所以走到了这一步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用__new__方法， 拿到其返回值</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用__init__，将返回值obj传递给__init__中的self，并在里面设置属性</span></span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此底层所表现出来的和我们在Python中看到的，是一样的。</strong></p>
<h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><p>​        我们说Python创建一个对象，比如PyFloatObject，会分配内存并进行初始化。然后Python内部会统一使用一个叫做PyObject*的泛型指针来保存和维护这个对象，而不是PyFloatObject *。    </p>
<p>​    	通过PyObject *保存和维护对象，可以实现更加抽象的上层逻辑，而不用关心对象的实际类型和实现细节。比如：哈希计算 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数可以计算任意对象的哈希值，而不用关心对象的类型是啥，它们都可以使用这个函数。</p>
<p><strong>但是不同类型的对象，其行为也千差万别，哈希值计算的方式也是如此，那么PyObject_Hash函数是如何解决这个问题的呢？不用想，因为元信息存储在对应的类型对象之中，所以肯定会通过其ob_type拿到指向的类型对象。而类型对象中有一个成员叫做tp_hash，它是一个函数指针，指向的函数专门用来计算其实例对象的哈希值，我们看一下PyObject_Hash的函数定义吧，它位于Object&#x2F;Object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/Object.c</span></span><br><span class="line">Py_hash_t</span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//Py_TYPE是一个宏，用来获取一个PyObject *内部的ob_type，不过从名字也能看出来</span></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(v);</span><br><span class="line">    <span class="comment">//获取对应的类型对象内部的tp_hash方法，tp_hash是一个函数指针</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果tp_hash不为空,证明确实指向了具体的hash函数，那么拿到拿到函数指针之后，通过*获取对应的函数</span></span><br><span class="line">        <span class="comment">//然后将PyObject *传进去计算哈希值，返回。</span></span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果tp_hash为空，那么有两种可能。1. 说明该类型对象可能还未初始化, 导致tp_hash暂时为空; 2. 说明该类型本身就不支持其&quot;实例对象&quot;被哈希</span></span><br><span class="line">    <span class="comment">// 如果是第1种情况，那么它的tp_dict、也就是属性字典一定为空，tp_dict是动态设置的，因此它若为空，是该类型对象没有初始化的重要特征</span></span><br><span class="line">    <span class="comment">//如果它不为空，说明类型对象一定已经被初始化了，所以此时tp_hash为空，就真的说明该类型不支持实例对象被哈希</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，那么先进行类型的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后再看是否tp_hash是否为空，为空的话，说明不支持哈希</span></span><br><span class="line">        <span class="comment">//不为空则调用对应的哈希函数</span></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里代表以上条件都不满足，说明该对象不可以被hash</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数先通过ob_type指针找到对象的类型，然后通过类型对象的tp_hash函数指针调用对应的哈希计算函数。所以PyObject_Hash根据对象的类型，调用不同的哈希函数，这不正是实现了多态吗？</strong></p>
<blockquote>
<p><strong>通过ob_type字段，Python在C语言的层面实现了对象的多态特性，思路跟C++中的”虚表指针”有着异曲同工之妙。</strong></p>
</blockquote>
<p><strong>另外可能有人觉得这个函数的源码写的不是很精简，比如一开始已经判断过内部的tp_hash是否为NULL，然后在下面又判断了一次。那么可不可以先判断tp_dict是否为NULL，为NULL进行初始化，然后再判断tp_hash是否NULL，不为NULL的话执行tp_hash。这样的话，代码会变得精简很多。</strong></p>
<blockquote>
<p><strong>答案是可以的，而且这种方式似乎更直观，但是效率上不如源码。因为我们这种方式的话，无论是什么对象，都需要判断其类型对象中tp_dict和tp_hash是否为NULL。而源码中先判断tp_hash是否为NULL，不为NULL的话就不需要再判断tp_dict了；如果tp_hash为NULL，再判断是否tp_dict也为NULL，如果tp_dict为NULL则初始化，再进一步再判断tp_hash是否还是NULL。所以对于已经初始化<code>(tp_hash不为NULL)</code>的类型对象，源码中少了一次对tp_dict是否为NULL的判断，所以效率会更高。</strong></p>
<p><strong>当然这并不是重点，我想说的重点是类似于<code>先判断tp_hash是否为空、如果不为空则直接调用</code>这种方式，叫做CPython中的快分支。而且CPython中还有很多其它的快分支，快分支的特点就是命中率极高，可以尽早做出判断、尽早处理。回到当前这个场景，只有当类型未被初始化的时候，才会不走快分支，而其余情况都走快分支。也就是说快分支只有在第一次调用的时候才可能不会命中，其余情况都是命中，因此没有必要每次都对tp_dict进行判断。所以源码的设计是非常合理的，我们在后面分析函数调用的时候，也会看到很多类似于这样的快分支。</strong></p>
<p><strong>再举个生活中的栗子解释一下快分支：好比你去见心上人，但是心上人说你今天没有打扮，于是你又跑回去打扮一番之后再去见心上人。所以既然如此，那为什么不能先打扮完再去见心上人呢？答案是在绝大部分情况下，即使你不打扮，心上人也不会介意，只有在极少数情况下，比如心情不好，才会让你回去打扮之后再过来。所以不打扮直接去见心上人就能牵手便属于快分支，它的特点就是命中率极高，绝大部分都会走这个情况，所以没必要每次都因为打扮耽误时间，只有在极少数情况下快分支才不会命中。</strong></p>
</blockquote>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p>这里说一句，关于对象我们知道Python中的类型对象和实例对象都属于对象，但是我们更关注的是实例对象的行为。</p>
<p>而不同对象的行为不同，比如hash值的计算方法就不同，由类型对象中tp_hash字段决定。但除了tp_hash，PyTypeObject中还定义了很多函数指针，这些指针最终都会指向某个函数，或者为空表示不支持该操作。这些函数指针可以看做是”类型对象”中定义的操作，这些操作决定了其”实例对象”在运行时的”行为”。虽然所有类型对象在底层都是由同一个结构体PyTypeObject实例化得到的，但内部成员接收的值不同，得到的类型对象就不同；类型对象不同，导致其实例对象的行为就不同，这也正是一种对象区别于另一种对象的关键所在。</p>
<blockquote>
<p><strong>比如列表支持append，这说明在PyList_Type中肯定有某个函数指针，能够找到用于列表append操作的函数。</strong></p>
<p><strong>整型支持除法操作，说明PyLong_Type中也有对应除法操作的函数指针。</strong></p>
<p><strong>整型、浮点型、字符串、元组、列表都支持加法操作，说明它们也都有对应加法操作的函数指针，并且类型不同，也会执行不同的加法操作。比如：1 + 1 &#x3D; 2，”xx” + “yy” &#x3D;  “xxyy”，不可能对字符串使用整型的加法操作。而字典不支持加法操作，说明创建PyDict_Type的时候，没有给相应的结构体成员设置函数指针，可能传了一个空。</strong></p>
</blockquote>
<p><strong>而根据支持的操作不同，Python中可以将对象进行以下分类：</strong></p>
<ul>
<li><code>数值型操作：比如整型、浮点型的加减乘除；</code></li>
<li><code>序列型操作：比如字符串、列表、元组的通过索引、切片取值行为；</code></li>
<li><code>映射型操作：比如字典的通过key映射出value，相当于y = f(x)，将x传进去映射出y；另外有一本专门讲Python解释器的书，基于Python2.5，书中的这里不叫映射型，而是叫关联型。但我个人喜欢叫映射型，所以差不多都是一个东西，理解就可以。</code></li>
</ul>
<p>​        <strong>而这三种操作，PyTypeObject中分别定义了三个指针。每个指针指向一个结构体实例，这个结构体实例中有大量的成员，成员也是函数指针，指向了具体的函数。</strong>    </p>
<p><strong>我们看一下定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    PyNumberMethods *tp_as_number;  <span class="comment">// 数值型相关操作</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;   <span class="comment">// 序列型相关操作</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;  <span class="comment">// 映射型相关操作</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下tp_as_number，它是PyNumberMethods类型的结构体指针：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">       arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">       in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="type">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p>​        <strong>你看到了什么，是的，这不就是python里面的魔法方法嘛。在PyNumberMethods里面定义了作为一个数值应该支持的操作。如果一个对象能被视为数值对象，比如整数，那么在其对应的类型对象PyLong_Type中，tp_as_number -&gt;  nb_add就指定了对该对象进行加法操作时的具体行为。同样，PySequenceMethods和PyMappingMethods中分别定义了作为一个序列对象和映射对象应该支持的行为，这两种对象的典型例子就是list和dict。所以，只要 类型对象 提供相关 操作 ， 实例对象 便具备对应的 行为 。</strong>    </p>
<p><strong>然而对于一种类型来说，它完全可以同时定义三个函数中的所有操作。换句话说，一个对象既可以表现出数值对象的特征，也可以表现出映射对象的特征。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Int(<span class="number">1</span>)</span><br><span class="line">b = Int(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;(嘎~嘎~嘎~)&quot;</span>])  <span class="comment"># (嘎~嘎~嘎~)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看上去a[“”]这种操作是一个类似于dict这样的对象才支持的操作。从int继承出来的Int自然是一个数值对象，但是通过重写__getitem__这个魔法函数，可以视为指定了Int在python内部对应的PyTypeObject对象的tp_as_mapping -&gt;  mp_subscript操作。最终Int实例对象表现的像一个map一样。归根结底就在于PyTypeObject中允许一种类型对象同时指定多种不同的行为特征。  默认使用PyTypeObject结构体实例化出来的PyLong_Type对象所生成的实例对象是不具备list和dict的属性特征的，但是我们继承PyLong_Type，同时指定__getitem__，使得我们自己构建出来的类型对象所生成的实例对象，同时具备int、list(部分)、dict(部分)的属性特征，就是因为python支持同时指定多种行为特征。</strong>     </p>
<p><strong>我们以浮点型为例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们看到了该类型对象在创建时，给成员tp_as_number，传入了一个float_as_number指针</span></span><br><span class="line"><span class="comment">//那么这个float_as_number指针就应该指向一个PyNumberMethods结构体实例</span></span><br><span class="line"><span class="comment">//而指向的结构体实例中也应该有大量和浮点数运算相关的函数指针，每个函数指针指向了浮点数运算相关的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//里面的float_add、float_sub、float_mul等等显然都是已经定义好的函数的指针</span></span><br><span class="line"><span class="comment">//然后创建PyNumberMethods结构体实例float_as_number的时候，分别赋值给了成员nb_add、nb_substract、nb_multiply等等等等</span></span><br><span class="line"><span class="comment">//创建完浮点数相关操作的PyNumberMethods结构体实例float_as_number之后，将其指针交给PyFloat_Type中的tp_as_number成员</span></span><br><span class="line"><span class="comment">//所以浮点数相加的时候，会执行object -&gt; ob_type -&gt; tp_as_number -&gt; nb_add, 而浮点类型对象的tp_as_number就是&amp;float_as_number</span></span><br><span class="line"><span class="comment">//所以再获取其成员nb_add的时候，拿到的就是float_add指针，然后调用float_add函数</span></span><br></pre></td></tr></table></figure>

<p><strong>所以PyFloat_Type是支持数值型操作的，但是我们看到tp_as_sequence和tp_as_mapping这两个成员接收到的值则不是一个函数指针，而是0，相当于空。因此float对象、即浮点数不支持序列型操作和映射型操作，比如：pi &#x3D;  3.14，我们无法使用len计算长度、无法通过索引或者切片获取指定位置的值、无法通过key获取value，这和我们使用Python时候的表现是一致的。</strong></p>
<blockquote>
<p><strong>我们看到PyFloat_Type中tp_as_number指向的结构体中的nb_add成员对应的函数指针是float_add，但如果是PyLong_Type的话，那么nb_add对应的函数指针则是long_add。</strong></p>
<p><strong>不同对象，使用的操作是不同的。整型相加，使用的肯定是long_add，浮点型相加使用的是float_add。</strong></p>
</blockquote>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在c和c++中，程序员被赋予了极大的自由，可以任意的申请内存。但是权利的另一面对应着责任，程序员最后不使用的时候，必须负责将申请的内存释放，并释放无效指针。可以说，这一点是万恶之源，大量内存泄漏、悬空指针、越界访问的bug由此产生。</p>
<p>现代的开发语言当中都有垃圾回收机制，语言本身负责内存的管理和维护，比如C#和golang。垃圾回收机制将开发人员从维护内存分配和清理的繁重工作中解放出来，但同时也剥夺了程序员和内存亲密接触的机会，并牺牲了一定的运行效率。但好处就是提高了开发效率，并降低了bug发生的几率。Python里面同样具有垃圾回收机制，代替程序员进行繁重的内存管理工作，而引用计数正是垃圾收集机制的一部分。</p>
<p>python通过对一个对象的引用计数的管理来维护对象在内存中的存在与否。我们知道Python中每一个东西都是一个对象，都有一个ob_refcnt成员。这个成员维护这该对象的引用计数，从而也最终决定着该对象的创建与消亡。</p>
<p>​        在python中，主要是通过Py_INCREF(op)和Py_DECREF(op)两个宏，来增加和减少一个对象的引用计数，当一个对象的引用计数减少到0后，Py_DECREF将调用该对象的析构函数来释放该对象所占有的内存和系统资源。这个析构函数就是对象的类型对象(Py***_Type)中定义的函数指针来指定的，也就是tp_dealloc。    </p>
<p>​        如果熟悉设计模式中的Observer模式，就可以看到，这里隐隐约约透着Observer模式的影子。在ob_refcnt减少到0时，将触发对象的销毁事件。从python的对象体系来看，各个对象提供了不同事件处理函数，而事件的注册动作正是在各个对象对应的类型对象中完成的。    </p>
<p><strong>我们在研究对象的行为的时候，说了比起类型对象，我们更关注实例对象的行为。那么对于引用计数也是一样的，只有实例对象，我们探讨引用计数才是有意义的。类型对象<code>(内置)</code>是超越引用计数规则的，永远都不会被析构，或者销毁，因为它们在底层是被静态定义好的。同理，我们自定义的类，虽然可以被回收，但是探讨它的引用计数也是没有价值的。我们以内置类型对象int为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># del关键字只能作用于变量, 不可以作用于对象</span></span><br><span class="line"><span class="comment"># 比如：pi = 3.14, 你可以del pi, 但是不可以del 3.14, 这是不符合语法规则的</span></span><br><span class="line"><span class="comment"># 而int虽然我们说它是整型的类型对象, 但这是从Python的层面</span></span><br><span class="line"><span class="comment"># 如果从底层来讲, int它也是一个变量, 指向了对应的数据结构(PyLong_Type)</span></span><br><span class="line"><span class="comment"># 既然是变量, 那么就可以删除, 但是这个删除并不是直接删除对象，而是将变量指向的对象的引用计数减去1，然后将这个变量也给删掉。</span></span><br><span class="line"><span class="comment"># Python中的对象是否被删除是通过其引用计数是否为0决定的, &quot;del 变量&quot;只是删除了这个变量，让这个变量不再指向该对象罢了</span></span><br><span class="line"><span class="comment"># 所以&quot;del 变量&quot;得到的结果就是我们没办法再使用这个变量了，这个变量就没了，但是变量之前指向的对象是不是也没了就看还有没有其它的引用也指向它。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;int&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 神奇的事情发生了, 告诉我们int这个变量没有被定义</span></span><br><span class="line"><span class="comment"># 原因就在于del关键字不会删除内置作用域里面的变量</span></span><br><span class="line"><span class="comment"># 我们看一下int的引用计数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(<span class="built_in">int</span>))  <span class="comment"># 138</span></span><br></pre></td></tr></table></figure>

<p><strong>惊了，居然有130多个变量在指向int，这130多个变量分别都是谁我们就无需关注了，找出这130多个变量显然是一件很恐怖的事情。</strong></p>
<blockquote>
<p><strong>总之，我们探讨类型对象的引用计数是没有太大意义的，而且内置类型对象是超越了引用计数的规则的，所以我们没必要太关注，我们重心是在实例对象上。我们真正的操作也都是依赖实例对象进行操作的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span>  <span class="comment"># 创建一个新对象，显然此时的引用计数为1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 估计有人好奇了，为啥引用计数是2, 难道不是1吗？因为e这个变量作为参数传到了sys.getrefcount这个函数里面</span></span><br><span class="line">   <span class="comment"># 所以函数里面的参数也指向2.71这个PyFloatObject，所以引用计数加1。当函数结束后，局部变量被销毁，再将引用计数减1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e1 = e  <span class="comment"># 变量间的传递会传递指针，所以e1也会指向2.71这个浮点数，因此它的引用计数加1。</span></span><br><span class="line">		   <span class="comment"># 注意：我们说变量只是个符号，引用计数是针对变量指向的对象而言的，变量本身没有所谓的引用计数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  <span class="comment"># 此时变量指向的对象的引用计数为3(sys.getrefcount函数参数对&quot;对象&quot;的引用也算在内)</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e1)  <span class="comment"># 我们说操作变量相当于操作变量指向的对象,e和e1都指向同一个对象，所以获取也是同一个对象的引用计数</span></span><br><span class="line"><span class="number">3</span>  <span class="comment"># 因此结果是一样的,都是3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [e, e1]  <span class="comment"># 放在容器里面，显然列表l中多了两个指针，这两个指针也指向这里的PyFloatObject对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">5</span>  <span class="comment"># 因此结果为5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l  <span class="comment"># 将列表删除、或者将列表清空，那么里面的变量也就没了，因此在删除变量的时候，会先将变量指向的对象的引用计数减去1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)  </span><br><span class="line"><span class="number">3</span>  <span class="comment"># 所以又变成了3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e1  <span class="comment"># 再删除一个变量，引用计数再减1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(e)</span><br><span class="line"><span class="number">2</span>  <span class="comment"># 结果为2，说明外部还有一个变量在引用它，因为这个浮点数不会被回收。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> e  <span class="comment"># 再次del，此时引用计数为0，这个浮点数就真的没了。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>另外，引用计数什么时候会加1，什么时候会减1，我们在上一篇博客中也说的很详细了，可以去看一下。</strong></p>
<p>​        <strong>关于引用计数，Python底层也提供了几个宏。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_NewReference(op) (                          \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span></span><br><span class="line"><span class="meta">    Py_REFCNT(op) = 1)<span class="comment">//对于新创建的对象，引用计数为1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">//引用计数为0时执行析构函数, Py_TYPE(op)-&gt;tp_dealloc获取析构函数对应的函数指针，再通过*获取指向的函数</span></span><br><span class="line"><span class="comment">//将传入PyObject *指针，将其回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++) <span class="comment">//引用计数自增1</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                             \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">            <span class="comment">//引用计数减1，如果减完1变成了0，则执行析构函数</span></span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//注意：Py_INCREF和Py_DECREF不可以处理NULL指针的，会报错</span></span><br><span class="line"><span class="comment">//所以又有两个宏，做了一层检测，会判断对象指针为NULL的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XINCREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xincref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xincref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_INCREF(_py_xincref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XDECREF(op)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                              \</span></span><br><span class="line"><span class="meta">        PyObject *_py_xdecref_tmp = (PyObject *)(op); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_py_xdecref_tmp != NULL)                  \</span></span><br><span class="line"><span class="meta">            Py_DECREF(_py_xdecref_tmp);               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然减少引用计数，除了Py_DECREF和Py_XDECREF之外，还有一个Py_CLEAR，也可以处理空指针的情况</span></span><br></pre></td></tr></table></figure>

<p><strong>因此这几个宏作用如下：</strong></p>
<ul>
<li><code>_Py_NewReference:  接收一个对象，将其引用计数设置为1，用于新创建的对象。此外我们在定义里面还看到了一个宏Py_REFCNT，这是用来获取对象引用计数的，当然除了Py_REFCNT之外，我们之前还见到了一个宏叫Py_TYPE，这是专门获取对象的类型的。</code></li>
<li><code>_Py_Dealloc: 接收一个对象, 执行该对象的类型对象里面的析构函数, 来对该对象进行回收。</code></li>
<li><code>Py_INCREF: 接收一个对象, 将该对象引用计数自增1。</code></li>
<li><code>Py_DECREF: 接收一个对象, 将该对象引用计数自减1。</code></li>
<li><code>Py_XINCREF: 和Py_INCREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_XDECREF: 和Py_DECREF功能一致，但是可以处理空指针。</code></li>
<li><code>Py_CLEAR: 和Py_XDECREF类似，也可以处理空指针。</code></li>
</ul>
<p>​        在一个对象的引用计数为0时，与该对象对应的析构函数就会被调用，但是要特别注意的是，我们刚才一致调用析构函数，会回收对象、销毁对象或者删除对象等等，意思都是将这个对象从内存中抹去，但是这并不意味着最终一定调用free释放空间，<strong>换句话说就是对象没了，但是对象占用的内存却有可能还在。</strong>如果对象没了，占用的内存也要释放的话，那么频繁申请、释放内存空间会使Python的执行效率大打折扣(更何况Python已经背负了人们对其执行效率的不满这么多年)。一般来说，Python中大量采用了<strong>内存对象池</strong>的技术，使用这种技术可以避免频繁地申请和释放内存空间。因此在析构的时候，只是将对象占用的空间归还到内存池中。Python在操作系统之上提供了一个内存池，说白了就是对malloc进行了一层封装，事先申请一部分内存，然后用于对象(占用内存低)的创建，这样就不必频繁地向操作系统请求空间了，从而大大的节省时间。<strong>这一点，在后面的Python内置类型对象(PyLongObject，PyListObject等等)的实现中，将会看得一清二楚。</strong>当然内存比较大的对象，还是需要向操作系统申请的，内存池只是用于那些内存占用比较小的对象的创建，因为这种对象显然没必要每次都和操作系统内核打交道。关于内存池，我们在后续系列中也会详细说。     </p>
<h3 id="python对象的分类"><a href="#python对象的分类" class="headerlink" title="python对象的分类"></a>python对象的分类</h3><p><strong>我们之前根据支持的操作，将Python对象分成了数值型、序列型、映射型，但其实我们是可以分为5类的：</strong></p>
<ul>
<li><code>Fundamental对象：类型对象，如int、float、bool</code></li>
<li><code>Numeric对象：数值对象，如int实例、float实例、bool实例</code></li>
<li><code>Sequence对象：序列对象，如str实例、list实例、tuple实例</code></li>
<li><code>Mapping对象：关联对象(映射对象)，如dict实例</code></li>
<li><code>Internal对象：python虚拟机在运行时内部使用的对象，如function实例(函数)、code实例(字节码)、frame实例(栈帧)、module实例(模块)、method实例(方法)，没错，函数、字节码、栈帧、模块、方法等等它们在底层一个一个类的实例对象。比如：函数的类型是&lt;class &#39;function&#39;&gt;，在底层对应PyFunctionObject，那么&lt;class  &#39;function&#39;&gt;的类型对象是什么呢？显然就是&lt;class &#39;type&#39;&gt;啦。</code></li>
</ul>
<p><strong>关于Internal对象，我们在后续系列中会细说。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一次我们说了Python中创建对象的两种方式，可以通过Python&#x2F;C  API创建，也可以通过类型对象创建。以及分析了对象的多态性，Python底层是如何通过C来实现多态，答案是通过ob_type。还说了对象的行为，对象进行某个操作的时候在底层发生了什么。最后说了引用计数，Python是通过引用计数来决定一个对象是否被回收的，但是有人知道它无法解决循环引用的问题。是的，所以Python中的gc就是为了解决这一点的，不过这也要等到介绍垃圾回收的时候再细说了。</p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Python整数的底层实现</title>
    <url>/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="05-Python整数的底层实现"><a href="#05-Python整数的底层实现" class="headerlink" title="05-Python整数的底层实现"></a>05-Python整数的底层实现</h2><p>这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？</p>
<p>既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。</p>
<h3 id="int实例对象的底层实现"><a href="#int实例对象的底层实现" class="headerlink" title="int实例对象的底层实现"></a>int实例对象的底层实现</h3><p><strong>Python中的整数底层对应的结构体是PyLongObject，它位于longobject.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合起来可以看成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125; PyLongObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把这个PyLongObject更细致的展开一下就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">//维护的元素个数</span></span><br><span class="line">    digit ob_digit[<span class="number">1</span>]; <span class="comment">//digit类型的数组,长度为1</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>别的先不说，就冲里面的ob_size我们就可以思考一番。首先Python中的整数有大小、但应该没有长度的概念吧，那为什么会有一个ob_size呢？从结构体成员来看，这个ob_size指的应该就是ob_digit数组的长度，而这个ob_digit数组显然只能是用来维护具体的值了。而数组的长度不同，那么对应的整数占用的内存也不同。所以答案出来了，整数虽然没有我们生活中的那种长度的概念，但它是个变长对象，因为不同的整数占用的内存可能是不一样的。</strong></p>
<p><strong>因此这个ob_size它指的是底层数组的长度，因为Python中整数对应的值在底层是使用数组来存储的。尽管它没有字符串、列表那种长度的概念，或者说无法对整型使用len方法，但它是个变长对象。</strong></p>
<p>​        <strong>那么下面的重点就在这个ob_digit数组了，我们要从它的身上挖掘信息，看看Python中整数对应的值(比如123)，是怎么放在这个数组里面的。不过首先我们要看看这个digit是个什么类型，它同样定义在longintrepr.h中</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PYLONG_BITS_IN_DIGIT是一个宏，如果你的机器是64位的，那么它会被定义为30，32位机器则会被定义为15</span></span><br><span class="line"><span class="comment">//至于这个宏是做什么的我们先不管</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而我们的机器现在基本上都是64位的，所以PYLONG_BITS_IN_DIGIT会等于30，因为digit等价于uint32_t<code>(unsigned int)</code>，所以它是一个无符号32位整型。</strong></p>
<p><strong>所以ob_digit这个数组是一个无符号32位整型数组，长度为1。当然这个数组具体多长则取决于你要存储的Python整数有多大，因为C中数组的长度不属于类型信息，你可以看成是长度n，而这个n是多少要取决于你的整数大小。显然整数越大，这个数组就越长，那么占用空间就越大。</strong></p>
<p>​        <strong>搞清楚了PyLongObject里面的所有成员，那么下面我们就来分析ob_digit是怎么存储Python中的整数，以及Python中的整数为什么不会溢出。</strong>    </p>
<p>​        <strong>不过说实话，关于Python的整数不会溢出这个问题，其实相信很多人已经有答案了，因为底层是使用数组存储的嘛，而数组的长度又没有限制，所以当然不会溢出啦。</strong>    </p>
<p>​        <strong>另外，还存在一个问题，那就是digit是一个无符号32位整型，那负数怎么存储？别着急，我们会举栗说明，将上面的疑问一一解答。</strong>    </p>
<p><strong>首先如果你是Python的设计者，要保证整数不会溢出，你会怎么办？我们把问题简化一下，假设有一个8位的无符号整数类型，我们知道它能表示的最大数字是255，但这时候如果我想表示256，要怎么办？</strong></p>
<p><strong>可能有人会想，那用两个数来存储不就好了。一个存储255，一个存储1，将这两个数放在数组里面。这个答案的话，虽然有些接近，但其实还有很大偏差：那就是我们并不能简单地按照大小拆分的，256拆分为255和1，要是265就拆分成255和10，而是要通过二进制的方式，我们来简单看一下。</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">我们知道<span class="number">8</span>位整数最大就是 <span class="number">2</span> ^ <span class="number">8</span> <span class="selector-tag">-</span> <span class="number">1</span>,也就是它的八位全部都是<span class="number">1</span>,结果是<span class="number">255</span></span><br><span class="line">所以<span class="number">255</span>对应的数组就是: <span class="selector-attr">[255]</span>, 因为此时一个<span class="number">8</span>位整数就能存下</span><br><span class="line"></span><br><span class="line">但如果是<span class="number">256</span>,那么<span class="number">8</span>位显然存不下了,此时就还需要一个位</span><br><span class="line">所以这个时候会使用两个<span class="number">8</span>位整数, 但并不是简单的相加, 而是使用一个新的<span class="number">8</span>位整数来模拟更高的位</span><br></pre></td></tr></table></figure>

<p>​        <strong>而Python底层也是类似这种做法，但是考虑的会更加全面。下面就以Python中的整数为例，看看底层数组的存储方式。</strong>    </p>
<p><strong>整数0：</strong></p>
<p><strong>注意：当要表示的整数为0时，ob_digit这个数组为空，不存储任何值，ob_size为0，表示这个整数的值为0，这是一种特殊情况。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002206919-1398161118.png" alt="img"></p>
<p><strong>整数1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002212476-1473281999.png" alt="img"></p>
<p><strong>当然存储的值为1时，ob_size的值就是1，此时ob_digit数组就是[1]。</strong></p>
<p><strong>整数-1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002220242-1580767637.png" alt="img"></p>
<p><strong>我们看到ob_digit数组没有变化，但是ob_size变成了-1，没错，整数的正负号是通过这里的ob_size决定的。ob_digit存储的其实是绝对值，无论n取多少，<code>-n</code>和<code>n</code>对应的ob_digit是完全一致的，但是ob_size则互为相反数。所以ob_size除了表示数组的长度之外，还可以表示对应整数的正负。</strong></p>
<p><strong>所以我们之前说整数越大，底层的数组就越长。更准确的说是绝对值越大，底层数组就越长。所以Python在比较两个整型的大小时，会先比较ob_size，如果ob_size不一样则可以直接比较出大小来。显然ob_size越大，对应的整数越大，不管ob_size是正是负，都符合这个结论，可以想一下。</strong></p>
<p><strong>整数2 ^ 30 -1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002228080-1963789840.png" alt="img"></p>
<p><strong>如果想表示2 ^30 - 1<code>(^这里代指幂运算,当然对于Python程序猿来说两个星号也是幂运算,表达的意义是一样的)</code>，那么也可以使用一个digit表示。虽然如此，但为什么突然举2 ^ 30 - 1这个数字呢？答案是，虽然digit是4字节、32位，但是Python只用30个位。</strong></p>
<blockquote>
<p><strong>之所以这么做是和加法进位有关系，如果32个位全部用来存储其绝对值，那么相加产生进位的时候，可能会溢出，比如有一个将32个位全部占满的整数<code>(2 ^ 32 - 1)</code>，即便它只加上1，也会溢出。这个时候为了解决这个问题，就需要先强制转换为64位再进行运算。</strong></p>
<p><strong>但如果只用30个位的话，那么加法是不会溢出的，或者说相加之后依旧可以用32位整数保存。因为30个位最大就是2 ^ 30 - 1，即便两个这样的值相加，结果也是(2 ^ 30 - 1) * 2，即：2 ^ 31 - 2。而32个位的话最大是2 ^ 32 - 1，所以肯定不会溢出的；如果一开始30个位就存不下，那么数组中会有两个digit。</strong></p>
</blockquote>
<p><strong>所以虽然将32位全部用完，可以只用一个digit表示更多、更大的整数，但是可能面临相加之后一个digit存不下的情况，于是只用30个位，如果数值大到30个位存不下的话，那么就会多使用一个digit。可能有人发现了，如果是用31个位的话，那么相加产生的最大值就是2 ^ 32 - 2，结果依旧可以使用一个32位整型存储啊，那Python为啥要牺牲两个位呢？答案是为了乘法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还记得这个宏吗？PYLONG_BITS_IN_DIGIT指的就是Python使用digit的位数</span></span><br><span class="line"><span class="comment">// 我们看到在32位机器上，digit相当于2字节、16位的整型，而它用了15位，只牺牲了一个位</span></span><br><span class="line"><span class="comment">// 64 位机器上则牺牲两个位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>整数2 ^ 30：</strong></p>
<p><strong>问题来了，我们说digit只用30位，所以2 ^ 30 - 1是一个digit能存储的最大值，那么现在是2 ^ 30，所以数组中就要有两个digit了。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002236296-672861305.png" alt="img"></p>
<p><em><em>我们看到此时就用两个digit来存储了，此时的数组里面的元素就是0和1，而且充当高位的放在后面，因为我们说了使用新的digit来模拟更高的位。由于一个digit只用30位，那么数组中第一个digit的最低位就是1，第二个digit的最低位就是31，第三个digit的最低位就是61，以此类推，所以如果ob_digit为[a, b, c]，那么对应的整数就为: a * 2 *</em> 0 + b * 2 *</em> 30 + c  * 2 ** 60，如果ob_digit不止3个，那么就按照30个位往上加，比如ob_digit还有第四个元素d，那么就再加上d * 2  ** 90即可。**</p>
<p><strong>再比如我们反推一下，如果a &#x3D; 88888888888，那么底层数组ob_digit中的值是多少？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="number">88888888888</span></span><br><span class="line"><span class="comment"># 我们说1个digit用30个位, 那么n个digit所能表示的最大整数就是2 ** (30 * n) - 1, 至于原因的话其实很好理解，但我们还是可以严格推导一下</span></span><br><span class="line"><span class="comment"># 我们以n = 2为例, 显然两个digit最高能表示 (2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30,</span></span><br><span class="line"><span class="comment"># 它等于 (2 ** 30 - 1) + (2 ** 60 - 2 ** 30) = 2 ** 60 - 1, 因此两个digit最大可以表示 2 ** 60 - 1</span></span><br><span class="line"><span class="comment"># 同理你可以n取3, 看看(2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30 + (2 ** 30 - 1) * 2 ** 60是不是等于2 ** 90 - 1</span></span><br><span class="line"><span class="comment"># 或者试试更大的数, 结论都是成立的</span></span><br><span class="line"><span class="built_in">print</span>(np.log2(a))  <span class="comment"># 36.37128404230425</span></span><br><span class="line"><span class="comment"># 36超过了30个位、但小于90个位, 因此需要两个digit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说 &quot;整数 = ob_digit[0] + ob_digit[1] * 2 ** 30 + ob_digit[2] * 2 ** 60 + ...&quot;</span></span><br><span class="line"><span class="comment"># 但是对于ob_digit长度为2的情况下, 这里的a = ob_digit[0] + ob_digit[1] * 2 ** 30</span></span><br><span class="line"><span class="built_in">print</span>(a // <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 82</span></span><br><span class="line"><span class="built_in">print</span>(a - <span class="number">82</span> * <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 842059320</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明此时底层对应的ob_digit数组就是[842059320, 82]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002245710-535862489.png" alt="img"></p>
<p><strong>我们修改解释器源代码重新编译，通过在创建整数的时候打印ob_digit里面的元素的值，也印证了这个结论。</strong></p>
<p>​        <strong>这个时候，我们可以分析整数所占的字节了。相信所有人都知道可以使用sys.getsizeof计算大小，但是这大小到底是怎么来的，估计会一头雾水。因为Python中对象的大小，是根据底层的结构体计算出来的。</strong>    </p>
<p>​        <strong>我们说ob_refcnt、ob_type、ob_size这三个是整数所必备的，它们都是8字节，加起来24字节。所以任何一个整数所占内存都至少24字节，至于具体占多少，则取决于ob_digit里面的元素都多少个。</strong>    </p>
<p>​        <strong>因此Python中整数所占内存 &#x3D; 24 + 4 * ob_digit数组长度</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是0的话, ob_digit数组为空, 所以此时就是24字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">0</span>))  <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是1的话, ob_digit数组有一个元素, 所以此时是24 + 4 = 28字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个digit只用30位, 所以最大能表示2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 如果是2 ** 30, 那么就需要两个元素, 所以是24 + 4 * 2 = 32字节</span></span><br><span class="line"><span class="comment"># 如果是两个digit, 那么能表示的最大整数就是2 ** 60 - 1</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span>))  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">60</span> - <span class="number">1</span>))  <span class="comment"># 32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">相信下面的不需要解释了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">60</span>))  <span class="comment"># 36</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof((<span class="number">1</span> &lt;&lt; <span class="number">90</span>) - <span class="number">1</span>))  <span class="comment"># 36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">90</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<h3 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h3><p><strong>由于分析过了浮点数以及浮点类型对象，因此int类型对象的实现以及int实例对象的创建啥的就不说了，可以自己去源码中查看，我们后面会着重介绍它的一些操作。还是那句话，Python中的API设计的很优美，都非常的相似，比如创建浮点数可以使用PyFloat_FromDouble、PyFloat_FromString等等，那么创建整数也可以使用PyLong_FromLong、PyLong_FromDouble、PyLong_FromString等等，直接去Objects中对应的源文件中查看即可。</strong></p>
<p><strong>这里说一下Python中的小整数对象池，我们知道Python中的整数属于不可变对象，运算之后会创建新的对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274354736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355024</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以这种做法就势必会有性能缺陷，因为程序运行时会有大量对象的创建和销毁。根据浮点数的经验，我们猜测Python应该也对整数使用了缓存池吧。答案是差不多，只不过不是缓存池，而是</strong><font color="red"><strong>小整数对象池</strong></font></p>
<p><strong>Python将那些使用频率高的整数预先创建好，而且都是单例模式，这些预先创建好的整数会放在一个静态数组里面，我们称为小整数对象池。如果需要使用的话会直接拿来用，而不用重新创建。注意：这些整数在Python解释器启动的时候，就已经创建了。</strong></p>
<p><strong>小整数对象池的实现位于longobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NSMALLPOSINTS宏规定了对象池中正数的个数 (从 0 开始，包括 0 )，默认 257 个；</code></li>
<li><code>NSMALLNEGINTS宏规定了对象池中负数的个数，默认5个；</code></li>
<li><code>small_ints是一个整数对象数组，保存预先创建好的小整数对象；</code></li>
</ul>
<p><strong>以默认配置为例，Python解释器在启动的时候就会预先创建一个可以容纳262个整数的数组，并会依次初始化 -5 到 256<code>(包括两端)</code>之间的262个PyLongObject。所以小整数对象池的结构如下：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002308727-1460169599.png" alt="img"></p>
<p><strong>但是为什么要实现缓存从-5到256之间的整数呢？因为Python认为这个范围内的整数使用频率最高，而缓存这些整数的内存相对可控。因此这只是某种权衡，很多程序的开发场景都没有固定的正确答案，需要根据实际情况来权衡利弊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140714000246400</span>, <span class="number">140714000246400</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>256位于小整数对象池内，所以全局唯一，需要使用的话直接去取即可，因此它们的地址是一样的。但是257不再小整数对象池内，所以它们的地址不一样。</strong></p>
<p><strong>我们上面是在交互式下演示的，但如果有小伙伴不是通过交互式的话，那么会得到出乎意料的结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>可能有人会好奇，为什么地址又是一样的了，257明明不在小整数对象池中啊。虽然涉及到了后面的内容，但是提前解释一下也是可以的。主要区别就在于一个是在交互式下执行的，另一个是通过 python3 xxx.py的方式执行的。</strong></p>
<blockquote>
<p><strong>首先Python的编译单元是函数，每个函数都有自己的作用域，在这个作用域中出现的所有常量都是唯一的，并且都位于常量池中，由co_consts指向。虽然我们上面的不是函数，而是在全局作用域中，但是全局你也可以看成是一个函数，它也是一个独立的编译单元。同一个编译单元中，常量只会出现一次。</strong></p>
<p><strong>当a &#x3D; 257的时候，会创建257这个整数、并放入常量池中；所以b &#x3D; 257的时候就不会再创建了，因为常量池中已经有了，所以会直接从常量池中获取，因此它们的地址是一样的，因为是同一个PyLongObject。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3.6下执行, 该系列的所有代码都是基于Python3.8, 但是这里先使用Python3.6, 至于原因, 后面会说</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140042202371968, 140042204149712)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140042202371968, 140042204255024)</span></span><br></pre></td></tr></table></figure>

<p><strong>此时f1和f2显然是两个独立的编译单元，256属于小整数对象池中的整数、全局唯一，因此即便不在同一个编译单元的常量池中，它的地址也是唯一的，因为它是预先定义好的，所以直接拿来用。但是257显然不是小整数对象池中的整数，而且不在同一个编译单元的常量池中，所以地址是不一样的。</strong></p>
<p><strong>而对于交互式环境来说，因为我们输入一行代码就会立即执行一行，所以任何一行可独立执行的代码都是一个独立的编译单元。注意：是可独立执行的代码，比如变量赋值、函数、方法调用等等；但如果是if、for、while、def等等需要多行表示的话，比如：<code>if 2 &gt; 1:</code>，显然这就不是一行可独立执行的代码，它还依赖你输入的下面的内容。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span>:  <span class="comment"># 此时按下回车，我们看到不再是&gt;&gt;&gt;, 而是..., 代表还没有结束, 还需要你下面的内容</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;2 &gt; 1&quot;</span>)</span><br><span class="line"><span class="meta">... </span> <span class="comment"># 此时这个if语句整体才是一个独立的编译单元</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是像a &#x3D; 1、foo()、lst.appned(123)这些显然它们是一行可独立执行的代码，因此在交互式中它们是独立的编译单元。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>  <span class="comment"># 此时这行代码已经执行了，它是一个独立的编译单元</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span>  <span class="comment"># 这行代码也是独立的编译单元，所以它里面的常量池为空，因此要重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)  <span class="comment"># 由于它们是不同常量池内的整数，所以id是不一样的。</span></span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，看看下面的代码，a和b的地址为啥又一样了呢？666和777明显也不在常量池中啊。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span>;b=<span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354896</span>, <span class="number">2431274354896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">777</span>, <span class="number">777</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354800</span>, <span class="number">2431274354800</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>显然此时应该已经猜到原因了，因为上面两种方式无论哪一种，都是在同一行，因此整体会作为一个编译单元，所以地址是一样的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在Python3.8中，如果是通过 python xxx.py的方式执行的话，即便是大整数、并且不再同一个编译单元的常量池中，它们的地址也是一样的，说明Python在3.8版本的时候做了优化。</strong></p>
<blockquote>
<p><strong>另外，如果没有特殊说明，那么我们这个系列的所有代码都是在Python3.8下执行的。说实话，我就是因为发现在Python3.8中，打印的地址都是一样的，才在上面试了一下Python3.6。但是Python3.8中具体是怎么优化的，这里就暂时不讨论了<code>(明明是你没有仔细研究)</code>。</strong></p>
</blockquote>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p><strong>整数溢出是程序开发中一大难题，由此引发的 BUG  不计其数，而且相当隐蔽。之前使用golang刷LeetCode的时候，怎么也通不过，最后发现是因为LeetCode后台有一个测试用例比较特殊，导致整数太大，golang中的int64存不下。而Python 选择从语言层面彻底解决这个痛点，殚心竭虑地设计了整数对象。而我们也探索了整数对象，并初步掌握了整数对象的内部结构。</strong></p>
<p><strong>Python中的整数是串联了多个C中的digit<code>(uint32_t)</code>，通过一个C数组的形式来实现整数的表示。这么做的好处就是Python中的整数没有长度限制了，因此不会溢出<code>(而浮点数使用C的double，所以它会溢出)</code>。之所以不会溢出，是因为数组是没有长度限制的，所以只要你的内存足够，就可以算任意大的数。所以Python表示：存不下？会溢出？这都不是事儿，直接继续往数组里面塞digit就ok了。</strong></p>
<blockquote>
<p><strong>这里再重温一下PyLongObject的数据结构，我们说它是一个变长对象。ob_size指的是数组的长度，并且它除了表示长度还能体现出整数的正负，而ob_digit这个数组只用来存储其绝对值。</strong></p>
<p><strong>但是说实话，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<p><strong>所以我们在分析浮点数的时候，一直说整数要比浮点数复杂，原因就在于此。浮点数相加的话直接两个double相加即可，但是整数相加可就没有那么简单了。</strong></p>
</blockquote>
<p><strong>整数支持的操作定义在什么地方相信不用我说了，直接去longobject.c中查看就可以了，根据浮点数的经验我们知道PyLong_Type中的tp_as_number成员也指向了PyNumberMethods结构体实例，里面的成员都是指向与整型运算相关的函数的指针。</strong></p>
<p><strong>注意：图中有一个箭头画错了，应该是 ob_type 指向 PyLong_Type，但图中不小心变成了 ob_size。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002525586-1003237779.png" alt="img"></p>
<h4 id="整数的大小比较"><a href="#整数的大小比较" class="headerlink" title="整数的大小比较"></a>整数的大小比较</h4><p><strong>先来看看Python中的整数在底层是如何比较的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">long_compare</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//sign是一个8字节的long, 用来表示a和b之间的比较结果</span></span><br><span class="line">    <span class="comment">//如果a == b, 那么sign = 0; 如果a &gt; b, 那么sign &gt; 0; 如果a &lt; b, 那么sign &lt; 0</span></span><br><span class="line">    Py_ssize_t sign;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Py_SIZE是一个宏:获取对象的ob_size,除此之外我们之前还见到了Py_REFCNT和Py_TYPE, 用来获取对象的引用计数和类型指针</span></span><br><span class="line">    <span class="comment">//如果两个整数的ob_size不一样, 我们说a和b一定不相等, 所以可以直接比较出大小</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) != Py_SIZE(b)) &#123;</span><br><span class="line">        <span class="comment">//如果一正一负, 那么肯定正的大, 因为ob_size还体现整数的正负, 所以正的ob_size对应的整数也会更大</span></span><br><span class="line">        <span class="comment">//如果都为正, 那么ob_size越大, 对应数组元素就越多, 显然整数就越大</span></span><br><span class="line">        <span class="comment">//如果都为负, 那么ob_size越大, 其绝对值就越小, 因为越接近0,所以对应的整数的绝对值也越小</span></span><br><span class="line">          <span class="comment">//但因为是负数,所以乘上-1之后,所以整数值反而会越大。比如: 1 &lt; 100, 但是乘上-1之后, 小于号就要变成大于号</span></span><br><span class="line">        <span class="comment">//因此无论是哪种情况，如果两个整数的ob_size不一样，是可以直接比较出大小的。</span></span><br><span class="line">        sign = Py_SIZE(a) - Py_SIZE(b);</span><br><span class="line">        <span class="comment">//所以sign &gt; 0的话a &gt; b, sign &lt; 0的话a &lt; b, 因为ob_size不一样, 所以sign不可能等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果相等, 那么说明a和b的符号相同, 数组中使用的digit也是一样的</span></span><br><span class="line">        <span class="comment">//那么接下来就只能挨个比较数组中的digit了</span></span><br><span class="line">        <span class="comment">//这里是获取数组的长度, 赋值给变量i</span></span><br><span class="line">        Py_ssize_t i = Py_ABS(Py_SIZE(a));</span><br><span class="line">        <span class="comment">//我们之前说，一个digit存不下，那么会使用两个digit, 以此类推</span></span><br><span class="line">        <span class="comment">//并且代表整数高位的digit会放在后面, 而比较两个数的大小显然是从高位开始比</span></span><br><span class="line">        <span class="comment">//因此遍历数组是从后往前遍历的, 先比较a -&gt; ob_digit[n]和 b -&gt; ob_digit[n]</span></span><br><span class="line">        <span class="comment">//如果一样就比较a -&gt; ob_digit[n-1]和a -&gt; ob_digit[n-1],直到将数组的元素全部比完,显然只要有一个不一样,就可以直接决定绝对值的大小</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            <span class="comment">//进行while循环, i是数组的长度, 因此数组的最大索引是i - 1, 所以这里的--i会先将i自减1,再判断自减1之后的i是否&gt;=0</span></span><br><span class="line">            <span class="comment">//然后比较a-&gt;ob_digit[i]和b-&gt;ob_digit[i], 如果数组内元素全部一样, 那么循环结束之后i肯定是-1,只要有一个不一样, 那么i一定&gt;=0</span></span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以如果i &lt; 0,说明两个整数的数组全部一样, 因此两个整数是一样的</span></span><br><span class="line">            <span class="comment">//所以sign = 0</span></span><br><span class="line">            sign = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话, 说明数组中索引为i的元素不一样, 那么直接相减就可以了</span></span><br><span class="line">            <span class="comment">//如果sign大于0, 显然a对应的绝对值比大, 否则a对应的绝对值比b小</span></span><br><span class="line">            sign = (sdigit)a-&gt;ob_digit[i] - (sdigit)b-&gt;ob_digit[i];</span><br><span class="line">            <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//但是我们说计算的是绝对值，如果ob_size小于0，绝对值越大其值反而越小，那么sign还要乘上-1</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因此最终: a &gt; b则sign &gt; 0, a &lt; b则sign &lt; 0, a == b则sign == 0</span></span><br><span class="line">    <span class="comment">//然后这里是一个嵌套的三元表达式, sign大于0则直接返回1表示a &gt; b, 小于0返回-1表示a &lt; b, 等于0则返回0表示a == b</span></span><br><span class="line">    <span class="keyword">return</span> sign &lt; <span class="number">0</span> ? <span class="number">-1</span> : sign &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到Python中的整数就是按照上面这种方式比较的，总的来说就是先比较ob_size，ob_size不一样则可以直接比较。如果ob_size一样的话，那么会从后往前挨个比较数组中的元素，最终确定大小关系。</strong></p>
<h4 id="整数的相加"><a href="#整数的相加" class="headerlink" title="整数的相加"></a>整数的相加</h4><p><strong>再来看看Python中的整数在底层是如何相加的，加法的实现显然是long_add，我们看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//a和b是两个PyLongObject *</span></span><br><span class="line">    <span class="comment">//z显然是指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//CHECK_BINOP是一个宏, 接收两个指针, 检测它们是不是都指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断a和b的ob_size的绝对值是不是都小于等于1, 如果是的话, 那么说明数组中最多只有一个元素</span></span><br><span class="line">    <span class="comment">//数组没有元素,说明整数是0;有一个元素,那么直接取出来、再判断正负号即可,然后直接相加。</span></span><br><span class="line">    <span class="comment">//所以显然这里走的是快分支,因为绝对值超过2 ** 30 - 1的整数还是比较少的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//MEDIUM_VALUE是一个宏, 接收一个abs(ob_size) &lt;= 1的PyLongObject的指针</span></span><br><span class="line">        <span class="comment">//如果ob_size是0, 那么结果为0; 如果ob_size绝对值为1, 那么结果为 ob_digit[0] 或者 -ob_digit[0]</span></span><br><span class="line">        <span class="comment">//所以直接将MEDIUM_VALUE(a) + MEDIUM_VALUE(b)之后的结果转成PyLongObject,然后返回其指针即可</span></span><br><span class="line">        <span class="comment">//因此如果数组中元素不超过1个的话, 那么显然是可以直接相加的</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里, 说明至少有一方的ob_size大于1</span></span><br><span class="line">    <span class="comment">//如果a &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果a &lt; 0并且b &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明两者符号相同, 那么通过x_add直接将两个整数相加即可</span></span><br><span class="line">            <span class="comment">//这个x_add专门用于整数的绝对值相加,并且会返回PyLongObject *,它的实现我们后面会说</span></span><br><span class="line">            <span class="comment">//所以z指向的PyLongObject的内部成员是已经设置好了的</span></span><br><span class="line">            <span class="comment">//只不过x_add加的是两者的绝对值, z指向的PyLongObject内部ob_type的符号我们还需要再度判断一下</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//因为a和b指向的整数都是负数, 所以将相加之后还要将ob_size乘上-1</span></span><br><span class="line">                Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//走到这里说明a &lt; 0并且b &gt; 0, 那么直接让b - a即可, 此时得到的结果一定是正</span></span><br><span class="line">            <span class="comment">//因此不需要考虑ob_size的符号问题</span></span><br><span class="line">            z = x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明a &gt; 0并且b &lt; 0, 所以让a - b即可</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两个整数均为正, 直接相加</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回z的指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以long_add这个函数并不长，但是调用了辅助函数x_add和x_sub，显然核心逻辑是在这两个函数里面。至于long_add函数，它的逻辑如下：</strong></p>
<ul>
<li><code>1. 定义一个变量z, 用于保存计算结果;</code></li>
<li><code>2. 判断两个整数底层对应的数组是不是都不超过1, 如果是的话那么通过宏MEDIUM_VALUE直接将其转成C中的一个digit, 然后直接相加、返回即可。显然这里走的是快分支,或者快速通道;</code></li>
<li><code>3. 但如果有一方ob_size绝对值不小于1, 那么判断两者的符号。如果都为负,那么通过x_add计算两者绝对值之和、再将ob_size乘上-1即可;</code></li>
<li><code>4. 如果a的ob_size小于0, b的ob_size大于0, 那么通过x_sub计算b和a绝对值之差即可;</code></li>
<li><code>5. 如果a的ob_size大于0, b的ob_size小于0, 那么通过x_sub计算a和b绝对值之差即可;</code></li>
<li><code>6. 如果a的ob_size大于0, b的ob_size大于0, 那么通过x_add计算让b和a绝对值之和即可;</code></li>
</ul>
<p><strong>所以Python中整数的设计非常的巧妙，ob_digit虽然是用来维护具体数值，但是它并没有考虑正负，而是通过ob_size来表示整数的正负号。这样运算的时候，计算的都是整数的绝对值，因此实现起来会方便很多。将绝对值计算出来之后，再通过ob_size来判断正负号。</strong></p>
<p><strong>因此long_add将整数加法转成了 “绝对值加法(x_add)”和”绝对值减法(x_sub)”：</strong></p>
<ul>
<li><code>x_add(a, b), 计算两者的绝对值之和, 即:|a| + |b|;</code></li>
<li><code>x_sub(a, b), 计算两者的绝对值之差, 即:|a| - |b|;</code></li>
</ul>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002538412-969820254.png" alt="img"></p>
<p><strong>由于绝对值加、减法不用考虑符号对计算结果的影响，实现更为简单，这是Python将整数运算转化成绝对值运算的缘由。虽然我们还没看到x_add和x_sub是如何对整数的绝对值进行相加和相减运算的，但也能从中体会到程序设计中逻辑的 划分 与 组合 的艺术，优秀的代码真的很美。</strong></p>
<blockquote>
<p><strong>那么下面我们的重心就在x_add和x_sub中了，看看它们是如何对大整数绝对值进行运算的。但是你可能会有疑问，大整数运算肯定很复杂，效率会差吧。显然这是必然的，整数数值越大，整数对象底层数组越长，运算开销也就越大。好在运算处理函数均以快速通道对小整数运算进行优化，将额外开销降到最低。</strong></p>
<p><strong>比如上面的long_add，如果a和b对应的整数的绝对值都小于等于2 ^  30 - 1，那么会直接转成C中的整型进行运算，性能损耗极小。并且走快速通道的整数的范围是：-(2 ^ 30 - 1) ~ 2 ^ 30 -  1，即：-1073741823 ~ 1073741823，显然它可以满足我们绝大部分的运算场景。</strong></p>
</blockquote>
<p>​        <strong>绝对值加法x_add：</strong>    </p>
<p><strong>在介绍绝对值加法之前，先来看看几个宏，先不管它们是干什么的，会在x_add中有体现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_SHIFT    30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_MASK     ((digit)(PyLong_BASE - 1))</span></span><br><span class="line"><span class="comment">//所以PyLong_MASK等于(1 &lt;&lt; 30) - 1, 就等于2 ** 30 - 1, 说明32个位, 前两个位为0, 后面三十个位则都是1</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，再想象一下我们平时算加法的时候是怎么算的：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002550125-674752602.png" alt="img"></p>
<p><strong>而x_add在逻辑和上面是类似的，下面分析x_add的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然a和b指向了两个要想加的整数对象</span></span><br><span class="line">    <span class="comment">//这里获取a和b的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//根据a和b的相加结果所创建的新的PyLongObject的指针</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//重点也是最难理解的地方: carry用于每个部分的运算结果(可不是大神带你carry哦)</span></span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size_a小于size_b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么将a和b进行交换, 以及size_a和size_b也进行交换, 为什么这么做呢?因为方便</span></span><br><span class="line">        <span class="comment">//我们小时候计算两个整数相加时候, 如果一个位数多,一个位数少, 也会习惯将位数多的放在左边</span></span><br><span class="line">        <span class="comment">//最终从右往左, 也就是从低位往高位逐个相加, 大于10则进1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//如果size_a和size_b相等, 或者size_a大于size_b, 那么该if就无需执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是创建一个ob_size为size_a + 1的PyLongObject, 然后返回其指针</span></span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//但为什么是size_a + 1呢?</span></span><br><span class="line">    <span class="comment">//因为此时size_a 一定不小于 size_b, 那么a和b相加之后的z的ob_size一定不小于size_a</span></span><br><span class="line">    <span class="comment">//但是也可以也可能比size_a多1, 比如: a = 2 ** 60 - 1, b = 1</span></span><br><span class="line">    <span class="comment">//所以相加之后结果为2 ** 60次方, 所以ob_size就变成了3, 因此在创建z的时候，ob_digit的容量会等于size_a + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正常情况下, z是一个PyLongObject *, 但如果z == NULL, 表示分配失败(解释器也会异常退出)</span></span><br><span class="line">    <span class="comment">//但说实话, 除非你内存不够了, 否则这种情况不会发生</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, 如果a和b的ob_size不一样, 那么size_a会大于size_b</span></span><br><span class="line">    <span class="comment">//所以显然是先以size_b为准, 两者从低位向高位依次对应相加; 当b到头了, 再单独算a的剩余部分;</span></span><br><span class="line">    <span class="comment">//假设size_a == 4, size_b == 2, 对应到ob_digit的话</span></span><br><span class="line">    <span class="comment">//就是a -&gt; ob_digit[0] + b -&gt; ob_digit[0], 作为z -&gt; ob_digit[0], 当然还需要考虑进位, 下面说</span></span><br><span class="line">    <span class="comment">//然后a -&gt; ob_digit[1] + b -&gt; ob_digit[1], 作为z -&gt; ob_digit[1], 此时b到头了</span></span><br><span class="line">    <span class="comment">//继续a -&gt; ob_digit[2]作为z -&gt; ob_digit[2], a -&gt; ob_digit[3]作为z -&gt; ob_digit[3]</span></span><br><span class="line">    <span class="comment">//此时a和b相加就结束了, 如果不考虑相加进位的话, 那么整体流程就是这个样子。然后我们继续往下看</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从索引为0开始遍历, 以i &lt; size_b为条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]作为carry, 显然carry如果没有超过2 ** 30 - 1的话</span></span><br><span class="line">        <span class="comment">//显然它就是z -&gt; ob_digit[i]</span></span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//但是carry是可能溢出的, 所以z -&gt; ob_digit[i] = carry &amp; PyLong_MASK</span></span><br><span class="line">        <span class="comment">//这个PyLong_MASK就是我们在介绍x_add之前先介绍的几个宏之一, 它表示的是2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//我们说它的前两个位为0, 后面三十个位全是1, 因此对于后面三十个位来说, 在和carry进行&quot;与运算&quot;之后,对应的位还和carry保持一致</span></span><br><span class="line">        <span class="comment">//所以在carry小于等于2 ** 30 - 1的时候carry &amp; PyLong_MASK就等于carry</span></span><br><span class="line">        <span class="comment">//但如果carry大于2 ** 30 - 1, 由于PyLong_MASK的前两位为0, 所以这一步可以确保carry不会超过2 ** 30 - 1</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//但是carry的前两位显然不可以丢, 所以它们要作用在数组中下一个元素相加的结果上</span></span><br><span class="line">        <span class="comment">//比如a -&gt; ob_digit[0] + b -&gt; ob_digit[0]得到结果正好是2 ** 32 - 1, 那么carry的前两位也是1</span></span><br><span class="line">        <span class="comment">//而数组中下一元素相加之后, 其结果对应的位要比本次循环高出30</span></span><br><span class="line">        <span class="comment">//所以这里将carry右移30位, 然后作用到下一次循环中</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果当b到头了, 那么继续从当前的i开始, 直到i == size_a, 逻辑还是和上面一样的</span></span><br><span class="line">        <span class="comment">//只不过将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]换成了a-&gt;ob_digit[i], 因为b到头了</span></span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//这里也要&quot;与上&quot;PyLong_MASK, 因为也可能存在进位的情况, 拿生活中的99999 + 1为例</span></span><br><span class="line">        <span class="comment">//此时a = 99999, b = 1, 显然第一次循环b就到头了, 但后面单独循环a的时候, 依旧是要加进位的</span></span><br><span class="line">        <span class="comment">//所以这里也是同理</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//carry右移30位</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个循环结束之后, 其实还差一步, 还拿99999 + 1举例子, 按照顺序相加最后得到的是00000</span></span><br><span class="line">    <span class="comment">//因为最后还进了一个1, 所以这里的carry也是同理, 因此z的ob_size要比size_a多1, 目的就在于此</span></span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="comment">//但如果最后的carry没有进位的话, 显然其结果就是0, 所以最后没有直接返回z, 而是返回了long_normalize(z)</span></span><br><span class="line">    <span class="comment">//这个long_normalize函数作用就是从后往前依次检查ob_digit的元素, 如果为0, 那么就将其ob_size减去1, 直到出现一个不为0的元素</span></span><br><span class="line">    <span class="comment">//当然对于我们当前来说, 显然最多只会检查一次</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python中的整数在底层实现的很巧妙，不理解的话可以多看几遍，然后我们在Python的层面上再反推一下，进一步感受底层运算的过程。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有a和b两个整数, 当然这里是使用列表直接模拟的底层数组ob_digit</span></span><br><span class="line">a = [<span class="number">1073741744</span>, <span class="number">999</span>, <span class="number">765</span>, <span class="number">123341</span>]</span><br><span class="line">b = [<span class="number">841</span>, <span class="number">1073741633</span>, <span class="number">2332</span>]</span><br><span class="line"><span class="comment"># 然后创建z, 表示a和b的相加结果</span></span><br><span class="line">z = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更直观, 我们一步步手动相加</span></span><br><span class="line"><span class="comment"># 首先是将a[0] + b[0], 得到carry</span></span><br><span class="line">carry = a[<span class="number">0</span>] + b[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1), 我们看到结果是761</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 761</span></span><br><span class="line"><span class="comment"># 因为如果carry小于等于 2 ** 30 - 1, 那么结果就是carry, 而这里是761, 显然carry肯定大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 因为carry &amp; (2 ** 30 - 1) == 761, 所以z的第一个元素就是761</span></span><br><span class="line">z.append(<span class="number">761</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算a[1] + b[1]得到新的carry, 但是之前的carry大于 2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还要再加上之前的右移30位的carry</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">1</span>] + b[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1)得到809</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 809</span></span><br><span class="line"><span class="comment"># 说明carry依旧大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 然后z的第二个元素就是809</span></span><br><span class="line">z.append(<span class="number">809</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算a[2] + b[2]的时候也是同理</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">2</span>] + b[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 但是显然此时的carry已经不大于 2 ** 30 - 1了</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 所以carry和carry &amp; (2 ** 30 - 1)的结果都是carry本身</span></span><br><span class="line"><span class="built_in">print</span>(carry, carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 3098 3098</span></span><br><span class="line"><span class="comment"># 说明z的第三个元素是3098</span></span><br><span class="line">z.append(<span class="number">3098</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时b到头了, 所以直接将a[3]作为carry, 当然我们不知道carry是否大于2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还是右移30位即可, 不过carry不大于2 ** 30 - 1的话, 那么 carry &gt;&gt; 30 就是0罢了</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(carry)  <span class="comment"># 123341</span></span><br><span class="line"><span class="comment"># 说明z的最后一个元素是123341, 当然理论上我们还要在对carry和 2 ** 30 - 1进行一次判断</span></span><br><span class="line"><span class="comment"># 当然由于我们知道carry肯定不会超过2 ** 30 - 1, 所以就不判断了</span></span><br><span class="line">z.append(<span class="number">123341</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时z为[761, 809, 3098, 123341]</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># [761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以ob_digit为[1073741744, 999, 765, 123341]和[841, 1073741633, 2332]的两个PyLongObject相加</span></span><br><span class="line"><span class="comment"># 得到的新的PyLongObject的ob_digit为[761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们根据ob_digit按照规则转成整数, 那么a + b的结果要和z是相等的</span></span><br><span class="line">a = <span class="number">1073741744</span> + <span class="number">999</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">765</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line">b = <span class="number">841</span> + <span class="number">1073741633</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">2332</span> * <span class="number">2</span> ** <span class="number">60</span></span><br><span class="line">z = <span class="number">761</span> + <span class="number">809</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">3098</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 152688762386380073438430860672944</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 2689765870042689307465</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># 152688762389069839308473549980409</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然结果为True, 由此证明我们之前的结论是成立的。</span></span><br><span class="line"><span class="built_in">print</span>(a + b == z)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看完绝对值加法x_add之后，再来看看绝对值减法x_sub，显然有了加法的经验之后再看减法会简单很多。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//依旧是获取两者的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//z指向相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//如果size_a 小于 size_b, 那么sign就是-1, 否则就是1</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//之前carry保存的相加的结果, borrow保存相减的结果</span></span><br><span class="line">    <span class="comment">//名字很形象, 相加要进位叫carry、相减要结尾叫borrow</span></span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果size_a比size_b小, 说明a的绝对值比b小</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么令sign = -1, 相减之后再乘上sign</span></span><br><span class="line">        <span class="comment">//因为计算的是绝对值之差, 符号是在绝对值之差计算完毕之后通过sign判断的</span></span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后依旧交换两者的位置, 相减的时候也确保大的一方在左边</span></span><br><span class="line">        <span class="comment">//相加的时候其实大的一方在左边还是在右边没有太大影响, 但是相减的时候大的一方在左边显然会省事很多</span></span><br><span class="line">        <span class="comment">//但是交换之后再相减, 肯定要变符号, 因此将sign设置为-1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//可能有人会有疑问了，那如果a的ob_size是1, b的ob_size是-3，一正一负,此时起到的效果是相加才对啊</span></span><br><span class="line">        <span class="comment">//是的, 所以此时会将a和b传到x_add里面，而不是这里, 后面我们会总结</span></span><br><span class="line">        <span class="comment">//由于ob_digit里面的元素都为正, 所以x_add计算的是绝对值之和，x_sub计算的绝对值之差, 总之在理解逻辑的时候把a和b都想象成正数即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">//这一个条件语句可能有人会觉得费解，我们分析一下</span></span><br><span class="line">        <span class="comment">//如果两者相等, 那么两个ob_digit里面对应的元素也是有几率都相等的</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="comment">//所以从ob_digit的尾巴开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">//如果都相等, 那么i会等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以直接返回0即可</span></span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//下面下面是为了计算相减之后的PyLongObject的ob_size</span></span><br><span class="line">        <span class="comment">//如果对应元素不相等, 假设a的ob_digit里面的元素是[2, 3, 4, 5], b的ob_digit是[1, 2, 3, 5]</span></span><br><span class="line">        <span class="comment">//因此上面的while循环结束之后, i会等于2, 显然只需要计算[2, 3, 4]和[1, 2, 3]之间的差即可, 因为最高位的5是一样的</span></span><br><span class="line">        <span class="comment">//然后判断索引为i时, 对应的值谁大谁小</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            <span class="comment">//如果a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i], 那么同样说明a小于b, 因此将sign设置为-1, 然后交换a和b的位置</span></span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为做减法, 所以size_a和size_b直接设置成i + 1即可, 因为高位在减法的时候会被抵消掉, 所以它们完全可以忽略</span></span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里依旧是申请空间</span></span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="comment">//申请失败返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后下面的逻辑和x_add是类似的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//让a-&gt;ob_digit[i] - b-&gt;ob_digit[i], 但如果存在借位, 那么还要减掉</span></span><br><span class="line">        <span class="comment">//但是问题来了, 我们说digit貌似是无符号的吧, 但是对于低位来说a-&gt;ob_digit[i] 是完全可以小于 b-&gt;ob_digit[i]的</span></span><br><span class="line">        <span class="comment">//但是这样减出来不成负数了, 所以C语言中有这么个特点, 比如：这里相减得到的是-100</span></span><br><span class="line">        <span class="comment">//那么结果就是2 ** 32 - 100, 因为digit是无符号32位, 所以存储的负数会变成 2 ** 32 + 该负数, 或者2 ** 32 - 负数的绝对值</span></span><br><span class="line">        <span class="comment">//以我们平时做的减法为例：32 - 19, 我们知道结果是13, 但是低位的2减去低位的9结果是-7, 如果是负数</span></span><br><span class="line">        <span class="comment">//那么要像高位借个1, 从而得到10,因此最后一位是10 - 7 = 3</span></span><br><span class="line">        <span class="comment">//以此为例, a -&gt; ob_digit[i] - b -&gt; ob_digit[i], 如果小于0, 那么肯定要像数组中i + 1的元素进行借位, 但我们说它会比当前高30个位</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        <span class="comment">//因此这里借个1, 借的就不是10了, 而是2 ** 30次方</span></span><br><span class="line">        <span class="comment">//所以borrow为负, 那么结果显然加上2 ** 30才对, 但是当前borrow加的是2 ** 32次方</span></span><br><span class="line">        <span class="comment">//所以将borrow 还要 与上 PyLong_MASK，然后其结果才是z-&gt;ob_digit[i]的值</span></span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//如果真的借了个1, 那么ob_digit中下一个元素肯定是要减去1的, 所以borrow右移30位</span></span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        <span class="comment">//和1进行与运算, 如果a -&gt; ob_digit[i] - b -&gt; ob_digit[i]为负, 那么就必须要借位</span></span><br><span class="line">        <span class="comment">//但由于digit只用30个位, 因此再加上2 ** 32次方之后，其结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以borrow右移30位之后, 再和1进行与运算之后结果肯定是1, 由此可以判断这次相减一定是借位了</span></span><br><span class="line">        <span class="comment">//如果为0代表结果为正、没有加上2 ** 32次方,那么结果borrow &amp; 1的结果就是0</span></span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//所以Python底层的整数只用了30个位真的非常巧妙, 尤其是在减法的时候</span></span><br><span class="line">        <span class="comment">//因为借位一次借2 ** 30, 可由于C的特性会加上2 ** 32次方, 但是它们的结果只有前两个高位不一样, 后面30个位是一样的</span></span><br><span class="line">        <span class="comment">//所以再与上PyLong_MASK, 所以就等价于加上了2 ** 30次方，从而得到正确的结果</span></span><br><span class="line">        <span class="comment">//但如果一旦借位, 那么数组下一个元素要减去1。但问题是怎么判断它有没有借位呢？判断有没有借位就是判断两个元素相减之后是否为负</span></span><br><span class="line">        <span class="comment">//如果为负数,那么C会将这个负数加上2 ** 32次方, 而两个不超过2 ** 30 - 1的数相减得到的负数的绝对值显然也不会超过2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//换句话说其结果对应的第31位一定是0, 那么再和32个位全部是1的2 ** 32次方相加, 得到的结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以再让borrow右移30位、并和1进行与运算。如果结果为1, 证明相减为负数, 确实像下一个元素借了1, 因此下一次循环的会减去1</span></span><br><span class="line">        <span class="comment">//如果borrow为0, 那么就证明a-&gt;ob_digit[i] - b-&gt;ob_digit[i]得到的结果为正,根本不需要借位, 所以下一次循环等于减了一个0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size_a和size_b一样, 那么这里的for循环是不会满足条件的, 但不一样的话, 肯定会走这里</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//我们看到这里的逻辑和之前分析x_add是类似的</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只不过由于不会产生进位, 因此不需要对borrow再做额外判断, x_add中最后还要判断carry有没有进位</span></span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sign &lt; 0, 那么证明是负数</span></span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后同样从后往前将z -&gt; ob_digit中为0的元素删掉, 直到遇见一个不为0的元素, 比如: 10000 - 9999, 虽然位数多, 但是结果是1</span></span><br><span class="line">    <span class="comment">//而z -&gt; ob_digit在申请空间的时候只是根据长度申请的, 所以最后还需要这样的一次判断</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以Python整数在底层的设计确实很精妙，尤其是在减法的时候，强烈建议多看几遍回味一下。</strong></p>
<h4 id="整数的相减"><a href="#整数的相减" class="headerlink" title="整数的相减"></a>整数的相减</h4><p><strong>整数的相减调用的是long_sub函数，显然long_sub和long_add的思路都是一样的，核心还是在x_add和x_sub上面，所以long_sub就没有什么可细说的了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//z指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//判断a和b是否均指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里依旧是快分支</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//直接相减，然后转成PyLongObject返回其指针</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) - MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a小于0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//a小于0，b小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用绝对值减法, 因为两者符号一样</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两者符号不一样，那么相加起到的是相加的效果</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//但是x_add和x_sub运算的是绝对值, x_sub中考虑的sign是基于绝对值而言的</span></span><br><span class="line">            <span class="comment">//比如：x_sub接收的a和b的ob_size分别是-5和-3, 那么得到的结果肯定是正的, 因为会用绝对值大的减去绝对值小的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是负数, 所以还要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果x_sub接收的a和b的ob_size分别是-3和-5, 由于还是用绝对值大的减去绝对值小的,所以会交换、从而变号，得到的结果是负的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是正数, 所以也要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//至于x_add就更不用说了, 当a为负、b为正的时候, a - b，就等于a和b的绝对值相加乘上-1</span></span><br><span class="line">            assert(Py_SIZE(z) == <span class="number">0</span> || Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">            Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//a大于0, b小于0, 所以a - b等于a和b的绝对值相加</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//a大于0, b大于0, 所以直接绝对值相减即可</span></span><br><span class="line">            <span class="comment">//而正数等于其绝对值, 所以x_sub里面考虑的符号就是真正的结果的符号</span></span><br><span class="line">            <span class="comment">//如果是上面的负数, 那么还要乘上-1</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以关于什么时候调用x_add、什么时候调用x_sub，我们总结一下，总之核心就在于它们都是对绝对值进行运算的，掌握好这一点就不难了：</strong></p>
<p><strong>a + b</strong></p>
<ul>
<li><code>如果a是正、b是正，调用x_add(a, b)，直接对绝对值相加返回结果</code></li>
<li><code>如果a是负、b是负，调用x_add(a, b)，但相加的是绝对值，所以long_add中在接收到结果之后还要对ob_size乘上-1</code></li>
<li><code>如果a是正、b是负，调用x_sub(a,  b)，此时等价于a的绝对值减去b的绝对值。并且x_sub是使用绝对值大的减去绝对值小的，如果a的绝对值大，那么显然正常；如果a的绝对值小，x_sub中会交换，但同时也会自动变号，因此结果也是正常的。举个普通减法的例子：5 + -3, 那么在x_sub中就是5 - 3; 如果是3 + -5, 那么在x_sub中就是-(5 - 3),  因为发生了交换。但不管那种情况，符号都是一样的</code></li>
<li><code>如果a是负、b是正，调用x_sub(b, a)，此时等价于b的绝对值减去a的绝对值。所以这个和上面a是正、b是负是等价的。</code></li>
</ul>
<p><strong>所以符号相同，会调用x_add、符号不同会调用x_sub。</strong></p>
<p><strong>a - b</strong></p>
<ul>
<li><code>如果a是正、b是负，调用x_add(a, b)直接对a和b的绝对值相加即可</code></li>
<li><code>如果a是正、b是正，调用x_sub(a, b)直接对a和b的绝对值相减即可，会根据绝对值自动处理符号，而a、b为正，所以针对绝对值处理的符号，也是a - b的符号</code></li>
<li><code>如果a是负、b是正，调用x_add(a, b)对绝对值进行相加, 但是结果显然为负，因此在long_sub中还要对结果的ob_size成员乘上-1</code></li>
<li><code>如果a是负、b是负，调用x_sub(a, b)对绝对值进行相减, 会根据绝对值自动处理符号,  但是在为负的情况下绝对值越大，其值反而越小, 因此针对绝对值处理的符号，和a -  b的符号是相反的。所以最终在long_sub中，也要对结果的ob_size成员乘上-1。举个普通减法的例子：-5 - -3,  那么在x_sub中就类似于5 - 3; 如果是-3 - -5, 那么在x_sub中就类似于-(5 - 3),  因为发生了交换。但不管那种情况得到的值的正负号都是相反的，所以要再乘上-1</code></li>
</ul>
<p><strong>所以符号相同，会调用x_sub、符号不同会调用x_add。</strong></p>
<p>​        <strong>所以可以仔细回味一下Python中整数的设计思想，以及运算方式。为什么只使用digit的30个位, 以及在相加、相减的时候是怎么做的。</strong>    </p>
<p>​        <strong>当然还有乘法和除法，乘法Python内部采用的是效率更高的karatsuba算法，相当来说比较复杂，有兴趣可以自己查看一下。重点还是了解Python中的整数在底层是怎么存储的，以及为什么要这么存储。</strong>    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>这一节我们介绍了整数的底层实现，并分析了Python中的整数为什么不会溢出，以及Python如何计算一个整数所占的字节。当然我们还说了小整数对象池，以及通过分析源码中的long_add和long_sub来了解底层是如何对整数进行运算的。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>10-PyCodeObject对象和pyc文件</title>
    <url>/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="10-Python中的PyCodeObject对象与pyc文件"><a href="#10-Python中的PyCodeObject对象与pyc文件" class="headerlink" title="10-Python中的PyCodeObject对象与pyc文件"></a>10-Python中的PyCodeObject对象与pyc文件</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>当我们想要执行一个py文件的时候，只需要python  xxx.py即可，但是你有没有想过这背后的流程是怎么样的呢？从这里开始我们就开始进入到Python虚拟机的环节了，之前都是在介绍Python中的一些内置对象，不过虚拟机的执行流程、以及背后的原理却更是值得我们关注的。</strong></p>
<p><strong>这里我们先来说一下Python执行py文件的流程：</strong></p>
<ul>
<li><code>1. 首先将文件里面的内容读取出来, 所以从这个角度上讲, 文件名不一定非要是.py结尾, .txt也是可以的, 只要文件里面的内容符合Python代码规范即可</code></li>
<li><code>2. 读取文件里面的内容之后会对其进行分词, 将源代码切分成一个一个的token</code></li>
<li><code>3. 然后Python编译器会对token进行语法解析, 建立抽象语法树(AST, abstract syntax tree)</code></li>
<li><code>4. 编译器再将得到AST编译成字节码</code></li>
<li><code>5. 最终由Python虚拟机来执行字节码</code></li>
</ul>
<p><strong>首先我们从中看到了Python编译器、Python虚拟机，而且我们平常还会说Python解释器，那么三者之间有什么区别呢？</strong></p>
<blockquote>
<p><strong>实际上Python解释器 &#x3D; Python编译器 + Python虚拟机，Python编译器负责将Python源代码编译成字节码<code>(包括文件读取、分词、建立AST、编译成字节码)</code>，Python虚拟机负责执行这些字节码。</strong></p>
</blockquote>
<p><strong>那么Python编译器和Python虚拟机都在什么地方呢？如果打开Python的安装目录，会发现有一个python.exe，点击的时候会通过它来启动一个终端。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202008/1229382-20200815023105176-468360562.png" alt="img"></p>
<p><strong>但问题是这个文件大小还不到100K，不可能容纳一个解释器加一个虚拟机，所以下面还有一个python38.dll，没错，编译器、虚拟机都藏身于python38.dll当中。</strong></p>
<p><strong>因此Python代码并不是直接就一步到胃、变成机器码，而是先被Python编译器编译成字节码，中间存在一个编译的过程。而之所以要存在编译，是为了能够让虚拟机更快速的执行，而且还可以尽早的检测出语法上的错误。</strong></p>
<p><strong>那么下面我们就来看看Python中的字节码长什么样子。</strong></p>
<h3 id="Python编译器的编译结果–PyCodeObject对象"><a href="#Python编译器的编译结果–PyCodeObject对象" class="headerlink" title="Python编译器的编译结果–PyCodeObject对象"></a>Python编译器的编译结果–PyCodeObject对象</h3><p><strong>我们知道Python代码的编译结果是字节码，里面必然隐藏了Python运行的秘密，因此不管是深入理解虚拟机还是调优Python的运行效率，字节码都是绕不过去的一个坎。</strong></p>
<blockquote>
<p><strong>注意：我们这里会研究字节码，但是不会研究Python是怎么编译得到字节码。因为Python编译器的工作原理和其它语言基本类似，很多关于编译原理的书籍都有介绍，编译这个过程不是Python特有的。并且研究Python的编译过程，对于我们开发帮助不是很大。</strong></p>
<p><strong>所以我们只需要知道Python解释器的背后有一个编译器会通过”读取文件”、”对源代码分词”、”分词之后会语法解析建立AST”、”对AST编译”得到字节码即可，至于这一列步骤是怎么做的、是怎么将源代码变成的字节码不是我们需要关心的，我们的重点是研究字节码本身以及虚拟机。</strong></p>
</blockquote>
<h4 id="PyCodeObject对象和pyc文件"><a href="#PyCodeObject对象和pyc文件" class="headerlink" title="PyCodeObject对象和pyc文件"></a>PyCodeObject对象和pyc文件</h4><p><strong>首先做Python开发的肯定都见过这个pyc文件，它一般位于<code>__pycache__</code>目录中，那么这个pyc文件和字节码之间有什么关系呢？</strong></p>
<p><strong>首先我们知道，Python执行这个文件首先要进行的动作就是编译，编译会得到字节码。然而除了字节码之外，还应该包含一些其它的信息，这些信息也是Python运行的时候所必须的。</strong></p>
<p><strong>在编译过程中，像常量值、字符串这些源代码当中的静态信息都会被Python编译器收集起来，并且这些静态信息也都会体现在编译之后的结果里面。在Python运行期间，这些源文件提供的静态信息都会被存储在一个运行时的对象当中，当Python运行结束时，这个运行时对象中所包含的信息还会被存储在一种文件中。这个对象和文件就是我们接下来要探讨的重点：PyCodeObject对象和pyc文件。</strong></p>
<blockquote>
<p><strong>Python中的字节码只是一个PyBytesObject对象、或者说一段字节序列，PyCodeObject对象中有一个成员co_code，它是一个指针，指向了这段字节序列。但是这个对象除了有co_code指向字节码之外，还有很多其它成员，负责保存代码涉及到的常量、变量<code>(名字、符号)</code>等等</strong></p>
<p><strong>所以我们知道了，pyc文件里面的内容是PyCodeObject对象。对于Python编译器来说，PyCodeObject对象才是其真正的编译结果，而pyc文件是这个对象在硬盘上表现形式。</strong></p>
</blockquote>
<p><strong>在程序运行期间，编译结果存在于内存的PyCodeObject对象当中，而Python结束运行之后，编译结果又被保存到了pyc文件当中。当下一次运行的时候，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不需要再度重新编译了。</strong></p>
<h4 id="python源码中的PyCodeObject对象"><a href="#python源码中的PyCodeObject对象" class="headerlink" title="python源码中的PyCodeObject对象"></a>python源码中的PyCodeObject对象</h4><p><strong>我们说Python编译器会将Python源代码编译成字节码，虚拟机执行的也是字节码，所以要理解虚拟机的运行时<code>(runtime)</code>行为，就必须要先掌握字节码。而我们说字节码是被底层结构体PyCodeObject的成员co_code指向，那么我们就必须来看看这个结构体了，它的定义位于 *Include&#x2F;code.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD		<span class="comment">/* 头部信息, 我们看到真的一切皆对象, 字节码也是个对象 */</span>	</span><br><span class="line">    <span class="type">int</span> co_argcount;            <span class="comment">/* 可以通过位置参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_posonlyargcount;     <span class="comment">/* 只能通过位置参数传递的参数个数,  Python3.8新增 */</span></span><br><span class="line">    <span class="type">int</span> co_kwonlyargcount;      <span class="comment">/* 只能通过关键字参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;             <span class="comment">/* 代码块中局部变量的个数，也包括参数 */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;           <span class="comment">/* 执行该段代码块需要的栈空间 */</span></span><br><span class="line">    <span class="type">int</span> co_flags;               <span class="comment">/* 参数类型标识 */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;         <span class="comment">/* 代码块在对应文件的行号 */</span></span><br><span class="line">    PyObject *co_code;          <span class="comment">/* 指令集, 也就是字节码, 它是一个bytes对象 */</span></span><br><span class="line">    PyObject *co_consts;        <span class="comment">/* 常量池, 一个元组，保存代码块中的所有常量。 */</span></span><br><span class="line">    PyObject *co_names;         <span class="comment">/* 一个元组,保存代码块中引用的其它作用域的变量 */</span></span><br><span class="line">    PyObject *co_varnames;      <span class="comment">/* 一个元组,保存当前作用域中的变量 */</span></span><br><span class="line">    PyObject *co_freevars;      <span class="comment">/* 内层函数引用的外层函数的作用域中的变量 */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* 外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的 */</span></span><br><span class="line"></span><br><span class="line">    Py_ssize_t *co_cell2arg;    <span class="comment">/* 无需关注 */</span></span><br><span class="line">    PyObject *co_filename;      <span class="comment">/* 代码块所在的文件名 */</span></span><br><span class="line">    PyObject *co_name;          <span class="comment">/* 代码块的名字，通常是函数名或者类名 */</span></span><br><span class="line">    PyObject *co_lnotab;        <span class="comment">/* 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的无需关注了</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;       <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="type">void</span> *co_extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *co_opcache_map;</span><br><span class="line">    _PyOpcache *co_opcache;</span><br><span class="line">    <span class="type">int</span> co_opcache_flag; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> co_opcache_size; </span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里面的每一个成员，我们后面都会逐一演示进行说明。总之Python编译器在对Python源代码进行编译的时候，对于代码中的每一个block，都会创建一个PyCodeObject与之对应。但是多少代码才算得上是一个block呢？事实上，Python有一个简单而清晰的规则：当进入一个新的名字空间，或者说作用域时，我们就算是进入了一个新的block了。这里又引出了名字空间，别急，我们后面会一点一点说，总之先举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = []</span><br></pre></td></tr></table></figure>

<p><strong>我们仔细观察一下上面这个文件，它在编译完之后会有三个PyCodeObject对象，一个是对应整个py文件的，一个是对应class A的，一个是对应def foo的。因为这是三个不同的作用域，所以会有三个PyCodeObject对象。</strong></p>
<p><strong>在这里，我们开始提及Python中一个至关重要的概念–名字空间(name  space)、也叫命名空间、名称空间，都是一个东西。名字空间是符号的上下文环境，符号的含义取决于名字空间。更具体的说，一个变量名对应的变量值什么，在Python中是不确定的，需要命名空间来决定。</strong></p>
<p>对于某个符号、或者名字<code>(我们在前面系列中说过Python的变量只是一个名字)</code>，比如说上面代码中的a，在某个名字空间中，它可能指向一个PyLongObject对象；而在另一个名字空间中，它可能指向一个PyListObject对象。但是在一个名字空间中，一个符号只能有一种含义。而且名字空间可以一层套一层的形成一条<code>名字空间链</code>，Python虚拟机在执行的时候，会有很大一部分时间消耗在从<code>名字空间链</code>中确定一个符号所对应的对象是什么。这也侧面说明了，Python为什么比较慢。</p>
<p><strong>如果你现在名字空间还不是很了解，不要紧，随着剖析的深入，你一定会对名字空间和Python在名字空间链上的行为有着越来越深刻的理解。总之现在需要记住的是：一个code block对应一个名字空间<code>(或者说作用域)</code>、同时也对应一个PyCodeObject对象。在Python中，类、函数、module都对应着一个独自的名字空间，因此都会有一个PyCodeObject与之对应。</strong></p>
<h4 id="如何在Python中访问PyCodeObject对象"><a href="#如何在Python中访问PyCodeObject对象" class="headerlink" title="如何在Python中访问PyCodeObject对象"></a>如何在Python中访问PyCodeObject对象</h4><p><strong>那么我们如何才能在Python中获取到PyCodeObject对象呢？PyCodeObject对象在Python中也是一个对象，它的类型对象是<code>&lt;class &#39;code&#39;&gt;</code>。但是这个类，底层没有暴露给我们，所以code对于Python来说只是一个没有定义的变量罢了。</strong></p>
<p><strong>但是我们可以通过其它的方式进行获取，首先来看看如何通过函数来获取该函数对应的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(func.__code__))  <span class="comment"># &lt;class &#x27;code&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过函数的<code>__code__</code>拿到底层对应的PyCodeObject对象，当然也可以获取里面的属性，我们来演示一下。</strong></p>
<p>​        <strong>co_argcount：可以通过位置参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, *args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_argcount)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *args, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_argcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>foo中的参数a、b、c都可以通过位置参数传递，所以结果是3；对于bar，显然是两个，这里不包括<code>\*args</code>；而函数func，显然是两个，因为参数c只能通过关键字参数传递。</strong></p>
<p>​        <strong>co_posonlyargcount：只能通过位置参数传递的参数个数，python3.8新增</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_posonlyargcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, /, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_posonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：这里是只能通过位置参数传递的参数个数。</strong></p>
<p>​        <strong>co_kwonlyargcount：只能通过关键字参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=<span class="number">1</span>, c=<span class="number">2</span>, *, d, e</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_kwonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>这里是d和e，它们必须通过关键字参数传递。</strong></p>
<p>​        <strong>co_nlocals：代码块中局部变量的个数，也包括参数</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量：a、b、c、name、age、gender，所以我们看到在编译成字节码的时候函数内局部变量的个数就已经确定了，因为它是静态存储的。</strong></p>
<p>​        <strong>co_stacksize：执行该段代码块需要的栈空间</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_stacksize)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>这个不需要关注</strong></p>
<p>​        <strong>co_firstlineno：代码块在对应文件的起始行</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然是文件的第一行</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_firstlineno)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>如果函数出现了调用呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_firstlineno)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>如果执行foo，那么会返回函数bar，调用的就是bar函数的字节码，那么得到就是<code>def bar():</code>所在的行数。因为每个函数都有自己独自的命名空间，以及PyCodeObject对象。</strong></p>
<p>​        <strong>co_names：一个元组，保存代码块中不在当前作用域的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_names)  <span class="comment"># (&#x27;print&#x27;, &#x27;c&#x27;, &#x27;list&#x27;, &#x27;int&#x27;, &#x27;str&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到print、c、list、int、str都是全局或者内置变量，函数、类也可以看成是变量，它们都不在当前foo函数的作用域中。</strong></p>
<p>​        <strong>co_varnames：一个元组，保存在当前作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>a、b、d是位于当前foo函数的作用域当中的，所以编译阶段便确定了局部变量是什么。</strong></p>
<p>​        <strong>co_consts：常量池，一个元组对象，保存代码块中的所有常量。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>, <span class="literal">False</span>, <span class="built_in">list</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># list不属于常量</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_consts)  <span class="comment"># (None, &#x27;abc&#x27;, True, False, 1, 2, 3, &#x27;a&#x27;, &#x27;&gt;&gt;&gt;&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>co_consts里面出现的都是常量，而<code>[1, 2, 3]</code>和<code>&#123;&quot;a&quot;: 1&#125;</code>，则是将里面元素单独拿出来了。不过可能有人好奇里面的None是从哪里来的。首先a和b是不是函数的参数啊，所以co_consts里面还要有两个常量，但是我们还没传参呢，所以使用None来代替。</strong></p>
<p>​        <strong>co_freevars：内层函数引用的外层函数的作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里调用的是f2的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1().__code__.co_freevars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_cellvars：外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():    </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但这里调用的是f1的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_cellvars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_filename：代码块所在的文件名</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_filename)  <span class="comment"># D:/satori/1.py</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_name：代码块的名字，通常是函数名或者类名</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_code：字节码</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, /, c, *, d, e</span>):</span><br><span class="line">    f = <span class="number">123</span></span><br><span class="line">    g = <span class="built_in">list</span>()</span><br><span class="line">    g.extend([<span class="built_in">tuple</span>, <span class="built_in">getattr</span>, <span class="built_in">print</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_code)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;d\x01&#125;\x05t\x00\x83\x00&#125;\x06|\x06\xa0\x01t\x02t\x03t\x04g\x03\xa1\x01\x01\x00d\x00S\x00&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 这便是字节码, 当然单单是这些字节码肯定不够的, 所以还需要其它的静态信息</span></span><br><span class="line"><span class="comment"># 其它的信息显然连同字节码一样, 都位于PyCodeObject中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># co_lnotab: 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_lnotab)  <span class="comment"># b&#x27;\x00\x01\x04\x01\x06\x01&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">然而事实上，Python不会直接记录这些信息，而是会记录增量值。比如说：</span></span><br><span class="line"><span class="string">字节码在co_code中的偏移量            .py文件中源代码的行号</span></span><br><span class="line"><span class="string">0                                  1  </span></span><br><span class="line"><span class="string">6                                  2</span></span><br><span class="line"><span class="string">50                                 7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么co_lnotab就应该是: 0 1 6 1 44 5</span></span><br><span class="line"><span class="string">0和1很好理解, 就是co_code和.py文件的起始位置</span></span><br><span class="line"><span class="string">而6和1表示字节码的偏移量是6, .py文件的行号增加了1</span></span><br><span class="line"><span class="string">而44和5表示字节码的偏移量是44, .py文件的行号增加了5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h4><p><strong>每一个PyCodeObject对象中都包含了一个co_code指针，指向code block中所有代码经过编译后得到的byte  code序列。前面我们说到，Python会将字节码序列和PyCodeObject对象一起存储在pyc文件中。但不幸的是，事实并不总是这样。有时，当我们运行一个简单的程序时并没有产生pyc文件，因此我们猜测：有些python程序只是临时完成一些琐碎的工作，这样的程序仅仅只会运行一次，然后就不会再使用了，因此也就没有保存至pyc文件的必要。</strong></p>
<p><strong>如果我们在代码中加上了一个import  abc这样语句，再执行你就会发现Python为其生成了pyc文件，这就说明import会触发pyc的生成。实际上，在运行过程中，如果碰到import  abc这样的语句，那么Python会在设定好的path中寻找abc.pyc或者abc.dll文件，如果没有这些文件，而是只发现了abc.py，那么Python会先将abc.py编译成PyCodeObject，然后创建pyc文件，并将PyCodeObject写到pyc文件里面去。接下来，再对abc.pyc进行import动作，对，并不是编译成PyCodeObject对象之后直接使用，而是先写到pyc里面去，然后将pyc文件的PyCodeObject对象重新在内存中复制出来。</strong></p>
<p><font color="red"><strong>关于python的import机制，我们后面章节会剖析，这里只是用来完成pyc文件的触发。当然得到pyc文件有很多方法，比如使用py_compile模块。</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>执行b.py的时候，会发现创建了a.cpython-38.pyc。另外关于pyc文件的创建位置，会在当前文件的同级目录下的<code>__pycache__</code>目录中创建，名字就叫做：py文件名.cpython-版本号.pyc</strong></p>
<h4 id="通过compile获取PyCodeObject对象"><a href="#通过compile获取PyCodeObject对象" class="headerlink" title="通过compile获取PyCodeObject对象"></a>通过compile获取PyCodeObject对象</h4><p><strong>事实上我们已经介绍了一种方法去获取相应的PyCodeObject对象，但是还有没有其他的方法呢？答案是通过内置函数compile，但是在介绍compile之前，先介绍一下eval和exec。</strong></p>
<p>​        <strong>eval：传入一个字符串，然后把字符串里面的内容拿出来。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 所以eval(&quot;a&quot;)就等价于a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1 + 1&quot;</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：eval是有返回值的，返回值就是字符串里面内容。</span></span><br><span class="line"><span class="comment"># 或者说eval是可以作为右值的，比如a = eval(&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment"># 所以eval里面绝不可以出现诸如赋值之类的，比如 print(eval(&quot;a = 3&quot;))，那么这个语句等价于print(a = 3)，这样显然会出现语法错误的</span></span><br><span class="line"><span class="comment"># 因此eval里面把字符串剥掉之后就是一个普通的值，不可以出现诸如if、def等语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;xxx&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>exec：传入一个字符串，把字符串里面的内容当成语句来执行，这个是没有返回值，或者说返回值是None。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1&quot;</span>)  <span class="comment"># 等价于把a = 1这个字符串里面的内容当成语句来执行</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;&quot;&quot;a = 123</span></span><br><span class="line"><span class="string">if a == 123:</span></span><br><span class="line"><span class="string">    print(&quot;a等于123&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;a不等于123&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(statement)  <span class="comment"># a等于123</span></span><br><span class="line"><span class="comment"># 注意：&#x27;a等于123&#x27;并不是exec返回的，而是把上面那坨字符串当成普通代码执行的时候print出来的</span></span><br><span class="line"><span class="comment"># 这便是exec的作用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么它和eval的区别就显而易见的，eval是要求字符串里面的内容能够当成一个值来打印，返回值就是里面的值</span></span><br><span class="line"><span class="comment"># 而exec则是直接执行里面的内容</span></span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">exec</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># invalid syntax (&lt;string&gt;, line 1)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>compile：关键来了，它执行后返回的就是一个code对象</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">statement = <span class="string">&quot;a, b = 1, 2&quot;</span></span><br><span class="line"><span class="comment"># 参数一：代码</span></span><br><span class="line"><span class="comment"># 参数二：可以为这些代码起一个文件名</span></span><br><span class="line"><span class="comment"># 参数三：执行方式,可以选择三种方式。exec: 将源码当做一个模块来编译;single: 用于编译一个单独d的Python语句(交互式下);eval:用于编译一个eval表达式</span></span><br><span class="line"><span class="comment"># 这里显然是exec</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_firstlineno)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(co.co_filename)  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(co.co_argcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是一个元组，因为我们是a, b = 1, 2这种方式赋值的，所以加载的是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># ((1, 2), None)</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;a = 1;b = 2&quot;</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># (1, 2, None)</span></span><br><span class="line"><span class="built_in">print</span>(co.co_names)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们后面在分析PyCodeObject的时候，会经常使用compile的方式。</strong></p>
<h3 id="pyc文件的生成"><a href="#pyc文件的生成" class="headerlink" title="pyc文件的生成"></a>pyc文件的生成</h3><h4 id="创建pyc文件的具体过程"><a href="#创建pyc文件的具体过程" class="headerlink" title="创建pyc文件的具体过程"></a>创建pyc文件的具体过程</h4><p><strong>前面我们提到，Python通过import  module进行加载时，如果没有找到相应的pyc或者dll文件，就会在py文件的基础上自动创建pyc文件。所以想要了解pyc文件是怎么创建的，只需要了解PyCodeObject是如何写入的即可。关于写入pyc文件，主要写入三个内容：</strong></p>
<p>​        <strong>1. magic number</strong>    </p>
<p><strong>这是Python定义的一个整数值，不同版本的Python会定义不同的magic  number，这个值是为了保证Python能够加载正确的pyc。比如Python3.7不会加载3.6版本的pyc，因为Python在加载这个pyc文件的时候会首先检测该pyc的magic number，如果和自身的magic number不一致，则拒绝加载。</strong></p>
<p>​        <strong>2. pyc的创建时间</strong>    </p>
<p><strong>这个很好理解，因为编译完之后要是把源代码修改了怎么办呢？因此会判断源代码的最后修改时间和pyc文件的创建时间，如果pyc文件的创建时间比源代码修改时间要早，说明在生成pyc之后，源代码被修改了，那么会重新编译新的pyc，而反之则会直接加载pyc。</strong></p>
<p>​        <strong>3.PyCodeObject对象</strong>    </p>
<p><strong>这个不用说了，肯定是要存储的。当然还有字节码，不过PyCodeObject里面的co_code指向了这个字节码，所以我们就直接说PyCodeObject对象了。</strong></p>
<h4 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h4><p><strong>既然要写入，那么肯定要有文件句柄，我们来看看：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：Python/marshal.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FILE是一个文件句柄，可以把WFILE看成是FILE的包装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FILE *fp;  <span class="comment">//文件句柄</span></span><br><span class="line">    <span class="comment">//下面的字段在写入信息的时候会看到</span></span><br><span class="line">    <span class="type">int</span> error;  </span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">char</span> *end;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    _Py_hashtable_t *hashtable;</span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line">&#125; WFILE;</span><br></pre></td></tr></table></figure>

<p><strong>写入magic number和时间：</strong></p>
<p><strong>写入magic number和时间都是调用了<code>PyMarshal_WriteLongToFile</code>，我们来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteLongToFile</span><span class="params">(<span class="type">long</span> x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明char型的数组，元素个数为4个</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//声明一个WFILE类型变量wf</span></span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="comment">//内存初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    <span class="comment">//设置fp，文件句柄</span></span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    <span class="comment">//将buf数组的指针赋值给wf.ptr和wf.buf</span></span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    <span class="comment">//相当于buf的最后一个元素的指针</span></span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">//写错误</span></span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    <span class="comment">//写入版本信息</span></span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="comment">//调用w_long将x也就是版本信息或者时间写到wf里面去</span></span><br><span class="line">    w_long(x, &amp;wf);</span><br><span class="line">    <span class="comment">//刷到磁盘上</span></span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到这一步只是初始化一个WFILE对象，真正写入则是调用w_long</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_long</span><span class="params">(<span class="type">long</span> x, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    w_byte((<span class="type">char</span>)( x      &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//w_long则是将要写入的x一个字节一个字节写到文件里面去。</span></span><br></pre></td></tr></table></figure>

<p><strong>写入PyCodeObject对象：</strong></p>
<p><strong>写入PyCodeObject对象则是调用了<code>PyMarshal_WriteObjectToFile</code>，我们也来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteObjectToFile</span><span class="params">(PyObject *x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="keyword">if</span> (w_init_refs(&amp;wf, version))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* caller mush check PyErr_Occurred() */</span></span><br><span class="line">    w_object(x, &amp;wf);</span><br><span class="line">    w_clear_refs(&amp;wf);</span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看到，和PyMarshal_WriteLongToFile基本是类似的</span></span><br><span class="line"><span class="comment">//只不过PyMarshal_WriteLongToFile调用的是w_long，而PyMarshal_WriteObjectToFile调用的是w_object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_object</span><span class="params">(PyObject *v, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> flag = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;depth &gt; MAX_MARSHAL_STACK_DEPTH) &#123;</span><br><span class="line">        p-&gt;error = WFERR_NESTEDTOODEEP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        w_byte(TYPE_NULL, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_None) &#123;</span><br><span class="line">        w_byte(TYPE_NONE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == PyExc_StopIteration) &#123;</span><br><span class="line">        w_byte(TYPE_STOPITER, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_Ellipsis) &#123;</span><br><span class="line">        w_byte(TYPE_ELLIPSIS, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_False) &#123;</span><br><span class="line">        w_byte(TYPE_FALSE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_True) &#123;</span><br><span class="line">        w_byte(TYPE_TRUE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!w_ref(v, &amp;flag, p))</span><br><span class="line">        w_complex_object(v, flag, p);</span><br><span class="line"></span><br><span class="line">    p-&gt;depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到本质上还是调用了w_byte，但是在这里面我们并没有看到诸如：列表、元组之类的数据的存储过程，注意最后的w_complex_object，关键来了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源代码很长, 具体逻辑就不贴了</span></span><br><span class="line"><span class="comment">//我们后面会单独截取一部分	进行分析</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_complex_object</span><span class="params">(PyObject *v, <span class="type">char</span> flag, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyLong_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyFloat_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyComplex_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyBytes_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyUnicode_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; PyUnicode_IS_ASCII(v)) &#123;</span><br><span class="line">            	<span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyAnySet_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyCode_Check(v)) &#123;</span><br><span class="line">        PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyObject_CheckBuffer(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        W_TYPE(TYPE_UNKNOWN, p);</span><br><span class="line">        p-&gt;error = WFERR_UNMARSHALLABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><font color="red"><strong>源代码很长，这里就不一一分析了，可以自行查看。不过虽然长，但是逻辑很简单，就是对不同的对象、执行不同的写动作。然而其最终目的都是通过w_byte写到pyc文件中。换句话说，Python在往pyc写入list对象时，只是将list中包含的数值或者字符串等对象写到了pyc文件中。同时这也意味着，Python在加载pyc文件时，必须基于这些数值或字符串重新构造出list对象。</strong></font></p>
<p><strong>对于PyCodeObject对象，很显然，w_object会遍历PyCodeObject中的所有域，将这些域依次写入。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br></pre></td></tr></table></figure>

<p><strong>但是当面对一个PyListObject对象时，会有什么变化呢？没错，会和PyCodeObject一样，w_object还是会遍历，然后将PyListObject对象中的每一个元素依次写入到pyc文件中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以看到PyTupleObject、PyListObject、PyDictObject都是采用了相同的姿势</span></span><br><span class="line"><span class="comment">//注意里面的W_TYPE</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">        n = PyTuple_Size(v);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; n &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            W_TYPE(TYPE_SMALL_TUPLE, p);</span><br><span class="line">            w_byte((<span class="type">unsigned</span> <span class="type">char</span>)n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            W_TYPE(TYPE_TUPLE, p);</span><br><span class="line">            W_SIZE(n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyTuple_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        W_TYPE(TYPE_LIST, p);</span><br><span class="line">        n = PyList_GET_SIZE(v);</span><br><span class="line">        W_SIZE(n, p);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyList_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        Py_ssize_t pos;</span><br><span class="line">        PyObject *key, *value;</span><br><span class="line">        W_TYPE(TYPE_DICT, p);</span><br><span class="line">        <span class="comment">/* This one is NULL object terminated! */</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(v, &amp;pos, &amp;key, &amp;value)) &#123;</span><br><span class="line">            w_object(key, p);</span><br><span class="line">            w_object(value, p);</span><br><span class="line">        &#125;</span><br><span class="line">        w_object((PyObject *)<span class="literal">NULL</span>, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到无论对于哪一个对象，在写入之前，都会先调用W_TYPE写一个类似于类型的东西，是的，诸如TYPE_LIST、TYPE_TUPLE、TYPE_DICT这样的标识，对于pyc文件的加载起着至关重要的作用。</strong></p>
<p><strong>之前说过，Python仅仅将容器里面的数值和字符串写入到pyc文件。当PyCodeObject写入到pyc之后，所有的数据就变成了字节流，类型信息就丢失了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从当前来看，常量池中没有任何关于列表的信息</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_consts)  <span class="comment"># (None, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<p><strong>然鹅如果没有类型信息，那么当python再次加载pyc文件的时候，就没办法知道字节流中隐藏的结构和蕴含的信息，所以Python必须往pyc文件写入一个标识，这些标识正是Python定义的类型信息。如果Python在pyc中发现了这样的标识，则预示着上一个对象结束，新的对象开始，并且也知道新对象是什么样的对象，从而也知道该执行什么样的加载动作，这些标识也是可以看到的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//marshal.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NULL               <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NONE               <span class="string">&#x27;N&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FALSE              <span class="string">&#x27;F&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TRUE               <span class="string">&#x27;T&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STOPITER           <span class="string">&#x27;S&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ELLIPSIS           <span class="string">&#x27;.&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT                <span class="string">&#x27;i&#x27;</span></span></span><br><span class="line"><span class="comment">/* TYPE_INT64 is not generated anymore.</span></span><br><span class="line"><span class="comment">   Supported for backward compatibility only. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT64              <span class="string">&#x27;I&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FLOAT              <span class="string">&#x27;f&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_FLOAT       <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_COMPLEX            <span class="string">&#x27;x&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_COMPLEX     <span class="string">&#x27;y&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LONG               <span class="string">&#x27;l&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STRING             <span class="string">&#x27;s&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INTERNED           <span class="string">&#x27;t&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_REF                <span class="string">&#x27;r&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TUPLE              <span class="string">&#x27;(&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LIST               <span class="string">&#x27;[&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_DICT               <span class="string">&#x27;&#123;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_CODE               <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNICODE            <span class="string">&#x27;u&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNKNOWN            <span class="string">&#x27;?&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_SET                <span class="string">&#x27;&lt;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FROZENSET          <span class="string">&#x27;&gt;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>到了这里可以看到，其实Python对于PyCodeObject对象的导出实际上是不复杂的，因为不管什么对象，最后都为归结为两种简单的形式，一种是数值写入，一种是字符串写入。上面都是对数值的写入，比较简单，仅仅需要按照字节一次写入pyc即可。然而在写入字符串的时候，Python设计了一种比较复杂的机制，有兴趣可以自己阅读源码，这里不再介绍。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前说对于这样的一个py文件，会创建三个PyCodeObject对象，但是写到pyc文件里面的只有一个PyCodeObject对象，这难道不就意味着有两个PyCodeObject丢失了吗？其实很明显，有两个PyCodeObject对象是位于另一个PyCodeObject对象当中的。因此foo和A对应的PyCodeObject对象位于a.py这个PyCodeObject对象当中，准确的说是位于co_consts指向的常量池当中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_consts)</span><br><span class="line"><span class="comment"># (None, &lt;code object f2 at 0x000001BC5DF3D450, file &quot;D:/satori/1.py&quot;, line 2&gt;, &#x27;f1.&lt;locals&gt;.f2&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到f2对应的PyCodeObject确实位于f1的常量池当中，但其实说白了不过f1的常量池当中有一个指针在指向f2对应PyCodeObject罢了。只不过在写入的时候，也会把指针的内容一块写进去，所以也可以理解就是写了3个PyCodeObject对象。不过这都不是重点，重点是PyCodeObject对象是可以嵌套的，当在一个作用域内部发现了一个新的作用域，那么新的作用域对应的PyCodeObject对象会位于外层作用域的PyCodeObject对象的常量池中，或者说被常量池中的一个指针指向。</strong></p>
<p><strong>而在写入pyc的时候会从最外层、也就是模块的PyCodeObject对象开始写入，如果碰到了包含的另一个PyCodeObject对象，那么就会递归地执行写入新的PyCodeObject对象的操作。如此下去，最终所有的PyCodeObject对象都会写入到pyc文件当中，因此pyc文件当中的PyCodeObject对象也是以一种嵌套的关系联系在一起的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>这里问一下，上面那段代码中创建了几个PyCodeObject对象呢？</strong></p>
<blockquote>
<p><strong>答案是6个，首先全局是一个，foo函数一个，bar函数一个，类A一个，类A里面的foo函数一个，类A里面的bar函数一个，所以一共是6个。</strong></p>
<p><strong>而且这里的PyCodeObject对象是层层嵌套的，一开始是对整个全局创建PyCodeObject对象，然后遇到了函数foo，那么再为函数foo创建一个PyCodeObject对象，依次往下。所以如果是常量值、字符串等等，则相当于是静态信息，直接存储起来便可；可如果是函数、类，那么会为其创建新的PyCodeObject对象，然后收集起来，所以A里面的foo函数对应的PyCodeObject对象是存在A对应PyCodeObject对象里面的；而A对应的PyCodeObject对象则是存在全局对应的PyCodeObject对象里面，当然此时还有外层的foo、bar函数。。</strong></p>
</blockquote>
<h3 id="Python的字节码与反编译"><a href="#Python的字节码与反编译" class="headerlink" title="Python的字节码与反编译"></a>Python的字节码与反编译</h3><p><strong>关于Python的字节码，是后面章节剖析虚拟机的重点，现在先来看一下。我们知道Python执行源代码之前会对其进行编译得到PyCodeObject对象，里面的co_code指向了字节码序列，Python虚拟机会根据这些字节码序列来进行一系列的操作<code>(当然也依赖其它的静态信息)</code>，从而完成对程序的执行。</strong></p>
<p><strong>当然每一个操作在python中都对应一个操作指令、或者操作数，总共一共定义了121个。其实说白了每个指令不过是一个整数罢了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POP_TOP                   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_TWO                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_THREE                 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP                   4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP_TWO               5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP                       9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_POSITIVE           10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NEGATIVE           11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NOT                12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_INVERT             15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MATRIX_MULTIPLY   16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_MATRIX_MULTIPLY  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_POWER             19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MULTIPLY          20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MODULO            22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_ADD               23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBTRACT          24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBSCR            25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_FLOOR_DIVIDE      26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TRUE_DIVIDE       27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_FLOOR_DIVIDE     28</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>然后我们可以通过反编译的方式查看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的dis模块是专门干这件事情</span></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 里面可以接收一个字节码对象, 当然函数也是可以的, 会自动获取co_code</span></span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  5           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              2 LOAD_FAST                1 (b)</span></span><br><span class="line"><span class="string">              4 BINARY_ADD</span></span><br><span class="line"><span class="string">              6 STORE_FAST               2 (c)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  6           8 LOAD_FAST                2 (c)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>字节码反编译后的结果多么像汇编语言！其中，第一列是源代码行号，第二列是字节码偏移量，第三列是操作数。</strong></p>
<p><strong>关于反编译的内容，我们会在剖析函数的时候，深入介绍。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>12-剖析字节码指令</title>
    <url>/2023/03/29/12-%E5%89%96%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程"><a href="#12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程" class="headerlink" title="12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程"></a>12-剖析字节码指令，从不一样的角度观测Python源代码的执行过程</h2><p><strong>上一章中，我们通过_PyEval_EvalFrameDefault看到了Python虚拟机的整体框架，那么这一章我们将深入到_PyEval_EvalFrameDefault的各个细节当中，深入剖析Python的虚拟机，在本章中我们将剖析Python虚拟机是如何完成对一般表达式的执行的。这里的一般表达式包括最基本的对象创建语句、打印语句等等。至于if、while等表达式，我们将其归类于控制流语句，对于Python中控制流的剖析，我们将留到下一章。</strong></p>
<h3 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h3><p><strong>这里我们通过问与答的方式，简单回顾一下前面的内容。</strong></p>
<p>​        <strong>请问 Python 程序是怎么运行的？是编译成机器码后在执行的吗？</strong>    </p>
<p><strong>不少初学者对 *Python* 存在误解，以为它是类似 *Shell* 的解释性脚本语言，其实并不是。虽然执行 *Python* 程序的 称为 *Python* 解释器，但它其实包含一个 “编译器” 和一个 “虚拟机”。</strong></p>
<p><strong>当我们在命令行敲下 <code>python xxxx.py</code> 时，*python* 解释器中的编译器首先登场，将 *Python* 代码编译成 *PyCodeObject* 对象。*PyCodeObject* 对象包含 字节码 以及执行字节码所需的 名字 以及 常量。</strong></p>
<p><strong>当编译器完成编译动作后，接力棒便传给 虚拟机。虚拟机 维护执行上下文，逐行执行 字节码 指令。执行上下文中最核心的 名字空间，便是由 虚拟机 维护的。</strong></p>
<p><strong>因此，*Python* 程序的执行原理其实更像 *Java*，可以用两个词来概括—— 虚拟机和字节码。不同的是，*Java* 编译器 *javac* 与 虚拟机 *java* 是分离的，而 *Python* 将两者整合成一个 *python* 命令。</strong></p>
<p>​        <strong>pyc 文件保存什么东西，有什么作用？</strong>    </p>
<p><strong>Python 程序执行时需要先由 编译器 编译成 *PyCodeObject* 对象，然后再交由 虚拟机 来执行。不管程序执行多少次，只要源码没有变化，编译后得到的 *PyCodeObject* 对象就肯定是一样的。因此，*Python* 将 *PyCodeObject* 对象序列化并保存到 *pyc* 文件中。当程序再次执行时，*Python* 直接从 *pyc* 文件中加载代码对象，省去编译环节。当然了，当 *py* 源码文件改动后，*pyc* 文件便失效了，这时 *Python* 必须重新编译 *py* 文件。</strong></p>
<p>​        <strong>如何查看 Python 程序的字节码？</strong>    </p>
<p><strong>Python 标准库中的 *dis* 模块，可以对 *PyCodeObject* 对象 以及 函数进行反编译，并显示其中的 字节码。</strong></p>
<blockquote>
<p><strong>其实dis.dis最终反编译的就是字节码，只不过我们可以传入一个函数，会自动获取其字节码。比如：函数foo，我们可以dis.dis(foo)、dis.dis(foo.<strong>code</strong>)、dis.dis(foo.<strong>code</strong>.co_code)，最终都是对字节码进行反编译的。</strong></p>
</blockquote>
<p><strong>在这里我们说几个常见的字节码指令，因为它太常见了以至于我们这里必须要提一下，然后再举例说明。</strong></p>
<ul>
<li><code>LOAD_CONST: 加载一个常量</code></li>
<li><code>LOAD_FAST: 在局部作用域中(比如函数)加载一个当前作用域的局部变量</code></li>
<li><code>LOAD_GLOBAL: 在局部作用域(比如函数)中加载一个全局变量或者内置变量</code></li>
<li><code>LOAD_NAME: 在全局作用域中加载一个全局变量或者内置变量</code></li>
<li><code>STORE_FAST: 在局部作用域中定义一个局部变量, 来建立和某个对象之间的映射关系</code></li>
<li><code>STORE_GLOBAL: 在局部作用域中定义一个global关键字声明的全局变量, 来建立和某个对象之间的映射关系</code></li>
<li><code>STORE_NAME: 在全局作用域中定义一个全局变量, 来建立和某个对象之间的映射关系</code></li>
</ul>
<p><strong>然后下面的我们就来看看这些指令：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(gender)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line">  <span class="number">9</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (gender)</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>           <span class="number">4</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">0</span> (gender)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">11</span>          <span class="number">12</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">14</span> LOAD_GLOBAL              <span class="number">1</span> (name)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_CONST 1 (&#39;female&#39;):  加载常量&quot;female&quot;, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_FAST 0 (gender): 在局部作用域中定义一个局部变量gender, 所以是STORE_FAST</code></li>
<li><code>4 LOAD_GLOBAL 0 (print): 在局部作用域中加载一个内置变量print, 所以是LOAD_GLOBAL</code></li>
<li><code>6 LOAD_FAST 0 (gender): 在局部作用域中加载一个局部变量gender, 所以是LOAD_FAST</code></li>
<li><code>14 LOAD_GLOBAL 1 (name): 在局部作用域中加载一个全局变量name, 所以是LOAD_GLOBAL</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    name = <span class="string">&quot;马自立三舅&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"> <span class="number">10</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;马自立三舅&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_GLOBAL             <span class="number">0</span> (name)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_CONST 1 (&#39;马自立三舅&#39;): 加载一个字符串常量, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_GLOBAL 0 (name): 在局部作用域中定义一个被global关键字声明的全局变量, 所以是STORE_GLOBAL</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">print(name)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_NAME                <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_NAME                <span class="number">0</span> (name)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code> 0 LOAD_CONST 0 (&#39;夏色祭&#39;): 加载一个字符串常量, 所以是LOAD_CONST</code></li>
<li><code>2 STORE_NAME 0 (name): 在全局作用域中定义一个全局变量name, 所以是STORE_NAME</code></li>
<li><code>4 LOAD_NAME 1 (print): 在全局作用域中加载一个内置变量print, 所以是LOAD_NAME</code></li>
<li><code>6 LOAD_NAME 0 (name): 在全局作用域中加载一个全局变量name, 所以是LOAD_NAME</code></li>
</ul>
<p><strong>因此LOAD_CONST、LOAD_FAST、LOAD_GLOBAL、LOAD_NAME、STORE_FAST、STORE_GLOBAL、STORE_NAME它们是和加载常量、变量和定义变量之间有关的，可以说常见的不能再常见了，你写的任何代码在反编译之后都少不了它们的身影，至少会出现一个。因此有必要提前解释一下，它们分别代表的含义是什么。</strong></p>
<p>​        <strong>Python 中变量交换有两种不同的写法，示例如下。这两种写法有什么区别吗？那种写法更好？</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>

<p><strong>这两种写法都能实现变量交换，表面上看第一种写法更加简洁明了，似乎更优。那么，在优雅的外表下是否隐藏着不为人知的性能缺陷呢？想要找到答案，唯一的途径是研究字节码：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"># 写法一</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (b)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> ROT_TWO</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (b)</span><br><span class="line">              </span><br><span class="line"># 写法二</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (tmp)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (tmp)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">2</span> (b)              </span><br></pre></td></tr></table></figure>

<p><strong>从字节码上看，第一种写法需要的指令条目要少一些：先将两个变量依次加载到栈，然后一条 *ROT_TWO* 指令将栈中的两个变量交换，最后再将变量依次写回去。注意到，变量加载的顺序与 *&#x3D;* 右边一致，写回顺序与 *&#x3D;* 左边一致。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(ROT_TWO)</span>: &#123;</span><br><span class="line">    <span class="comment">//从栈顶弹出元素, 因为栈是先入后出的</span></span><br><span class="line">    <span class="comment">//由于b先入栈、a后入栈, 所以这里获取的栈顶元素就是a</span></span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    <span class="comment">//运行时栈的第二个元素就是b</span></span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    <span class="comment">//当然栈里面的元素是谁在这里并不重要, 重点是我们看到栈顶元素被设置成了栈的第二个元素</span></span><br><span class="line">    <span class="comment">//栈的第二个元素被设置成了栈顶元素, 所以两个元素确实实现了交换</span></span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>而且，*ROT_TWO* 指令只是将栈顶两个元素交换位置，执行起来比 *LOAD_NAME* 和 *STORE_NAME* 都要快。</strong></p>
<p><strong>至此，我们可以得到结论了——第一种变量交换写法更优：</strong></p>
<ul>
<li><code>代码简洁明了, 不拖泥带水</code></li>
<li><code>不需要辅助变量 tmp, 节约内存</code></li>
<li><code>ROT_TWO 指令比 LOAD_NAME 和 STORE_NAME 组成的指令对更有优势，执行效率更高</code></li>
</ul>
<p>​        <strong>请解释 is 和 &#x3D;&#x3D; 这两个操作的区别。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">is</span> b</span><br><span class="line">a == b</span><br></pre></td></tr></table></figure>

<p><strong>我们知道 *is* 是 对象标识符 ( *object identity* )，判断两个引用是不是引用的同一个对象，等价于 *id(a) &#x3D;&#x3D; id(b)* ；而 *&#x3D;&#x3D;* 操作符判断两个引用所引用的对象是不是相等，等价于调用魔法方法 *a.<strong>eq</strong>(b)* 。因此，*&#x3D;&#x3D;* 操作符可以通过 *<strong>eq</strong>* 魔法方法进行覆写( *overriding* )，而 *is* 操作符无法覆写。</strong></p>
<p><strong>从字节码上看，这两个语句也很接近，区别仅在比较指令 *COMPARE_OP* 的操作数上：</strong></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"> # a is b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="name">a</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (<span class="name">b</span>)</span><br><span class="line">              <span class="number">4</span> COMPARE_OP               <span class="number">8</span> (<span class="name">is</span>)</span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              </span><br><span class="line"># a == b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="name">a</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (<span class="name">b</span>)</span><br><span class="line">              <span class="number">4</span> COMPARE_OP               <span class="number">2</span> (<span class="name">==</span>)</span><br><span class="line">              <span class="number">6</span> POP_TOP              </span><br></pre></td></tr></table></figure>

<p>*<strong>COMPARE_OP* 指令处理逻辑在 *Python&#x2F;ceval.c* 源文件中实现，关键函数是 *cmp_outcome*：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">cmp_outcome</span><span class="params">(<span class="type">int</span> op, PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们说Python中的变量在C的层面上是一个指针, 因此Python中两个变量是否指向同一个对象 等价于 在C中两个指针是否相等</span></span><br><span class="line">    <span class="comment">//而Python中的==, 则需要调用PyObject_RichCompare(指针1, 指针2, 操作符)来看它们指向的对象所维护的值是否相等</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">        <span class="comment">//is操作符的话, 在C的层面直接一个==判断即可</span></span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//而PyObject_RichCompare是一个函数调用, 将进一步调用对象的魔法方法进行判断。</span></span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);</span><br><span class="line">    &#125;</span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># a 和 b 均引用同一个对象, is 和 == 操作均返回 True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">int</span>(<span class="string">&#x27;1024&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 显然, 由于背后对象是不同的, is 操作结果是 False; 而对象值相同, == 操作结果是 True </span></span><br></pre></td></tr></table></figure>

<p><strong>用一张图看一下它们之间的区别：</strong></p>
<p><img src="/2023/03/29/12-%E5%89%96%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/1229382-20200818171117232-708867799.png" alt="img"></p>
<p><strong>一般而言如果a is b成立，那么a &#x3D;&#x3D; b多半成立，可能有人好奇，a is b成立说明a和b指向的是同一个对象了，那么a &#x3D;&#x3D; b表示该对象和自己进行比较，结果为啥不相等呢？以下面两种情况为例：</strong></p>
<ul>
<li><code>重写了__eq__的类的实例对象</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g <span class="keyword">is</span> g)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(g == g)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>浮点数nan</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">float</span>(<span class="string">&quot;nan&quot;</span>)</span><br><span class="line">b = math.nan</span><br><span class="line">c = np.nan</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> a, a == a)  <span class="comment"># True False</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> b, b == b)  <span class="comment"># True False</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">is</span> c, c == c)  <span class="comment"># True False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nan 是一个特殊的 浮点数, 意思是not a number, 表示不是一个数字, 用于表示 异常值, 即不存在或者非法的值</span></span><br><span class="line"><span class="comment"># 不管 nan 跟任何浮点(包括自身)做何种数学比较, 结果均为 False </span></span><br></pre></td></tr></table></figure>

<p>​        <strong>在 Python 中与 None 比较时，为什么要用 is None 而不是 &#x3D;&#x3D; None ？</strong>    </p>
<p><strong>None 是一种特殊的内建对象，它是单例对象，整个运行的程序中只有一个。因此，如果一个变量等于 *None*，那么*is None*一定成立，内存地址是相同的。</strong></p>
<p>*<strong>Python* 中的 *&#x3D;&#x3D;* 操作符对两个对象进行相等性比较，背后调用 *<strong>eq</strong>* 魔法方法。在自定义类中，<strong>eq</strong> 方法可以被覆写：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(g == <span class="literal">None</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>而且最重要的一点，我们在介绍is和 &#x3D;&#x3D;  之间区别的时候说过，Python的is在底层是比较地址是否相等，所以对于C而言只是判断两个变量间是否相等、一个 &#x3D;&#x3D;  操作符即可；但是对于Python的&#x3D;&#x3D;，在底层则是需要调用PyObject_RichCompare函数，然后进一步取出所维护的值进行比较。所以通过is None来判断会在性能上更有优势一些，再加上None是单例对象，使用is判断是最合适的。我们使用jupyter  notebook测试一下两者的性能吧：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%timeit name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="number">31.6</span> ns ± <span class="number">1.62</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000000</span> loops each)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%timeit name == <span class="literal">None</span></span><br><span class="line"><span class="number">36.6</span> ns ± <span class="number">2.8</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000000</span> loops each)</span><br></pre></td></tr></table></figure>

<h3 id="复杂内建对象的创建"><a href="#复杂内建对象的创建" class="headerlink" title="复杂内建对象的创建"></a>复杂内建对象的创建</h3><p><strong>像整数对象、字符串对象在创建时的字节码，相信都已经理解了。总共两条指令：直接先LOAD常量，然后STORE<code>(两者组成entry放在local名字空间中)</code>。</strong></p>
<p><strong>但是问题来了，像列表、字典这样的对象，底层是怎么创建的呢？显然它们的创建要更复杂一些，两条指令是不够的。下面我们就来看看列表、字典在创建时对应的字节码是怎样的吧。</strong></p>
<p><strong>不过在此之前我们需要看一些宏，这是PyFrame_EvalFrameEx<code>(调用了_PyEval_EvalFrameDefault)</code>在遍历指令序列co_code时所需要的宏，里面包括了对栈的各种操作，以及对PyTupleObject对象的元素的访问操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取PyTupleObject对象中指定索引对应的元素</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETITEM(v, i) PyTuple_GetItem((v), (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//调整栈顶指针, 这个stack_pointer指向运行时栈的顶端</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_STACKADJ(n) (stack_pointer += n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKADJ(n)     &#123; (void)(BASIC_STACKADJ(n), \</span></span><br><span class="line"><span class="meta">                          lltrace &amp;&amp; prtrace(TOP(), <span class="string">&quot;stackadj&quot;</span>)); \</span></span><br><span class="line"><span class="meta">                          assert(STACK_LEVEL() <span class="string">&lt;= co-&gt;</span>co_stacksize); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PUSH(v)     (*stack_pointer++ = (v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH(v)                BASIC_PUSH(v)</span></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_POP()       (*--stack_pointer)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP()           ((void)(lltrace &amp;&amp; prtrace(TOP(), <span class="string">&quot;pop&quot;</span>)), \</span></span><br><span class="line"><span class="meta">                         BASIC_POP())</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们随便创建一个列表和字典吧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">lst = [1, 2, &quot;3&quot;, &quot;xxx&quot;]</span></span><br><span class="line"><span class="string">d = &#123;&quot;name&quot;: &quot;夏色祭&quot;, &quot;age&quot;: -1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> BUILD_LIST               <span class="number">4</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">0</span> (lst)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          <span class="number">12</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">5</span> (-<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">6</span> ((<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>))</span><br><span class="line">             <span class="number">18</span> BUILD_CONST_KEY_MAP      <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> STORE_NAME               <span class="number">1</span> (d)</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">7</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先对于列表来说，它是先将列表中的常量加载进来了，从上面的4个LOAD_CONST也能看出来。然后重点来了，我们看到有一行指令 BUILD_LIST 4，从名字上也能看出来这是要根据load进行来的4个常量创建一个列表，后面的4表示这个列表有4个元素。</strong></p>
<p><strong>但是问题来了，Python怎么知道这构建的是一个列表呢？元组难道不可以吗？答案是因为我们创建的是列表，不是元组，而且这个信息也体现在了字节码中。然后我们看看BUILD_LIST都干了些什么吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BUILD_LIST)</span>: &#123;</span><br><span class="line">   <span class="comment">//这里的oparg显然指的就是BUILD_LIST后面的4</span></span><br><span class="line">      <span class="comment">//因此可以看到这个oparg的含义取决于字节码指令, 比如:LOAD_CONST就是代表索引, 这里的就是列表元素个数	</span></span><br><span class="line">      <span class="comment">//PyList_New表示创建一个能容纳4个元素的的PyListObject对象</span></span><br><span class="line">      PyObject *<span class="built_in">list</span> =  PyList_New(oparg);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line"><span class="comment">//从运行时栈里面将元素一个一个的弹出来, 注意它的索引, load元素的时候是按照1、2、&quot;3&quot;、&quot;xxx&quot;的顺序load</span></span><br><span class="line">      <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//但是栈是先入后出结构, 索引栈顶的元素是&quot;xxx&quot;, 栈底的元素是1</span></span><br><span class="line">          <span class="comment">//所以这里弹出元素的顺序就变成了&quot;xxx&quot;、&quot;3&quot;、2、1</span></span><br><span class="line">          PyObject *item = POP();</span><br><span class="line">          <span class="comment">//所以这里的oparg是从后往前遍历的, 即3、2、1、0</span></span><br><span class="line">          <span class="comment">//所以最终将&quot;xxx&quot;设置在索引为3的位置、将&quot;3&quot;设置在索引2位的位置, 将2设置在索引为1的位置, 将1设置在索引为0的位置</span></span><br><span class="line">          <span class="comment">//这显然是符合我们的预期的</span></span><br><span class="line">          PyList_SET_ITEM(<span class="built_in">list</span>, oparg, item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//构建完毕之后, 将其压入运行时栈, 此时栈中只有一个PyListObject对象, 因为先load进来的4个常量在构建列表的时候已经被逐个弹出来了</span></span><br><span class="line">      PUSH(<span class="built_in">list</span>);</span><br><span class="line">      DISPATCH();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>但BUILD_LIST之后，只改变了运行时栈，没有改变local空间。所以后面的STORE_NAME 0 (lst)表示将在local空间中建立一个 “符号lst” 到 “BUILD_LIST构建的PyListObject对象”  之间的映射，也就是组合成一个entry放在local空间中，这样我们后面才可以通过符号lst找到对应的列表。</strong></p>
<blockquote>
<p><strong>STORE_NAME我们已经见过了，这里就不说了。其实STORE_XXX和LOAD_XXX都是非常简单的，像LOAD_GLOBAL、LOAD_FAST、STORE_FAST等等可以自己去看一下，没有任何难度，当然我们下面也会说。</strong></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (&#x27;<span class="number">3</span>&#x27;)</span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (&#x27;xxx&#x27;)</span><br><span class="line">            <span class="number">8</span> BUILD_LIST               <span class="number">4</span></span><br><span class="line">           <span class="number">10</span> STORE_NAME               <span class="number">0</span> (<span class="name">lst</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>          <span class="number">12</span> LOAD_CONST               <span class="number">4</span> (&#x27;夏色祭&#x27;)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">5</span> (<span class="name">-1</span>)</span><br><span class="line">           <span class="number">16</span> LOAD_CONST               <span class="number">6</span> ((&#x27;name&#x27;, &#x27;age&#x27;))</span><br><span class="line">           <span class="number">18</span> BUILD_CONST_KEY_MAP      <span class="number">2</span></span><br><span class="line">           <span class="number">20</span> STORE_NAME               <span class="number">1</span> (<span class="name">d</span>)</span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">7</span> (<span class="name">None</span>)</span><br><span class="line">           <span class="number">24</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>然后我们再看看字典的构建方式，首先依旧是加载两个常量，显然这个字典是value。然后注意：我们看到key是作为一个元组加载进来的。而且如果我们创建了一个元组，那么这个元组也会整体被LOAD_CONST，所以从这里我们也能看到列表和元组之间的区别，列表的元素是一个一个加载的，元组是整体加载的，只需要LOAD_CONST一次即可。BUILD_CONST_KEY_MAP      2毋庸置疑就是构建一个字典了，后面的oparg是2，表示这个字典有两个entry，我们看一下源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BUILD_CONST_KEY_MAP)</span>: &#123;</span><br><span class="line">      Py_ssize_t i; <span class="comment">//循环变量</span></span><br><span class="line">      PyObject *<span class="built_in">map</span>;<span class="comment">//一个PyDictObject对象指针</span></span><br><span class="line">      PyObject *keys = TOP();<span class="comment">//从栈顶获取所有的key, 一个元组</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//如果keys不是一个元组或者这个元组的ob_size不等于oparg, 那么表示字典构建失败</span></span><br><span class="line">      <span class="keyword">if</span> (!PyTuple_CheckExact(keys) ||</span><br><span class="line">          PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) &#123;</span><br><span class="line">          _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                           <span class="string">&quot;bad BUILD_CONST_KEY_MAP keys argument&quot;</span>);</span><br><span class="line">          <span class="comment">//显然这是属于Python内部做的处理, 至少我们在使用层面没有遇到过这个问题</span></span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//申请一个字典, 表示至少要容纳oparg个键值对, 但是具体的容量肯定是要大于oparg的</span></span><br><span class="line">      <span class="comment">//至于到底是多少, 则取决于oparg, 总之这一步就是申请合适容量的字典</span></span><br><span class="line">      <span class="built_in">map</span> = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//很明显, 这里开始循环了, 要依次设置键值对了</span></span><br><span class="line">      <span class="comment">//还记得在BUILD_CONST_KEY_MAP之前, 常量是怎么加载的吗?是按照&quot;夏色祭&quot;、-1、(&#x27;name&#x27;, &#x27;age&#x27;)的顺序加载的</span></span><br><span class="line">      <span class="comment">//所以栈里面的元素, 从栈顶到栈底就应该是(&#x27;name&#x27;, &#x27;age&#x27;)、-1、&quot;夏色祭&quot;</span></span><br><span class="line">      <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="type">int</span> err;</span><br><span class="line">          <span class="comment">//这里是获取元组里面的元素, 也就是key, 注意: 索引是oparg - i, 而i是从oparg开始自减的</span></span><br><span class="line">          <span class="comment">//以当前为例, 循环结束时, oparg - i分别是0、1，那么获取的元素显然就分别是: &quot;name&quot;、&quot;age&quot;</span></span><br><span class="line">          PyObject *key = PyTuple_GET_ITEM(keys, oparg - i);</span><br><span class="line">          <span class="comment">//然后这里的PEEK和TOP类似, 都是获取元素但是不从栈里面删除, TOP是专门获取栈顶元素, PEEK还可以获取栈的其它位置的元素</span></span><br><span class="line">          <span class="comment">//而这里获取也是按照&quot;夏色祭&quot;、-1的顺序获取, 和&quot;name&quot;、&quot;age&quot;之间是正好对应的</span></span><br><span class="line">          PyObject *value = PEEK(i + <span class="number">1</span>);</span><br><span class="line">          <span class="comment">//然后将entry设置在map里面</span></span><br><span class="line">          err = PyDict_SetItem(<span class="built_in">map</span>, key, value);</span><br><span class="line">          <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">              Py_DECREF(<span class="built_in">map</span>);</span><br><span class="line">              <span class="keyword">goto</span> error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">//依次清空运行时栈, 将栈里面的元素挨个弹出来</span></span><br><span class="line">      Py_DECREF(POP());</span><br><span class="line">      <span class="keyword">while</span> (oparg--) &#123;</span><br><span class="line">          Py_DECREF(POP());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将构建的PyDictObject对象压入运行时栈</span></span><br><span class="line">      PUSH(<span class="built_in">map</span>);</span><br><span class="line">      DISPATCH();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后STORE_NAME               1 (d)，显然是再将运行时栈中的字典弹出来，将符号d和弹出来的字典建立一个entry放在local空间中。</strong></p>
<p><strong>在所有的字节码指令都执行完毕之后，运行时栈会是空的，但是所有的信息都存储在了local名字空间中。</strong></p>
<h3 id="函数中的变量"><a href="#函数中的变量" class="headerlink" title="函数中的变量"></a>函数中的变量</h3><p><strong>我们之前定义的变量是在模块级别的作用域中，但如果我们在函数中定义呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    s = <span class="string">&quot;python&quot;</span></span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (i)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (s)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到大致一样，但是有一点发生了变化，  那就是在将变量名和变量值映射的时候，使用的不再是STORE_NAME，而是STORE_FAST，显然STORE_FAST会更快一些。为什么这么说，这是因为函数中的局部变量总是固定不变的，在编译的时候就能确定局部变量使用的内存空间的位置，也能确定局部变量字节码指令应该如何访问内存，就能使用静态的方法来实现局部变量。其实局部变量的读写都在<code>fastlocals = f -&gt; f_localsplus</code>上面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_FAST)</span> &#123;</span><br><span class="line">            PyObject *value = POP();</span><br><span class="line">            SETLOCAL(oparg, value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETLOCAL(i, value)      do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line"><span class="meta">                                     GETLOCAL(i) = value; \</span></span><br><span class="line"><span class="meta">                                     Py_XDECREF(tmp); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETLOCAL(i)     (fastlocals[i])</span></span><br></pre></td></tr></table></figure>

<h3 id="一般表达式"><a href="#一般表达式" class="headerlink" title="一般表达式"></a>一般表达式</h3><h4 id="符号搜索"><a href="#符号搜索" class="headerlink" title="符号搜索"></a>符号搜索</h4><p><strong>我们还是举个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先源代码第一行对应的字节码指令无需介绍，但是第二行对应的指令变了，我们看到不再是LOAD_CONST，而是LOAD_NAME。其实也很好理解，第一行a &#x3D; 5，而5是一个常量所以是LOAD_CONST，但是b &#x3D; a，这里的a是一个变量名，所以是LOAD_NAME。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里显然要从几个名字空间里面去寻找指定的变量名对应的值</span></span><br><span class="line"><span class="comment">//找不到就会出现NameError</span></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_NAME)</span> &#123;</span><br><span class="line">           <span class="comment">//从符号表里面获取变量名</span></span><br><span class="line">           PyObject *name = GETITEM(names, oparg);</span><br><span class="line">           <span class="comment">//获取local命名空间, 一个PyDictObject对象</span></span><br><span class="line">           PyObject *locals = f-&gt;f_locals;</span><br><span class="line">           PyObject *v; <span class="comment">//value</span></span><br><span class="line">           <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               PyErr_Format(PyExc_SystemError,</span><br><span class="line">                            <span class="string">&quot;no locals when loading %R&quot;</span>, name);</span><br><span class="line">               <span class="keyword">goto</span> error;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//根据变量名从locals里面获取对应的value</span></span><br><span class="line">           <span class="keyword">if</span> (PyDict_CheckExact(locals)) &#123;</span><br><span class="line">               v = PyDict_GetItem(locals, name);</span><br><span class="line">               Py_XINCREF(v);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               v = PyObject_GetItem(locals, name);</span><br><span class="line">               <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                       <span class="keyword">goto</span> error;</span><br><span class="line">                   PyErr_Clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果v是NULL，说明local名字空间里面没有</span></span><br><span class="line">           <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="comment">//于是从global名字空间里面找</span></span><br><span class="line">               v = PyDict_GetItem(f-&gt;f_globals, name);</span><br><span class="line">               Py_XINCREF(v);</span><br><span class="line">               <span class="comment">//如果v是NULL说明global里面也没有</span></span><br><span class="line">               <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="comment">//下面的if和else里面的逻辑基本一致，只不过对builtin做了检测</span></span><br><span class="line">                   <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">                       <span class="comment">//local、global都没有，于是从builtin里面找</span></span><br><span class="line">                       v = PyDict_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                       <span class="comment">//还没有，NameError</span></span><br><span class="line">                       <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                           format_exc_check_arg(</span><br><span class="line">                                       PyExc_NameError,</span><br><span class="line">                                       NAME_ERROR_MSG, name);</span><br><span class="line">                           <span class="keyword">goto</span> error;</span><br><span class="line">                       &#125;</span><br><span class="line">                       Py_INCREF(v);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//从builtin里面找</span></span><br><span class="line">                       v = PyObject_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                       <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                           <span class="comment">//还没有，NameError</span></span><br><span class="line">                           <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                               format_exc_check_arg(</span><br><span class="line">                                           PyExc_NameError,</span><br><span class="line">                                           NAME_ERROR_MSG, name);</span><br><span class="line">                           <span class="keyword">goto</span> error;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到了，把v给push进去，相当于压栈</span></span><br><span class="line">           PUSH(v);</span><br><span class="line">           DISPATCH();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外如果是在函数里面，那么b &#x3D;  a就既不是LOAD_CONST、也不是LOAD_NAME，而是LOAD_FAST。这是因为函数中的变量在编译的时候就已经确定，因此是LOAD_FAST。那么如果b &#x3D; a在函数里面，而a &#x3D; 5定义在函数外面呢？那么结果是LOAD_GLOBAL，因为知道这个a到底是定义在什么地方。</strong></p>
<h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">c = a + b</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然这里我们直接从 8 LOAD_NAME开始看即可，首先是加在两个变量，然后通过BINARY_ADD进行加法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_ADD)</span> &#123;</span><br><span class="line">    <span class="comment">//获取两个值，也就是我们a和b对应的值, a是栈底、b是栈顶</span></span><br><span class="line">    PyObject *right = POP(); <span class="comment">//从栈顶弹出b</span></span><br><span class="line">    PyObject *left = TOP();  <span class="comment">//弹出b之后, 此时a就成为了栈顶, 直接通过TOP获取, 但是不弹出</span></span><br><span class="line">    PyObject *sum;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//这里检测是否是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(left) &amp;&amp;</span><br><span class="line">             PyUnicode_CheckExact(right)) &#123;</span><br><span class="line">        <span class="comment">//是的话直接拼接</span></span><br><span class="line">        sum = unicode_concatenate(left, right, f, next_instr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是的话相加</span></span><br><span class="line">        sum = PyNumber_Add(left, right);</span><br><span class="line">        Py_DECREF(left);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    <span class="comment">//设置sum, 将栈顶的元素(之前的a)给顶掉</span></span><br><span class="line">    SET_TOP(sum);</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信息输出"><a href="#信息输出" class="headerlink" title="信息输出"></a>信息输出</h4><p><strong>最后看看信息是如何输出的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (c)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">3</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">22</span> POP_TOP</span><br><span class="line">             <span class="number">24</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">26</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们直接从16 LOAD_NAME开始看，首先从builtins中加载变量print<code>(本质上加载和变量绑定的对象)</code>，然后加载变量c，将两者压入运行时栈。</strong></p>
<p><strong>CALL_FUNCTION，表示函数调用，执行刚才的print，后面的1则是参数的个数。另外，当调用print的时候，实际上又创建了一个栈帧，因为只要是函数调用都会创建栈帧的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_FUNCTION)</span> &#123;</span><br><span class="line">     PyObject **sp, *res;</span><br><span class="line">     sp = stack_pointer;</span><br><span class="line">     res = call_function(&amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">     stack_pointer = sp;</span><br><span class="line">     PUSH(res);</span><br><span class="line">     <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">goto</span> error;</span><br><span class="line">     &#125;</span><br><span class="line">     DISPATCH();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后POP_TOP表示从栈的顶端弹出函数的返回值，因为POP_TOP的上一步是一个call_function，也就是函数调用。而函数是有返回值的，在函数调用(call_function指令)执行完毕之后会自动将返回值设置在栈顶，而POP_TOP就是负责将上一步函数调用的返回值从栈顶弹出来。只不过我们这里是print函数返回的是None、我们不需要这个返回值，或者说我们没有使用变量接收，所以直接将其从栈顶弹出去即可。但如果我们是res &#x3D;  print(c)，那么你会发现指令POP_TOP就变成了STORE_NAME，因为要将符号和返回值绑定起来放在local空间中。最后LOAD_CONST、RETURN_VALUE，无需解释了，就是返回值，不光是函数，类代码块、模块代码块在执行完毕之后也会返回一个值给调用者，只不过这个值通常是None。最后再来看看print是如何打印的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/bltinmodule.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin_print</span><span class="params">(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs, PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Python里面print支持的参数, 这里是解析我们在调用print所传递的位置参数和关键字参数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> _keywords[] = &#123;<span class="string">&quot;sep&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;file&quot;</span>, <span class="string">&quot;flush&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PyArg_Parser</span> _<span class="title">parser</span> =</span> &#123;<span class="string">&quot;|OOOO:print&quot;</span>, _keywords, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化全部为NULL</span></span><br><span class="line">    PyObject *sep = <span class="literal">NULL</span>, *end = <span class="literal">NULL</span>, *file = <span class="literal">NULL</span>, *flush = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kwnames != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            !_PyArg_ParseStackAndKeywords(args + nargs, <span class="number">0</span>, kwnames, &amp;_parser,</span><br><span class="line">                                          &amp;sep, &amp;end, &amp;file, &amp;flush)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//file参数</span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span> || file == Py_None) &#123;</span><br><span class="line">        file = _PySys_GetObjectId(&amp;PyId_stdout);</span><br><span class="line">        <span class="comment">//默认输出到sys.stdout也就是控制台</span></span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_RuntimeError, <span class="string">&quot;lost sys.stdout&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sys.stdout may be None when FILE* stdout isn&#x27;t connected */</span></span><br><span class="line">        <span class="keyword">if</span> (file == Py_None)</span><br><span class="line">            Py_RETURN_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//sep分隔符, 默认是空格</span></span><br><span class="line">    <span class="keyword">if</span> (sep == Py_None) &#123;</span><br><span class="line">        sep = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sep &amp;&amp; !PyUnicode_Check(sep)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;sep must be None or a string, not %.200s&quot;</span>,</span><br><span class="line">                     sep-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//end, 默认是换行</span></span><br><span class="line">    <span class="keyword">if</span> (end == Py_None) &#123;</span><br><span class="line">        end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (end &amp;&amp; !PyUnicode_Check(end)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;end must be None or a string, not %.200s&quot;</span>,</span><br><span class="line">                     end-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将里面的元素逐个打印到file中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sep == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="comment">//设置sep为空格</span></span><br><span class="line">                err = PyFile_WriteString(<span class="string">&quot; &quot;</span>, file);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//否则说明用户了sep</span></span><br><span class="line">                err = PyFile_WriteObject(sep, file,</span><br><span class="line">                                         Py_PRINT_RAW);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//end同理，不指定的话默认是打印换行</span></span><br><span class="line">    <span class="keyword">if</span> (end == <span class="literal">NULL</span>)</span><br><span class="line">        err = PyFile_WriteString(<span class="string">&quot;\n&quot;</span>, file);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//flush表示是否强制刷新控制台</span></span><br><span class="line">    <span class="keyword">if</span> (flush != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *tmp;</span><br><span class="line">        <span class="type">int</span> do_flush = PyObject_IsTrue(flush);</span><br><span class="line">        <span class="keyword">if</span> (do_flush == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (do_flush) &#123;</span><br><span class="line">            tmp = _PyObject_CallMethodId(file, &amp;PyId_flush, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Py_DECREF(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们就简单分析了一下字节码指令，介绍了一些常见的指令。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>11-探索Python虚拟机和字节码的奥秘</title>
    <url>/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    <content><![CDATA[<h2 id="11-探索Python虚拟机执行字节码的奥秘"><a href="#11-探索Python虚拟机执行字节码的奥秘" class="headerlink" title="11-探索Python虚拟机执行字节码的奥秘"></a>11-探索Python虚拟机执行字节码的奥秘</h2><p><strong>这一次我们就来剖析Python运行字节码的原理，我们知道Python虚拟机是Python的核心，在源代码被编译成PyCodeObject对象时，就将由Python虚拟机接手整个工作。Python虚拟机会从PyCodeObject中读取字节码，并在当前的上下文中执行，直到所有的字节码都被执行完毕。</strong></p>
<h3 id="Python虚拟机的执行环境"><a href="#Python虚拟机的执行环境" class="headerlink" title="Python虚拟机的执行环境"></a>Python虚拟机的执行环境</h3><p><strong>Python的虚拟机实际上是在模拟操作系统运行可执行文件的过程，我们先来看看在一台普通的x86的机器上，可执行文件是以什么方式运行的。在这里主要关注运行时栈的栈帧，如图所示：</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192050931-2050285817.png" alt="img"></p>
<p><strong>x86体系处理器通过栈维护调用关系，每次函数调用时就在栈上分配一个帧用于保存调用上下文以及临时存储。CPU中有两个关键寄存器，rsp指向当前栈顶，rbp指向当前栈帧。每次调用函数时，调用者(Caller)负责准备参数、保存返回地址，并跳转到被调用函数中执行代码；作为被调用者(Callee)，函数先将当前rbp寄存器压入栈（保存调用者栈帧位置），并将rbp设为当前栈顶(保存当前新栈帧的位置)。由此，rbp寄存器与每个栈帧中保存调用者栈帧地址一起完美地维护了函数调用关系链。</strong></p>
<p><strong>我们以Python中的代码为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"></span><br><span class="line">g()</span><br></pre></td></tr></table></figure>

<p><strong>当程序进入到函数 f 中执行时，那么显然调用者的帧就是函数 g 的栈帧，而当前帧则是 f 的栈帧。</strong></p>
<blockquote>
<p><strong>解释一下：栈是先入后出的数据结构，从栈顶到栈底地址是增大的。对于一个函数而言，其所有对局部变量的操作都在自己的栈帧中完成，而调用函数的时候则会为调用的函数创建新的栈帧。</strong></p>
</blockquote>
<p><strong>在上图中，我们看到运行时栈的地址是从高地址向低地址延伸的。当在函数 g  中调用函数 f 的时候，系统就会在地址空间中，于 g 的栈帧之后创建 f  的栈帧。当然在函数调用的时候，系统会保存上一个栈帧的栈指针(rsp)和帧指针(rbp)。当函数的调用完成时，系统就又会把rsp和rbp的值恢复为创建 f 栈帧之前的值，这样程序的流程就又回到了 g  函数中，当然程序的运行空间则也又回到了函数g的栈帧中，这就是可执行文件在x86机器上的运行原理。</strong></p>
<p><strong>而上一章我们说Python源代码经过编译之后，所有字节码指令以及其他静态信息都存储在PyCodeObject当中，那么是不是意味着Python虚拟机就在PyCodeObject对象上进行所有的动作呢？其实不能给出唯一的答案，因为尽管<font color="green">PyCodeObject包含了关键的字节码指令以及静态信息</font>，</strong><font color="red"><strong>但是有一个东西，是没有包含、也不可能包含的，就是程序运行的动态信息–执行环境</strong>。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var = <span class="string">&quot;satori&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    var = <span class="number">666</span></span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure>

<p><strong>首先代码当中出现了两个print(var)，它们的字节码指令是相同的，但是执行的效果却显然是不同的，这样的结果正是执行环境的不同所产生的。因为环境的不同，var的值也是不同的。因此同一个符号在不同环境中对应不同的类型、不同的值，必须在运行时进行动态地捕捉和维护，这些信息是不可能在PyCodeObject对象中被静态的存储的。</strong></p>
<p><strong>所以我们还需要执行环境，这里的执行环境和我们下面将要说的名字空间比较类似<code>(名字空间暂时就简单地理解为作用域即可)</code>。但是名字空间仅仅是执行环境的一部分，除了名字空间，在执行环境中，还包含了其他的一些信息。</strong></p>
<p>​        <strong>因此对于上面代码，我们可以大致描述一下流程：</strong>    </p>
<ul>
<li><code>当python在执行第一条语句时，已经创建了一个执行环境，假设叫做A</code></li>
<li><code>所有的字节码都会在这个环境中执行，Python可以从这个环境中获取变量的值，也可以修改。</code></li>
<li><code>当发生函数调用的时候，Python会在执行环境A中调用函数f的字节码指令，会在执行环境A之外重新创建一个执行环境B</code></li>
<li><code>在环境B中也有一个名字为var的对象，但是由于环境的不同，var也不同。两个人都叫小明，但一个是北京的、一个是上海的，所以这两者没什么关系</code></li>
<li><code>一旦当函数f的字节码指令执行完毕，会将当前f的栈帧销毁(也可以保留下来)，再回到调用者的栈帧中来。就像是递归一样，每当调用函数就会创建一个栈帧，一层一层创建，一层一层返回。</code></li>
</ul>
<p><strong>所以Python在运行时的时候，并不是在PyCodeObject对象上执行操作的，而是我们一直在说的栈帧对象(PyFrameObject)，从名字也能看出来，这个栈帧也是一个对象。</strong></p>
<h4 id="Python源码中的PyFrameObject"><a href="#Python源码中的PyFrameObject" class="headerlink" title="Python源码中的PyFrameObject"></a>Python源码中的PyFrameObject</h4><p><strong>对于Python而言，PyFrameObject可不仅仅只是类似于x86机器上看到的那个简简单单的栈帧，Python中的PyFrameObject实际上包含了更多的信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD  		<span class="comment">/* 可变对象的头部信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* 上一级栈帧, 也就是调用者的栈帧 */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* PyCodeObject对象, 通过栈帧对象的f_code可以获取对应的PyCodeObject对象 */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin命名空间，一个PyDictObject对象 */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global命名空间，一个PyDictObject对象 */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local命名空间，一个PyDictObject对象  */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* 运行时的栈底位置 */</span></span><br><span class="line"></span><br><span class="line">    PyObject **f_stacktop;      <span class="comment">/* 运行时的栈顶位置 */</span></span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* 回溯函数，打印异常栈 */</span></span><br><span class="line">    <span class="type">char</span> f_trace_lines;         <span class="comment">/* 是否触发每一行的回溯事件 */</span></span><br><span class="line">    <span class="type">char</span> f_trace_opcodes;       <span class="comment">/* 是否触发每一个操作码的回溯事件 */</span></span><br><span class="line"></span><br><span class="line">    PyObject *f_gen;            <span class="comment">/* 是否是生成器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f_lasti;                <span class="comment">/* 上一条指令在f_code中的偏移量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f_lineno;               <span class="comment">/* 当前字节码对应的源代码行 */</span></span><br><span class="line">    <span class="type">int</span> f_iblock;               <span class="comment">/* 当前指令在栈f_blockstack中的索引 */</span></span><br><span class="line">    <span class="type">char</span> f_executing;           <span class="comment">/* 当前栈帧是否仍在执行 */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* 用于try和loop代码块 */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* 动态内存，维护局部变量+cell对象集合+free对象集合+运行时栈所需要的空间 */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到，Python会根据PyCodeObject对象来创建一个栈帧对象<code>(或者直接说栈帧也行)</code>，也就是PyFrameObject对象，虚拟机实际上是在PyFrameObject对象上执行操作的。每一个PyFrameObject都会维护一个PyCodeObject，换句话说，每一个PyCodeObject都会隶属于一个PyFrameObject。并且从f_back中可以看出，在Python的实际执行过程中，会产生很多PyFrameObject对象，而这些对象会被链接起来，形成一条执行环境链表，这正是x86机器上栈帧之间关系的模拟。在x86机器上，栈帧间通过rsp和rbp指针建立了联系，使得新栈帧在结束之后能够顺利的返回到旧栈帧中，而Python则是利用f_back来完成这个动作。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192059369-802300135.png" alt="img"></p>
<p><strong>里面f_code成员是一个指针，指向相应的PyCodeObject对象，而接下来的f_builtins、f_globals、f_locals是三个独立的名字空间，在这里我们看到了名字空间和执行环境(即栈帧)之间的关系。名字空间实际上是维护这变量名和变量值的PyDictObject对象，所以在这三个PyDictObject对象中分别维护了各自name和value的对应关系。</strong></p>
<p><strong>在PyFrameObject的开头，有一个PyObject_VAR_HEAD，表示栈帧是一个变长对象，即每一次创建PyFrameObject对象大小可能是不一样的，那么变动在什么地方呢？首先每一个PyFrameObject对象都维护了一个PyCodeObject对象，而每一个PyCodeObject对象都会对应一个代码块(code  block)。在编译一段代码块的时候，会计算这段代码块执行时所需要的栈空间的大小，这个栈空间大小存储在PyCodeObject对象的co_stacksize中。而不同的代码块所需要的栈空间是不同的，因此PyFrameObject的开头要有一个PyObject_VAR_HEAD对象。最后其实PyFrameObject里面的内存空间分为两部分，一部分是编译代码块需要的空间，另一部分是计算所需要的空间，我们也称之为”运行时栈”。</strong></p>
<blockquote>
<p><strong>注意：x86机器上执行时的运行时栈不止包含了计算<code>(还有别的)</code>所需要的内存空间，但PyFrameObject对象的运行时栈则只包含计算所需要的内存空间，这一点务必注意。</strong></p>
</blockquote>
<h4 id="在python中访问PyFrameObject对象"><a href="#在python中访问PyFrameObject对象" class="headerlink" title="在python中访问PyFrameObject对象"></a>在python中访问PyFrameObject对象</h4><p><strong>在Python中获取栈帧，我们可以使用inspect模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="comment"># 返回当前所在的栈帧, 这个函数实际上是调用了sys._getframe(1)</span></span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frame = f()</span><br><span class="line"><span class="built_in">print</span>(frame)  <span class="comment"># &lt;frame at 0x000001FE3D6E69F0, file &#x27;D:/satori/1.py&#x27;, line 6, code f&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(frame))  <span class="comment"># &lt;class &#x27;frame&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到栈帧的类型是<code>&lt;class &#39;frame&#39;&gt;</code>，正如PyCodeObject对象的类型是<code>&lt;class &#39;code&#39;&gt;</code>一样。还是那句话，这两个类Python解释器没有暴露给我们，所以不可以直接使用。同理，还有Python的函数，类型是<code>&lt;class &#39;function&#39;&gt;</code>；模块，类型是<code>&lt;class &#39;module&#39;&gt;</code>，这些Python解释器都没有给我们提供，如果直接使用的话，那么frame、code、function、module只是几个没有定义的变量罢了，这些类我们只能通过这种间接的方式获取。</strong></p>
<p>​        <strong>下面我们就来获取一下栈帧的成员属性</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用函数g的时候, 也会触发函数f的调用</span></span><br><span class="line"><span class="comment"># 而一旦f执行完毕, 那么f对应的栈帧就被全局变量frame保存起来了</span></span><br><span class="line">frame = g()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(frame)  <span class="comment"># &lt;frame at 0x00000194046863C0, file &#x27;D:/satori/1.py&#x27;, line 8, code f&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一级栈帧, 即调用者的栈帧, 显然是g的栈帧</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back)  <span class="comment"># &lt;frame at 0x00000161C79169F0, file &#x27;D:/satori/1.py&#x27;, line 14, code g&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块也是有栈帧的, 我们后面会单独说</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_back)  <span class="comment"># &lt;frame at 0x00000174CE997840, file &#x27;D:/satori/1.py&#x27;, line 25, code &lt;module&gt;&gt;</span></span><br><span class="line"><span class="comment"># 显然最外层就是模块了, 模块对应的上一级栈帧是None</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_back.f_back)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取PyCodeObject对象</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_code)  <span class="comment"># &lt;code object f at 0x00000215D560D450, file &quot;D:/satori/1.py&quot;, line 4&gt;</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_code.co_name)  <span class="comment"># f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取f_locals, 即栈帧内部的local名字空间</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;神乐mea&#x27;, &#x27;age&#x27;: 38&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">另外我们看到函数运行完毕之后里面的局部变量居然还能获取</span></span><br><span class="line"><span class="string">原因就是栈帧没被销毁, 因为它被返回了, 而且被外部变量接收了</span></span><br><span class="line"><span class="string">同理：该栈帧的上一级栈帧也不能被销毁, 因为当前栈帧的f_back指向它了, 引用计数不为0, 所以要保留</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈帧对应的行号</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_lineno)  <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span>(frame.f_back.f_lineno)  <span class="comment"># 14</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">行号为8的位置是: return inspect.currentframe()</span></span><br><span class="line"><span class="string">行号为14的位置是: return f()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过栈帧我们可以获取很多的属性，我们后面还会慢慢说。</strong></p>
<p><strong>此外，异常处理也可以获取到栈帧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="comment"># exc_info返回一个三元组,分别是异常的类型、值、以及traceback</span></span><br><span class="line">        exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">        <span class="built_in">print</span>(exc_type)  <span class="comment"># &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line">        <span class="built_in">print</span>(exc_value)  <span class="comment"># division by zer</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb)  <span class="comment"># &lt;traceback object at 0x00000135CEFDF6C0&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用exc_tb.tb_frame即可拿到异常对应的栈帧</span></span><br><span class="line">        <span class="comment"># 另外这个exc_tb也可以通过except ZeroDivisionError as e; e.__traceback__的方式获取</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb.tb_frame.f_back)  <span class="comment"># &lt;frame at 0x00000260C1297840, file &#x27;D:/satori/1.py&#x27;, line 17, code &lt;module&gt;&gt;</span></span><br><span class="line">        <span class="comment"># 因为foo是在模块级别、也就是最外层调用的,所以tb_frame是当前函数的栈帧、那么tb_frame.f_back就是整个模块对应的栈帧</span></span><br><span class="line">        <span class="comment"># 那么再上一级的话, 栈帧就是None了</span></span><br><span class="line">        <span class="built_in">print</span>(exc_tb.tb_frame.f_back.f_back)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="名字、作用域、名字空间"><a href="#名字、作用域、名字空间" class="headerlink" title="名字、作用域、名字空间"></a>名字、作用域、名字空间</h3><p><strong>我们在PyFrameObject里面看到了3个独立的名字空间：f_locals、f_globals、f_builtins。名字空间对于Python来说是一个非常重要的概念，整个Python虚拟机运行的机制和名字空间有着非常紧密的联系。并且在Python中，与命名空间这个概念紧密联系着的还有”名字”、”作用域”这些概念，下面就来剖析这些概念是如何实现的。</strong></p>
<h4 id="Python中的变量只是一个名字"><a href="#Python中的变量只是一个名字" class="headerlink" title="Python中的变量只是一个名字"></a>Python中的变量只是一个名字</h4><p><strong>很早的时候我们就说过，Python中的变量在底层一个泛型指针PyObject *，而在Python的层面上来说，变量只是一个名字、或者说符号，用于和对象进行绑定的。变量的定义本质上就是建立名字和对象之间的约束关系，所以a &#x3D; 1这个赋值语句本质上就是将符号a和1对应的PyLongObject绑定起来，让我们通过a可以找到对应的PyLongObject。</strong></p>
<p><strong>除了变量赋值，函数定义、类定义也相当于定义变量，或者说完成名字和对象之间的绑定。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>定义一个函数也相当于定义一个变量，会先根据函数体创建一个函数对象，然后将名字<code>foo</code>和函数对象绑定起来，所以函数名和函数体之间是分离的，同理类也是如此。</strong></p>
<p><strong>再有导入一个模块，也相当于定义一个变量。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<p><strong>import os，相当于将名字<code>os</code>和模块对象绑定起来，通过os可以访问模块里面的属性。或者import numpy as np当中的as语句也相当于定义一个变量，将名字<code>np</code>和对应的模块对象绑定起来，以后就可以通过np这个名字去访问模块内部的属性了。</strong></p>
<blockquote>
<p><strong>另外，当我们导入一个模块的时候，解释器是这么做的。比如：import os等价于os &#x3D; <strong>import</strong>(“os”)，可以看到本质上还是一个赋值语句。</strong></p>
</blockquote>
<h4 id="作用域和名字空间"><a href="#作用域和名字空间" class="headerlink" title="作用域和名字空间"></a>作用域和名字空间</h4><p><strong>我们说赋值语句、函数定义、类定义、模块导入，本质上只是完成了名字和对象之间的绑定。而从概念上讲，我们实际上得到了一个<code>name</code>和<code>obj</code>这样的映射关系，通过name获取对应的obj，而它们的容身之所就是名字空间。而名字空间是通过PyDictObject对象实现的，这对于映射来说简直再适合不过了，所以字典在Python底层也是被大量使用的，因此是经过高度优化的。</strong></p>
<p><strong>但是一个模块内部，名字还存在可见性的问题，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到同一个变量名，打印的确实不同的值，说明指向了不同的对象。换句话说这两个变量是在不同的名字空间中被创建的，我们知道名字空间本质上是一个字典，如果两者是在同一个名字空间，那么由于字典的key的不重复性，那么当我进行a&#x3D;2的时候，会把字典里面key为’a’的value给更新掉，但是在外面还是打印为1，这说明，两者所在的不是同一个名字空间。在不同的名字空间，打印的也就自然不是同一个a。</strong></p>
<p><strong>因此对于一个模块而言，内部是可能存在多个名字空间的，每一个名字空间都与一个作用域相对应。作用域就可以理解为一段程序的正文区域，在这个区域里面定义的变量是有作用的，然而一旦出了这个区域，就无效了。</strong></p>
<p><strong>对于作用域这个概念，至关重要的是要记住它仅仅是由源程序的文本所决定的。在Python中，一个变量在某个位置是否起作用，是由其在文本位置是否唯一决定的。因此，Python是具有静态作用域<code>(词法作用域)</code>的，而名字空间则是作用域的动态体现。一个由程序文本定义的作用域在Python运行时就会转化为一个名字空间、即一个PyDictObject对象。也就是说，在函数执行时，会为创建一个名字空间，这一点在以后剖析函数时会详细介绍。</strong></p>
<blockquote>
<p><strong>我们之前说Python在对Python源代码进行编译的时候，对于代码中的每一个block，都会创建一个PyCodeObject与之对应。而当进入一个新的名字空间、或者说作用域时，我们就算是进入了一个新的block了。相信此刻你已经明白了，而且根据我们使用Python的经验，显然函数、类都是一个新的block，当Python运行的时候会它们创建各自的名字空间。</strong></p>
<p><strong>所以名字空间是名字、或者变量的上下文环境，名字的含义取决于命名空间。更具体的说，一个变量名对应的变量值什么，在Python中是不确定的，需要名字空间来决定。</strong></p>
</blockquote>
<p><strong>位于同一个作用域中的代码可以直接访问作用域中出现的名字，即所谓的”直接访问”，也就是不需要通过属性引用的访问修饰符:<code>.</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(A.a)  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(b)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>比如：B里面想访问A里面的内容，比如通过<code>A.属性</code>的方式，表示通过A来获取A里面的属性。但是访问B的内容就不需要了，因为都是在同一个作用域，所以直接访问即可。</strong></p>
<p><strong>访问名字这样的行为被称为<code>名字引用</code>，名字引用的规则决定了Python程序的行为。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>还是对于上面的代码，如果我们把函数里面的a&#x3D;2给删掉，那么显然作用域里面已经没有a这个变量的，那么再执行程序会有什么后果呢？从Python层面来看，显然是会寻找外部的a。因此我们可以得到如下结论：</strong></p>
<ul>
<li><code>作用域是层层嵌套的,显然是这样,毕竟python虚拟机操作的是PyFrameObject对象,而PyFrameObject对象也是嵌套的,当然还有PyCodeObject</code></li>
<li><code>内层的作用域是可以访问外层作用域的</code></li>
<li><code>外层作用域无法访问内层作用域,尽管我们没有试,但是想都不用想,如果把外层的a=1给去掉,那么最后面的print(a)铁定报错。因为外部的作用域算是属于顶层了(先不考虑builtin)</code></li>
<li><code>查找元素会依次从当前作用域向外查找,也就是查找元素对应的作用域是按照从小往大、从里往外的方向前进的,到了最外层还没有,就真没有了(先不考虑builtin)</code></li>
</ul>
<h4 id="LGB规则"><a href="#LGB规则" class="headerlink" title="LGB规则"></a>LGB规则</h4><p><strong>我们说函数、类是有自己的作用域的，但是模块对应的源文件本身也有相应的作用域。比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>由于这个文件本身也有自己的作用域<code>(显然是global作用域)</code>，所以Python解释器在运行a.py这个文件的时候，也会为其创建一个名字空间，而显然这个名字空间就是global名字空间。它里面的变量是全局的，或者说是模块级别的，在当前的文件内可以直接访问。</strong></p>
<p><strong>而函数也会有一个作用域，这个作用域称为local作用域(对应local名字空间)；同时Python自身还定义了一个最顶层的作用域，也就是builtin作用域(比如：dir、range、open都是builtin里面的)。这三个作用域在python2.2之前就存在了，所以那时候Python的作用域规则被称之为LGB规则：名字引用动作沿着local作用域<code>(local名字空间)</code>、global作用域<code>(global名字空间)</code>、builtin作用域<code>(builtin名字空间)</code>来查找对应的变量。</strong></p>
<p><strong>而获取名字空间，Python也提供了相应的内置函数：</strong></p>
<ul>
<li><code>locals函数: 获取当前作用域的local名字空间, local名字空间也称为局部名字空间</code></li>
<li><code>globals函数: 获取当前作用域的global名字空间, global名字空间也称为全局名字空间</code></li>
</ul>
<p><strong>对于global名字空间来说，它对应一个字典，并且这个字典是全局唯一的，全局变量都存储在这里面。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())  <span class="comment"># &#123;..., &#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1, &#x27;foo&#x27;: &lt;function foo at 0x0000020BF60851F0&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>里面的…表示省略了一部分输出，我们看到创建的全局变量都在里面了。而且foo也是一个变量，它指向一个函数对象，我们说foo也对应一个PyCodeObject。但是在解释到def  foo的时候，便会根据这个PyCodeObject对象创建一个PyFunctionObject对象，然后将foo和这个函数对象绑定起来。当我们调用foo的时候，会根据PyFunctionObject对象再创建PyFrameObject对象、然后执行，这些留在介绍函数的时候再细说。总之，我们看到foo也是一个全局变量，全局变量都在global名字空间中。</strong></p>
<blockquote>
<p><strong>global名字空间全局唯一，它是程序运行时全局变量和与之绑定的对象的容身之所，你在任何一个地方都可以访问到global名字空间。正如，你在任何一个地方都可以访问相应的全局变量一样。</strong></p>
<p><strong>此外，我们说名字空间是一个字典，变量和变量指向的值会以键值对的形式存在里面。那么换句话说，如果我手动的往这个global名字空间里面添加一个键值对，是不是也等价于定义一个全局变量呢？</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">globals</span>()[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">            <span class="built_in">globals</span>()[<span class="string">&quot;age&quot;</span>] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f3</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()()()</span><br><span class="line"><span class="built_in">print</span>(age)  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到确实如此，通过往global名字空间里面插入一个键值对完全等价于定义一个全局变量。并且我们看到global名字空间是全局唯一的，你在任何地方调用globals()得到的都是global名字空间，正如你在任意地方都可以访问到全局变量一样。所以即使是在函数中向global名字空间中插入一个键值对，也等价于定义一个全局变量、并和对象绑定起来。</strong></p>
<ul>
<li><code>name = &quot;夏色祭&quot;等价于 globals[&quot;name&quot;] = &quot;夏色祭&quot;</code></li>
<li><code>print(name)等价于print(globals[&quot;name&quot;])</code></li>
</ul>
<p><strong>对于local名字空间来说，它也对应一个字典，显然这个字典是就不是全局唯一的了，每一个作用域都会对应自身的local名字空间。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    age = <span class="number">38</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>() == <span class="built_in">globals</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="built_in">print</span>(g())  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;神乐mea&#x27;, &#x27;age&#x27;: 38&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>显然对于模块来讲，它的local名字空间和global名字空间是一样的，也就是说模块对应的PyFrameObject对象里面的f_locals和f_globals指向的是同一个PyDictObject对象。</strong></p>
<p><strong>但是对于函数而言，局部名字空间和全局名字空间就不一样了。而调用locals也是获取自身的局部名字空间，因此不同的函数的local名字空间是不同的，而调用locals函数返回结果显然取决于调用它的位置。但是globals函数的调用结果是一样的，获取的都是global名字空间，这也符合”函数内找不到某个变量的时候会去找全局变量”这一结论。</strong></p>
<p><strong>所以我们说在函数里面查找一个变量，查找不到的话会找全局变量，全局变量再没有会查找内置变量。本质上就是按照自身的local空间、外层的global空间、内置的builtin空间的顺序进行查找。因此local空间会有很多个，因为每一个函数或者类都有自己的局部作用域，这个局部作用域就可以称之为该函数的local空间；但是global空间则全局唯一，因为该字典存储的是全局变量，无论你在什么地方，通过globals拿到的永远全局变量对应的名字空间，向该空间中添加键值对，等价于创建全局变量。</strong></p>
<p><strong>对于builtin命名空间，它也是一个字典。当local空间、global空间都没有的时候，会去builtin空间查找。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">    <span class="comment"># local空间有&quot;name&quot;这个key, 直接从局部名字空间获取</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="comment"># 但是当前的local空间没有&quot;age&quot;这个key, 所以会从global空间查找</span></span><br><span class="line">    <span class="comment"># 从这里也能看出为什么函数也能访问到global空间了</span></span><br><span class="line">    <span class="comment"># 如果函数内访问不到的话, 那么它怎么能够在局部变量找不到的时候去找全局变量呢</span></span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但是local空间、global空间都没有&quot;int&quot;这个key, 所以要去builtin空间查找了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;xxx&quot;的话, 三个空间都没有, 那么结果只能是NameError了</span></span><br><span class="line">    <span class="built_in">print</span>(xxx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">神乐mea</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">File &quot;D:/satori/1.py&quot;, line 18, in f1</span></span><br><span class="line"><span class="string">    print(xxx)</span></span><br><span class="line"><span class="string">NameError: name &#x27;xxx&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题来了，builtin名字空间如何获取呢？答案是通过builtins模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们调用int、str、list显然是从内置作用域、也就是builtin命名空间中查找的</span></span><br><span class="line"><span class="comment"># 即使我们只通过list也是可以的, 因为local空间、global空间没有的话, 最终会从builtin空间中查找,</span></span><br><span class="line"><span class="comment"># 但如果是builtins.list, 那么就不兜圈子了, 表示: &quot;builtin空间,就从你这获取了&quot;</span></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">list</span> <span class="keyword">is</span> <span class="built_in">list</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">builtins.<span class="built_in">dict</span> = <span class="number">123</span></span><br><span class="line"><span class="comment"># 将builtin空间的dict改成123，那么此时获取的dict就是123，因为是从内置作用域中获取的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span> + <span class="number">456</span>)  <span class="comment"># 579</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="number">123</span></span><br><span class="line"><span class="comment"># 如果是str = 123，等价于创建全局变量str = 123，显然影响的是global空间，而查找显然也会先从global空间查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  <span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 但是此时不影响内置作用域</span></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">str</span>)  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>这里提一下Python2当中，while 1比while True要快，为什么？</strong>    </p>
<p><strong>因为True在Python2中不是关键字，所以它是可以作为变量名的，那么python在执行的时候就要先看local空间和global空间中有没有True这个变量，有的话使用我们定义的，没有的话再使用内置的True，而1是一个常量直接加载就可以。所以while True它多了符号查找这一过程，但是在Python3中两者就等价了，因为True在python3中是一个关键字，所以会直接作为一个常量来加载。</strong></p>
<p>​        <strong>这里再提一下函数的local空间</strong>    </p>
<p><strong>我们说：globals[“name”] &#x3D; “夏色祭”等价于定义一个全局变量name &#x3D; “夏色祭”，那么如果是在函数里面执行了locals[“name”] &#x3D; “夏色祭”，是不是等价于创建局部变量name &#x3D; “夏色祭”呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;name &quot;</span>] = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">f1()  <span class="comment"># name &#x27;name&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>我们说对于全局变量来讲，变量的创建是通过向字典添加键值对的方式实现的。因为全局变量会一直在变，需要使用字典来动态维护。但是对于函数来讲，内部的变量是通过静态方式访问的，因为其局部作用域中存在哪些变量在编译的时候就已经确定了，我们通过PyCodeObject的co_varnames即可获取内部都有哪些变量。</strong></p>
<p><strong>所以虽然我们说查找是按照LGB的方式查找，但是访问函数内部的变量其实是静态访问的，不过完全可以按照LGB的方式理解。</strong></p>
<blockquote>
<p><strong>所以名字空间可以说是Python的灵魂，因为它规定了Python变量的作用域，使得Python对变量的查找变得非常清晰。</strong></p>
</blockquote>
<h4 id="LEGB规则"><a href="#LEGB规则" class="headerlink" title="LEGB规则"></a>LEGB规则</h4><p><strong>我们上面说的LGB是针对Python2.2之前的，那么Python2.2开始，由于引入了嵌套函数，显然最好的方式应该是内层函数找不到应该首先去外层函数找，而不是直接就跑到global空间、也就是全局里面找，那么此时的规则就是LEGB。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>调用f，实际上调用的是bar函数，最终输出的结果是2。如果按照LGB的规则来查找的话。bar函数的作用域没有a、那么应该到全局里面找，打印的应该是1才对。但是我们之前说了，作用域仅仅是由文本决定的，函数bar位于函数foo之内，所以bar函数定义的作用域内嵌与函数foo的作用域之内。换句话说，函数foo的作用域是函数bar的作用域的直接外围作用域，所以首先是从foo作用域里面找，如果没有那么再去全局里面找。而作用域和名字空间是对应的，所以最终打印了2。</strong></p>
<blockquote>
<p><strong>因此在执行f &#x3D; foo()的时候，会执行函数foo中的def bar():语句，这个时候Python会将a&#x3D;2与函数bar对应的函数对象捆绑在一起，将捆绑之后的结果返回，这个捆绑起来的整体称之为闭包。</strong></p>
<p><strong>所以：闭包 &#x3D; 内层函数 + 引用的外层作用域</strong></p>
</blockquote>
<p><strong>这里显示的规则就是LEGB，其中E成为enclosing，代表<code>直接外围作用域</code>这个概念。</strong></p>
<h4 id="global表达式"><a href="#global表达式" class="headerlink" title="global表达式"></a>global表达式</h4><p><strong>有一个很奇怪的问题，最开始学习python的时候，笔者也为此困惑了一段时间，下面我们来看一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先这段代码打印1，这显然是没有问题的，但是下面问题来了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:/Users/satori/Desktop/love_minami/a.py&quot;, line 8, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    foo()</span></span><br><span class="line"><span class="string">  File &quot;C:/Users/satori/Desktop/love_minami/a.py&quot;, line 5, in foo</span></span><br><span class="line"><span class="string">    print(a)</span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;a&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我仅仅是在print下面，在当前作用域又新建了一个变量a，结果就告诉我<code>局部变量a在赋值之前就被引用了</code>，这是怎么一回事，相信肯定有人为此困惑。</strong></p>
<p><strong>弄明白这个错误的根本就在于要深刻理解两点：</strong></p>
<ul>
<li><code>一个赋值语句所定义的变量在这个赋值语句所在的作用域里都是可见的</code></li>
<li><code>函数中的变量是静态存储、静态访问的, 内部有哪些变量在编译的时候就已经确定</code></li>
</ul>
<p><strong>在编译的时候，因为存在a &#x3D;  2这条语句，所以知道函数中存在一个局部变量a，那么查找的时候就会在局部空间中查找。但是还没来得及赋值，就print(a)了，所以报错：局部变量a在赋值之前就被引用了。但如果没有a &#x3D; 2这条语句则不会报错，因为知道局部作用域中不存在a这个变量，所以会找全局变量a，从而打印1。</strong></p>
<p><strong>更有趣的东西隐藏在字节码当中，我们可以通过反汇编来查看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">dis.dis(g)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  7           0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line"><span class="string">              2 LOAD_GLOBAL              1 (a)</span></span><br><span class="line"><span class="string">              4 CALL_FUNCTION            1</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dis.dis(f)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 12           0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line"><span class="string">              2 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              4 CALL_FUNCTION            1</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 13           8 LOAD_CONST               1 (2)</span></span><br><span class="line"><span class="string">             10 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="string">             12 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             14 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>中间的序号代表字节码的偏移量，我们看第二条，g的字节码是<code>LOAD_GLOBAL</code>，意思是在global名字空间中查找，而f的字节码是<code>LOAD_FAST</code>，表示在local名字空间中查找名字。这说明Python采用了静态作用域策略，在编译的时候就已经知道了名字藏身于何处。</strong></p>
<p><strong>因此上面的例子表明，一旦作用域有了对某个名字的赋值操作，这个名字就会在作用域中可见，就会出现在local名字空间中，换句话说，就遮蔽了外层作用域中相同的名字。</strong></p>
<p><strong>但有时我们想要在函数里面修改全局变量呢？当然Python也为我们精心准备了global关键字，比如函数内部出现了<code>global a</code>，就表示我后面的a是全局的，你要到global名字空间里面找，不要在local空间里面找了</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">        <span class="keyword">global</span> a</span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line">bar()()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>但是如果外层函数里面也出现了a，我们想找外层函数里面的a而不是全局的a，该怎么办呢？Python同样为我们准备了关键字: <code>nonlocal</code>，但是nonlocal的时候，必须确保自己是内层函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line">bar()()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 外界依旧是1</span></span><br></pre></td></tr></table></figure>

<h4 id="属性引用与名称引用"><a href="#属性引用与名称引用" class="headerlink" title="属性引用与名称引用"></a>属性引用与名称引用</h4><p><strong>属性引用实质上也是一种名称引用，其本质都是到名称空间中去查找一个名称所引用的对象。这个就比较简单了，比如a.xxx，就是到a里面去找xxx，这个规则是不受LEGB作用域限制的，就是到a里面查找，有就是有、没有就是没有。</strong></p>
<p><strong>这个比较简单，但是有一点我们需要注意，那就是我们说属性查找会按照LEGB的规则，但是仅仅限制在自身所在的模块内。举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>关于模块的导入我们后面系列中会详细说，总之目前在b.py里面执行的import a，你可以简单认为就是把a.py里面的内容拿过来执行一遍即可，所以这里相当于print(name)。</strong></p>
<p><strong>但是执行b.py的时候会提示变量name没有被定义，可是把a导进来的话，就相当于print(name)，而我们上面也定义name这个变量了呀。显然，即使我们把a导入了进来，但是a.py里面的内容依旧是处于一个模块里面。而我们也说了，名称引用虽然是LEGB规则，但是无论如何都无法越过自身的模块的，print(name)是在a.py里面的，而变量name被定义在b.py中，所以是不可能跨过模块a的作用域去访问模块b里面的内容的。</strong></p>
<blockquote>
<p><strong>所以模块整体也有一个作用域，就是该模块的全局作用域，每个模块是相互独立的。所以我们发现每个模块之间作用域还是划分的很清晰的，都是相互独立的。</strong></p>
</blockquote>
<p><strong>关于模块，我们后续会详细说。总之通过<code>.</code>的方式本质上都是去指定的命名空间中查找对应的属性。</strong></p>
<h4 id="属性空间"><a href="#属性空间" class="headerlink" title="属性空间"></a>属性空间</h4><p><strong>我们知道，自定义的类中如果没有__slots__，那么这个类的实例对象都会有一个属性字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">        self.age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g.__dict__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于查找属性而言, 也是去属性字典中查找</span></span><br><span class="line"><span class="built_in">print</span>(g.name, g.__dict__[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理设置属性, 也是更改对应的属性字典</span></span><br><span class="line">g.__dict__[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;female&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gender)  <span class="comment"># female</span></span><br></pre></td></tr></table></figure>

<p><strong>当然模块也有属性字典，属性查找方面，本质上和上面的类的实例对象是一致的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">str</span>)  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(builtins.__dict__[<span class="string">&quot;str&quot;</span>])  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>另外global空间里面是保存了builtin空间的指针的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># globals()[&quot;__builtins__&quot;]直接等价于import builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(builtins)  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但我们说globals函数是在什么地方呢? 显然是在builtin空间中</span></span><br><span class="line"><span class="comment"># 所以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].</span><br><span class="line">      <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>在 *Python* 中，一个名字(变量)可见范围由 “作用域” 决定，而作用域由语法静态划分，划分规则提炼如下：</strong></p>
<ul>
<li><code>.py文件(模块)最外层为全局作用域</code></li>
<li><code>遇到函数定义，函数体形成子作用域</code></li>
<li><code>遇到类定义，类定义体形成子作用域</code></li>
<li><code>名字仅在其作用域以内可见</code></li>
<li><code>全局作用域对其他所有作用域可见</code></li>
<li><code>函数作用域对其直接子作用域可见，并且可以传递(闭包)</code></li>
</ul>
<p><strong>与”作用域”相对应， *Python* 在运行时借助 *PyDictObject* 对象保存作用域中的名字，构成动态的”名字空间” 。这样的名字空间总共有 *4* 个：</strong></p>
<ul>
<li><code>局部名字空间(local): 不同的函数,局部名字空间不同</code></li>
<li><code>全局名字空间(global): 全局唯一</code></li>
<li><code>闭包名字空间(enclosing)</code></li>
<li><code>内建名字空间(builtin)</code></li>
<li><code>在查找名字时会按照LEGB规则查找, 但是注意: 无法跨越文件本身。就是按照自身文件的LEGB, 如果属性查找都找到builtin空间了, 那么证明这已经是最后的倔强。如果builtin空间再找不到, 那么就只能报错了, 不可能跑到其它文件中找</code></li>
</ul>
<h3 id="python虚拟机的运行框架"><a href="#python虚拟机的运行框架" class="headerlink" title="python虚拟机的运行框架"></a>python虚拟机的运行框架</h3><p><strong>当Python启动后，首先会进行运行时环境的初始化。注意这里的<code>运行时环境</code>，它和上面说的<code>执行环境</code>是不同的概念。运行时环境是一个全局的概念，而执行时环境是一个栈帧，是一个与某个code  block相对应的概念。现在不清楚两者的区别不要紧，后面会详细介绍。关于运行时环境的初始化是一个非常复杂的过程，我们后面将用单独的一章进行剖析，这里就假设初始化动作已经完成，我们已经站在了Python虚拟机的门槛外面，只需要轻轻推动一下第一张骨牌，整个执行过程就像多米诺骨牌一样，一环扣一环地展开。</strong></p>
<p><strong>首先Python虚拟机执行PyCodeObject对象中字节码的代码为*Python&#x2F;ceval.c*中，主要函数有两个：*PyEval_EvalCodeEx* 是通用接口，一般用于函数这样带参数的执行场景； PyEval_EvalCode 是更高层封装，用于模块等无参数的执行场景。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCode</span><span class="params">(PyObject *co, PyObject *globals, PyObject *locals)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCodeEx</span><span class="params">(PyObject *_co, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *args, <span class="type">int</span> argcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *kws, <span class="type">int</span> kwcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *defs, <span class="type">int</span> defcount,</span></span><br><span class="line"><span class="params">                  PyObject *kwdefs, PyObject *closure)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这两个函数最终调用 *_PyEval_EvalCodeWithName* 函数，初始化栈帧对象并调用*PyEval_EvalFrame* 和*PyEval_EvalFrameEx*函数进行处理。栈帧对象将贯穿代码对象执行的始终，负责维护执行时所需的一切上下文信息。而*PyEval_EvalFrame* 和*PyEval_EvalFrameEx*函数最终调用 *_PyEval_EvalFrameDefault* 函数，虚拟机执行的秘密就藏在这里。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrame</span><span class="params">(PyFrameObject *f)</span>;</span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrameEx</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span></span><br><span class="line"></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_<span class="title function_">PyEval_EvalFrameDefault</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192108147-1756306627.png" alt="img"></p>
<p>***_PyEval_EvalFrameDefault*函数是虚拟机运行的核心，这一个函数加上注释大概在3100行左右。可以说代码量非常大，但是逻辑并不难理解。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    该函数首先会初始化一些变量，PyFrameObject对象中的PyCodeObject对象包含的信息不用说，还有一个重要的动作就是初始化堆栈的栈顶指针，使其指向f-&gt;f_stacktop</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    co = f-&gt;f_code;</span><br><span class="line">    names = co-&gt;co_names;</span><br><span class="line">    consts = co-&gt;co_consts;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">    next_instr = first_instr;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_lasti &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        assert(f-&gt;f_lasti % <span class="keyword">sizeof</span>(_Py_CODEUNIT) == <span class="number">0</span>);</span><br><span class="line">        next_instr += f-&gt;f_lasti / <span class="keyword">sizeof</span>(_Py_CODEUNIT) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack_pointer = f-&gt;f_stacktop;</span><br><span class="line">    assert(stack_pointer != <span class="literal">NULL</span>);</span><br><span class="line">    f-&gt;f_stacktop = <span class="literal">NULL</span>;       </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PyFrameObject对象中的f_code就是PyCodeObject对象,而PyCodeObject对象里面的co_code域则保存着字节码指令和字节码指令参数</span></span><br><span class="line"><span class="comment">    python执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。在Python的虚拟机中，利用三个变量来完成整个遍历过程。</span></span><br><span class="line"><span class="comment">    首先co_code本质上是一个PyBytesObject对象，而其中的字符数组才是真正有意义的东西。也就是说整个字节码指令序列就是c中一个普普通通的数组。</span></span><br><span class="line"><span class="comment">    因此遍历的过程使用的3个变量都是char *类型的变量</span></span><br><span class="line"><span class="comment">    1.first_instr：永远指向字节码指令序列的开始位置</span></span><br><span class="line"><span class="comment">    2.next_instr：永远指向下一条待执行的字节码指令的位置</span></span><br><span class="line"><span class="comment">    3.f_lasti：指向上一条已经执行过的字节码指令的位置</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<p><strong>那么这个一步一步的动作是如何完成的呢？其实就是一个for循环加上一个巨大的switch case结构。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//......   </span></span><br><span class="line">    co = f-&gt;f_code;</span><br><span class="line">    names = co-&gt;co_names;</span><br><span class="line">    consts = co-&gt;co_consts;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 逐条取出字节码来执行</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Py_atomic_load_relaxed(eval_breaker)) &#123;</span><br><span class="line">            <span class="comment">// 读取下条字节码</span></span><br><span class="line">            <span class="comment">// 字节码位于： f-&gt;f_code-&gt;co_code, 偏移量由 f-&gt;f_lasti 决定</span></span><br><span class="line">            opcode = _Py_OPCODE(*next_instr);</span><br><span class="line">            <span class="comment">//opcode是指令，我们说Python在Include/opcode.h中定义了121个指令</span></span><br><span class="line">            <span class="keyword">if</span> (opcode == SETUP_FINALLY ||</span><br><span class="line">                opcode == SETUP_WITH ||</span><br><span class="line">                opcode == BEFORE_ASYNC_WITH ||</span><br><span class="line">                opcode == YIELD_FROM) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fast_next_opcode; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        fast_next_opcode:</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">//判断该指令属于什么操作，然后执行相应的逻辑</span></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="comment">// 加载常量</span></span><br><span class="line">                <span class="keyword">case</span> LOAD_CONST:</span><br><span class="line">                    <span class="comment">// ....</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 加载名字</span></span><br><span class="line">                <span class="keyword">case</span> LOAD_NAME:</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在这个执行架构中，对字节码一步一步的遍历是通过几个宏来实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INSTR_OFFSET()  \</span></span><br><span class="line"><span class="meta">    (sizeof(_Py_CODEUNIT) * (int)(next_instr - first_instr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTOPARG()  do &#123; \</span></span><br><span class="line"><span class="meta">        _Py_CODEUNIT word = *next_instr; \</span></span><br><span class="line"><span class="meta">        opcode = _Py_OPCODE(word); \</span></span><br><span class="line"><span class="meta">        oparg = _Py_OPARG(word); \</span></span><br><span class="line"><span class="meta">        next_instr++; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><strong>Python的字节码有的是带有参数的，有的是没有参数的，而判断字节码是否带有参数是通过HAS_AGR这个宏来实现的。注意：对于不同的字节码指令，由于存在是否需要指令参数的区别，所以next_instr的位移可以是不同的，但无论如何，next_instr总是指向python下一条要执行的字节码。</strong></p>
<p><strong>Python在获得了一条字节码指令和其需要的参数指令之后，会对字节码利用switch进行判断，根据判断的结果选择不同的case语句，每一条指令都会对应一个case语句。在case语句中，就是Python对字节码指令的实现。所以这个switch语句非常的长，函数总共3000行左右，这个switch就占了2400行，因为指令有121个，比如：LOAD_CONST、LOAD_NAME、YIELD_FROM等等，而每一个指令都要对应一个case语句。</strong></p>
<p><strong>在成功执行完一条字节码指令和其需要的指令参数之后，Python的执行流程会跳转到fast_next_opcode处，或者for循环处。不管如何，Python接下来的动作就是获取下一条字节码指令和指令参数，完成对下一条指令的执行。通过for循环一条一条地遍历co_code中包含的所有字节码指令，然后交给for循环里面的switch语句，如此周而复始，最终完成了对Python程序的执行。</strong></p>
<p><strong>尽管只是简单的分析，但是相信大家也能了解Python执行引擎的大体框架，在Python的执行流程进入了那个巨大的for循环，取出第一条字节码交给里面的switch语句之后，第一张多米诺骨牌就已经被推倒，命运不可阻挡的降临了。一条接一条的字节码像潮水一样涌来，浩浩荡荡，横无际涯。</strong></p>
<p>​        <strong>我们这里通过反编译的方式演示一下</strong>    </p>
<p><strong>指令分为很多种，我们这里就以简单的顺序执行为例，不涉及任何的跳转指令，看看Python是如何执行字节码的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">r = <span class="number">3</span></span><br><span class="line">area = pi * r ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>对它们反编译之后，得到的字节码指令如下：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">3.14</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (pi)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="number">3</span>)</span><br><span class="line">            <span class="number">6</span> STORE_NAME               <span class="number">1</span> (r)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (pi)</span><br><span class="line">           <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (r)</span><br><span class="line">           <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">           <span class="number">14</span> BINARY_POWER</span><br><span class="line">           <span class="number">16</span> BINARY_MULTIPLY</span><br><span class="line">           <span class="number">18</span> STORE_NAME               <span class="number">2</span> (area)</span><br><span class="line">           <span class="number">20</span> LOAD_CONST               <span class="number">3</span> (None)</span><br><span class="line">           <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>第一列是源代码的行号，第二列是指令的偏移量<code>(或者说指令对应的索引)</code>，第三列是指令<code>(或者操作码, 它们在宏定义中代表整数)</code>，第四列表示指令参数<code>(或者操作数)</code>。</strong></p>
<ul>
<li><strong>0 LOAD_CONST: 表示加载一个常量<code>(压入&quot;运行时栈&quot;)</code>，后面的0 (3.14)表示从常量池中加载索引为0的对象，3.14表示加载的对象是3.14(所以最后面的括号里面的内容实际上起到的是一个提示作用，告诉你加载的对象是什么)。</strong></li>
<li><strong>2 STORE_NAME: 表示将LOAD_CONST得到的对象用一个名字存储、或者绑定起来。0 (pi)表示使用符号表<code>(co_varnames)</code>中索引为0的名字<code>(符号)</code>，且名字为”pi”。</strong></li>
<li><strong>4 LOAD_CONST和6 STORE_NAME显然和上面是一样的，只不过后面的索引变成了1，表示加载常量池中索引为1的对象、符号表中索引为1的符号<code>(名字)</code>。另外从这里我们也能看出，一行赋值语句实际上对应两条字节码<code>(加载常量、与名字绑定)</code>。</strong></li>
<li><strong>8 LOAD_NAME表示加载符号表中pi对应的值，10 LOAD_NAME表示加载符号表中r对应的值，12 LOAD_CONST表示加载2这个常量<code>2 (2)表示常量池中索引为2的对象是2</code>。</strong></li>
<li><strong>14 BINARY_POWER表示进行幂运算，16 BINARY_MULTIPLY表示进行乘法运算，18 STORE_NAME表示用符号表中索引为2的符号<code>(area)</code>存储上一步计算的结果，20 LOAD_CONST表示将None加载进来，22 RETURN_VALUE将None返回。虽然它不是在函数里面，但也是有这一步的。</strong></li>
</ul>
<p>​        <strong>我们通过几张图展示一下上面的过程：</strong>    </p>
<p>*<strong>Python* 虚拟机刚开始执行时，准备好栈帧对象用于保存执行上下文，关系如下<code>(省略部分信息)</code>。另外，图中有地方画错了，图中的co_varnames应该改成co_names。我们说对于函数来说是通过co_varnames获取符号表(local空间里面局部变量的存储位置，一个静态数组)，因为函数有哪些局部变量在编译时已经确定，会静态存储在符号表co_varnames中。但我们这里是对模块进行反编译、不是函数，而模块的符号是全局的，local空间和global空间是同一个，使用字典来维护，所以它的co_varnames是一个空元组。但co_names是可以获取到所有的符号的，因此这里把co_names理解为符号表即可，但我们知道全局变量是存在字典里面的。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192115796-1415510203.png" alt="img"></p>
<p><strong>由于 *next_instr* 初始状态指向字节码开头，虚拟机开始加载第一条字节码指令： <code>0 LOAD_CONST 0 (3.14)</code> 。字节码分为两部分，分别是 操作码 ( *opcode* )和 操作数 ( *oparg* ) 。<code>LOAD_CONST</code> 指令表示将常量加载进运行时栈，常量下标由操作数给出。<code>LOAD_CONST</code> 指令在 *_PyEval_EvalFrameDefault* 函数 *switch* 结构的一个 *case* 分支中实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(LOAD_CONST) &#123;</span><br><span class="line">    <span class="comment">//通过GETITEM从consts(常量池)中加载索引为oparg的对象(常量)</span></span><br><span class="line">    <span class="comment">//所以0 LOAD_CONST 0 (3.14)分别表示: </span></span><br><span class="line">    <span class="comment">//字节码指令的偏移量、操作码、对象在常量池中的索引(即这里的oparg)、对象的值(对象的值、或者说常量的值其实是dis模块帮你解析出来的)</span></span><br><span class="line">    PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">    <span class="comment">//增加引用计数</span></span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="comment">//压入运行时栈, 这个运行时栈是位于栈帧对象尾部, 我们一会儿会说</span></span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192124938-1897728358.png" alt="img"></p>
<p><strong>接着虚拟机接着执行 <code>2 STORE_NAME 0 (pi)</code> 指令，从符号表中获取索引为0的符号、即pi，然后将栈顶元素<code>3.14</code>弹出，再把符号”pi”和整数对象3.14绑定起来保存到local名字空间</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192130184-726653805.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_NAME)</span>: &#123;</span><br><span class="line">    	    <span class="comment">//从符号表中加载索引为oparg的符号	</span></span><br><span class="line">            PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    	    <span class="comment">//从栈顶弹出元素	</span></span><br><span class="line">            PyObject *v = POP();</span><br><span class="line">            <span class="comment">//获取名字空间namespace</span></span><br><span class="line">            PyObject *ns = f-&gt;f_locals;</span><br><span class="line">            <span class="type">int</span> err;</span><br><span class="line">            <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有名字空间则报错, 这个tstate是和线程密切相关的, 我们后面会说</span></span><br><span class="line">                _PyErr_Format(tstate, PyExc_SystemError,</span><br><span class="line">                              <span class="string">&quot;no locals found when storing %R&quot;</span>, name);</span><br><span class="line">                Py_DECREF(v);</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//将符号和对象绑定起来放在ns中</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_CheckExact(ns))</span><br><span class="line">                err = PyDict_SetItem(ns, name, v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                err = PyObject_SetItem(ns, name, v);</span><br><span class="line">            Py_DECREF(v);</span><br><span class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>你可能会问，变量赋值为啥不直接通过名字空间，而是到临时栈绕一圈？主要原因在于： *Python* 字节码只有一个操作数，另一个操作数只能通过临时栈给出。 *Python* 字节码设计思想跟 *CPU*精简指令集类似，指令尽量简化，复杂指令由多条指令组合完成。</strong></p>
<p><strong>同理，r &#x3D; 2对应的两条指令也是类似的。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192137804-938965116.png" alt="img"></p>
<p><strong>然后8 LOAD_NAME 0 (pi)、10 LOAD_NAME 1 (r)、12 LOAD_CONST 2 (2)，表示将符号pi指向的值、符号r指向的值、常量2压入运行时栈。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192143225-1822001009.png" alt="img"></p>
<p><strong>然后14 BINARY_POWER表示进行幂运算，16 BINARY_MULTIPLY表示进行乘法运算。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192148891-744431496.png" alt="img"></p>
<p><strong>其中， <code>BINARY_POWER</code> 指令会从栈上弹出两个操作数(底数 *3* 和 指数 *2* )进行 幂运算，并将结果 *9* 压回栈中； <code>BINARY_MULTIPLY</code> 指令则进行乘积运算 ，步骤也是类似的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_POWER)</span>: &#123;</span><br><span class="line">    		<span class="comment">//从栈顶弹出元素, 这里是指数2</span></span><br><span class="line">            PyObject *<span class="built_in">exp</span> = POP();</span><br><span class="line">            <span class="comment">//我们看到这个是TOP, 所以其实它不是弹出底数3, 而是获取底数3, 所以3这个元素依旧在栈里面</span></span><br><span class="line">            PyObject *base = TOP();</span><br><span class="line">    	    <span class="comment">//进行幂运算</span></span><br><span class="line">            PyObject *res = PyNumber_Power(base, <span class="built_in">exp</span>, Py_None);</span><br><span class="line">            Py_DECREF(base);</span><br><span class="line">            Py_DECREF(<span class="built_in">exp</span>);</span><br><span class="line">            <span class="comment">//将幂运算的结果再设置回去, 所以原来的3被计算之后的9给替换掉了</span></span><br><span class="line">            SET_TOP(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_MULTIPLY)</span>: &#123;</span><br><span class="line">            <span class="comment">//同理这里也是弹出元素9</span></span><br><span class="line">            PyObject *right = POP();</span><br><span class="line">            <span class="comment">//获取元素3.14</span></span><br><span class="line">            PyObject *left = TOP();</span><br><span class="line">            <span class="comment">//乘法运算</span></span><br><span class="line">            PyObject *res = PyNumber_Multiply(left, right);</span><br><span class="line">            Py_DECREF(left);</span><br><span class="line">            Py_DECREF(right);</span><br><span class="line">            <span class="comment">//将运算的结果28.26将原来的3.14给替换掉</span></span><br><span class="line">            SET_TOP(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终执行指令18 STORE_NAME               2 (area)，会从符号表中加载索引为2的符号、即area，再将”area”和浮点数28.26绑定起来放到名字空间中。</strong></p>
<p><img src="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/1229382-20200816192156864-1221966200.png" alt="img"></p>
<p><strong>整体的执行流程便如上面几张图所示，当然字节码指令有很多，我们说它们定义在Include&#x2F;opcode.h中，有121个。比如：除了LOAD_CONST、STORE_NAME之外，还有LOAD_FAST、LOAD_GLOBAL、STORE_FAST，以及if语句、循环语句所使用的跳转指令，运算使用的指令等等等等，这些在后面的系列中会慢慢遇到。</strong></p>
<h4 id="PyFrameObject中的动态内存空间"><a href="#PyFrameObject中的动态内存空间" class="headerlink" title="PyFrameObject中的动态内存空间"></a>PyFrameObject中的动态内存空间</h4><p><strong>上面我们提到了一个运行时栈，我们说加载常量的时候会将常量<code>(对象)</code>从常量池中获取、并压入运行时栈，当计算或者使用变量保存的时候，会将其从栈里面弹出来。那么这个运行时栈所需要的空间都保存在什么地方呢？</strong></p>
<p><strong>PyFrameObject中有这么一个属性f_localsplus<code>(可以回头看一下PyFrameObject的定义)</code>，我们说它是动态内存，用于”维护局部变量+cell对象集合+free对象集合+运行时栈所需要的空间”，因此可以看出这段内存不仅仅使用来给栈使用的，还有别的对象使用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFrameObject*</span><br><span class="line"><span class="title function_">PyFrame_New</span><span class="params">(PyThreadState *tstate, PyCodeObject *code,</span></span><br><span class="line"><span class="params">            PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//本质上调用了_PyFrame_New_NoTrack</span></span><br><span class="line">    PyFrameObject *f = _PyFrame_New_NoTrack(tstate, code, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//上一级的栈帧, PyThreadState指的是线程对象</span></span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    <span class="comment">//当前的栈帧</span></span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//builtin</span></span><br><span class="line">    PyObject *builtins;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">        ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">        nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">        <span class="comment">//这四部分便构成了PyFrameObject维护的动态内存区，其大小由extras确定</span></span><br><span class="line">        extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells +</span><br><span class="line">            nfrees;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">        f-&gt;f_code = code;</span><br><span class="line">        <span class="comment">//计算初始化运行时，栈的栈顶，所以没有加上stacksize</span></span><br><span class="line">        extras = code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        <span class="comment">//f_valuestack维护运行时栈的栈底</span></span><br><span class="line">        f-&gt;f_valuestack = f-&gt;f_localsplus + extras;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;extras; i++)</span><br><span class="line">            f-&gt;f_localsplus[i] = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f_stacktopk维护运行时栈的栈顶</span></span><br><span class="line">    f-&gt;f_stacktop = f-&gt;f_valuestack;</span><br><span class="line">    f-&gt;f_builtins = builtins;</span><br><span class="line">    Py_XINCREF(back);</span><br><span class="line">    f-&gt;f_back = back;</span><br><span class="line">    Py_INCREF(code);</span><br><span class="line">    Py_INCREF(globals);</span><br><span class="line">    f-&gt;f_globals = globals;</span><br><span class="line">    <span class="comment">/* Most functions have CO_NEWLOCALS and CO_OPTIMIZED set. */</span></span><br><span class="line">    <span class="keyword">if</span> ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==</span><br><span class="line">        (CO_NEWLOCALS | CO_OPTIMIZED))</span><br><span class="line">        ; <span class="comment">/* f_locals = NULL; will be set by PyFrame_FastToLocals() */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code-&gt;co_flags &amp; CO_NEWLOCALS) &#123;</span><br><span class="line">        locals = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>)</span><br><span class="line">            locals = globals;</span><br><span class="line">        Py_INCREF(locals);</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置一些其他属性，返回返回该栈帧</span></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，在创建PyFrameObject对象时，额外申请的”运行时栈”对应的空间并不完全是给运行时栈使用的，有一部分是给”PyCodeObject对象中存储的那些局部变量”、”co_freevars”、”co_cellvars”<code>(co_freevars、co_cellvars是与闭包有关的内容，后面章节会剖析)</code>使用的，而剩下的才是给真正运行时栈使用的。</strong></p>
<p><strong>并且这段连续的空间是由四部分组成，并且顺序是”局部变量”、”Cell对象”、”Free对象”、”运行时栈”。</strong></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们深入了 *Python* 虚拟机源码，研究虚拟机执行字节码的全过程。虚拟机在执行PyCodeObject对象里面的字节码之前，需要先根据PyCodeObject对象创建栈帧对象 ( *PyFrameObject* )，用于维护运行时的上下文信息。然后在PyFrameObject的基础上，执行字节码。</strong></p>
<p>*<strong>PyFrameObject* 关键信息包括：</strong></p>
<ul>
<li><code>f_locals: 局部名字空间</code></li>
<li><code>f_globals: 全局名字空间</code></li>
<li><code>f_builtins: 内建名字空间</code></li>
<li><code>f_code: PyCodeObject对象</code></li>
<li><code>f_lasti: 上条已执行指令的编号, 或者说偏移量、索引都可以</code></li>
<li><code>f_back: 该栈帧的上一级栈帧、即调用者栈帧</code></li>
<li><code>f_localsplus: 局部变量 + co_freevars + co_cellvars + 运行时栈, 这四部分需要的空间</code></li>
</ul>
<p><strong>栈帧对象通过 *f_back* 串成一个”栈帧调用链”，与 *CPU* 栈帧调用链有异曲同工之妙。我们还借助 *inspect* 模块成功取得栈帧对象<code>(底层是通过sys模块)</code>，并在此基础上输出整个函数调用链。</strong></p>
<p><strong>Python虚拟机的代码量不小，但是核心并不难理解，主要是*_PyEval_EvalFrameDefault*里面的一个巨大的for循环，准确的说for循环里面的那个巨型switch语句。其中的switch语句，case了每一个操作指令，当出现什么指令就执行什么操作。</strong></p>
<p><strong>另外我们提到运行时环境，这个运行时环境非常复杂，因为Python启动是要创建一个主进程、在进程内创建一个主线程的。所以还涉及到了进程和线程的初始化，在后面的系列中我们会详细说，包括GIL的问题。这里我们就先假设运行时环境已经初始化好了，我们直接关注虚拟机执行字节码的流程即可。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>08-解密Python中列表的底层实现</title>
    <url>/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="08-解密Python中列表的底层实现"><a href="#08-解密Python中列表的底层实现" class="headerlink" title="08-解密Python中列表的底层实现"></a>08-解密Python中列表的底层实现</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python中的列表可以说使用的非常广泛了，在初学列表的时候，老师会告诉你列表就是一个大仓库，什么都可以存放。不过在最开始的几个章节中，我们花了很大的笔墨介绍了Python中的对象，并明白了Python中变量的本质，我们知道列表中存放的元素其实都是泛型指针PyObject *，所以到现在列表已经没有什么好神秘的了。</strong></p>
<p><strong>并且根据我们使用列表的经验，我们可以得出以下两个结论：</strong></p>
<ul>
<li><code>每个列表中的元素个数可以不一样：所以这是一个变长对象</code></li>
<li><code>可以对列表中的元素进行添加、删除、修改等操作，所以这是一个可变对象</code></li>
</ul>
<p><strong>在分析列表对应的底层结构之前，我们先来回顾一下列表的使用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表，这里是通过Python/C API创建的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往列表尾部追加一个元素，此时是在本地操作的，返回值为None</span></span><br><span class="line"><span class="comment"># 但是列表被改变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾部弹出一个元素，会返回弹出的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment"># 此时列表也会被修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 另外在pop的时候还可以指定索引，弹出指定的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在指定位置插入一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过extend在尾部追加多个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.extend([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找指定元素第一次出现的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.index(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算某个元素在列表中出现的次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据元素的值删除第一个出现的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(<span class="number">4</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>上面的一些操作是列表经常使用的，但是在分析它的实现之前，我们肯定要了解它们的时间复杂度如何。这些东西即使不看源码，也是必须要知道的，尤其想要成为一名优秀的Python工程师。</strong></p>
<ul>
<li><code>append：会向尾部追加元素，所以时间复杂度为O(1)</code></li>
<li><code>pop：默认从尾部弹出元素，所以时间复杂度为O(1);如果不是尾部，而是从其它的位置弹出元素的话，那么该位置后面所有的元素都要向前移动，此时时间复杂度为O(n)</code></li>
<li><code>insert：向指定位置插入元素，该位置后面的所有元素都要向后移动，所以时间复杂度为O(n)</code></li>
</ul>
<p><strong>注意：由于列表里面的元素个数是可以自由变化的，所以列表有一个容量的概念，我们后面会说。当添加元素时，列表可能会扩容；同理当删除元素时，列表可能会缩容。</strong></p>
<p><strong>下面我们就来看一下列表对应的底层结构。</strong></p>
<h3 id="列表的内部结构–PyListObject"><a href="#列表的内部结构–PyListObject" class="headerlink" title="列表的内部结构–PyListObject"></a>列表的内部结构–PyListObject</h3><p>*<strong>list* 对象<code>(列表)</code>在 *Python* 内部，由 *PyListObject* 结构体表示，定义于头文件 *Include&#x2F;listobject.h* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面有如下成员：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 变长对象的公共头部信息</code></li>
<li><code>ob_item：一个二级指针，指向一个PyObject *类型的指针数组，这个指针数组保存的便是对象的指针，而操作底层数组都是通过ob_item来进行操作的。</code></li>
<li><code>allocated：容量, 我们知道列表底层是使用了C的数组, 而底层数组的长度就是列表的容量</code></li>
</ul>
<p><strong>列表之所以要有容量的概念，是因为列表可以动态添加元素，但是底层的数组在创建完毕之后，其长度却是固定的。所以一旦添加新元素的时候，发现底层数组已经满了，这个时候只能申请一个更长的数组，同时把原来数组中的元素依次拷贝到新的数组里面<code>(这一过程就是列表的扩容)</code>，然后再将新元素添加进去。但是问题来了，总不可能每添加一个元素，就申请一次数组、将所有元素都拷贝一次吧。所以Python在列表扩容的时候，会将底层数组申请的长一些，可以在添加元素的时候不用每次都申请新的数组。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040124028-249317005.png" alt="img"></p>
<p><strong>这便是列表的底层结构示意图，图中的object只是单纯的代指对象，不是Python中的基类object。我们看到底层数组的长度为5，说明此时列表的容量为5，但是里面只有3个PyObject  *指针，说明列表的ob_size是3，或者说列表里面此时有3个元素。注意：尽管底层数组的容量目前是5个，但是我们访问的时候，最多只能访问到第三个元素，也就是说索引最大只能是2，这是显而易见的，因为列表里面只有3个元素。</strong></p>
<p><strong>如果这个时候我们往列表中append一个元素，那么会将这个新元素设置在底层数组中索引为ob_size的位置、或者说第四个位置。一旦设置完，ob_size会自动加1，因为ob_size要和列表的长度保持一致。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040129642-1322638478.png" alt="img"></p>
<p><strong>如果此时再往列表中append一个元素的话，那么还是将新元素设置在索引为ob_size的位置，此时也就是第5个位置。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040138915-609447201.png" alt="img"></p>
<p><strong>列表的容量是5，但此时长度也达到了5，这说明当下一次append的时候已经没有办法再容纳新的元素了。因为此时列表的长度、或者说元素个数已经达到了容量，当然最直观的还是这里的底层数组，很明显全都占满了。那这个时候如果想再接收新的元素的话，要怎么办呢？显然只能扩容了。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040145842-412135912.png" alt="img"></p>
<p><strong>原来的容量是5个，长度也是5个，当再来一个新元素的时候由于没有位置了，所以要扩容。但是扩容的时候肯定会将容量申请的大一些、即底层数组申请的长一些<code>(具体申请多长,Python内部有一个公式,我们后面会说)</code>，假设申请的新的底层数组长度是8，那么说明列表的容量就变成了8。然后将原来数组中的PyObject  *按照顺序依次拷贝到新的数组里面，再让ob_item指向新的数组。最后将要添加的新元素设置在新的数组中索引为ob_size的位置、即第6个位置，然后将ob_size加1，此时ob_size就变成了6。</strong></p>
<p><strong>以上便是列表底层在扩容的时候所经历的过程。</strong></p>
<blockquote>
<p><strong>由于扩容会申请新的数组，然后将旧数组的元素拷贝到新数组中，所以这是一个时间复杂度为O(n)的操作。而append可能会导致列表扩容，因此append最坏情况下也是一个O(n)的操作，只不过扩容不会频繁发生，所以append的平均时间复杂度还是O(1)。</strong></p>
</blockquote>
<p>​        <strong>另外我们还可以看到一个现象，那就是Python中的列表在底层是分开存储的，因为PyListObject结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组的二级指针。显然我们添加、删除、修改元素等操作，都是通过ob_item这个二级指针来间接操作这个指针数组。</strong>    </p>
<p>​        <strong>所以底层对应的PyListObject实例的大小其实是不变的，因为指针数组没有存在PyListObject里面。但是Python在计算内存大小的时候是会将这个指针数组也算进去的，所以Python中列表的大小是可变的。</strong>    </p>
<p><strong>而且我们知道，列表在append之后地址是不变的，至于原因上面的几张图已经解释的很清楚了。如果长度没有达到容量，那么append其实就是往底层数组中设置了一个新元素；如果达到容量了，那么会扩容，但是扩容只是申请一个新的指针数组，然后让ob_item重新指向罢了。所以底层数组会变，但是PyListObject结构体实例本身是没有变化的。因此列表无论是append、extend、pop、insert等等，只要是在本地操作，那么它的地址是不会变化的。</strong></p>
<p><strong>下面我们再来看看Python中的列表所占的内存大小是怎么算的：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 24字节</code></li>
<li><code>ob_item: 二级指针, 8字节</code></li>
<li><code>allocated: 8字节</code></li>
</ul>
<p><strong>但是不要忘记，在计算列表大小的时候，ob_item指向的指针数组也要算在内。所以：一个列表的大小 &#x3D; 40 + 8 * 指针数组长度<code>(或者列表容量)</code>。注意是底层数组长度、或者列表容量，可不是列表长度，因为底层数组一旦申请了，不管你用没用，大小就摆在那里了。就好比你租了间房子，就算不住，房租该交还是得交。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显然一个空数组占40个字节</span></span><br><span class="line"><span class="built_in">print</span>([].__sizeof__())  <span class="comment"># 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 40 + 3 * 8 = 64</span></span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;x&quot;</span> * <span class="number">1000</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="comment"># 虽然里面有一个长度为1000的字符串，但我们说列表存放的都是指针, 所以大小都是8字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 我们通过l = [1, 2, 3]这种方式创建列表的话</span></span><br><span class="line"><span class="comment"># 不管内部元素有多少个, 其ob_size和allocated都是一样的</span></span><br><span class="line"><span class="comment"># 那么列表什么时候会扩容呢? 答案是在添加元素的时候发现容量不够了才会扩容</span></span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 40 + 10 * 8 = 120</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 120</span></span><br><span class="line"><span class="comment"># 这个时候append一个元素</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 184</span></span><br><span class="line"><span class="comment"># 我们发现大小达到了184, (184 - 40) // 8 = 18, 说明扩容之后申请的底层数据的长度为18 </span></span><br></pre></td></tr></table></figure>

<p><strong>所以列表的大小我们就知道是怎么来的了，而且为什么列表在通过索引定位元素的时候，时间复杂度是O(1)。因为列表中存储的都是对象的指针，不管对象有多大，其指针大小是固定的，都是8字节。通过索引可以瞬间计算出偏移量，从而找到对应元素的指针，而操作指针会自动操作指针所指向的内存。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="built_in">print</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]].__sizeof__())  <span class="comment"># 48</span></span><br></pre></td></tr></table></figure>

<p><strong>相信上面这个结果，你肯定能分析出原因。因为第一个列表中有3个指针，所以是40 + 24 &#x3D; 64；而第二个列表中有一个指针，所以是40 + 8 &#x3D; 48。用一张图来展示一下<code>[1, 2, 3]</code>和<code>[[1, 2, 3]]</code>的底层结构，看看它们之间的区别：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040157535-1310257941.png" alt="img"></p>
<p>​        <strong>分析完PyListObject之后，我们来看看它支持的操作，显然我们要通过类型对象PyList_Type来查看。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到，列表支持序列型操作和映射型操作，下面我们就来分析一下。</strong></p>
<h3 id="列表支持的操作"><a href="#列表支持的操作" class="headerlink" title="列表支持的操作"></a>列表支持的操作</h3><p><strong>我们看看平常使用的列表所支持的操作在底层是如何实现的。</strong></p>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p><strong>我们先来说说列表的扩容，因为我们知道列表是会自动扩容的，那么什么时候会扩容呢？我们说列表扩容的时候，是在添加元素时发现底层数组已经满了的情况下才会扩容。换句话说，一个列表在添加元素的时候会扩容，那么说明在添加元素之前，其内部的元素个数和容量是相等的。然后我们看看底层是怎么实现的，这些操作都位于Objects&#x2F;listobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_resize</span><span class="params">(PyListObject *self, Py_ssize_t newsize)</span></span><br><span class="line">&#123;   <span class="comment">//参数self就是列表啦，newsize指的元素在添加之后的ob_size</span></span><br><span class="line">    <span class="comment">//比如列表的ob_size是5，那么在append的时候发现容量不够，所以会扩容，那么这里的newsize就是6</span></span><br><span class="line">    <span class="comment">//如果是extend添加3个元素，那么这里的newsize就是8</span></span><br><span class="line">    <span class="comment">//当然list_resize这个函数不仅可以扩容，也可以缩容，假设列表原来有1000个元素，这个时候将列表清空了</span></span><br><span class="line">    <span class="comment">//那么容量肯定缩小，不然会浪费内存，如果清空了列表，那么这里的newsize显然就是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//items是一个二级指针，显然是用来指向指针数组的</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//新的容量，以及对应的内存大小</span></span><br><span class="line">    <span class="type">size_t</span> new_allocated, num_allocated_bytes;</span><br><span class="line">    <span class="comment">//获取原来的容量</span></span><br><span class="line">    Py_ssize_t allocated = self-&gt;allocated;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize达到了容量的一半，但还没有超过容量, 那么意味着newsize、或者新的ob_size和容量是匹配的，所以不会变化</span></span><br><span class="line">    <span class="keyword">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        assert(self-&gt;ob_item != <span class="literal">NULL</span> || newsize == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//只需要将列表的ob_size设置为newsize即可</span></span><br><span class="line">        Py_SIZE(self) = newsize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里说明容量和ob_size不匹配了，所以要进行扩容或者缩容。</span></span><br><span class="line">    <span class="comment">//因此要申请新的底层数组，申请多少个?这里给出了公式,一会儿我们可以通过Python进行测试</span></span><br><span class="line">    new_allocated = (<span class="type">size_t</span>)newsize + (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//显然容量不可能无限大，是有范围的，当然这个范围基本上是达不到的</span></span><br><span class="line">    <span class="keyword">if</span> (new_allocated &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize为0，那么容量也会变成0，假设将列表全部清空了，容量就会变成0</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">        new_allocated = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们说数组中存放的都是PyObject *, 所以要计算内存</span></span><br><span class="line">    num_allocated_bytes = new_allocated * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line">    <span class="comment">//申请相应大小的内存，将其指针交给items</span></span><br><span class="line">    items = (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果items是NULL, 代表申请失败</span></span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后让ob_item = items, 也就是指向新的数组, 此时列表就发生了扩容或缩容</span></span><br><span class="line">    self-&gt;ob_item = items;</span><br><span class="line">    <span class="comment">//将ob_size设置为newsize, 因为它维护列表内部元素的个数</span></span><br><span class="line">    Py_SIZE(self) = newsize;</span><br><span class="line">    <span class="comment">//将原来的容量大小设置为新的容量大小</span></span><br><span class="line">    self-&gt;allocated = new_allocated;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到还是很简单的，没有什么黑科技，下面我们就来分析一下列表扩容的时候，容量和元素个数之间的规律。其实在list_resize函数中是有注释的，其种一行写着：<code>The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</code></strong></p>
<p><strong>说明我们往一个空列表中不断append元素的时候，容量会按照上面的规律进行变化，我们来试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还记得底层是怎么改变容量的吗？</span></span><br><span class="line"><span class="comment"># 我们说有一个公式: new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="comment"># 我们来看一下</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此时容量是: 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    lst.append(item)  <span class="comment"># 添加元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算ob_size</span></span><br><span class="line">    ob_size = <span class="built_in">len</span>(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断ob_size和当前的容量</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        <span class="comment"># lst的大小减去空列表的大小, 再除以8显然就是容量的大小, 因为不管你有没有用, 容量已经分配了</span></span><br><span class="line">        allocated = (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;列表扩容啦, 新的容量是: <span class="subst">&#123;allocated&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时容量是: 0</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 4</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 8</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 16</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 25</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 35</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 46</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 58</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 72</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 88</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 106</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到和官方给的结果是一样的，显然这是毫无疑问的，我们根据底层的公式也能算出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ob_size = <span class="number">0</span></span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    ob_size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        allocated = ob_size + (ob_size &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> ob_size &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>)</span><br><span class="line">        <span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 0 4 8 16 25 35 46 58 72 88 106 </span></span><br></pre></td></tr></table></figure>

<p>​        <strong>但还是那句话，扩容是指解释器发现容量不够的情况下才会扩容，如果我们直接通过lst &#x3D; []这种形式创建列表的话，那么其长度和容量是一样的。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="comment"># 长度和容量一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但此时添加一个元素的话, 那么ob_size会变成1001, 大于容量1000</span></span><br><span class="line"><span class="comment"># 所以此时列表就要扩容了, 执行list_resize, 里面的new_size就是1001, 然后是怎么分配容量来着</span></span><br><span class="line"><span class="comment"># new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新容量:&quot;</span>, <span class="number">1001</span> + (<span class="number">1001</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">1001</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 新容量: 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append一个元素，列表扩容</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 计算容量</span></span><br><span class="line"><span class="built_in">print</span>((lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果是一样的, 因为底层就是这么实现的, 所以结果必须一样</span></span><br><span class="line"><span class="comment"># 只不过我们通过这种测试的方式证明了这一点, 也更加了解了底层的结构是什么样子的。</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>介绍完扩容，那么介绍缩容，因为列表元素个数要是减少到和容量不匹配的话，也要进行缩容。</strong>    </p>
<p>​        <strong>举个生活中的例子，假设你租了10间屋子用于办公，显然你要付10间屋子的房租，不管你有没有住，一旦租了肯定是要付钱的。同理底层数组也是一样，只要你申请了，不管有没有元素，内存已经占用了。但有一天你用不到10间屋子了，假设会用8间或者9间，那么会让剩余的屋子闲下来。但由于退租比较麻烦，并且只闲下来一两间屋子，所以多余的屋子就不退了，还是会付10间屋子的钱，这样当没准哪天又要用的时候就不用重新租了。对于列表也是如此，如果在删除元素(相当于屋子不用了)的时候发现长度没有超过容量但是又达到了容量的一半，所以也不会缩容。但是，如果屋子闲了8间，也就是只需要两间屋子就足够了，那么此时肯定要退租了，闲了8间，可能会退掉6间。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除500个元素, 此时长度或者说ob_size就为500</span></span><br><span class="line">lst[<span class="number">500</span>:] = []</span><br><span class="line"><span class="comment"># 但是ob_size还是达到了容量的一半, 所以不会缩容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 500 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果再删除一个元素的话, 那么不好意思, 显然就要进行缩容了, 因为ob_size变成了499, 小于1000 // 2</span></span><br><span class="line"><span class="comment"># 缩容之后容量怎么算呢? 还是之前那个公式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">499</span> + (<span class="number">499</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">499</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 567</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下, 删除一个元素, 看看会不会按照我们期待的规则进行缩容</span></span><br><span class="line">lst.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 499 567</span></span><br></pre></td></tr></table></figure>

<p><strong>一切都和我们想的是一样的，另外在代码中我们还看到一个if语句，就是如果newsize是0，那么容量也是0，我们来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line">lst[:] = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 0 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果按照之前的容量变化公式的话, 会发现结果应该是3, 但是结果是0, 就是因为多了if判断:如果newsize是0, 就把容量也设置为0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 但为什么要这么做呢?因为Python认为, 列表长度为0的话，说明你不想用这个列表了, 所以多余的3个也没有必要申请了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还以租房为栗, 如果你一间屋子都不用了, 说明可能你不用这里的屋子办公了</span></span><br><span class="line"><span class="comment"># 因此多余3间屋子也没有必要再租了, 所以直接全部退掉</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是列表在改变容量时所采用的策略，我们从头到尾全部分析了一遍。</strong></p>
<h4 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h4><p><strong>append方法用于像尾部追加一个元素，我们看看底层实现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_append</span><span class="params">(PyListObject *self, PyObject *object)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然调用的app1是核心, 它里面实现了添加元素的逻辑</span></span><br><span class="line">    <span class="comment">//Py_RETURN_NONE是一个宏，表示返回Python中的None, 因为list.append返回的就是None</span></span><br><span class="line">    <span class="keyword">if</span> (app1(self, object) == <span class="number">0</span>)</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">app1</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;	<span class="comment">//self是列表，v是要添加的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取列表的长度</span></span><br><span class="line">    Py_ssize_t n = PyList_GET_SIZE(self);</span><br><span class="line">    assert (v != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果长度已经达到了限制，那么无法再添加了, 会抛出OverflowError</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//还记得这个list_resize吗? self就是列表, n + 1就是newsize，或者说新的ob_size</span></span><br><span class="line">    <span class="comment">//会自动判断是否要进行扩容, 当然里面还有重要的一步，就是将列表的ob_size设置成newsize、也就是这里的n + 1</span></span><br><span class="line">    <span class="comment">//因为append之后列表长度大小会变化，而ob_size则要时刻维护这个大小</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//因为v作为了列表的一个元素，所以其指向的对象的引用计数要加1</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//然后调用PyList_SET_ITEM，这是一个宏，它的作用就是设置元素的，我们下面会看这个宏长什么样</span></span><br><span class="line">    <span class="comment">//原来的列表长度为n, 里面的元素的最大索引是n - 1，那么追加的话就等于将元素设置在索引为n的地方</span></span><br><span class="line">    PyList_SET_ITEM(self, n, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们说PyList_SET_ITEM是用来设置元素的，设置在什么地方呢？显然是设置在底层数组中</span></span><br><span class="line"><span class="comment">//PyList_SET_ITEM一个宏,除了这个宏之外，还有很多其它的宏，它们位于Inlcude/listobject.h中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_SIZE(op)    (assert(PyList_Check(op)),Py_SIZE(op))</span></span><br><span class="line"><span class="comment">//这些宏的作用是啥，一目了然</span></span><br></pre></td></tr></table></figure>

<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>我们在使用列表的时候，可以通过val &#x3D; lst[1]这种方式获取元素，那么底层是如何实现的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//先看item是不是一个整型，显然这个item除了整型之外，也可以是切片</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        Py_ssize_t i;</span><br><span class="line">        <span class="comment">//这里检测i是否合法，因为Python的整型是没有限制的</span></span><br><span class="line">        <span class="comment">//但是列表的长度和容量都是由一个有具体类型的变量维护的，所以其个数肯定是有范围的</span></span><br><span class="line">        <span class="comment">//所以你输入一个lst[2 ** 100000]显然是不行的, 在Python中会报错IndexError: cannot fit &#x27;int&#x27; into an index-sized integer</span></span><br><span class="line">        i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置异常</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果i小于0, 那么加上列表的长度, 变成正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//然后调用list_item</span></span><br><span class="line">        <span class="keyword">return</span> list_item(self, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">list_item(PyListObject *a, Py_ssize_t i)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//检测索引i的合法性，如果i &gt; 列表的长度, 那么会报出索引越界的错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        <span class="comment">//如果索引为负数也会报出索引越界错误,因为上面已经对负数索引做了处理了,但如果负数索引加上长度之后还是个负数, 那么同样报错。</span></span><br><span class="line">        <span class="comment">//假设列表长度是5, 你的索引是-100, 加上长度之后是-95，结果还是个负数, 所以也会报错</span></span><br><span class="line">        <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            indexerr = PyUnicode_FromString(</span><br><span class="line">                <span class="string">&quot;list index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PyErr_SetObject(PyExc_IndexError, indexerr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ob_item获取第i个元素</span></span><br><span class="line">    Py_INCREF(a-&gt;ob_item[i]);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> a-&gt;ob_item[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然获取元素的时候不光可以通过索引，还可以通过切片的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        start: 切片的起始位置</span></span><br><span class="line"><span class="comment">        end: 切片的结束位置</span></span><br><span class="line"><span class="comment">        step: 切片的步长</span></span><br><span class="line"><span class="comment">        slicelength: 获取元素个数,比如[1:5:2],显然slicelength就是2, 因为只能获取索引为1和3的元素</span></span><br><span class="line"><span class="comment">        cur: 底层数组中元素的索引</span></span><br><span class="line"><span class="comment">        i: 循环变量, 因为切片的话只能循环获取每一个元素, 比如[1:5:2], 需要循环两次。第一次循环, 上面的cur就是1, 第二次循环cur就是3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, cur, i;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面代码中会有所体现</span></span><br><span class="line">        PyObject* it;</span><br><span class="line">        PyObject **src, **dest;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//对切片item进行解包进行解包, 得到起始位置、结束位置、步长</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算出slicelength, 因为即便我们指定的切片是[1:3:5], 但如果列表只有3个元素, 所以slicelength也只能是1</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(Py_SIZE(self), &amp;start, &amp;stop,</span><br><span class="line">                                            step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果slicelength为0, 那么不好意思, 表示没有元素可以获取, 因此直接返回一个空列表即可</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//PyList_New表示创建一个PyListObject, 里面的参数表示底层数组的长度</span></span><br><span class="line">            <span class="comment">//另外对于创建列表，Python底层只提供了PyList_New这一种Python/C API</span></span><br><span class="line">            <span class="comment">//当我们执行lst = [1, 2, 3]的时候就会执行PyList_New(3)</span></span><br><span class="line">            <span class="keyword">return</span> PyList_New(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果步长为1, 那么会调用list_slice,这个函数内部的逻辑很简单,首先接收一个PyListObject *和两个整型(ilow, ihigh)</span></span><br><span class="line">        <span class="comment">//然后在内部会创建一个PyListObject *np, 申请相应的底层数组，设置allocated</span></span><br><span class="line">        <span class="comment">//然后将参数列表中索引为ilow的元素到索引为ihigh的元素依次拷贝到np -&gt; ob_item里面, 然后这是ob_size并返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list_slice(self, start, stop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里说明步长不为1, 我们说result是一个PyListObject *, 底层数组没有存储在PyListObject中，而是通过ob_item发生关联</span></span><br><span class="line">            <span class="comment">//所以这一步是申请底层数组、设置容量的，容量就是这里的slicelength, 上面的list_slice中也调用了这一步</span></span><br><span class="line">            result = list_new_prealloc(slicelength);</span><br><span class="line">            <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//src是一个二级指针, 也就是self -&gt; ob_item</span></span><br><span class="line">            src = self-&gt;ob_item;</span><br><span class="line">            <span class="comment">//同理dest是result -&gt; ob_item</span></span><br><span class="line">            dest = ((PyListObject *)result)-&gt;ob_item;</span><br><span class="line">            <span class="comment">//进行循环, cur从start开始遍历, 每次加上step步长</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += (<span class="type">size_t</span>)step, i++) &#123;</span><br><span class="line">                <span class="comment">//it就是self -&gt; ob_item中的元素</span></span><br><span class="line">                it = src[cur];</span><br><span class="line">                <span class="comment">//增加指向的对象的引用计数</span></span><br><span class="line">                Py_INCREF(it);</span><br><span class="line">                <span class="comment">//将其设置到dest中</span></span><br><span class="line">                dest[i] = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将大小设置为slicelength，说明通过切片创建新列表, 其长度和容量也是一致的</span></span><br><span class="line">            Py_SIZE(result) = slicelength;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明item不合法</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;list indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     item-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现这个和字符串类似啊，因为通过字符串也支持切片的方式获取。</strong></p>
<blockquote>
<p><strong>随着源码的分析，我们也渐渐明朗Python的操作在底层是如何实现的了，真的一点不神秘，实现的逻辑非常简单。</strong></p>
</blockquote>
<h4 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h4><p><strong>获取元素知道了，设置元素也不难了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_ass_subscript</span><span class="params">(PyListObject* self, PyObject* item, PyObject* value)</span></span><br><span class="line">&#123;	<span class="comment">//在list_subscript的基础上多了一个value参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//依旧是进行检测i是否合法</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//索引小于0，则加上列表的长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//调用list_ass_item进行设置，我们之前见到了list_item，是用来基于索引获取的</span></span><br><span class="line">        <span class="comment">//这里的list_ass_item是基于索引进行元素设置的</span></span><br><span class="line">        <span class="keyword">return</span> list_ass_item(self, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    	<span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">list_ass_item(PyListObject *a, Py_ssize_t i, PyObject *v)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//判断索引是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                        <span class="string">&quot;list assignment index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的list_ass_slice后面会说</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> list_ass_slice(a, i, i+<span class="number">1</span>, v);</span><br><span class="line">    <span class="comment">//增加v指向对象的引用计数，因为指向它的指针被传到了列表中</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将第i个元素设置成v</span></span><br><span class="line">    Py_SETREF(a-&gt;ob_item[i], v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过索引设置元素，逻辑很容易，关键是通过切片设置元素会比较复杂。而复杂的原因就在于步长，我们通过Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先通过切片进行设置的话, 右值一定要是一个可迭代对象</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="comment"># 会将lst[0]设置为11, lst[1]设置为22, lst[2]设置为33</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [11, 22, 33, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而且它们的长度是可以不相等的</span></span><br><span class="line"><span class="comment"># 这里表示将[0: 3]的元素设置为[1, 2], lst[0]设置成1, lst[1]设置成2</span></span><br><span class="line"><span class="comment"># 问题来了, lst[2]咋办? 由于右值中已经没有元素与之匹配了, 那么lst[2]就会被删掉</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们如果想删除[0: 3]的元素, 那么只需要执行lst[0: 3] = []即可</span></span><br><span class="line"><span class="comment"># 因为[]里面没有元素能与之匹配, 所以lst中[0: 3]的元素由于匹配不到, 所以直接就没了</span></span><br><span class="line"><span class="comment"># 当然由于Python的动态特性, lst[0: 3] = []、lst[0: 3] = ()、lst[0: 3] = &quot;&quot;等等都是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># 实际上我们del lst[0]的时候, 实际上就是执行了lst[0: 1] = []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然如果右值元素多的话也是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># lst[0]匹配1很好理解, 但是此时左边已经结束了, 所以剩余的元素会依次插在后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重点来了, 如果切片有步长的话, 那么两边一定要匹配</span></span><br><span class="line"><span class="comment"># 由于此时lst中有8个元素, lst[:: 2]会得到4个元素, 那么右边的可迭代对象的长度也是4</span></span><br><span class="line">lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;a&#x27;, 2, &#x27;b&#x27;, 4, &#x27;c&#x27;, 7, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果长度不一致</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 显然会报错</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># attempt to assign sequence of size 3 to extended slice of size 4</span></span><br></pre></td></tr></table></figure>

<p><strong>至于通过切片来设置元素，源码很长，这里就不分析了，总之核心如下：</strong></p>
<ul>
<li><code>如果步长为1: 那么会调用list_ass_slice。我们说:  list_item是基于索引获取元素、list_slice是基于切片获取元素、list_ass_item是基于索引设置元素、list_ass_slice是基于切片设置元素。而list_ass_slice内部的代码逻辑也很长，但是核心并不难, 我们通过lst[a: b] = [v1, v2, v3, ...]这种方式就会走这里的list_ass_slice。</code></li>
<li><code>如果步长不为1，那么就是采用循环的方式逐个设置。</code></li>
</ul>
<p><strong>主要是考虑的情况比较多，但是核心逻辑并不复杂，有兴趣可以自己去深入了解一下。</strong></p>
<h4 id="insert插入元素"><a href="#insert插入元素" class="headerlink" title="insert插入元素"></a>insert插入元素</h4><p><strong>insert用来在指定的位置插入元素，我们知道它是一个时间复杂度为O(n)的一个操作，因为插入位置后面的所有元素都要向后移动。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *newitem)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用ins1</span></span><br><span class="line">    <span class="keyword">return</span> ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ins1</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/*参数self：PyListObject *</span></span><br><span class="line"><span class="comment">    参数where：索引</span></span><br><span class="line"><span class="comment">    参数v：插入的值，这是一个PyObject *指针，因为list里面存的都是指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i:后面for循环遍历用的，n则是当前列表的元素个数</span></span><br><span class="line">    Py_ssize_t i, n = Py_SIZE(self);</span><br><span class="line">    <span class="comment">//指向指针数组的二级指针</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//如果v是NULL，错误的内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列表的元素个数不可能无限增大，一般当你还没创建到PY_SSIZE_T_MAX个对象时</span></span><br><span class="line">    <span class="comment">//你内存就已经玩完了，但是python仍然做了检测，当达到这个PY_SSIZE_T_MAX时，会报出内存溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调整列表容量，既然要inert，那么就势必要多出一个元素</span></span><br><span class="line">    <span class="comment">//这个元素还没有设置进去，但是先把这个坑给留出来</span></span><br><span class="line">    <span class="comment">//当然如果容量够的话，是不会扩容的，只有当容量不够的时候才会扩容</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//确定插入点</span></span><br><span class="line">    <span class="keyword">if</span> (where &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里可以看到如果where小于0，那么我们就加上n，也就是当前列表的元素个数</span></span><br><span class="line">        <span class="comment">//比如有6个元素，那么我们where=-1，加上6，就是5，显然就是insert在最后一个索引的位置上 </span></span><br><span class="line">        where += n;</span><br><span class="line">        <span class="comment">//如果吃撑了，写个-100，加上元素的个数还是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (where &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//那么where=0，就在开头插入</span></span><br><span class="line">            where = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果where &gt; n，那么就索引为n的位置插入，</span></span><br><span class="line">    <span class="comment">//可元素个数为n，最大索引是n-1啊，对，所以此时就相当于append</span></span><br><span class="line">    <span class="keyword">if</span> (where &gt; n)</span><br><span class="line">        where = n;</span><br><span class="line">    <span class="comment">//拿到原来的二级指针，指向一个指针数组</span></span><br><span class="line">    items = self-&gt;ob_item;</span><br><span class="line">    <span class="comment">//然后不断遍历，把索引为i的值赋值给索引为i+1</span></span><br><span class="line">    <span class="comment">//既然是在where处插入那么where之前的就不需要动了，到where处就停止了</span></span><br><span class="line">    <span class="keyword">for</span> (i = n; --i &gt;= where; )</span><br><span class="line">        items[i+<span class="number">1</span>] = items[i];</span><br><span class="line">    <span class="comment">//增加v指向的对象的引用计数，因为列表中的元素也引用了该对象</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将索引为where的值设置成v</span></span><br><span class="line">    items[where] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以可以看到，Python插入数据是非常灵活的。不管你在什么位置插入，都是合法的。因为它会自己调整位置，在确定位置之后，会将当前位置以及之后的所有元素向后挪动一个位置，空出来的地方设置为插入的值。</strong></p>
<h4 id="pop弹出元素"><a href="#pop弹出元素" class="headerlink" title="pop弹出元素"></a>pop弹出元素</h4><p><strong>pop默认是从尾部弹出元素的，因为如果不指定索引的话，默认是-1。当然我们也可以指定索引，弹出指定索引对应的元素。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_pop_impl</span><span class="params">(PyListObject *self, Py_ssize_t index)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//弹出的对象的指针，因为弹出一个元素实际上是先用某个变量保存起来，然后再从列表中删掉</span></span><br><span class="line">    PyObject *v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面代码中体现</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果列表长度为0，显然没有元素可以弹, 因此会报错</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop from empty list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//索引小于0，那么加上列表的长度得到正数索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        index += Py_SIZE(self);</span><br><span class="line">    <span class="comment">//依旧是调用valid_index，判断是否越界。显然pop没有insert那么智能</span></span><br><span class="line">    <span class="comment">//insert的话，索引在加上列表长度之和还小于0，那么默认是在索引为0的地方插入</span></span><br><span class="line">    <span class="comment">//但是pop就不行了，pop的话会报出索引越界错误，同理索引大于等于列表长度，insert会等价于append,而pop同样报出索引越界错误</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(index, Py_SIZE(self))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据索引获取指定位置的元素</span></span><br><span class="line">    v = self-&gt;ob_item[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里同样是一个快分支，如果index是最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (index == Py_SIZE(self) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//那么直接调用list_resize即可，我们说只要涉及元素的添加、删除都要执行list_resize</span></span><br><span class="line">        <span class="comment">//至于容量是否变化，就看是否满足newsize和allocated之间的关系,如果allocated//2 &lt;= newsize &lt;= allocated，那么容量就不变</span></span><br><span class="line">        <span class="comment">//list_resize中会将ob_size设置成newsize，也就是原来的ob_size减去1, 因为是在尾部删除的，所以只需要将ob_size设置为ob_size-1即可</span></span><br><span class="line">        status = list_resize(self, Py_SIZE(self) - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list_resize执行成功会返回0</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//直接将对象的指针返回</span></span><br><span class="line">            <span class="keyword">return</span> v; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明不是快分支</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//这里调用了list_ass_slice, 这一步等价于self[index: index + 1] = []</span></span><br><span class="line">    status = list_ass_slice(self, index, index+<span class="number">1</span>, (PyObject *)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置失败，减少引用计数</span></span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回指针</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以pop本质上也是调用了list_ass_slice。</strong></p>
<h4 id="index查询元素的索引"><a href="#index查询元素的索引" class="headerlink" title="index查询元素的索引"></a>index查询元素的索引</h4><p><strong>index可以接收一个元素，返回该元素首次出现的索引。当然还可以额外指定一个start和end，表示查询的范围</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_index_impl</span><span class="params">(PyListObject *self, PyObject *value, Py_ssize_t start,</span></span><br><span class="line"><span class="params">                Py_ssize_t stop)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果start小于0，加上长度。</span></span><br><span class="line">    <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果stop小于0，加上长度</span></span><br><span class="line">        <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">        stop += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (stop &lt; <span class="number">0</span>)</span><br><span class="line">            stop = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从start开始循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; stop &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取相应元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//增加引用计数，因为有指针指向它</span></span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//进行比较PyObject_RichCompareBool是一个富比较，接收三个参数：元素1、元素2、操作(这里显然是Py_EQ)</span></span><br><span class="line">        <span class="comment">//相等返回1，不相等返回0</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        <span class="comment">//比较完之后，减少引用计数</span></span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果相等，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环走完一圈，发现都没有相等的，那么报错，提示元素不再列表中</span></span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">&quot;%R is not in list&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以lst.index是一个时间复杂度为O(n)的操作，因为它在底层要循环整个列表，如果运气好，可以第一个元素就是，运气不好可能就好循环整个列表了。同理后面要说的if value in lst这种方式也是一样的，因为都要循环整个列表，只不过后者返回的是一个布尔值。</strong></p>
<h4 id="count查询元素出现的次数"><a href="#count查询元素出现的次数" class="headerlink" title="count查询元素出现的次数"></a>count查询元素出现的次数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_count</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//初始为0</span></span><br><span class="line">    Py_ssize_t count = <span class="number">0</span>;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//遍历每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//如果相等，那么count自增1，继续下一次循环</span></span><br><span class="line">        <span class="comment">//注意这里的相等，判断的是什么呢？显然是对象的地址，如果地址一样，那么肯定指向同一个对象，所以一定相等。</span></span><br><span class="line">        <span class="keyword">if</span> (obj == value) &#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//走到这里说明地址不一样，但是地址不一样只能说明a is b不成立，但并不代表a == b不成立，所以调用PyObject_RichCompareBool进行判断</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//大于0，说明相等，count++</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回count</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromSsize_t(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>count毫无疑问，无论在什么情况下，它都是一个时间复杂度为O(n)的操作，因为列表必须要从头遍历到尾。</strong></p>
<h4 id="remove根据元素的值删除元素"><a href="#remove根据元素的值删除元素" class="headerlink" title="remove根据元素的值删除元素"></a>remove根据元素的值删除元素</h4><p><strong>除了根据索引删除元素之外，也可以元素指向的对象维护的值删除元素，删除第一个出现元素。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_remove</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历，获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//比较是否相等</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//如果相等</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用list_ass_slice删除元素</span></span><br><span class="line">            <span class="keyword">if</span> (list_ass_slice(self, i, i+<span class="number">1</span>,</span><br><span class="line">                               (PyObject *)<span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//返回None</span></span><br><span class="line">                Py_RETURN_NONE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明元素不在列表中</span></span><br><span class="line">    PyErr_SetString(PyExc_ValueError, <span class="string">&quot;list.remove(x): x not in list&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reverse翻转列表"><a href="#reverse翻转列表" class="headerlink" title="reverse翻转列表"></a>reverse翻转列表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_reverse_impl</span><span class="params">(PyListObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果列表长度不大于1的话, 那么直接返回其本身即可</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//大于1的话，执行reverse_slice, 传递了两个参数</span></span><br><span class="line">        <span class="comment">//第一个参数self -&gt; ob_item显然是底层数组首元素的地址</span></span><br><span class="line">        <span class="comment">//而第二个参数self-&gt;ob_item + Py_SIZE(self)则是底层数组中索引为ob_size的元素的地址</span></span><br><span class="line">        <span class="comment">//但是很明显能访问的最大索引应该是ob_size - 1才对, 别急我们继续往下看, 看一下reverse_slice函数的实现</span></span><br><span class="line">        reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self));</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">reverse_slice</span><span class="params">(PyObject **lo, PyObject **hi)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(lo &amp;&amp; hi);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们看到又执行了一次--hi,将hi移动到了ob_size - 1位置，也就是说此时二级指针hi保存的还是索引为ob_size - 1的元素的值</span></span><br><span class="line">    <span class="comment">//所以个人觉得有点纳闷, 直接reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self) - 1);不行吗</span></span><br><span class="line">    --hi;</span><br><span class="line">    <span class="comment">//当lo小于hi的时候</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        PyObject *t = *lo;</span><br><span class="line">        *lo = *hi;</span><br><span class="line">        *hi = t;</span><br><span class="line">        <span class="comment">//上面三步就等价于 *lo, *hi = *hi, *lo, 但是C不支持这么写</span></span><br><span class="line">        <span class="comment">//所以我们看到就是将索引为0的元素和索引为ob_size-1的元素进行了交换，前后两个指针继续靠近,指向的元素继续交换，知道两个指针相遇</span></span><br><span class="line">        ++lo;</span><br><span class="line">        --hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以到现在，你还认为Python中的列表神秘吗？虽然我们不可能写出一个Python解释器，但是底层的一些思想其实并没有那么难，作为一名程序猿很容易想的到。</strong></p>
<h4 id="两个列表相加"><a href="#两个列表相加" class="headerlink" title="两个列表相加"></a>两个列表相加</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_concat</span><span class="params">(PyListObject *a, PyObject *bb)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size;  <span class="comment">//相加之后的列表长度</span></span><br><span class="line">    Py_ssize_t i; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="comment">//两个二级指针，指向ob_item</span></span><br><span class="line">    PyObject **src, **dest;</span><br><span class="line">    <span class="comment">//新的列表</span></span><br><span class="line">    PyListObject *np;</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(bb)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                  <span class="string">&quot;can only concatenate list (not \&quot;%.200s\&quot;) to list&quot;</span>,</span><br><span class="line">                  bb-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b ((PyListObject *)bb)</span></span><br><span class="line">    <span class="comment">//判断长度是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &gt; PY_SSIZE_T_MAX - Py_SIZE(b))</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//计算新列表的长度</span></span><br><span class="line">    size = Py_SIZE(a) + Py_SIZE(b);</span><br><span class="line">    <span class="comment">//设置np -&gt; ob_item指向的底层数组</span></span><br><span class="line">    np = (PyListObject *) list_new_prealloc(size);</span><br><span class="line">    <span class="keyword">if</span> (np == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取a -&gt; ob_item和np -&gt; ob_item</span></span><br><span class="line">    src = a-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item;</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(a); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取b-&gt;ob_item</span></span><br><span class="line">    <span class="comment">//获取np-&gt;ob_item + Py_SIZE(a), 要从Py_SIZE(a)的位置开始设置, 否则就把之前的元素覆盖掉了</span></span><br><span class="line">    src = b-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item + Py_SIZE(a);</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(b); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size</span></span><br><span class="line">    Py_SIZE(np) = size;</span><br><span class="line">    <span class="comment">//返回np</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)np;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断元素是否在列表中"><a href="#判断元素是否在列表中" class="headerlink" title="判断元素是否在列表中"></a>判断元素是否在列表中</h4><p><strong>对于一个序列来说，可以使用in操作符，等价于调用其<code>__contains__</code>魔法方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_contains</span><span class="params">(PyListObject *a, PyObject *el)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">	<span class="comment">//挨个循环，比较是否相等。存在cmp会等于1，cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)不满足，直接返回</span></span><br><span class="line">    <span class="comment">//不相等则为0, 会一直比完列表中所有的元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, cmp = <span class="number">0</span> ; cmp == <span class="number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i) &#123;</span><br><span class="line">        item = PyList_GET_ITEM(a, i);</span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        cmp = PyObject_RichCompareBool(el, item, Py_EQ);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真的非常简单，没有什么好说的。</strong></p>
<h4 id="列表的深浅拷贝"><a href="#列表的深浅拷贝" class="headerlink" title="列表的深浅拷贝"></a>列表的深浅拷贝</h4><p><strong>列表的深浅拷贝也是初学者容易犯的错误之一，我们看一个Python的例子。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是浅拷贝, 这个过程会创建一个新列表, 会将里面的指针拷贝一份</span></span><br><span class="line"><span class="comment"># 但是指针指向的内存并没有拷贝</span></span><br><span class="line">lst_cp = lst.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个对象的地址是一样的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]), <span class="built_in">id</span>(lst_cp[<span class="number">0</span>]))  <span class="comment"># 2207105155392 2207105155392</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst[0], 会改变lst_cp[0]</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123]] [[123]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst_cp[0], 会改变lst[0]</span></span><br><span class="line">lst_cp[<span class="number">0</span>].append(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123, 456]] [[123, 456]]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们通过索引或者切片也是一样的道理</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">val = lst[<span class="number">0</span>]</span><br><span class="line">lst_cp = lst[<span class="number">0</span>: <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> val <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 此外，lst[:]完全等价于lst.copy()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>之所以会有这样现象，是因为我们说过Python中变量、容器里面的元素都是一个泛型指针PyObject *，在传递的时候会传递指针， 但是在操作的时候会操作指针指向的内存。</strong></p>
<p><strong>所以lst.copy()就是创建了一个新列表，然后把元素拷贝了过去，并且这里的元素是指针。因为只是拷贝指针，没有拷贝指针指向的对象<code>(内存)</code>，所以它们的地址都是一样的，因为指向的是同一个对象。</strong></p>
</blockquote>
<p><strong>但如果我们就想在拷贝指针的同时也拷贝指针指向的对象呢？答案是使用一个叫copy的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[]]</span><br><span class="line"><span class="comment"># 此时拷贝的时候，就会把指针指向的对象也给拷贝一份</span></span><br><span class="line">lst_cp1 = copy.deepcopy(lst)</span><br><span class="line">lst_cp2 = lst[:]</span><br><span class="line"></span><br><span class="line">lst_cp2[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[123]]</span></span><br><span class="line"><span class="built_in">print</span>(lst_cp1)  <span class="comment"># [[]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lst[:]这种方式也是浅拷贝, 所以修改lst_cp2[0], 也会影响lst[0]</span></span><br><span class="line"><span class="comment"># 但是没有影响lst_cp1[0], 证明它们是相互独立的, 因为指向的是不同的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040208452-2140599376.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是一样的</strong></p>
<p><strong>深拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040216408-1830378933.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是不一样的</strong></p>
<p><strong>注意：copy.deepcopy虽然在拷贝指针的同时会将指针指向的对象也拷贝一份，但这仅仅是针对于可变对象，对于不可变对象是不会拷贝的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[], <span class="string">&quot;古明地觉&quot;</span>]</span><br><span class="line">lst_cp = copy.deepcopy(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>] <span class="keyword">is</span> lst_cp[<span class="number">1</span>])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会这样，其实原因很简单。因为不可变对象是不支持本地修改的，你若想修改只能指向新的对象，但是对其它的变量则没有影响，其它变量该指向谁就还指向谁。因为a &#x3D;  b只是将对象的指针拷贝一份给a，然后a和b都指向了同一个对象，至于a和b本身则是没有任何关系的。如果此时b指向了新的对象，是完全不会影响a的，a还是指向原来的对象。所以如果一个指针指向的对象不支持本地修改，那么深拷贝不会拷贝对象本身，因为指向的是不可变对象，所以不会有修改一个影响另一个的情况出现。</strong></p>
<p><strong>关于列表还有一些陷阱：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [[]] * <span class="number">5</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [1], [1], [1], [1]]</span></span><br><span class="line"><span class="comment"># 列表乘上一个n，等于把列表里面的元素重复n次</span></span><br><span class="line"><span class="comment"># 注意: 类似于lst = [1, 2, 3], 虽然我们写的是整数，但是它存储的并不是整数，而是其指针</span></span><br><span class="line"><span class="comment"># 所以会把指针重复5次, 因此列表里面5个指针都指向了同一个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式创建的话，里面的元素都指向了不同的列表</span></span><br><span class="line">lst = [[], [], [], [], []]</span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [], [], [], []]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再比如字典，在后续系列中会说</span></span><br><span class="line">d = <span class="built_in">dict</span>.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [])</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [], 2: [], 3: [], 4: []&#125;</span></span><br><span class="line">d[<span class="number">1</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [123], 2: [123], 3: [123], 4: [123]&#125;</span></span><br><span class="line"><span class="comment"># 它们都指向了同一个列表，因此这种陷阱在工作中要注意, 因为一不小心就会出现大问题</span></span><br></pre></td></tr></table></figure>

<h3 id="创建PyListObject"><a href="#创建PyListObject" class="headerlink" title="创建PyListObject"></a>创建PyListObject</h3><p><strong>我们说创建一个列表，Python底层只提供了唯一一个Python&#x2F;C API，也就是PyList_New。这个函数接收一个size参数，从而允许我们在创建一个PyListObject对象时指定底层数组的长度。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyList_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个PyListObject *对象</span></span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size小于0，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存池是否可用，如果可用</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        <span class="comment">//将缓存池内对象个数减1</span></span><br><span class="line">        numfree--;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        <span class="comment">//设置引用计数</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不可用的时候，申请内存</span></span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size小于等于0，ob_item设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，创建一个指定容量的指针数组，然后让ob_item指向它</span></span><br><span class="line">        <span class="comment">//所以是先创建PyListObject对象, 然后创建底层数组, 最后通过ob_item建立联系</span></span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size和allocated，然后返回op</span></span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到源码里面有一个缓冲池，是的，创建PyListObject对象时，会先检测缓冲池free_lists里面是否有可用的对象，有的话直接拿来用，否则通过malloc在系统堆上申请。缓冲池中最多维护80个PyListObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Empty list reuse scheme to save calls to malloc and free */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyList_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyListObject *free_list[PyList_MAXFREELIST];</span><br></pre></td></tr></table></figure>

<p><strong>根据之前的经验我们知道，既然能从缓存池中获取，那么在执行析构函数的时候也要把列表放到缓存池里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_dealloc</span><span class="params">(PyListObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="comment">//将底层数组中每个指针指向的对象的引用计数都减去1</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//然后释放底层数组所占的内存</span></span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断缓冲池里面PyListObject对象的个数，如果没满，就添加到缓存池</span></span><br><span class="line">    <span class="comment">//注意：我们看到执行到这一步的时候, 底层数组已经被释放掉了</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则的话再释放掉PyListObject对象所占的内存</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道在创建一个新的PyListObject对象时，实际上是分为两步的，先创建PyListObject对象，然后创建底层数组，最后让PyListObject对象中的ob_item成员指向这个底层数组。同理，在销毁一个PyListObject对象时，先销毁ob_item维护的底层数组，然后再释放PyListObject对象自身<code>(如果缓存池已满的情况下)</code>。</strong></p>
<p><strong>现在可以很清晰地明白了，原本空荡荡的缓存池其实是被已经死去的PyListObject对象填充了，在以后创建新的PyListObject对象时，Python会首先唤醒这些死去的PyListObject对象，给它们一个洗心革面、重新做人的机会。但需要注意，这里缓存的仅仅是PyListObject对象，对于底层数组，其ob_item已经不再指向了。从list_dealloc中我们看到，PyListObject对象在放进缓存池之前，ob_item指向的数组就已经被释放掉了，同时数组中指针指向的对象的引用计数会减1。所以最终数组中这些指针指向的对象也大难临头各自飞了，或生存、或毁灭，总之此时和PyListObject之间已经没有任何联系了。但是为什么要这么做呢？为什么不连底层数组也一起维护呢？可以想一下，如果继续维护的话，数组中指针指向的对象永远不会被释放，那么很可能会产生悬空指针的问题，所以这些指针指向的对象所占的空间必须交还给系统<code>(前提是没有其它指针指向了)</code>。</strong></p>
<p><strong>但是实际上，是可以将PyListObject对象维护的底层数组进行保留的，即只将数组中指针指向的对象的引用计数减1，然后将数组中的指针都设置为NULL，不再指向之前的对象了，但是并不释放底层数组本身所占用的内存空间。因此这样一来，释放的内存不会交给系统堆，那么再次分配的时候，速度会快很多。但是这样带来一个问题，就是这些内存没人用也会一直占着，并且只能供PyListObject对象的ob_item指向的底层数组使用，因此Python还是为避免消耗过多内存，采取将底层数组的内存交换给了系统堆这样的做法，在时间和空间上选择了空间。</strong></p>
<h3 id="元组的底层结构–PyTupleObject"><a href="#元组的底层结构–PyTupleObject" class="headerlink" title="元组的底层结构–PyTupleObject"></a>元组的底层结构–PyTupleObject</h3><p><strong>因为元组比较简单，和列表比较相似，所以就放在一起介绍了。我们知道元组，就相当于不支持元素添加、修改、删除等操作的列表。</strong></p>
<p><strong>元组的实现机制非常简单，可以看做是在列表的基础上删除了<code>增删改</code>等操作。既然如此，那要元组有什么用呢？毕竟元组的功能只是列表的子集。元组存在的最大一个特点就是，它可以作为字典的key、以及可以作为集合的元素。因为字典和集合存储数据的原理是哈希表，字典和集合我们后续章节会说。对于列表这样的可变对象来说是可以动态改变的，而哈希值是一开始就计算好的，显然如果支持动态修改的话，那么哈希值肯定会变，这是不允许的。所以如果我们希望字典的key是一个序列，显然元组再适合不过了。</strong></p>
<p><strong>从tuple的特点也能看出：tuple的底层是一个变长对象，但同时也是一个不可变对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，对于不可变对象来说，它底层结构体定义也非常简单。一个引用计数、一个类型、一个指针数组。这里的1可以想象成n，我们在PyLongObject中说过。</strong></p>
<p><strong>并且我们发现不像列表，元组没有allocated，这是因为它是不可变的，不支持resize操作。至于维护的值，同样是指针组成的数组，数组里面的每一个指针都指向了具体的值。</strong></p>
<h4 id="PyTupleObject的创建"><a href="#PyTupleObject的创建" class="headerlink" title="PyTupleObject的创建"></a>PyTupleObject的创建</h4><p><strong>正如列表一样，Python创建PyTupleObject也提供了类似的初始化方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyTuple_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyTupleObject指针</span></span><br><span class="line">    PyTupleObject *op;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="comment">//元组同样有缓存池</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; free_list[<span class="number">0</span>]) &#123;</span><br><span class="line">        op = free_list[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        tuple_zero_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//如果长度为0，那么直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; PyTuple_MAXSAVESIZE &amp;&amp; (op = free_list[size]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        free_list[size] = (PyTupleObject *) op-&gt;ob_item[<span class="number">0</span>];</span><br><span class="line">        numfree[size]--;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        fast_tuple_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Inline PyObject_InitVar */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">        <span class="comment">//设置ob_size，和ob_type</span></span><br><span class="line">        Py_SIZE(op) = size;</span><br><span class="line">        Py_TYPE(op) = &amp;PyTuple_Type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//引用计数初始化为1</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 元组的元素个数同样有限制，但我们说这个限制一般达不到 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>)size &gt; ((<span class="type">size_t</span>)PY_SSIZE_T_MAX - <span class="keyword">sizeof</span>(PyTupleObject) -</span><br><span class="line">                    <span class="keyword">sizeof</span>(PyObject *)) / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">        op = PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, size);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        op-&gt;ob_item[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        free_list[<span class="number">0</span>] = op;</span><br><span class="line">        ++numfree[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);          <span class="comment">/* extra INCREF so that this is never freed */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_TRACK_COUNT</span></span><br><span class="line">    count_tracked++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject初始化类似，同样需要做一些类型检测，内存是否溢出等等。</strong></p>
<p><strong>当然有了列表的经验，元组的一些底层操作我们就不分析了，它是列表的子集。</strong></p>
<h4 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h4><p><strong>列表和元组两者在通过索引查找元素的时候是一致的，但是元组除了能作为字典的key之外，还有一个特点，就是分配的速度比较快。一方面是因为由于其不可变性，使得在编译的时候就确定了，另一方面就是它还具有静态资源缓存的作用。</strong></p>
<p><strong>对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python  就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。你可以理解为PyTupleObject对象在被析构时，不仅对象本身没有被回收，连底层的指针数组也被缓存起来了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = timeit(stmt=<span class="string">&quot;x1 = [1, 2, 3, 4, 5]&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line">t2 = timeit(stmt=<span class="string">&quot;x2 = (1, 2, 3, 4, 5)&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t1, <span class="number">2</span>))  <span class="comment"># 0.05</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t2, <span class="number">2</span>))  <span class="comment"># 0.01</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到用时，元组只是列表的五分之一。这便是元组的另一个优势，可以将资源缓存起来。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>09-字典和集合的底层实现</title>
    <url>/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="09-解密Python中字典和集合的底层实现，深度分析哈希表"><a href="#09-解密Python中字典和集合的底层实现，深度分析哈希表" class="headerlink" title="09-解密Python中字典和集合的底层实现，深度分析哈希表"></a>09-解密Python中字典和集合的底层实现，深度分析哈希表</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python的字典是一种映射型容器对象，保存了键(key)到值(value)的映射关系。通过字典，我们可以快速的实现值的查找，json这种数据结构也是借鉴了Python中的字典。而且字典在Python中是经过高度优化的，因为Python底层也在大量的使用字典这种数据结构。</strong></p>
<p><strong>那么这次我们就来全面分析一下Python中的字典。</strong></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>我们先来回顾一下字典的基本使用，然后再来分析它的一些特性以及底层实现。</strong></p>
<p><strong>创建一个字典：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者我们还可以通过dict, 传入关键字参数即可</span></span><br><span class="line">d = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然dict里面还可以接收位置参数, 但是最多接收一个</span></span><br><span class="line">d1 = <span class="built_in">dict</span>(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">d2 = <span class="built_in">dict</span>([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)], c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d2)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以根据已有字典创建新的字典</span></span><br><span class="line">d = &#123;**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然通过dict也是可以的, 但是注意: 通过**这种方式本质上是把字典变成多个关键字参数</span></span><br><span class="line"><span class="comment"># 所以里面的key一定要符合Python的变量规范</span></span><br><span class="line">d = <span class="built_in">dict</span>(**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这种是不合法的, 因为**&#123;1: 1&#125;等价于1=1</span></span><br><span class="line">    d = <span class="built_in">dict</span>(**&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># keywords must be strings</span></span><br><span class="line"><span class="comment"># 但是这种是合法的</span></span><br><span class="line">d = &#123;**&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>&#125;, **&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="string">&quot;嘿嘿&quot;</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 1, 2: 2, (1, 2, 3): &#x27;嘿嘿&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>字典支持的操作：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个空字典</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置键值对</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地觉&quot;</span></span><br><span class="line">d[<span class="string">&quot;where&quot;</span>] = <span class="string">&quot;东方地灵殿&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地觉&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新值, 字典里面的key是不重复的, 所以不会出现一个字典中有多个key的情况出现</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地恋&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地恋&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个值, 可以使用del或者pop</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">d.pop(<span class="string">&quot;where&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然字典支持的操作远不止上面那些，但是这些Python层面上的东西想必所有人都了如指掌了，因为字典支持的操作，仅仅相当于是一些API的调用罢了，对着文档查一遍、操作一波就完事了。我们重点是要分析字典这种数据结构在底层的实现方式，以及它背后的一些原理，这才是我们需要关注的。</strong></p>
<p><strong>首先字典的底层是借助哈希表实现的，什么是哈希表我们后面会详细说，总之字典的添加元素、删除元素、查找元素等操作的平均时间复杂度是O(1)。当然了，在哈希不均匀的情况下，最坏时间复杂度是O(n)，但是这种情况很少发生。</strong></p>
<p>​        <strong>我们来测试一下字典的执行效率，看看它和列表之间的区别。一个有1千万个键值对的字典。然后对两者使用in来查询某个元素是否存在,</strong>     </p>
<p>​        <strong>我们测试的方式是，使用if … in …来查询一个元素是否存在，看看它们的耗时如何。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">count: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param count: 循环次数</span></span><br><span class="line"><span class="string">    :param value: 查询的元素</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 有一千万个随机数的列表</span></span><br><span class="line">    lst = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">30</span>, size=<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># 根据这个列表构造出含有一千万个键值对的字典</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在列表中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> lst</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在字典中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> d</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字典查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别查询一千次、一万次、十万次、二十万次</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">3</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 0.13</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">4</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 1.22</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 12.68</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span> * <span class="number">2</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 25.72</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字典的查询速度非常快，从测试中我们看到，随着循环次数越来越多，列表所花费的总时间越来越长。但是字典由于查询所花费的时间极少，查询速度非常快，所以即便循环50万次，花费的总时间也不过才0.01秒左右。</strong></p>
<p><strong>此外字典还有一个特点，就是它的”快”不会受到数据量的影响，你从含有一万个键值对的字典中查找，和你从含有一千万个键值对的字典中查找，两者花费的时间几乎是没有区别的。</strong></p>
<p><strong>那么字典到底是使用了什么黑科技，才能达到这么快的效果呢？想要知道答案的话，那就从字典在底层的内部结构中寻找吧。</strong></p>
<h3 id="初识哈希表"><a href="#初识哈希表" class="headerlink" title="初识哈希表"></a>初识哈希表</h3><p>**由于映射型容器的使用场景非常广泛，几乎所有现代语言都支持映射型容器，而且特别关注”键”的搜索效率。例如：C++标准模板库中的 *map* 就是一种关联式容器，内部基于红黑树实现。红黑树是一种平衡二叉树，能够提供良好的操作效率，插入、删除、搜索等关键操作的时间复杂度均为*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>，Linux的epoll也是使用了红黑树。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20230329155658577-1680101009722.png" alt="image-20230329155658577"></p>
<p>**而对于Python来讲，映射型容器指的就是字典，我们说字典在Python内部是被高度优化的。因为不光我们在用，Python虚拟机在运行时也重度依赖字典，比如：自定义类、以及其实例对象都有自己的属性字典，还有名字空间本质上也是一个字典，因此Python对字典的要求会更加苛刻。所以Python在实现字典时采用的数据结构肯定是要优于红黑树的<code>(至少在添加、删除、查询元素等方面)</code>，也就是说它的时间复杂度是优于红黑树的。时间复杂度优于*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>的数据结构有哪些呢？没错，你应该已经猜到了，就是散列表、又称哈希表。</strong></p>
<p>​        <strong>所以在介绍字典之前，我们需要介绍一下哈希表。当然这里只是先大致介绍一下，能够一个宏观的认识，为了在理解字典时能够方便一些。至于更详细的内容，我们会在本文的后面介绍。</strong>    </p>
<p><strong>我们在介绍元组的时候，说元组可以作为字典的key，但是列表不可以，就是因为列表是不可哈希的。哈希表的原理是将key通过哈希函数进行运算转换为一个数值，用这个数值来充当索引，因此这就有一个前提，就是你的值不可以变。而列表是个可变对象，因此它不可以作为字典的key。</strong></p>
<p><strong>直接这么说的话，可能会感到很迷，我们画一张图。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164717645-250695028-1680101009725.png" alt="img"></p>
<p><strong>我们发现除了key、value之外，还有一个index。其实哈希表本质上也是使用了索引的思想，我们知道虽然列表在遍历的时候是个时间复杂度为O(n)的操作，但是通过索引定位元素则是一个时间复杂度为O(1)的操作，不管你列表有多长，通过索引总是能瞬间定位到指定元素。所以哈希表实际上也是使用了数组<code>(列表)</code>的思想，会把这个key通过哈希函数映射成一个数值，作为索引。至于它是怎么映射的，我们后面再谈，现在我们就假设是按照我们接下来说的方法映射的。</strong></p>
<p><strong>比如我们这里有一个能容纳10个元素的字典<code>(这里假设容量为10其实是不准确的,容量应该是2的n次方,但是这里只是介绍哈希表,所以不管了)</code>，我们先设置d[“satori”]&#x3D;82，那么会对”satori”这个字符串进行一个哈希运算，然后再对10、也就是和当前的总容量进行取模，这样的话是不是能够得到一个小于10的数呢？假设是5，那么就存在索引为5地方。然后又进行d[“koishi”]&#x3D;83，那么按照同样的规则运算得到8，那么就存在索引为8的位置，同理第三次设置d[“mashiro”]&#x3D;80，对mashiro进行哈希、取模，得到2，那么存储在索引为2的地方。</strong></p>
<p><strong>同理当我们根据键来获取值的时候，比如：d[“satori”]，那么同样会对字符串”satori”进行哈希、取模，得到索引发现是5，直接把索引为5的value给取出来。</strong></p>
<p><strong>当然这种方式肯定存在缺陷，比如：</strong></p>
<ul>
<li><code>不同的值进行哈希、取模运算之后得到的结果一定是不同的吗？</code></li>
<li><code>在运算之后得到索引的时候，发现这个位置已经有人占了怎么办？</code></li>
<li><code>取值的时候，索引为5，可如果索引为5对应的key和我们指定获取的key不一致怎么办？</code></li>
</ul>
<blockquote>
<p><strong>所以哈希值是有冲突的，如果一旦冲突，那么Python底层会改变策略重新映射，直到映射出来的索引没有人用。比如我们设置一个新的key、value，d[“tomoyo”]&#x3D;88，可是我们对”tomoyo”这个key进行映射之后得到的结果也是5，而索引为5的地方已经被key为”satori”的键给占了，那么Python就会改变规则来对”tomoyo”重新进行运算，找到一个空位置进行添加。但如果我们再次设置d[“satori”]&#x3D;100，那么对satori进行映射得到的结果也是5，而key是一致的，那么就会把对应的值进行修改。</strong></p>
<p><strong>同理，当我们获取值的时候，d[“tomoyo”]，对key进行映射，得到索引。但是发现key不是”tomoyo”而是”satori”，于是改变规则<code>(这个规则跟设置key冲突时，采用的规则是一样的)</code>，重新映射，得到索引，然后发现key是一致的，于是将值取出来。</strong></p>
<p><strong>但如果我们指定了一个不存在的key，那么哈希映射，找到对应索引，发现没有key，证明我们指定的key是不存在的。但如果有的话，发现key和我们指定的key不相等，说明哈希运算得到索引只是碰巧一样，但由于key不一样，因此会改变规则重新运算，得到新的索引。然而发现没有对应的key，于是报错：指定的key不存在。</strong></p>
</blockquote>
<p><strong>所以从这里就已经能说明问题了，就是把key转换成类似列表的索引。可能有人问，这些值貌似不是连续的啊，对的，肯定不是连续的。并不是说你先存，你的索引就小、就在前面，这是由key进行哈希运算之后的结果决定的。而且容量有10个，目前我们只存了4个元素，那么哈希表、或者说字典会不会扩容呢？当然，既然是可变对象，当然会扩容。并且它还不是像列表那样，容量不够才扩容，而当元素个数达到容量的三分之二的时候就会扩容。</strong></p>
<p><strong>我们可以认为字典底层还是使用了索引的思想，字典不可能会像列表那样，元素之间是连续的，一个一个挨在一起的。既然是哈希运算，得到的值肯定是随机的。容量为10，尽管有6个是空着的，但是没关系，我们只要保证设置的元素整体上是有序的即可。就好比有10张桌椅，小红坐在第3张，小明坐在第8张，尽管有空着的，但是没关系，就让它空着。只要我到第3张桌椅能够找到小红、第8张可以找到小明即可。这些桌椅的位置就可以看成是索引，只要我通过索引能够找到对应的元素即可。但是容量为10，为什么不能全部占满之后再扩容呢？试想一下，既然是随机的，那么肯定会出现哈希值碰撞，并且当元素个数到达三分之二之后，这种碰撞的概率非常大。因此当容量到达三分之二的时候，就会申请一份更大的空间，以便来容纳新的元素。</strong></p>
<p><strong>所以我们发现哈希表实际上就是一种空间换时间的方法，如果容量为100，那么就相当于有100个位置，每个元素都进行哈希映射，找到自己的位置。各自的位置都是不固定的，也许会空出来很多元素，但是无所谓，只要保证这些元素在100个位置上是相对有序、通过哈希运算得到索引之后，可以在相应的位置找到它即可。</strong></p>
<p><strong>所以相信应该所有人都能明白为什么哈希表的时间复杂度是O(1)了，就是因为使用了索引的思想，每一个索引都是连续的，只不过一部分索引没有相应的key、value罢了。但这无所谓，因为索引和key、value是一一对应的，通过索引我们能瞬间定位到指定的key，再来检测key是否存在以及和我们指定的key是否一致。如果不存在，那么不好意思，证明这个地方根本没有key、value，说明我们指定了一个不存在的key。而且由于元素个数达到容量的三分之二的时候，碰撞的概率非常大，因此几乎不可能出现容量正好都排满的情况，否则那要改变规则、重复映射多少次啊。</strong></p>
<p>​        <strong>一句话总结：哈希表就是一种空间换时间的方法</strong>    </p>
<p><strong>设置键值对如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164728024-1124533030-1680101009725.png" alt="img"></p>
<p><strong>根据键获取值，如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164734209-960036321-1680101009725.png" alt="img"></p>
<h3 id="字典的底层结构–PyDictObject"><a href="#字典的底层结构–PyDictObject" class="headerlink" title="字典的底层结构–PyDictObject"></a>字典的底层结构–PyDictObject</h3><p><strong>下面我们来看看字典在底层对应的结构体PyDictObject，位于Include&#x2F;dictobject.h中，它的实现还是很复杂的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里是PyObject_HEAD,不是PyObject_VAR_HEAD</span></span><br><span class="line">    <span class="comment">//PyObject_HEAD只有引用计数和类型，没有ob_size</span></span><br><span class="line">    <span class="comment">//但字典显然是一个变长对象，因此肯定有别的成员来维护字典的长度, 当然字典也有容量</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典里面键值对的个数</span></span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典版本：全局唯一，每一次value的变动，都会导致其改变</span></span><br><span class="line">    <span class="type">uint64_t</span> ma_version_tag;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ma_keys从定义上来看，它是一个指针, 指向了一个PyDictKeysObject对象</span></span><br><span class="line">    <span class="comment">//事实上在底层哈希表分为两种，分别是：combined table(结合表)和split table(分离表)</span></span><br><span class="line">    <span class="comment">//如果是结合表，那么键值对存在ma_keys里面，此时下面的ma_values为NULL</span></span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是分离表，那么&quot;键&quot;存在ma_keys里，&quot;value&quot;存在ma_values里</span></span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们下面介绍的是常用的结合表</span></span><br></pre></td></tr></table></figure>

<p><strong>所以名字起得很形象，结合表的话，键和值就存在一起；分离表的话，键和值就存在不同的地方。至于为什么这么做，后面会解释。</strong></p>
<p><strong>整个结构体实际上是看不出来啥的，主要的原因就在那个PyDictKeysObject，我们需要再来看看它长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们看到这是给struct _dictkeysobject起了一个别名，所以真正要看的是_dictkeysobject</span></span><br><span class="line"><span class="comment">//它位于Objects/dict-common.h中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> <span class="title">PyDictKeysObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> &#123;</span></span><br><span class="line">    <span class="comment">//引用计数，跟映射视图的实现有关，类似于对象的引用计数</span></span><br><span class="line">    Py_ssize_t dk_refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表大小，比如是2的n次方，这样可将模运算优化成按位与运算</span></span><br><span class="line">    <span class="comment">//所以我们在上面介绍哈希表的时候，假设字典能容纳10个元素，这个假设是不准确的，不过无所谓啦</span></span><br><span class="line">    Py_ssize_t dk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function to lookup in the hash table (dk_indices):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict(): general-purpose, and may return DKIX_ERROR if (and</span></span><br><span class="line"><span class="comment">         only if) a comparison raises an exception.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode(): specialized to Unicode string keys, comparison of</span></span><br><span class="line"><span class="comment">         which can never raise an exception; that function can never return</span></span><br><span class="line"><span class="comment">         DKIX_ERROR.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further</span></span><br><span class="line"><span class="comment">         specialized for Unicode string keys that cannot be the &lt;dummy&gt; value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_split(): Version of lookdict() for split tables. */</span></span><br><span class="line">    <span class="comment">//哈希查找函数的指针，从注释上我们看到有好几种，会根据字典的当前状态选用最优的版本</span></span><br><span class="line">    dict_lookup_func dk_lookup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中可用的entry数量，这个entry你可以理解为键值对，一个entry就是一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表是有容量的，所以这个dk_usable就表示当前的容量还能容纳多个entry</span></span><br><span class="line">    Py_ssize_t dk_usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中已经使用的entry数量</span></span><br><span class="line">    Py_ssize_t dk_nentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries,</span></span><br><span class="line"><span class="comment">       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The size in bytes of an indice depends on dk_size:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - 1 byte if dk_size &lt;= 0xff (char*)</span></span><br><span class="line"><span class="comment">       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)</span></span><br><span class="line"><span class="comment">       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)</span></span><br><span class="line"><span class="comment">       - 8 bytes otherwise (int64_t*)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span><br><span class="line">    <span class="comment">//哈希表 起始地址 ，哈希表后紧接着 键值对数组 dk_entries 。</span></span><br><span class="line">    <span class="type">char</span> dk_indices[];  <span class="comment">/* char is required to avoid strict aliasing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;PyDictKeyEntry dk_entries[dk_usable];&quot; array follows:</span></span><br><span class="line"><span class="comment">       see the DK_ENTRIES() macro */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>而我们说一个键值对在底层对应一个entry，而这个entry指的就是PyDictKeyEntry对象，我们看看这个结构体长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Cached hash code of me_key. */</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value; <span class="comment">/* This field is only meaningful for combined tables */</span></span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>显然ma_key和ma_value就是键和值，我们之前说Python中变量、以及容器内部的元素都是泛型指针PyObject  *，其中也包括字典，这里也得到了证明。但是我们看到entry除了有键和值之外，还有一个me_hash，它表示键对应的哈希值，这样可以避免重复计算。</strong></p>
<p><strong>至此，字典的整个底层结构就非常清晰了。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814180611353-1782148743-1680101009725.png" alt="img"></p>
<p><strong>字典的真正实现藏在PyDictKeysObject中，它的内部包含两个关键数组：一个是<strong><strong>哈希索引数组dk_indices</strong></strong>，另一个是<strong><strong>键值对数组dk_entries</strong></strong>。字典所维护的键值对<code>(entry)</code>按照先来后到的顺序保存在键值对数组中，而哈希索引数组则保存”键值对”在”键值对数组”中的索引。另外，哈希索引数组中的一个位置我们称之为一个”槽”，比如图中的哈希索引数组便有8个槽，它字典的数量是相等的。</strong></p>
<p><strong>比如我们往空字典<code>(但是容量已经有了, 初始是8个, 不过可用的数量为5个)</code>中插入键值对<code>&quot;夏色祭&quot;: &quot;お娘&quot;</code>的时候，Python会执行以下步骤：</strong></p>
<ul>
<li><code>1. 将键值对保存在dk_entries中，由于初始字典是空的，所以会保存在dk_entries数组中索引为0的位置</code></li>
<li><code>2. 通过哈希函数将键&quot;夏色祭&quot;映射成一个数值，作为索引，假设是5</code></li>
<li><code>3. 将插入的键值对在数组中的索引0，保存在哈希索引数组中索引为5的槽中</code></li>
</ul>
<p><strong>然后当我们在查找键”夏色祭”对应的值的时候，便可瞬间定位。过程如下：</strong></p>
<ul>
<li><code>1. 通过哈希函数将键&quot;夏色祭&quot;映射成数值，也就是索引。因为在设置的时候索引是5，所以在获取的时候映射出来的索引肯定也是5</code></li>
<li><code>2. 找到哈希索引数组中索引为5的槽，得到其保存的0，这里的0对应键值对数组的索引</code></li>
<li><code>3. 找到键值对数组中索引为0的位置，取出PyDictKeyEntry中的me_value，也就是值(当然肯定要先比较key、也就是me_key是否一致, 不一致则重新映射。当然如果该位置为NULL, 那么直接报出KeyError)</code></li>
</ul>
<p><strong>由于<strong><strong>哈希值计算</strong></strong>以及<strong><strong>数组定位</strong></strong>均是O(1)的时间复杂度，所以字典的查询速度才会这么快。当然我们上面没有涉及到哈希冲突，关于哈希冲突我们会在后面详细说，但是就字典在存储和获取的时候就是上面那个流程。</strong></p>
<blockquote>
<p><strong>当然我们在上面的”初识哈希表”这一部分，为了避免牵扯太多，所以说的相对简化了。比如：”mashiro”:  80，我们说”mashiro”映射出来的索引是2，那么键值对就直接存在索引为2的地方。这实际上是简化了，因为这相当于把”哈希索引数组”和”键值对数组”合在一块了。而在早期的Python中，它也确实是这么做的。</strong></p>
<p><strong>但是从上面字典的结构图中我们看到，实际上是先将”键值对”按照先来后到的顺序存在一个数组<code>(键值对数组)</code>中，然后再把其索引存放在另一个数组<code>(哈希索引数组)</code>中索引为2<code>(&quot;mashiro&quot;映射出来的索引是2)</code>的地方。所以在查找的时候，映射出来的索引2其实是哈希索引数组对应的索引。然后对应的槽也存储了一个索引，这个索引是键值对数组对应的索引，假设是4，所以会再根据索引4从键值对数组中获取指定的PyDictKeyEntry对象，再根据该对象获取指定的value。</strong></p>
<p><strong>所以可以看出两者整体思想是基本类似的，理解起来没有什么区别，甚至第一种方式实现起来还会更简单一些。但为什么采用后者这种实现方式，以及这两者之间的区别，我们在后面还会专门分析，之所以采用后者主要是基于内存的考量。</strong></p>
</blockquote>
<h4 id="容量策略"><a href="#容量策略" class="headerlink" title="容量策略"></a>容量策略</h4><p><strong>根据字典的行为我们断定，字典肯定和列表一样有着”预分配机制”。因为可以扩容，那么为了避免频繁申请内存，所以在扩容的是时候会将容量申请的比键值对个数要多一些。那么字典的容量策略是怎么样的呢？</strong></p>
<p><strong>在Object&#x2F;dictobject.c源文件中我们可以看到一个宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MINSIZE 8</span></span><br></pre></td></tr></table></figure>

<p><strong>从这个宏定义中我们可以得知，一个字典的最小容量是8，或者说内部哈希表的长度最小是8。</strong></p>
<p>​        <strong>哈希表越密集，哈希冲突则越频繁，性能也就越差。因此，哈希表必须是一种 稀疏 的表结构，越稀疏则性能越好。但由于  “内存开销”  的制约，哈希表不可能无限地稀疏，所以需要在时间和空间上进行权衡。实践经验表明，一个1&#x2F;2到2&#x2F;3满的哈希表，性能较为理想——以相对合理的  “内存” 换取相对高效的 “执行性能”。</strong>    </p>
<p>​        <strong>为保证哈希表的稀疏程度，进而控制哈希冲突频率， Python 通过 宏USABLE_FRACTION  将哈希表内元素控制在2&#x2F;3以内。宏USABLE_FRACTION 根据哈希表规模n，计算哈希表可存储元素的个数，也就是 键值对数组  的长度。以长度为 8 的哈希表为例，最多可以保持 5 个键值对，超出则需要扩容。</strong>    </p>
<p><strong>而USABLE_FRACTION 是一个非常重要的宏定义，位于源文件 *Objects&#x2F;dictobject.c* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span><br></pre></td></tr></table></figure>

<p><strong>哈希表规模一定是2的n次方，也就是说 *Python* 采用”翻倍扩容”的策略。例如，长度为 *8* 的哈希表扩容后，长度变为 *16* 。</strong></p>
<p><strong>最后，我们来考察一个空字典所占用的内存空间。*Python* 为空字典分配了一个长度为 *8* 的哈希表，因而也要占用相当多的内存，主要有以下几个部分组成：</strong></p>
<ul>
<li><code>PyDictObject中有6个成员，一个8字节，加起来共48字节</code></li>
<li><code>PyDictKeysObject中有7个成员，除了两个数组之外，剩余的每个成员也是一个8字节，所以加起来40字节</code></li>
<li><code>而剩余的两个数组，一个是char类型的数组dk_indices，里面1个元素占1字节；还有一个PyDictKeyEntry类型的数组dk_entries，里面一个元素占24字节，因为PyDictKeyEntry里面有三个成员，一个8字节。但是注意：字典容量为8，说明哈希索引数组长度为8，但是键值对数组dk_entries长度是5，至于原因我们上面分析的很透彻了。因此这两个数组加起来总共是 8 + 24 * 5 = 128字节</code></li>
</ul>
<p><strong>所以一个空字典占用的内存是：48 + 40 + 128 &#x3D; 216字节，我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">216</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是注意：我们说空字典容量为8，但前提它不是通过Python&#x2F;C API创建的，如果是d &#x3D; {}这种方式，那么初始容量就是0，显然此时只有48字节，因为ma_keys此时是NULL。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">48</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>另外，我们看到在计算内存的时候使用的不是sys.getsizeof，而是对象的__sizeof__方法，这两者有什么区别呢？答案是使用sys.getsizeof计算出来内存大小会比调用对象的__sizeof__方法计算出来的内存大小多出16个字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="built_in">dict</span>()), <span class="built_in">dict</span>().__sizeof__()</span><br><span class="line">(<span class="number">232</span>, <span class="number">216</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(&#123;&#125;), &#123;&#125;.__sizeof__()</span><br><span class="line">(<span class="number">64</span>, <span class="number">48</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>之所以会出现这种情况，是因为sys.getsizeof将垃圾回收器的开销也考虑进去了。</strong></p>
<blockquote>
<p><strong>我们说Python底层是通过引用计数来判断对象是否被回收，但是引用计数有一个致命缺陷就是它无法解决循环引用的问题，所以Python内部的gc就是专门用来解决循环引用的。如果创建了一个可能会发生循环引用的对象，那么Python会将该对象挂在链表上，当然链表总共有三条，分别是零代链表、一代链表、二代链表。</strong></p>
<p><strong>先将对象挂在零代链表上，Python的gc一旦发动，那么会采用三色标记模型来对零代链表上的对象进行标记–清除，将那些发生了循环引用的对象的引用计数减一。</strong></p>
<p><strong>而这样的链表为什么有三条呢？试想一下，gc发动的成本也是很高的，如果在gc的洗礼下还能活下来的对象，说明其暂时是较稳的，没有必要每次都对其进行检测。所以会将零代链表中比较稳定的对象移动到一代链表中，同理二代链表也是同理。当清理零代链表达到10次的时候，会清理一次一代链表，清理一代链表达到10次的时候会清理一次二代链表。这样的技术在Python中也被成为分代技术。</strong></p>
</blockquote>
<p><strong>而移动到链表中的对象，除了 PyObject 之外还会有一个额外的 PyGC_Head，所以 sys.getsizeof 计算结果多出的16字节，就是这个 PyGC_Head 所占的大小（在后续介绍GC的时候会说）。</strong></p>
<p><strong>但是整型、浮点型、字符串等等，它们使用sys.getsizeof和调用__sizeof__计算出来的结果是一样的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="number">123</span>), (<span class="number">123</span>).__sizeof__()</span><br><span class="line">(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="string">&quot;matsuri&quot;</span>), <span class="string">&quot;matsuri&quot;</span>.__sizeof__()</span><br><span class="line">(<span class="number">56</span>, <span class="number">56</span>)</span><br></pre></td></tr></table></figure>

<p><strong>至于为什么一样，想必你已经猜到了，因为整型、字符串这种对象是不可能发生循环引用的，只有容器对象才会有可能发生循环引用。我们说Python中的gc是专门针对可能发生循环引用的对象的，对于不会发生循环引用的对象来说，不会参与gc，一个引用计数足够了，所以它们使用两种方式计算出的结果是一样的。</strong></p>
<blockquote>
<p><strong>关于垃圾回收，是一门很复杂的学问，我们这里简单提一下。在该系列的后续，我们会详细的探讨Python中的垃圾回收。</strong></p>
</blockquote>
<h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><p><strong>我们说在Python早期，哈希表并没有分成两个数组实现，而是由一个键值对数组实现，这个数组也承担哈希索引的角色：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164757642-1115745631-1680101009725.png" alt="img"></p>
<p><strong>我们看到这种结构不正是我们在介绍哈希表的时候说的吗？一个键值对数组既用来存储，又用来充当索引，无需分成两个步骤，而且这种方式也似乎更简单、更直观。而我们说Python在早期确实是通过这种方式实现的哈希表，只是这种实现方式有一个弊端，就是太耗费内存了。</strong></p>
<p><strong>我们说哈希表必须保持一定程度的稀疏，最多只有2&#x2F;3满，这意味着至少要浪费1&#x2F;3的空间。</strong></p>
<p><em><em>所以Python为了尽量节省内存，将键值对数组压缩到原来的2&#x2F;3，只用来存储，而对key进行映射得到的索引由另一个数组<code>(哈希索引数组)</code>来存储。因为键值对数组里面一个元素要占用24字节，而哈希索引数组在容量不超过256的时候，里面一个元素只占一个字节；容量不超过65536的时候，里面一个元素只占两个字节，其它以此类推。由于哈希索引数组里面的元素大小比键值对数组里面的元素大小要小很多，所以将哈希表分成两个数组<code>(避免键值对数组的浪费)</code>来实现会更加的节省内存。我们可以举个栗子计算一下，假设我们容量是2 *</em> 16 &#x3D; 65536的哈希表。</em>*</p>
<p><strong>如果是通过第一种方式，只用一个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span></span><br><span class="line"><span class="number">1572864</span>  <span class="comment"># 总共需要这么多字节来存储</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> // <span class="number">3</span></span><br><span class="line"><span class="number">524288</span>  <span class="comment"># 除以3, 会浪费这么多字节</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果是通过第二种方式，使用两个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> * <span class="number">2</span> / <span class="number">3</span> + <span class="number">2</span> ** <span class="number">16</span> * <span class="number">2</span></span><br><span class="line"><span class="number">1179648</span>  <span class="comment"># 容量虽然是2 ** 16次方, 但是键值对数组是容量的2 / 3, 然后加上哈希索引数组的大小</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以一个数组存储比两个数组存储要多用393216字节的内存，因此Python选择使用两个数组来进行存储。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>我们通过考察字典的搜索效率，并深入源码研究其内部哈希表的实现，得到以下结论：</strong></p>
<ul>
<li><code>字典是一种高效的映射式容器，每秒完成高达 *200* 多万次搜索操作；</code></li>
<li><code>字典内部由哈希表实现，哈希表的稀疏特性意味着昂贵的内存开销；</code></li>
<li><code>为优化内存使用，Python将哈希表分为 哈希索引数组 和 键值对数组，也就是通过两个数组来实现；</code></li>
<li><code>哈希表在 1/2 到 2/3 满时，性能较为理想，较好地平衡了 内存开销 与 搜索效率；</code></li>
</ul>
<h3 id="深入哈希表"><a href="#深入哈希表" class="headerlink" title="深入哈希表"></a>深入哈希表</h3><p><strong>通过字典的底层实现，我们找到字典快速、高效的秘密–哈希表。对于映射式容器，一般是通过平衡搜索树或哈希表实现。而Python的字典选用了哈希表，主要是考虑到在搜索方面哈希表的效率更高。因为我们说Python底层重度依赖字典，所以对字典在搜索、设置元素方面的性能，要求的更加苛刻。</strong></p>
<p><strong>但是由于哈希表的稀疏特性，导致其会有巨大的内存牺牲，而为了优化，Python别出心裁的将哈希表分成两部分来实现，分别是：哈希索引数组和键值对数组。</strong></p>
<p><strong>但是显然这当中还有很多细节我们没有说，比如：哈希函数到底是怎么将一个键映射成索引的？哈希冲突了怎么办？哈希攻击又是什么？以及删除操作<code>(没有表面想的那么简单)</code>如何实现？而下面我们就来攻破这些难题，深入理解哈希表。</strong></p>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p><strong>Python内置函数hash会返回对象的哈希值，哈希表依赖于哈希值。</strong></p>
<p><strong>而根据哈希表的性质，我们知道键对象必须满足以下两个条件，否则哈希表便无法正常工作。</strong></p>
<ul>
<li><code>1. 哈希值在对象的整个生命周期内不可以改变</code></li>
<li><code>2. 可比较，如果两个对象相等(使用==操作符结果为True)，那么它们的哈希值一定相同</code></li>
</ul>
<p><strong>满足这两个条件的对象便是”可哈希(hashable)”对象，只有可哈希对象才可以作为哈希表的键<code>(key)</code>。因此像字典、集合等底层由哈希表实现的对象，其元素必须是可哈希对象。</strong></p>
<p><strong>Python中内置的不可变对象都是可哈希对象，比如：整数、浮点数、字符串、元组<code>(元组里面也要是不可变对象)</code>等等，而像可变对象，比如列表、字典等等便不可作为哈希表的键。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&quot;xxx&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;  <span class="comment"># 键是可哈希的就行，值是否可哈希则没有要求</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&#x27;xxx&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;[]: <span class="number">123</span>&#125;  <span class="comment"># 列表是可变对象，因为无法哈希</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;  <span class="comment"># 元组也是可哈希的</span></span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, []): <span class="number">123</span>&#125;  <span class="comment"># 但如果元组里面包含了不可哈希的对象，那么整体也会变成不可哈希对象</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而我们自定义的类的实例对象也是可哈希的，且哈希值是通过对象的地址计算得到的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 141215868971 141215869022</span></span><br></pre></td></tr></table></figure>

<p><strong>而且Python也支持我们重写哈希函数，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 123 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;&lt;__main__.A object at 0x000002A2842282B0&gt;: 1, &lt;__main__.A object at 0x000002A2842285E0&gt;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>并且我们看到虽然哈希值一样，但是在作为字典的键的时候，如果发生了冲突，会改变规则。注意：我们自定义的类的实例对象默认都是可哈希的，但如果类里面重写了__eq__方法，且没有重写__hash__方法的话，那么这个类的实例对象就不可哈希了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unhashable type: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么会有这种现象呢？首先我们说在没有重写__hash__方法的时候，哈希值默认是根据对象的地址计算得到的。而且对象如果相等<code>(使用==操作符会得到True)</code>，那么哈希值一定是一样的。但是我们重写了__eq__，相当于控制了&#x3D;&#x3D;操作符的比较结果，两个对象是否相等就是由我们来控制了，可哈希值却还是根据地址计算得到的。两个对象地址不同，哈希值不同，但是对象却可以相等、又可以不相等，这就导致了矛盾。因此在重写了__eq__、但是没有重写__hash__的情况下，其实例对象便不可哈希了。</strong></p>
<p><strong>但如果重写了__hash__，那么哈希值计算方式就不再通过地址计算了，因此此时是可以哈希的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)  <span class="comment"># &#123;&lt;__main__.A object at 0x000001CEC8D682B0&gt;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时我们看到字典里面只有一个元素了，因为我们说重写了__hash__方法之后，计算得到哈希值都是一样的</span></span><br><span class="line"><span class="string">但是在没有重写__eq__的情况下，默认都是不相等的。如果哈希值一样，但是对象不相等，所以会重新映射。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而我们重写了__eq__，返回的结果是True，所以Python认为对象是相等的，由于key的不重复性，保留了后面的键值对</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>同样的，我们再来看一个Python中字典的例子</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>: <span class="number">123</span>&#125;</span><br><span class="line"></span><br><span class="line">d[<span class="number">1.0</span>] = <span class="number">234</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 234&#125;</span></span><br><span class="line"></span><br><span class="line">d[<span class="literal">True</span>] = <span class="number">345</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 345&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>天哪，这是咋回事？因为整数在计算哈希的时候，得到结果就是其本身；而浮点数显然不是，但如果浮点数的小数点后面只有一个0，那么它和整数是等价的。因此两者的哈希值一样，而3和3.0在Python中也是相等的，因此它们视为同一个key，所以相当于是替换。同理True也是一样，我们说它bool继承自int，所以它等价于1，比如：9 + True &#x3D; 10，因为True的哈希值和1也是一样的，而且也是相等的，索引d[True] &#x3D; 345也是更新。</strong></p>
<blockquote>
<p><strong>但是问题来了，值更新了我们可以理解，字典里面只有一个元素也可以理解，但是为什么key一直是1呢？理论上最终结果应该是True才对啊。</strong></p>
<p><strong>其实这算是Python偷了个懒吧<code>(开个玩笑)</code>，因为key的哈希值是一样的，并且也相等，所以Python不会对key进行替换。从字典在设置元素的时候我们也知道，如果对key映射成索引之后发现哈希索引数组的此位置没有人用，那么就按照先来后到的顺序将”键值对”存在键值对数组中，再将其索引存在哈希索引数组的指定的槽中；如果有人用了，但是对应的key不想等，则重新映射找一个新位置；如果有人用了、并且相等，则说明是同一个key，那么把value换掉即可。所以在替换元素的整个过程中，根本没有涉及到对键的修改，因此上面那个例子的最终结果，value会变、但键依旧是1，而不是True。</strong></p>
</blockquote>
<p><strong>理想的哈希函数必须保证哈希值尽量均匀地分布于整个哈希空间中，越是相近的值，其哈希值差别应该越大。</strong></p>
<blockquote>
<p><strong>所以一个好的哈希函数对实现哈希表起到至关重要的作用。</strong></p>
</blockquote>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p><strong>一方面，不同的对象，哈希值有可能相同，另一方面，与哈希值空间相比，哈希表的槽位是非常有限的。因此，存在多个键被映射到哈希索引的同一槽位的可能性，这便是<strong><strong>索引冲突</strong></strong>。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164807998-1827451738-1680101009725.png" alt="img"></p>
<p><strong>解决哈希冲突的常用方法有两种：</strong></p>
<ul>
<li><code>分离链接法(separate chaining)</code></li>
<li><code>开放寻址法(open addressing)</code></li>
</ul>
<p><strong>Python采用的便是开放寻址法。</strong></p>
<h5 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h5><p><strong>“分离链接法”为每个哈希槽维护一个链表，所有哈希到同一槽位的键保存到对应的链表中：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164818019-995843865-1680101009725.png" alt="img"></p>
<p><strong>如上图所示，哈希索引数组的每一个槽都连接着一个链表，初始状态为空，哈希表某个槽位对应的”键”则保存在对应的链表中。例如：key1和key3都哈希到下标为3的槽位，依次保存在对应的链表中；key2被哈希到下标为1的槽位。</strong></p>
<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p><strong>Python依旧是将key映射成索引存在哈希索引数组的槽中，如果发现槽被占了，那么就尝试另一个。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164825466-1426145061-1680101009725.png" alt="img"></p>
<p>*<em>key3被哈希到槽位为3的时候，发现这个坑被key1给占了，所以只能重新找个坑了。但是为什么找到5呢？显然在解决哈希冲突的时候是有策略的，一般而言，如果是第i次尝试，那么会在首槽的基础上加上一个偏移量*d*<em>i*</em></em></p>
<p>**。比如哈希之后索引是n，那么首槽就是n，然而n这个槽被占了，于是重新映射，重新映射之后的索引就是n + *d**i****<em>，所以可以看出探测方式因函数*d*<em>i*</em></em></p>
<p><strong>而异。</strong></p>
<p><strong>而常见的探测函数有两种：</strong></p>
<ul>
<li><code>线性探测(linear probing)</code></li>
<li><code>平方探测(quadratic probing)</code></li>
</ul>
<p>*<em>线性探测很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个线性函数，例如：*d*<em>i*</em></em></p>
<p> <strong>&#x3D; 2 * i</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164833564-723416397-1680101009725.png" alt="img"></p>
<p>*<em>哈希之后对应的槽是1，但是被占了，这个时候会在首槽的基础上加一个偏移量*d*<em>i*</em></em></p>
<p><strong>。第1次尝试，偏移量是2；第2次尝试，偏移量是4；第3次尝试，偏移量是6。然后再加上首槽的1，所以尝试之后的位置分别是3、5、7。</strong></p>
<p>*<em>平方探测也很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个平方函数，例如：*d*<em>i*</em></em> <strong>&#x3D; *i*2</strong></p>
<p><strong>。同理如果是平方探测，首槽还是1，那么冲突之后重试的槽就是1 + 1、1 + 4、 1+ 9。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164841296-1736851838-1680101009725.png" alt="img"></p>
<blockquote>
<p><strong>线性探测和平方探测很简单，平方探测似乎更胜一筹。因为如果哈希表存在局部热点，探测很难快速跳过热点区域，而平方探测则可以解决这一点。但是这两种方法其实都不够好–因为固定的探测序列加大了冲突的概率。</strong></p>
</blockquote>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164847932-1766657391-1680101009725.png" alt="img"></p>
<p><strong>key1和key2都哈希到槽1，而由于探测序列是相同的，因此冲突概率很高。所以Python对此进行了优化，探测函数参考对象哈希值，生成不同的探测序列，进一步降低哈希冲突的可能性：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164855563-1413795961-1680101009726.png" alt="img"></p>
<h5 id="探测函数"><a href="#探测函数" class="headerlink" title="探测函数"></a>探测函数</h5><p><strong>Python为哈希表搜索提供了多种探测函数，lookdict、lookdict_unicode、lookdict_index，一般通用的是lookdict。lookdict_unicode是专门针对key为字符串的entry，lookdict_index针对key为整数的entry，可以把lookdict_unicode、lookdict_index看成lookdict的特殊实现，只不过key是整数和字符串的场景非常常见，因此为其单独实现了一个函数。</strong></p>
<blockquote>
<p><strong>注意: 我们对字典无论是设置值还是获取值，都需要进行搜索。</strong></p>
</blockquote>
<p><strong>我们这里重点看一下lookdict的函数实现，它位于 *Objects&#x2F;dictobject.c* 源文件内。关键代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">lookdict</span><span class="params">(PyDictObject *mp, PyObject *key,</span></span><br><span class="line"><span class="params">         Py_hash_t hash, PyObject **value_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i, mask, perturb;</span><br><span class="line">    <span class="comment">//keys数组的首地址</span></span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    <span class="comment">//entries数组的首地址</span></span><br><span class="line">    PyDictKeyEntry *ep0;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    dk = mp-&gt;ma_keys;</span><br><span class="line">    ep0 = DK_ENTRIES(dk);</span><br><span class="line">    mask = DK_MASK(dk);</span><br><span class="line">    perturb = hash;</span><br><span class="line">    <span class="comment">//哈希，定位探测链冲突的第一个entry的索引</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// dk-&gt;indecs[i]</span></span><br><span class="line">        Py_ssize_t ix = dk_get_index(dk, i);</span><br><span class="line">        <span class="comment">//如果ix == DKIX_EMPTY，说明没有存储值</span></span><br><span class="line">        <span class="comment">//理论上是报错的，但是在底层是将值的指针设置为NULL</span></span><br><span class="line">        <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">            *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> ix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ix &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到指定的entry的指针</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;ep0[ix];</span><br><span class="line">            assert(ep-&gt;me_key != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//如果两个key一样，那么直接将值的地址设置为ep-&gt;me_value</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            但是注意：我们说Python中的变量是一个指针</span></span><br><span class="line"><span class="comment">            所以这里的一样，表示的两个指针是一样的, 或者地址是一样的, 所以在Python中指向的是同一个对象</span></span><br><span class="line"><span class="comment">            也就是说这一步等价于Python中的: if a is b</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_key == key) &#123;</span><br><span class="line">                *value_addr = ep-&gt;me_value;</span><br><span class="line">                <span class="keyword">return</span> ix;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果两个对象不一样，那么就比较它们的哈希值是否相同</span></span><br><span class="line">            <span class="comment">//比如33和33是一个对象,都是小整数对象池里面整数，但是3333和3333却不是，但是它们的值是一样的</span></span><br><span class="line">            <span class="comment">//因此先判断id是否一致，如果不一致再比较哈希值是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_hash == hash) &#123;</span><br><span class="line">                <span class="comment">//哈希值一样的话, 那么获取me_key</span></span><br><span class="line">                PyObject *startkey = ep-&gt;me_key;</span><br><span class="line">                Py_INCREF(startkey);  <span class="comment">//inc ref</span></span><br><span class="line">                <span class="comment">//比较key是否一致</span></span><br><span class="line">                <span class="type">int</span> cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                Py_DECREF(startkey);  <span class="comment">//dec ref</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">return</span> DKIX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        *value_addr = ep-&gt;me_value;</span><br><span class="line">                        <span class="keyword">return</span> ix;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* The dict was mutated, restart */</span></span><br><span class="line">                    <span class="keyword">goto</span> top;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果条件均不满足，调整姿势，进行下一次探索</span></span><br><span class="line">        <span class="comment">//由于参考了对象哈希值，探测序列因哈希值而异</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i*<span class="number">5</span> + perturb + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希攻击"><a href="#哈希攻击" class="headerlink" title="哈希攻击"></a>哈希攻击</h4><p>*<strong>Python* 在 *3.3* 以前， 哈希算法只根据对象本身计算哈希值。因此，只要 *Python* 解释器相同，对象哈希值也肯定相同。</strong></p>
<p><strong>如果一些别有用心的人构造出大量哈希值相同的 *key* ，并提交给服务器，会发生什么事情呢？例如，向一台 *Python 2 Web* 服务器 *post* 一个 *json* 数据，数据包含大量的 *key* ，所有 *key* 的哈希值相同。这意味着哈希表将频繁发生哈希冲突，性能由 O(1)急剧下降为 O(N)，这便是哈希攻击。</strong></p>
<p><strong>问题虽然很严重，但是好在应对方法比较简单–直接往对象身上撒把盐(salt)即可。具体做法如下：</strong></p>
<ul>
<li><code>1. Python解释器进程启动后，产生一个随机数作为盐</code></li>
<li><code>2. 哈希函数同时参考对象本身以及随机数计算哈希值</code></li>
</ul>
<p><strong>这样一来，攻击者无法获悉解释器内部的随机数，也就无法构造出哈希值相同的对象了！*Python* 自 *3.3* 以后，哈希函数均采用加盐模式，杜绝了哈希攻击的可能性。*Python* 哈希算法在 *Python&#x2F;pyhash.c* 源文件中实现，有兴趣的可以自己去了解一下。</strong></p>
<p><strong>以我当前使用的Python3.8为例，在执行<code>hash(&quot;夏色祭&quot;)</code>的时候，每次执行得到的结果都是不一样的。</strong></p>
<h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p><strong>通过前面的学习，我们现在已经知道哈希表就是通过相应的函数将需要搜索的键映射为一个索引，最终通过索引去访问连续的内存区域。而对于哈希表这种数据结构，最终目的就是加速键的搜索过程。用于映射的函数就是哈希函数，映射之后的值就是哈希值，再由哈希值得到索引<code>(不过为了方便,我们有时会将哈希函数映射的结果直接称为索引)</code>。因此在哈希表的实现中，哈希函数的优劣将直接决定哈希表搜索效率的高低。</strong></p>
<p><strong>并且我们知道，当键值对数量越多，在映射成索引之后就越容易出现冲突。而我们之前说如果冲突了，就改变规则重新映射。事实上，Python也确实是这么做的，这种方法叫做开放寻址法。当发生冲突时，Python会通过一个二次探测函数f，计算下一个候选位置addr，如果可用就插入进去。如果不可用，会继续使用探测函数，直到找到一个可用的位置。通过多次使用探测函数f，从一个位置可以到达多个位置，我们认为这些位置就形成了一个”冲突探测链(探测序列)”。比如当我们插入一个key&#x3D;”satori”的键值对，在a位置发现不行，又走b位置，发现也被人占了，于是到达c位置，发现没有key，于是就占了c这个位置。那么a -&gt; b -&gt; c便形成了一条冲突探测链，同理我们查找的时候也会按照这个顺序进行查找。</strong></p>
<blockquote>
<p><strong>显然上面这些东西，现在理解起来已经没什么难度了，但是问题来了。</strong></p>
<p><strong>如果我此时把上面b位置的entry给删掉的话，会引发什么后果？首先我们知道，b位置上的key和我们指定的”satori”这个key的哈希值是一样的，不然它们也不会映射到同一个槽。当我们直接获取d[“satori”]，肯定会先走a位置，发现有人但key又不是”satori”，于是重新映射；然后走到b，发现还不对，再走到c位置，发现key是”satori”，于是就把值取出来了。显然这符合我们的预期，但是，我要说但是了。</strong></p>
<p><strong>如果我们把b位置上的entry删掉呢？那么老规矩，映射成索引，先走到a位置发现坑被占；于是又走到b位置，结果发现居然没有内容，那么直接就报出了一个KeyError。所以继续寻找的前提是，这个地方要存储了entry，并且存在的<code>entry -&gt; me_key</code>和指定的key不相同，但如果没有的话，就说明根本没有这个key，直接KeyError。然而”satori”这个key确实是存在的，因此发生这种情况我们就说<code>探测链断裂</code>。本来应该走到c的，但是由于b没有元素，因此探测函数在b处就停止了。</strong></p>
</blockquote>
<p><strong>因此我们发现，当一个元素只要位于任何一条探测链当中，在删除元素时都不能真正意义上的删除，而是一种”伪删除”操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个键值对就是一个entry, 在底层就是一个 PyDictKeyEntry 对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>在Python中，当一个PyDictObject对象发生变化时，其中的entry会在三种不同的状态之间进行切换：unused态、active态、dummy态。</strong></p>
<ul>
<li><code>当一个entry的me_key和me_value都是NULL的时候，entry处于unused态。unused态表明该entry中并没有存储key、value，并且在此之前也没有存储过它们，每一个entry在初始化的时候都会处于这个状态。不过me_value的话，即使不是unused态也可能为NULL，更准确的说不管何时它都可能会NULL，这取决于到底是combined table、还是split  table。我们说如果是分离表的话，value是不存在这里的，只有key存在这里，因此me_value永远是NULL。而如果是结合表，那么key和value都存在这里面。所以对于me_key，只可能在unused的时候才可能会NULL。</code></li>
<li><code>当entry存储了key时，那么此时entry便从unused态变成了active态。</code></li>
<li><code>当entry中的key(value)被删除后，状态便从active态变成dummy态。注意：这里是dummy，删除了并不代表就能够回到unused态，来存储其他key了。我们也说了，unused态是指当前没有、并且之前也没有存储过。key被删除后，会变成dummy，否则就会发生我们之前说的探测链断裂。至于这个dummy到底是啥，我们后面说。总是entry进入dummy态，就是我们刚才提到的伪删除技术。当Python沿着某条探测链搜索时，如果发现一个entry处于dummy态，就会明白虽然当前的entry是无效的，但是后面的entry可能是有效的，所以不会直接就停止搜索、报错，而是会继续搜索，这样就保证了探测链的连续性。至于报错，是在找到了unused状态的entry时才会报错，因为这里确实一直都没有存储过key，但是索引确实是这个位置，这说明当前指定的key就真的不存在哈希表中，此时才会报错。</code></li>
</ul>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164910070-2009596752-1680101009726.png" alt="img"></p>
<blockquote>
<p><strong>unused态只能转换为active态；active态只能转换为dummy态；dummy态只能转化为active态。</strong></p>
</blockquote>
<p><strong>哈希槽位状态常量在 *Objects&#x2F;dict-common.h* 头文件中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_EMPTY (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_DUMMY (-2)  <span class="comment">/* Used internally */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_ERROR (-3)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，如果一个entry被删除了，那么它就变成了dummy态。而我们说dummy态是可以转为active态的，要如何转化呢？如果新来了一个entry，这个entry在存储的时候发生冲突，那么会沿着冲突探测链查找，在查找的时候要是遇到了处于dummy态entry，那么原来处于dummy态的entry就会变成active态。</strong></p>
<p><strong>换句话说，对于处理dummy态的entry，Python压根不会主动理会，只是说这个元素被标记为删除了，但是内存还会继续占用。如果新来的entry，没有发生冲突，一上来就有位置可以存储，那么是不会理会dummy态entry的。只有当发生冲突的时候，正好撞上了dummy态的entry，才会将dummy态的entry给替换掉。此时entry就变成了active态，然后内部维护的就是新的键值对。</strong></p>
<p><strong>如果哈希表满了，那么就申请新的存储单元，然后将所有的active态的entry都搬过去，而处于dummy态的entry则直接丢弃。之所以可以丢弃，是因为dummy状态的entry存在是为了保证探测链不断裂，但是现在所有的active都拷贝到新的内存当中了，它们会形成一条新的探测链，因此也就不需要这些dummy态的entry了。至于到底是扩容、缩容、还是容量不变，取决于当前哈希表的entry个数。但是无论怎么样，当新的哈希表创建之后，便又有新的存储单元可用了。</strong></p>
<h3 id="PyDictObject的创建与维护"><a href="#PyDictObject的创建与维护" class="headerlink" title="PyDictObject的创建与维护"></a>PyDictObject的创建与维护</h3><h4 id="PyDictObject的创建"><a href="#PyDictObject的创建" class="headerlink" title="PyDictObject的创建"></a>PyDictObject的创建</h4><p><strong>Python内部通过PyDict_New来创建一个新的dict对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDict_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//new_keys_object表示创建PyDictKeysObject*对象</span></span><br><span class="line">    <span class="comment">//里面传一个数值，表示entry的容量</span></span><br><span class="line">    <span class="comment">//#define PyDict_MINSIZE 8，从宏定义我们能看出来为8</span></span><br><span class="line">    <span class="comment">//表示默认初始化能容纳8个entry的PyDictKeysObject</span></span><br><span class="line">    <span class="comment">//为什么是8，这是通过大量的经验得来的。</span></span><br><span class="line">    PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE);</span><br><span class="line">    <span class="keyword">if</span> (keys == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这一步则是根据PyDictKeysObject *创建一个新字典</span></span><br><span class="line">    <span class="keyword">return</span> new_dict(keys, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyDictKeysObject *<span class="title function_">new_keys_object</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测，size是否&gt;=PyDict_MINSIZE</span></span><br><span class="line">    assert(size &gt;= PyDict_MINSIZE);</span><br><span class="line">    assert(IS_POWER_OF_2(size));</span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(size);</span><br><span class="line">    <span class="comment">//es：哈希表中的每个索引占多少字节</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0xff</span>) &#123;</span><br><span class="line">        es = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        es = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">        es = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        es = <span class="keyword">sizeof</span>(Py_ssize_t);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注意到，字典里面也有缓冲池，当然这里指定是字典的key</span></span><br><span class="line">    <span class="comment">//如果有的话，直接从里面取</span></span><br><span class="line">    <span class="keyword">if</span> (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则malloc重新申请</span></span><br><span class="line">        dk = PyObject_MALLOC(<span class="keyword">sizeof</span>(PyDictKeysObject)</span><br><span class="line">                             + es * size</span><br><span class="line">                             + <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">        <span class="keyword">if</span> (dk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置引用计数、可用的entry个数等信息</span></span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = <span class="number">1</span>;</span><br><span class="line">    dk-&gt;dk_size = size;</span><br><span class="line">    dk-&gt;dk_usable = usable;</span><br><span class="line">    <span class="comment">//dk_lookup很关键，里面包括了哈希函数和冲突时的二次探测函数的实现</span></span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;</span><br><span class="line">    dk-&gt;dk_nentries = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//哈希表的初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dk-&gt;dk_indices[<span class="number">0</span>], <span class="number">0xff</span>, es * size);</span><br><span class="line">    <span class="built_in">memset</span>(DK_ENTRIES(dk), <span class="number">0</span>, <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">    <span class="keyword">return</span> dk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//这是一个字典的缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//系统堆中申请内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</span><br><span class="line">        <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DK_DECREF(keys);</span><br><span class="line">            free_values(values);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置key、value等等</span></span><br><span class="line">    mp-&gt;ma_keys = keys;</span><br><span class="line">    mp-&gt;ma_values = values;</span><br><span class="line">    mp-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>我们对PyDictObject对象的操作都是建立在搜索的基础之上的，插入和删除也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertdict</span><span class="params">(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//增加对key和value的引用计数</span></span><br><span class="line">    Py_INCREF(key);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_values != <span class="literal">NULL</span> &amp;&amp; !PyUnicode_CheckExact(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> Fail;</span><br><span class="line"></span><br><span class="line">    assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict);</span><br><span class="line">    MAINTAIN_TRACKING(mp, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查共享key，可能扩容哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp) &amp;&amp;</span><br><span class="line">        ((ix &gt;= <span class="number">0</span> &amp;&amp; old_value == <span class="literal">NULL</span> &amp;&amp; mp-&gt;ma_used != ix) ||</span><br><span class="line">         (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">        ix = DKIX_EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//搜索成功</span></span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">        <span class="comment">/* 插入一个新的slot，这个slot可以直接看成是entry */</span></span><br><span class="line">        assert(old_value == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_keys-&gt;dk_usable &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 需要resize */</span></span><br><span class="line">            <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> Fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找值的插入位置，就是我们之前说的将key这个值通过哈希函数映射为索引</span></span><br><span class="line">        Py_ssize_t hashpos = find_empty_slot(mp-&gt;ma_keys, hash);</span><br><span class="line">        <span class="comment">//拿到PyDictKeyEntry *指针</span></span><br><span class="line">        ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[mp-&gt;ma_keys-&gt;dk_nentries];</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries);</span><br><span class="line">        ep-&gt;me_key = key; <span class="comment">//设置key</span></span><br><span class="line">        ep-&gt;me_hash = hash;<span class="comment">//设置哈希</span></span><br><span class="line">        <span class="comment">//如果ma_values数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_values) &#123;</span><br><span class="line">            assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置进去，还记得这是什么表吗？对，这是一张split table</span></span><br><span class="line">            mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ma_values数据为空的话，那么value就设置在PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">            ep-&gt;me_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mp-&gt;ma_used++;<span class="comment">//使用个数+1</span></span><br><span class="line">        mp-&gt;ma_version_tag = DICT_NEXT_VERSION();<span class="comment">//版本数+1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_usable--;<span class="comment">//可用数-1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_nentries++;<span class="comment">//里面entry数量+1</span></span><br><span class="line">        assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= <span class="number">0</span>);</span><br><span class="line">        assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断key是否存在，存在即替换</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        mp-&gt;ma_values[ix] = value;</span><br><span class="line">        <span class="keyword">if</span> (old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* pending state */</span></span><br><span class="line">            assert(ix == mp-&gt;ma_used);</span><br><span class="line">            mp-&gt;ma_used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(old_value != <span class="literal">NULL</span>);</span><br><span class="line">        DK_ENTRIES(mp-&gt;ma_keys)[ix].me_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    Py_XDECREF(old_value); <span class="comment">/* which **CAN** re-enter (see issue #22653) */</span></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Fail:</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上是插入元素，但我们看到无论是插入元素、还是设置元素，insertdict都是可以胜任。但是请注意一下参数，有一个hash参数，这个hash是从什么地方获取的呢？答案是，在调用这个insertdict之前其实会首先调用<code>PyDict_SetItem</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_SetItem</span><span class="params">(PyObject *op, PyObject *key, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>)</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用insertdict，必要时调整元素 */</span></span><br><span class="line">    <span class="keyword">return</span> insertdict(mp, key, hash, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说如果entry个数达到容量的三分之二，那么会调整容量，如何调整呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增长率</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROWTH_RATE(d) ((d)-&gt;ma_used*3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertion_resize</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//本质上调用了dictresize，传入PyDictObject * 和增长率</span></span><br><span class="line">    <span class="keyword">return</span> dictresize(mp, GROWTH_RATE(mp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dictresize</span><span class="params">(PyDictObject *mp, Py_ssize_t minsize)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//新的容量，entry的个数</span></span><br><span class="line">    Py_ssize_t newsize, numentries;</span><br><span class="line">    <span class="comment">//老的keys</span></span><br><span class="line">    PyDictKeysObject *oldkeys;</span><br><span class="line">    <span class="comment">//老的values</span></span><br><span class="line">    PyObject **oldvalues;</span><br><span class="line">    <span class="comment">//老的entries，新的entries</span></span><br><span class="line">    PyDictKeyEntry *oldentries, *newentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确定table的大小*/</span></span><br><span class="line">    <span class="keyword">for</span> (newsize = PyDict_MINSIZE;</span><br><span class="line">         newsize &lt; minsize &amp;&amp; newsize &gt; <span class="number">0</span>;</span><br><span class="line">         newsize &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (newsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取原来的所有keys</span></span><br><span class="line">    oldkeys = mp-&gt;ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建能够容纳newsize个entry的内存空间 */</span></span><br><span class="line">    mp-&gt;ma_keys = new_keys_object(newsize);</span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_keys == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//把以前的key拷贝过去。</span></span><br><span class="line">        mp-&gt;ma_keys = oldkeys;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须满足 可用 &gt;= 已用</span></span><br><span class="line">    assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= mp-&gt;ma_used);</span><br><span class="line">    <span class="keyword">if</span> (oldkeys-&gt;dk_lookup == lookdict)</span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_lookup = lookdict;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取已用entries</span></span><br><span class="line">    numentries = mp-&gt;ma_used;</span><br><span class="line">    <span class="comment">//获取旧信息</span></span><br><span class="line">    oldentries = DK_ENTRIES(oldkeys);</span><br><span class="line">    newentries = DK_ENTRIES(mp-&gt;ma_keys);</span><br><span class="line">    oldvalues = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//如果oldvalues不为NULL，这应该是一个 split table</span></span><br><span class="line">    <span class="comment">//split table的特点是key是能是unicode、</span></span><br><span class="line">    <span class="comment">//那么需要把split table转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (oldvalues != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            assert(oldvalues[i] != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//将ma_values数组里面的元素统统都设置到PyDictKeyEntry对象里面去</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;oldentries[i];</span><br><span class="line">            PyObject *key = ep-&gt;me_key;</span><br><span class="line">            Py_INCREF(key);</span><br><span class="line">            newentries[i].me_key = key;</span><br><span class="line">            newentries[i].me_hash = ep-&gt;me_hash;</span><br><span class="line">            newentries[i].me_value = oldvalues[i];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//减少原来对oldkeys的引用计数</span></span><br><span class="line">        DK_DECREF(oldkeys);</span><br><span class="line">        <span class="comment">//将ma_values设置为NULL，因为所有的value都存在了PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">        mp-&gt;ma_values = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldvalues != empty_values) &#123;</span><br><span class="line">            free_values(oldvalues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 否则的话说明这本身就是一个combined table</span></span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_nentries == numentries) &#123;</span><br><span class="line">            <span class="comment">//将就得entries拷贝到新的entries里面去</span></span><br><span class="line">            <span class="built_in">memcpy</span>(newentries, oldentries, numentries * <span class="keyword">sizeof</span>(PyDictKeyEntry));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理旧的entries</span></span><br><span class="line">            <span class="comment">//active态的entry搬到新table中</span></span><br><span class="line">            <span class="comment">//dummy态的entry，调整key的引用计数，丢弃该entry</span></span><br><span class="line">            PyDictKeyEntry *ep = oldentries;</span><br><span class="line">            <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (ep-&gt;me_value == <span class="literal">NULL</span>)</span><br><span class="line">                    ep++;</span><br><span class="line">                newentries[i] = *ep++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//字典缓冲池的操作，后面介绍</span></span><br><span class="line">        assert(oldkeys-&gt;dk_lookup != lookdict_split);</span><br><span class="line">        assert(oldkeys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_size == PyDict_MINSIZE &amp;&amp;</span><br><span class="line">            numfreekeys &lt; PyDict_MAXFREELIST) &#123;</span><br><span class="line">            DK_DEBUG_DECREF keys_free_list[numfreekeys++] = oldkeys;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DK_DEBUG_DECREF PyObject_FREE(oldkeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//建立哈希表索引</span></span><br><span class="line">    build_indices(mp-&gt;ma_keys, newentries, numentries);</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_usable -= numentries;</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_nentries = numentries;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来看一下改变dict内存空间的一些动作：</strong></p>
<ul>
<li><code>首先要确定table的大小，很显然这个大小一定要大于minsize，这个minsize通过我们已经看到了，是通过宏定义的，是已用entry的3倍</code></li>
<li><code>根据新的table，重新申请内存</code></li>
<li><code>将原来的处于active状态的entry拷贝到新的内存当中，而对于处于dummy状态的entry则直接丢弃。可以丢弃的原因我们上面也说过了。主要是因为哈希表扩容了，会申请的一个新的数组，直接将原来的active态的entry组成一条新的探测链即可，因此也就不需要这些dummy态的entry了</code></li>
</ul>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>插入元素(设置元素)如果明白了，删除元素我觉得都可以不需要说了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_DelItem</span><span class="params">(PyObject *op, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这显然和dictresize一样，是先获取hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    assert(key);</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//真正来删除是下面这个函数</span></span><br><span class="line">    <span class="keyword">return</span> _PyDict_DelItem_KnownHash(op, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_PyDict_DelItem_KnownHash(PyObject *op, PyObject *key, Py_hash_t hash)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t ix;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(hash != <span class="number">-1</span>);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//获取对应entry的index</span></span><br><span class="line">    ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY || old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// split table不支持删除操作，如果是split table，需要转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictresize(mp, DK_SIZE(mp-&gt;ma_keys))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">        assert(ix &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//传入hash和ix，又调用了delitem_common</span></span><br><span class="line">    <span class="keyword">return</span> delitem_common(mp, hash, ix, old_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">delitem_common</span><span class="params">(PyDictObject *mp, Py_hash_t hash, Py_ssize_t ix,</span></span><br><span class="line"><span class="params">               PyObject *old_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到对应的hash索引</span></span><br><span class="line">    Py_ssize_t hashpos = lookdict_index(mp-&gt;ma_keys, hash, ix);</span><br><span class="line">    assert(hashpos &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//已经entries个数-1</span></span><br><span class="line">    mp-&gt;ma_used--;</span><br><span class="line">    <span class="comment">//版本-1</span></span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    <span class="comment">//拿到entry的指针</span></span><br><span class="line">    ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[ix];</span><br><span class="line">    <span class="comment">//将其设置为dummy状态</span></span><br><span class="line">    dk_set_index(mp-&gt;ma_keys, hashpos, DKIX_DUMMY);</span><br><span class="line">    ENSURE_ALLOWS_DELETIONS(mp);</span><br><span class="line">    old_key = ep-&gt;me_key;</span><br><span class="line">    <span class="comment">//将其key、value都设置为NULL</span></span><br><span class="line">    ep-&gt;me_key = <span class="literal">NULL</span>;</span><br><span class="line">    ep-&gt;me_value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    Py_DECREF(old_value);</span><br><span class="line"></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程非常清晰，也很简单。先使用PyDict_DelItem计算hash值，再使用_PyDict_DelItem_KnownHash计算出索引，最后使用delitem_common获取相应的entry，删除维护的元素，并将entry从active态设置为dummy态，同时还会调整ma_used(已用entry)的数量</strong></p>
<h3 id="PyDictObject缓存池"><a href="#PyDictObject缓存池" class="headerlink" title="PyDictObject缓存池"></a>PyDictObject缓存池</h3><p><strong>从介绍PyLongObject的小整数对象池的时候，我们就说过，不同的对象都有自己的缓存池，比如列表，当然字典也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyDict_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyDictObject *free_list[PyDict_MAXFREELIST];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>PyDictObject的缓存池机制其实和PyListObject的缓存池是类似的，开始时，这个缓存池什么也没有，直到第一个PyDictObject对象被销毁时，这个PyDictObject缓冲池里面才开始接纳被缓冲的PyDictObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dict_dealloc</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取ma_values指针</span></span><br><span class="line">    PyObject **values = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//获取所有的ma_keys指针</span></span><br><span class="line">    PyDictKeysObject *keys = mp-&gt;ma_keys;</span><br><span class="line">    <span class="comment">//两个整型</span></span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追踪、调试</span></span><br><span class="line">    PyObject_GC_UnTrack(mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(mp)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//调整引用计数    </span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (values != empty_values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123;</span><br><span class="line">                Py_XDECREF(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            free_values(values);</span><br><span class="line">        &#125;</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        assert(keys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将被销毁的对象放到缓冲池当中</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)</span><br><span class="line">        free_list[numfree++] = mp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject对象的缓冲池机制一样，缓冲池中只保留了PyDictObject对象。如果维护的是从系统堆中申请的内存空间，那么Python将释放这份内存空间，归还给系统堆。如果不是，那么仅仅只需要调整维护的对象的引用计数即可。</strong></p>
<p><strong>其实在创建一个PyDictObject对象时，如果缓冲池中有可用的对象，也会直接从缓冲池中取，而不需要再重新创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>​        <strong>关于字典的剖析我们就说到这里，其实内容还是很多的，尤其是哈希表背后的一些原理，值得好好体会一下。</strong>    </p>
<h3 id="PySetObject"><a href="#PySetObject" class="headerlink" title="PySetObject"></a>PySetObject</h3><p><strong>由于集合和字典在底层使用的都是哈希表，所以我们放在一起说吧。</strong></p>
<p><strong>既然集合也使用了哈希表，那么它的查询性能也是很高的。由于哈希表我们已经说了很多了，所以我们下面就直接来看集合的底层结构吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//python中的集合的每一个元素，是通过setentry这个结构体来存储的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject *key; <span class="comment">// 元素的指针</span></span><br><span class="line">    Py_hash_t hash; <span class="comment">// 元素的哈希值</span></span><br><span class="line">&#125; setentry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们发现在set中，每一个元素依然叫做entry</span></span><br><span class="line">    Py_ssize_t fill;            <span class="comment">/* active态以及dummy态的entry总数量*/</span></span><br><span class="line">    Py_ssize_t used;            <span class="comment">/* active态的entry数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 该table包含mask+1个slot，mask+1是2的幂次方</span></span><br><span class="line"><span class="comment">    我们存储的是mask，而不是size，因为更常需要mask</span></span><br><span class="line"><span class="comment">    这个mask是用来和哈希值进行运算的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于小表，该table指向固定大小的small table，对于bigger table则指向额外的malloc内存</span></span><br><span class="line"><span class="comment">    该table的指针永远不会为NULL。</span></span><br><span class="line"><span class="comment">    所以它是指向setentry数组的一个指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setentry *table;</span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* 该PySetObject的哈希值，只适用于frozenset */</span></span><br><span class="line">    Py_ssize_t finger;          </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于pop元素的，search finger就是我们从包含某个元素的节点开始，找到我们希望的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//smalltable就是显然就是一个保存了setentry类型的数组</span></span><br><span class="line">    <span class="comment">//PySet_MINSIZE是一个宏定义，默认是8。如果元素比较少的话，存在smalltable里面</span></span><br><span class="line">    <span class="comment">//当smalltable存不下的时候(仮)，就会使用malloc申请。存不下，指的是超过8个的时候吗？</span></span><br><span class="line">    <span class="comment">//由于哈希表的特性，需要预留一定的空间，因此还没存到8个的时候，就会扩容了</span></span><br><span class="line">    setentry smalltable[PySet_MINSIZE];</span><br><span class="line">    PyObject *weakreflist;      <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">&#125; PySetObject;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164928460-76799035-1680101009726.png" alt="img"></p>
<h4 id="PySetObject对象的创建"><a href="#PySetObject对象的创建" class="headerlink" title="PySetObject对象的创建"></a>PySetObject对象的创建</h4><p><strong>创建一个PySetObject对象可以使用PySet_New方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PySet_New</span><span class="params">(PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//底层调用了make_new_set</span></span><br><span class="line">    <span class="keyword">return</span> make_new_set(&amp;PySet_Type, iterable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">make_new_set</span><span class="params">(PyTypeObject *type, PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//申明一个PySetObject *指针</span></span><br><span class="line">    PySetObject *so;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//申请该元素所需要的内存</span></span><br><span class="line">    so = (PySetObject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//申请失败，返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (so == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化都为0</span></span><br><span class="line">    so-&gt;fill = <span class="number">0</span>;</span><br><span class="line">    so-&gt;used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//PySet_MINSIZE默认为8，mask初始化为7</span></span><br><span class="line">    so-&gt;mask = PySet_MINSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将table指向保存数据的smalltable的头指针</span></span><br><span class="line">    so-&gt;table = so-&gt;smalltable;</span><br><span class="line">    <span class="comment">//初始化hash值为-1</span></span><br><span class="line">    so-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//finger为0</span></span><br><span class="line">    so-&gt;finger = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//弱引用列表为NULL</span></span><br><span class="line">    so-&gt;weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果迭代器不为NULL，那么把元素依次更新的so这个PySetObject中</span></span><br><span class="line">    <span class="keyword">if</span> (iterable != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set_update_internal(so, iterable)) &#123;</span><br><span class="line">            Py_DECREF(so);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//返回初始化完成的set</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)so;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从以上步骤可以看出，初始化一个PySetObject对象主要初始化其内部的数据结构。</strong></p>
<h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>插入元素，会调用PySet_Add：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PySet_Add</span><span class="params">(PyObject *anyset, PyObject *key)</span></span><br><span class="line">&#123;	<span class="comment">//参数是两个指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PySet_Check(anyset) &amp;&amp;</span><br><span class="line">        (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != <span class="number">1</span>)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本质上调用了set_add_key</span></span><br><span class="line">    <span class="keyword">return</span> set_add_key((PySetObject *)anyset, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个变量，显然是存储哈希值的</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//计算哈希值</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="comment">//如果传入的元素不能被hash，那么直接返回-1</span></span><br><span class="line">        <span class="comment">//在python层面显然会报错</span></span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用了set_add_entry，并把hash也作为参数传了进去</span></span><br><span class="line">    <span class="keyword">return</span> set_add_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *table;  <span class="comment">//指向setentry数组的指针，当然数组里面也是指针</span></span><br><span class="line">    setentry *freeslot;<span class="comment">//存放不可hash的entry</span></span><br><span class="line">    setentry *entry;<span class="comment">//entry指针</span></span><br><span class="line">    <span class="type">size_t</span> perturb;</span><br><span class="line">    <span class="type">size_t</span> mask;<span class="comment">//和hash运算</span></span><br><span class="line">    <span class="type">size_t</span> i; <span class="comment">//一个整型变量，后面的索引值</span></span><br><span class="line">    <span class="type">size_t</span> j;<span class="comment">//遍历用的</span></span><br><span class="line">    <span class="type">int</span> cmp;<span class="comment">//比较的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pre-increment is necessary to prevent arbitrary code in the rich</span></span><br><span class="line"><span class="comment">       comparison from deallocating the key just before the insertion. */</span></span><br><span class="line">    Py_INCREF(key);  <span class="comment">//增加key的引用计数</span></span><br><span class="line"></span><br><span class="line">  restart:</span><br><span class="line"></span><br><span class="line">    mask = so-&gt;mask;  <span class="comment">//获取mask</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;<span class="comment">//mask和hash进行与运算，得到一个索引</span></span><br><span class="line"></span><br><span class="line">    entry = &amp;so-&gt;table[i];<span class="comment">//获取对应的entry指针</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果entry-&gt;key == NULL，表示当前位置没有被使用</span></span><br><span class="line">        <span class="comment">//直接跳到found_unused标签</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则说明有人用了</span></span><br><span class="line">    freeslot = <span class="literal">NULL</span>;</span><br><span class="line">    perturb = hash; <span class="comment">// 将perturb设置为hash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        找到entry-&gt;hash，之前说了，entry结构体由两部分组成</span></span><br><span class="line"><span class="comment">        一个*key，也就是指向真正元素的指针，另一个是hash值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//如果和我们当前的hash值一样的话</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">            <span class="comment">//拿到当前的key</span></span><br><span class="line">            PyObject *startkey = entry-&gt;key;</span><br><span class="line">            <span class="comment">/* startkey cannot be a dummy because the dummy hash field is -1 */</span></span><br><span class="line">            <span class="comment">//entry里面的key不可以为dummy态，因为这相当于删除(伪删除)了，hash为-1</span></span><br><span class="line">            assert(startkey != dummy);</span><br><span class="line">            <span class="comment">//如果已经存在的key和我们添加的key是一样，说明重复了</span></span><br><span class="line">            <span class="comment">//而集合内的元素不允许重复</span></span><br><span class="line">            <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                <span class="comment">//直接跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//如果是unicode，那么先转化，然后再比较两个key是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                <span class="comment">//如果一样，跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//那么获取头部指针</span></span><br><span class="line">            table = so-&gt;table;</span><br><span class="line">            <span class="comment">//增加startkey的引用计数</span></span><br><span class="line">            Py_INCREF(startkey);</span><br><span class="line">            <span class="comment">//不一样的话，通过富比较，去比较两个对象维护的值是否一致</span></span><br><span class="line">            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">            <span class="comment">//介绍startkey的引用计数</span></span><br><span class="line">            Py_DECREF(startkey);</span><br><span class="line">            <span class="comment">//如果cmp大于0，比较成功</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)          </span><br><span class="line">                <span class="comment">//说明索引被人占了</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//小于0说明比较失败</span></span><br><span class="line">                <span class="keyword">goto</span> comparison_error;</span><br><span class="line">            <span class="comment">/* 如果table或者entry改变了，我们必须从头开始 */</span></span><br><span class="line">            <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                <span class="comment">//跳转到restart标签</span></span><br><span class="line">                <span class="keyword">goto</span> restart;</span><br><span class="line">            <span class="comment">//拿到当前的mask</span></span><br><span class="line">            mask = so-&gt;mask;                 <span class="comment">/* help avoid a register spill */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能hash</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="comment">//则设置为freeslot</span></span><br><span class="line">            freeslot = entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果当前索引值加上9小于当前的mask</span></span><br><span class="line">        <span class="comment">//#define LINEAR_PROBES 9</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//循环9次</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; LINEAR_PROBES ; j++) &#123;</span><br><span class="line">                <span class="comment">//每次得到下一个entry</span></span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//如果hash=0，并且对应的key为NULL</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == <span class="number">0</span> &amp;&amp; entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="comment">//跳转到found_unused_or_dummy标签</span></span><br><span class="line">                    <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">                    <span class="comment">//如果hash值相同，获取对应的key</span></span><br><span class="line">                    PyObject *startkey = entry-&gt;key;</span><br><span class="line">                    <span class="comment">//key必须不为dummy态</span></span><br><span class="line">                    assert(startkey != dummy);</span><br><span class="line">                    <span class="comment">//如果两个key相同，跳转到found_active标签</span></span><br><span class="line">                    <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//如果为unicode，还是转化后比较</span></span><br><span class="line">                    <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                        &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                        &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//下面的跟if (i + LINEAR_PROBES &lt;= mask) &#123;上面的是一样的</span></span><br><span class="line">                    table = so-&gt;table;</span><br><span class="line">                    Py_INCREF(startkey);</span><br><span class="line">                    cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                    Py_DECREF(startkey);</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> comparison_error;</span><br><span class="line">                    <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                        <span class="keyword">goto</span> restart;</span><br><span class="line">                    mask = so-&gt;mask;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">                    freeslot = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有找到，说明哈希值冲突，改变规则，重新计算索引值</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        <span class="comment">//按照(i * 5 + 1 + perturb) &amp; mask重新计算</span></span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//获取新索引对应的entry</span></span><br><span class="line">        entry = &amp;so-&gt;table[i];</span><br><span class="line">        <span class="comment">//如果对应的key为NULL，说明重新计算索引之后找到了可以存储的地方</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//跳转到found_unused_or_dummy</span></span><br><span class="line">            <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">        <span class="comment">//否则说明比较倒霉，改变规则重新映射索引依旧冲突</span></span><br><span class="line">        <span class="comment">//那么继续循环，比较key是否一致等等</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//未使用或者dummy，dummy我们是不可以使用的</span></span><br><span class="line">  found_unused_or_dummy:</span><br><span class="line">    <span class="comment">//如果这个freeslot为NULL，说明是可用的</span></span><br><span class="line">    <span class="keyword">if</span> (freeslot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">    <span class="comment">//否则，说明为dummy态，那么我们依旧可以使用，正好废物利用</span></span><br><span class="line">    <span class="comment">//将used数量加一</span></span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    freeslot-&gt;key = key;</span><br><span class="line">    freeslot-&gt;hash = hash;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//发现未使用的</span></span><br><span class="line">  found_unused:</span><br><span class="line">    <span class="comment">//将fill和used个数+1</span></span><br><span class="line">    so-&gt;fill++;</span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">    <span class="comment">//检查active态+dummy的entry个数是否小于mask的3/5</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)so-&gt;fill*<span class="number">5</span> &lt; mask*<span class="number">3</span>)</span><br><span class="line">        <span class="comment">//是的话，表示无需扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则要进行扩容</span></span><br><span class="line">    <span class="comment">//扩容的规则就是如果active态的entry各式各样如果大于50000，那么两倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="keyword">return</span> set_table_resize(so, so-&gt;used&gt;<span class="number">50000</span> ? so-&gt;used*<span class="number">2</span> : so-&gt;used*<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//如果是found_active，表示key重复了</span></span><br><span class="line">  <span class="comment">//直接减少一个引用计数即可</span></span><br><span class="line">  found_active:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//比较失败，同样减少引用计数，返回-1</span></span><br><span class="line">  comparison_error:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下流程就是：</strong></p>
<ul>
<li><code>传入hash值，计算出索引值，通过索引值找到对应的entry</code></li>
<li><code>如果entry-&gt;key=NULL，那么将hash和key存到对应的entry</code></li>
<li><code>如果有key，但是值相同，则不插入，直接减少引入计数。因为不是字典，不存在更新一说</code></li>
<li><code>如果有key，但是值不相同。那么从该索引往后的9个entry(i + 9 &lt;= mask)，如果存在key为NULL的entry，那么设置进去。</code></li>
<li><code>如果以上条件都不满足，那么改变策略重新计算索引值，直到找到一个满足key为NULL的entry</code></li>
<li><code>判断容量问题，如果active态+dummy态的entry个数不小于3/5 * mask，那么扩容，扩容的规则是active态的entry个数是否大于50000，是的话就二倍扩容，否则4倍扩容。</code></li>
</ul>
<h4 id="PySetObject扩容"><a href="#PySetObject扩容" class="headerlink" title="PySetObject扩容"></a>PySetObject扩容</h4><p><strong>我们之前说PySetObject会改变容量，那么它是如何改变的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_table_resize</span><span class="params">(PySetObject *so, Py_ssize_t minused)</span></span><br><span class="line">&#123;	<span class="comment">//显然参数是：PySetObject *指针以及容量大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//三个setentry *指针</span></span><br><span class="line">    setentry *oldtable, *newtable, *entry;</span><br><span class="line">    <span class="comment">//oldmask</span></span><br><span class="line">    Py_ssize_t oldmask = so-&gt;mask;</span><br><span class="line">    <span class="comment">//newmask</span></span><br><span class="line">    <span class="type">size_t</span> newmask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否为其申请过内存</span></span><br><span class="line">    <span class="type">int</span> is_oldtable_malloced;</span><br><span class="line">    <span class="comment">//将PySet_MINSIZE个entry直接copy过来</span></span><br><span class="line">    <span class="comment">//因为你既然要扩容的话，那么肯定是这里面存不下了</span></span><br><span class="line">    setentry small_copy[PySet_MINSIZE];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//minused必须大于等于0</span></span><br><span class="line">    assert(minused &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the smallest table size &gt; minused. */</span></span><br><span class="line">    <span class="comment">/* XXX speed-up with intrinsics */</span></span><br><span class="line">    <span class="comment">//newsize扩大二倍，直到大于minused</span></span><br><span class="line">    <span class="comment">//所以我们刚才说的大于50000，二倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="comment">//实际上是最终的newsize是比二倍或者四倍扩容的结果要大的</span></span><br><span class="line">    <span class="type">size_t</span> newsize = PySet_MINSIZE;</span><br><span class="line">    <span class="keyword">while</span> (newsize &lt;= (<span class="type">size_t</span>)minused) &#123;</span><br><span class="line">        <span class="comment">//newsize最大顶多也就是PY_SSIZE_T_MAX + 1，但是基本不可能存储这么多元素</span></span><br><span class="line">        newsize &lt;&lt;= <span class="number">1</span>; <span class="comment">// The largest possible value is PY_SSIZE_T_MAX + 1.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get space for a new table. */</span></span><br><span class="line">    <span class="comment">//为新的table申请空间</span></span><br><span class="line">    oldtable = so-&gt;table;</span><br><span class="line">    assert(oldtable != <span class="literal">NULL</span>);</span><br><span class="line">    is_oldtable_malloced = oldtable != so-&gt;smalltable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize和PySet_MINSIZE(这里的8)相等</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == PySet_MINSIZE) &#123;</span><br><span class="line">        <span class="comment">/* A large table is shrinking, or we can&#x27;t get any smaller. */</span></span><br><span class="line">        <span class="comment">//拿到smalltable，就是默认初始化8个entry数组的那哥们</span></span><br><span class="line">        newtable = so-&gt;smalltable;</span><br><span class="line">        <span class="comment">//如果oldtable和newtable一样</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == oldtable) &#123;</span><br><span class="line">            <span class="comment">//并且没有dummy态的entry</span></span><br><span class="line">            <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">                <span class="comment">/* No dummies, so no point doing anything. */</span></span><br><span class="line">                <span class="comment">//那么无需做任何事情</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We&#x27;re not going to resize it, but rebuild the</span></span><br><span class="line"><span class="comment">               table anyway to purge old dummy entries.</span></span><br><span class="line"><span class="comment">               Subtle:  This is *necessary* if fill==size,</span></span><br><span class="line"><span class="comment">               as set_lookkey needs at least one virgin slot to</span></span><br><span class="line"><span class="comment">               terminate failing searches.  If fill &lt; size, it&#x27;s</span></span><br><span class="line"><span class="comment">               merely desirable, as dummies slow searches. */</span></span><br><span class="line">            <span class="comment">//否则的话，dummy的个数一定大于0</span></span><br><span class="line">            assert(so-&gt;fill &gt; so-&gt;used);</span><br><span class="line">            <span class="comment">//扔掉dummy态，只把oldtable中active态的拷贝过来</span></span><br><span class="line">            <span class="built_in">memcpy</span>(small_copy, oldtable, <span class="keyword">sizeof</span>(small_copy));</span><br><span class="line">            <span class="comment">//将small_copy重新设置为oldtable</span></span><br><span class="line">            oldtable = small_copy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，肯定大于8，申请newsize个setentry所需要的空间</span></span><br><span class="line">        newtable = PyMem_NEW(setentry, newsize);</span><br><span class="line">        <span class="comment">//如果newtable为NULL，那么申请内存失败，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the set empty, using the new table. */</span></span><br><span class="line">    <span class="comment">//newtable肯定不等于oldtable</span></span><br><span class="line">    assert(newtable != oldtable);</span><br><span class="line">    <span class="comment">//创建一个能融安newsize个entry的空set</span></span><br><span class="line">    <span class="built_in">memset</span>(newtable, <span class="number">0</span>, <span class="keyword">sizeof</span>(setentry) * newsize);</span><br><span class="line">    <span class="comment">//将mask设置为newsize-1</span></span><br><span class="line">    <span class="comment">//将table设置为newtable</span></span><br><span class="line">    so-&gt;mask = newsize - <span class="number">1</span>;</span><br><span class="line">    so-&gt;table = newtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the data over; this is refcount-neutral for active entries;</span></span><br><span class="line"><span class="comment">       dummy entries aren&#x27;t copied over, of course */</span></span><br><span class="line">    <span class="comment">//获取newmask</span></span><br><span class="line">    newmask = (<span class="type">size_t</span>)so-&gt;mask;</span><br><span class="line">    <span class="comment">//将原来旧table的setentry数组里面所有setentry的key和hash值全部设置到新的table里面</span></span><br><span class="line">    <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        so-&gt;fill = so-&gt;used;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span> &amp;&amp; entry-&gt;key != dummy) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果已经为其申请了内存，那么要将其归还给系统堆</span></span><br><span class="line">    <span class="keyword">if</span> (is_oldtable_malloced)</span><br><span class="line">        PyMem_DEL(oldtable);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置元素是通过set_insert_clean设置的</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">set_insert_clean</span><span class="params">(setentry *table, <span class="type">size_t</span> mask, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    <span class="type">size_t</span> perturb = hash;</span><br><span class="line">    <span class="type">size_t</span> i = (<span class="type">size_t</span>)hash &amp; mask; <span class="comment">//计算索引</span></span><br><span class="line">    <span class="type">size_t</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        entry = &amp;table[i];  <span class="comment">//获取当前entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> found_null; <span class="comment">//如果为空则跳转found_null设置key与hash</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//如果没有还是老规矩，遍历之后的9个entry</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LINEAR_PROBES; j++) &#123;</span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//找到空的entry，那么跳转到found_null设置key与hash</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> found_null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到，那么改变规则，重新计算索引</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">  found_null:</span><br><span class="line">    <span class="comment">//设置key与hash</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_remove</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *tmpkey;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将该值设置为dummy态</span></span><br><span class="line">    rv = set_discard_key(so, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//类型检测</span></span><br><span class="line">        <span class="keyword">if</span> (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="comment">//对该值重新初始化为frozenset</span></span><br><span class="line">        tmpkey = make_new_set(&amp;PyFrozenSet_Type, key);</span><br><span class="line">        <span class="keyword">if</span> (tmpkey == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将该key设置为空</span></span><br><span class="line">        rv = set_discard_key(so, tmpkey);</span><br><span class="line">        Py_DECREF(tmpkey);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果没有找到则报错</span></span><br><span class="line">    <span class="keyword">if</span> (rv == DISCARD_NOTFOUND) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面调用了set_discard_key方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//老套路，先计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将hash值也船进入</span></span><br><span class="line">    <span class="keyword">return</span> set_discard_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">////通过传入的key和hash找到该entry</span></span><br><span class="line">    <span class="comment">//并且hash对应的key要和传入的key是一样的</span></span><br><span class="line">    entry = set_lookkey(so, key, hash);  </span><br><span class="line">    <span class="comment">//如果entry为NULL，直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果entry不为NULL，但是对应的key为NULL</span></span><br><span class="line">    <span class="comment">//返回DISCARD_NOTFOUND</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> DISCARD_NOTFOUND;</span><br><span class="line">    <span class="comment">//获取要删除的key</span></span><br><span class="line">    old_key = entry-&gt;key;</span><br><span class="line">    <span class="comment">//并将entry的key设置为dummy</span></span><br><span class="line">    entry-&gt;key = dummy;</span><br><span class="line">    <span class="comment">//hash值设置为-1</span></span><br><span class="line">    entry-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//减少使用数量</span></span><br><span class="line">    so-&gt;used--;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    <span class="comment">//返回DISCARD_FOUND</span></span><br><span class="line">    <span class="keyword">return</span> DISCARD_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到集合添加、删除元素和字典是有些相似的，毕竟底层都是使用了hash表嘛。</strong></p>
<h4 id="集合的运算-交集"><a href="#集合的运算-交集" class="headerlink" title="集合的运算(交集)"></a>集合的运算(交集)</h4><p><strong>在python中使用集合的时候，可以取两个集合的交集、并集、差集、对称差集等等，这里介绍一下交集，其余的可以自行看源码研究<code>(Objects/setobject.c)</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_intersection</span><span class="params">(PySetObject *so, PyObject *other)</span></span><br><span class="line">&#123;	    </span><br><span class="line">    <span class="comment">//result，显然是用来存储两者交集运算的结果的</span></span><br><span class="line">    PySetObject *result;</span><br><span class="line">    <span class="comment">//不看下面代码的话，很难知道这几个PyObject * 是用来干啥的</span></span><br><span class="line">    <span class="comment">//我们下面代码再看看这是干啥的</span></span><br><span class="line">    PyObject *key, *it, *tmp;</span><br><span class="line">    <span class="comment">//这个肯定是hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果两个对象一样</span></span><br><span class="line">    <span class="keyword">if</span> ((PyObject *)so == other)</span><br><span class="line">        <span class="comment">//直接返回其中一个的拷贝即可</span></span><br><span class="line">        <span class="keyword">return</span> set_copy(so);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这行代码表示创建一个空的PySetObject *</span></span><br><span class="line">    result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果result == NULL，说明创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测other是不是PySetObject *</span></span><br><span class="line">    <span class="keyword">if</span> (PyAnySet_Check(other)) &#123;</span><br><span class="line">        <span class="comment">//初始索引为0</span></span><br><span class="line">        Py_ssize_t pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//setentry *</span></span><br><span class="line">        setentry *entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果other元素的个数大于so</span></span><br><span class="line">        <span class="keyword">if</span> (PySet_GET_SIZE(other) &gt; PySet_GET_SIZE(so)) &#123;</span><br><span class="line">            <span class="comment">//就把so和other进行交换</span></span><br><span class="line">            tmp = (PyObject *)so;</span><br><span class="line">            so = (PySetObject *)other;</span><br><span class="line">            other = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从少的那一方的开头开始便利</span></span><br><span class="line">        <span class="keyword">while</span> (set_next((PySetObject *)other, &amp;pos, &amp;entry)) &#123;</span><br><span class="line">            <span class="comment">//拿到key和hash</span></span><br><span class="line">            key = entry-&gt;key;</span><br><span class="line">            hash = entry-&gt;hash;</span><br><span class="line">            <span class="comment">//传入other的key和hash，在so中去找</span></span><br><span class="line">            rv = set_contains_entry(so, key, hash);</span><br><span class="line">            <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果对应的rv不存在，那么显然就没有</span></span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">                <span class="comment">//存在的话设置进result里面</span></span><br><span class="line">                <span class="keyword">if</span> (set_add_entry(result, key, hash)) &#123;</span><br><span class="line">                    Py_DECREF(result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果不是PyObject *</span></span><br><span class="line">    <span class="comment">//那么获取其对应的迭代器，相当于python中的__iter__</span></span><br><span class="line">    it = PyObject_GetIter(other);</span><br><span class="line">    <span class="comment">//如果是NULL，降低其引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="comment">//返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面的没必要分析了，在python中，只能set和set(或者frozenset)之间才可以取交集</span></span><br><span class="line">    <span class="keyword">while</span> ((key = PyIter_Next(it)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        rv = set_contains_entry(so, key, hash);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set_add_entry(result, key, hash))</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">  error:</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    Py_DECREF(result);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合小结"><a href="#集合小结" class="headerlink" title="集合小结"></a>集合小结</h4><p><strong>可以看到，剖析集合的时候话很少。主要是有了剖析字典的经验，因此再剖析集合的时候就很简单了。并且在Python中还有一个frozenset，就是不可变的集合。但是不像列表和元组，元组还是有很多特殊的，并不单单只是不可变的列表，从具有自己独自的结构体就能看出来。而frozenset对象和set对象都是一个结构体，只有一个PySetObject，没有PyFrozenSetObject。我们在看PySetObject的时候，发现里面有一个hash成员，如果是frozenset的话，那么hash值是不为-1的，因为它不可以添加、删除元素，是不可变对象。由于比较相似，因此frozenset就不再说了，可以自己源码中研究，位置还是<code>Object/setobject.c</code>。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>14-函数在底层的数据结构以及创建方式</title>
    <url>/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="14-函数在底层的数据结构、以及它的创建方式"><a href="#14-函数在底层的数据结构、以及它的创建方式" class="headerlink" title="14-函数在底层的数据结构、以及它的创建方式"></a>14-函数在底层的数据结构、以及它的创建方式</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>函数是任何一门编程语言都具备的基本元素，它可以将多个动作组合起来，一个函数代表了一系列的动作。当然我们之前说函数也是一个变量，该变量指向一个函数。而且在调用函数时会干什么来着，没错，要在运行时栈中创建栈帧，用于函数的执行。</strong></p>
<p><strong>那么下面就来看看函数在C中是如何实现的，生得一副什么模样。</strong></p>
<h3 id="PyFunctionObject对象"><a href="#PyFunctionObject对象" class="headerlink" title="PyFunctionObject对象"></a>PyFunctionObject对象</h3><p><strong>我们说过Python中一切皆对象，函数也不例外。在Python中，函数这种抽象机制是通过<code>PyFunctionObject</code>对象实现的，位于 *Include&#x2F;funcobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD               <span class="comment">/* 头部信息, 不用多说 */</span></span><br><span class="line">    PyObject *func_code;        <span class="comment">/* 函数的PyCodeObject对象, 因为函数就是根据该PyCodeObject对象创建的 */</span></span><br><span class="line">    PyObject *func_globals;     <span class="comment">/* 函数的global名字空间 */</span></span><br><span class="line">    PyObject *func_defaults;    <span class="comment">/* 函数参数的默认值, 一个元组或者空 */</span></span><br><span class="line">    PyObject *func_kwdefaults;  <span class="comment">/* 只能通过关键字参数传递的&quot;参数&quot;和&quot;该参数的默认值&quot;, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_closure;     <span class="comment">/* 获取闭包对象 */</span></span><br><span class="line">    PyObject *func_doc;         <span class="comment">/* 函数的doc */</span></span><br><span class="line">    PyObject *func_name;        <span class="comment">/* 函数名 */</span></span><br><span class="line">    PyObject *func_dict;        <span class="comment">/* 属性字典, 一般为空 */</span></span><br><span class="line">    PyObject *func_weakreflist; <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">    PyObject *func_module;      <span class="comment">/* 函数所在的模块 */</span></span><br><span class="line">    PyObject *func_annotations; <span class="comment">/* 函数参数的注解, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_qualname;    <span class="comment">/* 函数的全限定名, 我们后面会说它和func_name之间的区别 */</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant:</span></span><br><span class="line"><span class="comment">     *     func_closure contains the bindings for func_code-&gt;co_freevars, so</span></span><br><span class="line"><span class="comment">     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</span></span><br><span class="line"><span class="comment">     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyFunctionObject;</span><br></pre></td></tr></table></figure>

<p><strong>PyFunctionObject的这些成员都是以func开头的，比如：func_name，但是我们在Python中获取的时候直接通过__name__获取即可。</strong></p>
<p><strong>func_code：函数的字节码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = foo.__code__</span><br><span class="line"><span class="built_in">print</span>(code)  <span class="comment"># &lt;code object foo at 0x000001D250B9D3A0, file &quot;C:/Users/satori/Desktop/三无少女/2.py&quot;, line 1&gt;</span></span><br><span class="line"><span class="built_in">print</span>(code.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>func_globals：global命名空间</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="comment"># __globals__其实就是外部的global名字空间</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__)  <span class="comment"># &#123;......, &#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__ == <span class="built_in">globals</span>())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>func_defaults：函数参数的默认值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是默认值</span></span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)  <span class="comment"># (&#x27;夏色祭&#x27;, -1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(): </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有默认值的话, __defaults__为None</span></span><br><span class="line"><span class="built_in">print</span>(bar.__defaults__)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>func_kwdefaults：只能通过关键字参数传递的”参数”和”该参数的默认值”</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印是为None的, 这是因为虽然有默认值, 但是它并不要求必须通过关键字的方式传递</span></span><br><span class="line"><span class="built_in">print</span>(foo.__kwdefaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在前面加上一个*, 表示后面的参数就必须通过关键字的方式传递</span></span><br><span class="line"><span class="comment"># 因为如果不通过关键字的话, 那么无论多少个位置参数都会被*给吸收掉, 无论如何也不可能传递给name、age</span></span><br><span class="line"><span class="comment"># 我们经常会看到*args, 这是因为我们需要函数调用时传递过来的值, 所以可以通过args以元组的形式来拿到这些值</span></span><br><span class="line"><span class="comment"># 但是这里我们不需要, 我们只是希望后面的参数必须通过关键字参数传递, 因此前面写一个*即可</span></span><br><span class="line"><span class="comment"># 当然写*args或者其他的也可以, 但是我们用不到, 所以写一个*即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">*, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时就打印了默认值，因为这是只能通过kw(关键字)传递的参数的默认值</span></span><br><span class="line"><span class="built_in">print</span>(bar.__kwdefaults__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;satori&#x27;, &#x27;age&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_closure：闭包对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="keyword">nonlocal</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看的是闭包里面nonlocal的值</span></span><br><span class="line"><span class="comment"># 这里有两个nonlocal，所以foo().__closure__是一个有两个元素的元组</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__)  <span class="comment"># (&lt;cell at 0x000001FD1D3B02B0: int object at 0x00007FFDE559D660&gt;,</span></span><br><span class="line">                          <span class="comment"># &lt;cell at 0x000001FD1D42E310: str object at 0x000001FD1D3DA090&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">1</span>].cell_contents)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：查看闭包属性我们使用的是内层函数，不是外层的foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_doc：函数的文档</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span>, age is <span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__doc__)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_name：函数名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_dict：属性字典</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般函数的属性字典都会空，属性字典基本上在类里面使用</span></span><br><span class="line"><span class="built_in">print</span>(foo.__dict__)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_weakreflist：弱引用列表</strong></p>
<p><strong>Python无法获取这个属性，底层没有提供相应的接口。</strong></p>
<p><strong>func_module：函数所在的模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__module__)  <span class="comment"># __main__</span></span><br></pre></td></tr></table></figure>

<p><strong>func_annotations：注解</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name: <span class="built_in">str</span>, age: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.5的时候新增的语法</span></span><br><span class="line"><span class="built_in">print</span>(foo.__annotations__)  <span class="comment"># &#123;&#x27;name&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;age&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_qualname：全限定名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__, foo.__qualname__)  <span class="comment"># foo foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.foo.__name__, A.foo.__qualname__)  <span class="comment"># foo A.foo</span></span><br></pre></td></tr></table></figure>

<p><strong>在PyFunctionObject的定义中，我们看到一个func_code成员，指向了一个PyCodeObject对象，我们说函数就是根据这个PyCodeObject对象创建的。因为我们知道一个PyCodeObject对象是对一段代码的静态表示，Python编译器在将源代码进行编译之后，对里面的每一个代码块<code>(code block)</code>都会生成一个、并且是唯一一个PyCodeObject对象，这个PyCodeObject对象中包含了这个代码块中的一些静态信息，也就是可以从源代码中看到的信息。</strong></p>
<blockquote>
<p><strong>比如：某个函数对应的code block中有一个 name &#x3D; “夏色祭” 这样的表达式，那么符号”a”和对应的值1、以及它们之间的联系就是静态信息。这些信息会被静态存储起来，符号”a”会被存在符号表<code>co_varnames</code>中、值1会被存在常量池<code>co_consts</code>中、这两者之间是一个赋值，因此会有两条指令LOAD_CONSTS和STORE_FAST存在字节码指令序列<code>co_code</code>中。</strong></p>
<p><strong>这些信息是编译的时候就可以得到的，因此PyCodeObject对象是编译时候的结果。</strong></p>
</blockquote>
<p><strong>但是PyFunctionObject对象是何时产生的呢？实际上PyFunctionObject对象是Python代码在运行时动态产生的，更准确的说，是在执行一个def语句的时候创建的。</strong></p>
<blockquote>
<p><strong>当Python虚拟机在当前栈帧中执行字节码时发现了def语句，那么就代表发现了新的PyCodeObject对象，因为它们是可以层层嵌套的。所以虚拟机会根据这个PyCodeObject对象创建对应的PyFunctionObject对象，然后将函数名和函数体对应的PyFunctionObject对象组成键值对放在当前的local空间中。</strong></p>
<p><strong>显然在PyFunctionObject对象中，也会包含这些函数的静态信息，这些信息存储在func_code中，实际上，func_code一定会指向与函数对应的PyCodeObject对象。除此之外，PyFunctionObject对象中还包含了一些函数在执行时所必须的动态信息，即上下文信息。比如func_globals，就是函数在执行时关联的global作用域(globals)，说白了就是让你在局部变量找不到的时候能够找全局变量，可如果连global空间都没有的话，那即便想找也无从下手呀。而global作用域中的符号和值必须在运行时才能确定，所以这部分必须在运行时动态创建，无法存储在PyCodeObject中，所以要根据PyCodeObject对象创建PyFunctionObject对象，相当于一个封装。总之一切的目的，都是为了更好的执行字节码。</strong></p>
</blockquote>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先虚拟机从上到下执行字节码</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pia, 出现了一个def</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么知道源代码进入了一个新的作用域了, 这里遇到一个新的PyCodeObject对象了</span></span><br><span class="line"><span class="comment"># 而通过def知道这是一个函数, 所以会进行封装, 将PyCodeObject对象封装成PyFunctionObject</span></span><br><span class="line"><span class="comment"># 所以当执行完def语句之后, 一个函数就被创建了, 放在当前的local空间中, 当然对于模块来说: local空间也是global空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;......, &#x27;foo&#x27;: &lt;function foo at 0x000001B299FAF3A0&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的类型是&lt;class &#x27;function&#x27;&gt;, 当然这个类Python没有暴露给我们</span></span><br><span class="line"><span class="comment"># 当我们调用函数foo的时候, 会从local空间中取出符号&quot;foo&quot;对应的PyFunctionObject对象</span></span><br><span class="line"><span class="comment"># 然后根据这个PyFunctionObject对象创建PyFrameObject对象, 也就是为函数创建一个栈帧</span></span><br><span class="line"><span class="comment"># 然后将执行权交给新创建的栈帧, 在新创建的栈帧中执行字节码</span></span><br></pre></td></tr></table></figure>

<h4 id="PyFrameObject和PyFunctionObject对象的区别与联系"><a href="#PyFrameObject和PyFunctionObject对象的区别与联系" class="headerlink" title="PyFrameObject和PyFunctionObject对象的区别与联系"></a>PyFrameObject和PyFunctionObject对象的区别与联系</h4><p><code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器内部用于实现函数调用和执行的两个重要数据结构。它们之间有以下区别和联系：</p>
<ol>
<li>区别：</li>
</ol>
<ul>
<li><code>PyFrameObject</code>表示Python解释器的执行栈帧，包含了函数调用时的局部变量、参数、返回值等信息。每当Python解释器执行一个函数时，就会在执行栈上创建一个新的<code>PyFrameObject</code>，并将该栈帧推入执行栈中。当函数执行完毕时，该栈帧将被弹出执行栈。</li>
<li><code>PyFunctionObject</code>表示Python中的函数对象，包含了函数的代码、参数、默认值等信息。每当Python解释器遇到一个函数定义时，就会创建一个新的<code>PyFunctionObject</code>对象，并将其保存在内存中。在函数调用时，Python解释器会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上，从而完成函数调用。</li>
</ul>
<ol>
<li>联系：</li>
</ol>
<p><code>PyFrameObject</code>和<code>PyFunctionObject</code>之间存在密切的联系，因为它们一起实现了Python解释器中的函数调用和执行过程。具体来说，当Python解释器执行一个函数时，它会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上。在函数执行过程中，<code>PyFrameObject</code>对象将存储函数的局部变量、参数和返回值等信息，并通过Python解释器的执行栈来管理函数调用的层次关系。当函数执行完毕时，Python解释器会弹出执行栈，并将<code>PyFrameObject</code>对象从内存中释放掉。</p>
<p>总的来说，<code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器中实现函数调用和执行的两个重要数据结构。<code>PyFrameObject</code>用于存储函数调用时的局部变量、参数和返回值等信息，而<code>PyFunctionObject</code>用于存储函数的代码、参数和默认值等信息。它们之间紧密地协作，以实现Python函数的调用和执行过程。</p>
<h3 id="函数对象如何创建"><a href="#函数对象如何创建" class="headerlink" title="函数对象如何创建"></a>函数对象如何创建</h3><p><strong>我们现在已经看清了函数的模样，它在底层对应PyFunctionObject对象，并且它和PyCodeObject对象关系密切。那么Python底层又是如何完成PyCodeObject对象到PyFunctionObject对象之间的转变呢？想了解这其中的奥秘，就必须要从字节码入手。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然这个代码中出现了两个PyCodeObject对象，一个对应整个py文件，另一个则是对应函数foo。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把字符串当成是一个py文件来进行编译</span></span><br><span class="line">co = <span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  </span><br><span class="line"><span class="comment"># (&#x27;夏色祭&#x27;, &lt;code object foo at 0x00000183F9101450, file &quot;func&quot;, line 3&gt;, &#x27;foo&#x27;, 1, 2, None)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_name)  <span class="comment"># &lt;module&gt;</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts[<span class="number">1</span>].co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，”函数foo对应的PyCodeObject对象”是”py文件对应的PyCodeObject对象”的常量池co_consts中的一个元素。因为在对py文件创建PyCodeObject对象的时候，发现了一个函数代码块foo，那么会对函数代码块foo继续创建一个PyCodeObject对象(每一个代码块都会对应一个PyCodeObject对象)，而函数foo对应的PyCodeObject对象则是py文件对应的PyCodeObject对象的co_consts常量池当中的一个元素。</strong></p>
<blockquote>
<p><strong>通过以上例子，我们发现PyCodeObject对象是嵌套的。之前我们我们说过，每一个code block<code>(函数、类等等)</code>都会对应一个PyCodeObject对象。现在我们又看到了，根据层级来分的话，”内层代码块对应的PyCodeObject对象”是”最近的外层代码块对应的PyCodeObject对象”的常量池co_consts中的一个元素。而最外层则是模块对应的PyCodeObject对象，因此这就意味着我们通过最外层的PyCodeObject对象可以找到所有的PyCodeObject对象，显然这是毋庸置疑的。而这里和栈帧也是对应的，栈帧我们说过也是层层嵌套的，而内层栈帧通过f_back可以找到外层、也就是调用者对应的栈帧，当然这里我们之前的章节已经说过了，这里再提一遍。</strong></p>
</blockquote>
<p><strong>这里再来重新看一下上面的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然dis模块自动帮我们分成了两部分，上面是模块的字节码，下面是函数的字节码。首先函数很简单我们就不看了，直接看模块的。</strong></p>
<p><strong>首先开头的LOAD_CONST和STORE_NAME显然是 name &#x3D; “夏色祭” 对应的指令。然后我们看<code>4 LOAD_CONST</code>，这条指令也是加载了一个常量，但这个常量是一个PyCodeObject对象；<code>6 LOAD_CONST</code>则是将字符串常量”foo”、即函数名加载了进来，然后通过MAKE_FUNCTION指令构建一个PyFunctionObject对象；然后<code>10 STORE_NAME</code>，让符号foo指向这个PyFunctionObject对象。再下面就是函数调用了，函数调用的具体细节我们之后会详细说。</strong></p>
<p><strong>并且我们还看到一个有趣的现象，那就是源代码的行号。我们发现之前看到源代码的行号都是从上往下、依次增大的，这很好理解，毕竟一条一条解释嘛。但是这里却发生了变化，先执行了第6行，之后再执行第4行。如果是从Python层面的函数调用来理解的话，很容易一句话就解释了，因为函数只有在调用的时候才会执行。但是从字节码的角度来理解的话，我们发现函数的声明和实现是分离的，是在不同的PyCodeObject对象中。确实如此，虽然一个函数名和函数体是一个整体，但是Python虚拟机在实现这个函数的时候，却在物理上将它们分离开了，构建函数的字节码指令序列必须在模块对应的PyCodeObject对象中。</strong></p>
<blockquote>
<p><strong>我们之前说过，函数即变量。我们是可以把函数当成是普通的变量来处理的，函数名就相当于变量名，函数体就相当于是变量指向的值。而foo函数显然是在全局中定义的一个函数，那么foo是不是要出现在py文件对应的PyCodeObject对象的符号表co_names里面呢？foo对应的PyCodeObject对象是不是要出现在py文件对应的PyCodeObject对象的常量池co_consts里面呢？</strong></p>
</blockquote>
<p><strong>至此，函数的结构就已经非常清晰了。</strong></p>
<p><img src="/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/1229382-20200822015055004-867736003.png" alt="img"></p>
<p><strong>所以函数名和函数体是分离的，它们存在不同的PyCodeObject对象当中。分析完结构之后，我们的重点就在于那个MAKE_FUNCTION指令了，我们说当遇到<code>def foo(a, b)</code>的时候，在语法上将这是函数的声明语句，但是从虚拟机的角度来看这其实是函数对象的创建语句。所以下面我们就要分析一下这个指令，看看它到底是怎么将一个PyCodeObject对象变成一个PyFunctionObject对象的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(MAKE_FUNCTION)</span>: &#123;</span><br><span class="line">    PyObject *qualname = POP(); <span class="comment">//弹出符号表中的函数名</span></span><br><span class="line">    PyObject *codeobj = POP();  <span class="comment">//弹出对应的字节码对象</span></span><br><span class="line">    <span class="comment">//创建PyFunctionObject对象, 接收三个参数, 首先第一个参数和第三个参数很好理解, 但重点是第二个参数</span></span><br><span class="line">    <span class="comment">//首先f指的就是当前所在的栈帧, 对于我们目前这个里而言就是模块、或者py文件对应的栈帧</span></span><br><span class="line">    <span class="comment">//然后将f_globals、也就是global名字空间传递了进去, 所以我们现在明白了为什么函数可以调用__globals__了</span></span><br><span class="line">    <span class="comment">//当然也明白为什么函数可以在局部变量找不到的时候去找全局变量了</span></span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//下面是设置闭包、注解、参数默认值等属性</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//将函数或者说函数对象压入运行时栈</span></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在MAKE FUNCTION之前，先进行了LOAD  CONST，显然是将foo对应的字节码对象和符号foo压入到了栈中。所以在执行MAKE  FUNCTION的时候，首先就是将这个字节码对象以及对应符号弹出栈，然后再加上当前PyFrameObject对象中维护的global名字空间f_globals对象，三者作为参数传入PyFunction_NewWithQualName函数中，从而构建出相应的PyFunctionObject对象。</strong></p>
<p><strong>下面我们来看看PyFunction_NewWithQualName是如何构造出一个函数的，它位于 *Objects&#x2F;funcobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFunction_NewWithQualName</span><span class="params">(PyObject *code, PyObject *globals, PyObject *qualname)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//要返回的PyFunctionObject *, 这里先声明一下</span></span><br><span class="line">    PyFunctionObject *op;</span><br><span class="line">    <span class="comment">//函数的doc、PyCodeObject的co_consts、函数所在的模块</span></span><br><span class="line">    PyObject *doc, *consts, *module;</span><br><span class="line">    <span class="type">static</span> PyObject *__name__ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        __name__ = PyUnicode_InternFromString(<span class="string">&quot;__name__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyObject_GC_New为函数对象申请空间</span></span><br><span class="line">    op = PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面就是设置PyFunctionObject对象的成员属性了</span></span><br><span class="line">    op-&gt;func_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(code);</span><br><span class="line">    op-&gt;func_code = code;</span><br><span class="line">    Py_INCREF(globals);</span><br><span class="line">    op-&gt;func_globals = globals;</span><br><span class="line">    op-&gt;func_name = ((PyCodeObject *)code)-&gt;co_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_name);</span><br><span class="line">    op-&gt;func_defaults = <span class="literal">NULL</span>; <span class="comment">/* No default arguments */</span></span><br><span class="line">    op-&gt;func_kwdefaults = <span class="literal">NULL</span>; <span class="comment">/* No keyword only defaults */</span></span><br><span class="line">    op-&gt;func_closure = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;vectorcall = _PyFunction_Vectorcall;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyCodeObject对象获取常量池</span></span><br><span class="line">    consts = ((PyCodeObject *)code)-&gt;co_consts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们知道函数的doc其实就是一个字符串, 显然它也是常量池的一个常量, 并且是常量池的第一个元素</span></span><br><span class="line">    <span class="comment">//否则的话它就是不能成为doc</span></span><br><span class="line">    <span class="keyword">if</span> (PyTuple_Size(consts) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//所以如果consts&gt;=1, 并且第一个元素是字符串, 那么它就是函数的doc</span></span><br><span class="line">        doc = PyTuple_GetItem(consts, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!PyUnicode_Check(doc))</span><br><span class="line">            doc = Py_None;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则doc就是None</span></span><br><span class="line">        doc = Py_None;</span><br><span class="line">    Py_INCREF(doc);</span><br><span class="line">    <span class="comment">//下面也是设置PyFunctionObject对象的成员</span></span><br><span class="line">    op-&gt;func_doc = doc;</span><br><span class="line"></span><br><span class="line">    op-&gt;func_dict = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_module = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_annotations = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __module__: If module name is in globals, use it.</span></span><br><span class="line"><span class="comment">       Otherwise, use None. */</span></span><br><span class="line">    module = PyDict_GetItemWithError(globals, __name__);</span><br><span class="line">    <span class="keyword">if</span> (module) &#123;</span><br><span class="line">        Py_INCREF(module);</span><br><span class="line">        op-&gt;func_module = module;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qualname)</span><br><span class="line">        op-&gt;func_qualname = qualname;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op-&gt;func_qualname = op-&gt;func_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_qualname);</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以通过MAKE_FUNCTION我们便创建了PyFunctionObject对象，然后它会被压入栈中，再通过STORE_NAME将符号foo和PyFunctionObject对象组成一个entry，存储在当前栈帧的local名字空间中，当然也是global名字空间。只不过为了和函数保持统一，我们都说成local名字空间，只不过不同的作用域对应的local空间是不一样的。</strong></p>
<p><strong>当然了我们说函数对象的类型是<code>&lt;class &#39;function&#39;&gt;</code>，但是这个类底层没有暴露给我们，但是我们依旧可以通过曲线救国的方式进行获取。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="comment"># lambda匿名函数的类型也是&lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="keyword">lambda</span>: <span class="literal">None</span>))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们可以仿照底层的思路，通过<code>&lt;class &#39;function&#39;&gt;</code>来创建一个函数对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到PyCodeObject对象</span></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="comment"># 根据class function创建函数对象, 接收三个参数: PyCodeObject对象、名字空间、函数名</span></span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, <span class="built_in">globals</span>(), <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f.__name__)  <span class="comment"># 根据f创建的new_f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>是不是很神奇呢？另外我们说函数在访问gender指向的对象时，显然先从自身的符号表中找，如果没有那么回去找全局变量。这是因为，我们在创建函数的时候将global名字空间传进去了，如果我们不传递呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f = <span class="built_in">type</span>(f)(code, <span class="literal">None</span>, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function() argument &#x27;globals&#x27; must be dict, not None</span></span><br><span class="line"><span class="comment"># 这里告诉我们function的第二个参数globals必须是一个字典</span></span><br><span class="line"><span class="comment"># 我们传递一个空字典</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f1.__name__)  <span class="comment"># 根据f创建的new_f1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(new_f1(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;gender&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到告诉我们gender没有定义</span></span><br></pre></td></tr></table></figure>

<p><strong>因此现在我们又在Python的角度上理解了一遍，为什么Python中的函数能够在局部变量找不到的时候，去找全局变量，原因就在于构建函数的时候，将global名字空间交给了函数。使得函数可以在global空间进行变量查找，所以它才能够找到全局变量。而我们这里给了一个空字典，那么显然就找不到gender这个变量了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;萌妹子&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以手动传递一个字典进去, 此时我们传递的字典对于函数来说就是global名字空间</span></span><br><span class="line"><span class="comment"># 所以在函数内部找不到某个变量的时候, 就会去我们指定的名字空间中找</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: 萌妹子</span></span><br><span class="line"><span class="comment"># 所以此时的gender不再是外部的&quot;female&quot;, 而是我们指定的&quot;萌妹子&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此外我们还可以为函数指定默认值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须接收一个PyTupleObject对象</span></span><br><span class="line">new_f.__defaults__ = (<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"><span class="comment"># 即使我们不传递参数, 也是完全可以的, 因为已经有默认值了</span></span><br><span class="line"><span class="built_in">print</span>(new_f())  <span class="comment"># name: 神乐mea, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以指定部分默认参数</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"><span class="comment"># 这里的在设置默认值的时候是从后往前设置的, 比如: (&quot;神乐mea&quot;, 38)</span></span><br><span class="line"><span class="comment"># 是将38设置为age的默认值, &quot;神乐mea&quot;设置为name的默认值</span></span><br><span class="line"><span class="comment"># 所以这里的(38,) , 会将38设置为age的默认值, 不是name</span></span><br><span class="line"><span class="comment"># 那name怎么办? 如果没有对应的默认值了, 那么它就必须在函数调用的时候由我们显式的传递</span></span><br><span class="line">new_f1.__defaults__ = (<span class="number">38</span>,)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f1()</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># f() missing 1 required positional argument: &#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_f1(<span class="string">&quot;神楽めあ&quot;</span>))  <span class="comment"># name: 神楽めあ, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">但是问题来了, 为什么在设置默认值的时候要从后往前呢?</span></span><br><span class="line"><span class="string">首先如果默认值的个数和参数的个数正好匹配, 那么相安无事, 如果不匹配那么只能是默认值的个数小于参数个数</span></span><br><span class="line"><span class="string">如果是从后往前, 那么(38,)就意味着38设置为age的默认值, name就必须由我们在调用的时候传递</span></span><br><span class="line"><span class="string">但如果是从前往后, 那么(38,)就意味着38设置为name的默认值, age就必须由我们在调用的时候来传递</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是问题来了, 如果38设置为name的默认值, 这会是什么情况? 显然等价于:</span></span><br><span class="line"><span class="string">def new_f1(name=38, age):</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">你认为这样的函数能够通过编译吗?显然是不行的, 因为默认参数必须在非默认参数的后面</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 所以Python的这个做法是完全正确的, 必须要从后往前进行设置</span></span><br></pre></td></tr></table></figure>

<p><strong>当然，这种设置默认值的方式显然也可以使用于通过def定义的函数，因为我们上面的new_f、new_f1和f都是<code>&lt;class &#39;function&#39;&gt;</code>对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认值</span></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你用的是pycharm, 那么会在f()这个位置给你做上标记, 提示你参数没有传递</span></span><br><span class="line"><span class="comment"># 但我们知道由于使用__defaults__已经设置了默认值, 所以这里是不会报错的, 只不过pycharm没有检测到, 当然基本上所有的ide都无法做到这一点</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>另外我们说，默认值的个数一定要小于等于参数的个数，但如果大于呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>, <span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 神乐mea, age: 38, gender: female</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依旧从后往前, 38给age、&quot;神乐mea&quot;给name</span></span><br><span class="line"><span class="comment"># 参数都有默认值了, 那么就结束了</span></span><br><span class="line"><span class="comment"># 当然如果是__defaults__指向的元组先结束, 那么没有得到默认值的参数就必须由我们来传递了</span></span><br></pre></td></tr></table></figure>

<p>​        *<em>想不到Python中的函数可以玩出这么多新花样，现在你是不是对函数有了一个更深刻的认识了呢？当然目前介绍的只是函数的一小部分内容，还有函数如何调用、位置参数和关键字参数如何解析、对于有默认值的参数如何在我们不传递的时候使用默认值以及在我们传递的时候使用我们传递的值、*args和*<em>kwargs又如何解析、闭包怎么做到的、还有装饰器等等等等，这些我们接下来会单独用几篇博客详细说。</em></em>    </p>
<p>​        <strong>因为放在一篇博客里面的话，字数至少要好几万，而我使用的Markdown编辑器typora在字数达到一万五的时候就会出现明显卡顿，要是一下子都写完的话，绝对卡到爆，而且越往后越卡，这对我而言也是个痛苦。而且函数的内容也比较多，我们就多用一些篇幅去介绍它吧。</strong>    </p>
<h3 id="判断函数都有哪些参数"><a href="#判断函数都有哪些参数" class="headerlink" title="判断函数都有哪些参数"></a>判断函数都有哪些参数</h3><p><strong>最后我们再来看看我们如何检测一个函数有哪些参数，首先函数的局部变量<code>(包括参数)</code>在编译是就已经确定，会存在符号表co_varnames中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意: 在定义函数的时候*和**最多只能出现一次</span></span><br><span class="line"><span class="comment"># 显然a和b必须通过位置参数传递</span></span><br><span class="line"><span class="comment"># c和d可以通过位置参数或者关键字参数传递</span></span><br><span class="line"><span class="comment"># e和f必须通过关键字参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *args, e, f, **kwargs</span>):</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    h = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">varnames = f.__code__.co_varnames</span><br><span class="line"><span class="built_in">print</span>(varnames)</span><br><span class="line"><span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;args&#x27;, &#x27;kwargs&#x27;, &#x27;g&#x27;, &#x27;h&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先co_varnames打印的符号表是有顺序的, 参数永远在函数内部定义的局部变量的前面</span></span><br><span class="line"><span class="string">g和h就是函数内部定义的局部变量, 所以它在所有的后面</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果是参数的话, 那么*和**会位于最后面, 其它参数位置不变, 所以除了g和h, 最后面的就是args和kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 我们就可以进行判断了</span></span><br><span class="line"><span class="comment"># 1. 寻找必须通过位置参数传递的参数</span></span><br><span class="line">posonlyargcount = f.__code__.co_posonlyargcount</span><br><span class="line"><span class="built_in">print</span>(posonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: posonlyargcount])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 寻找可以通过位置参数传递或者关键字参数传递的参数</span></span><br><span class="line">argcount = f.__code__.co_argcount</span><br><span class="line"><span class="built_in">print</span>(argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: <span class="number">4</span>])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(varnames[posonlyargcount: <span class="number">4</span>])  <span class="comment"># (&#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 寻找必须通过关键字参数传递的参数</span></span><br><span class="line">kwonlyargcount = f.__code__.co_kwonlyargcount</span><br><span class="line"><span class="built_in">print</span>(kwonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[argcount: argcount + kwonlyargcount])  <span class="comment"># (&#x27;e&#x27;, &#x27;f&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 寻找*args和**kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在介绍PyCodeObject对象的时候, 我们说里面有一个co_flags成员</span></span><br><span class="line"><span class="string">它是专门用来判断参数中是否有*args和**kwargs的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flags = f.__code__.co_flags</span><br><span class="line"><span class="comment"># 如果flags和4进行按位与之后为真, 那么就代表有*args, 否则没有</span></span><br><span class="line"><span class="comment"># 如果flags和8进行按位与之后为真, 那么就代表有**kwargs, 否则没有</span></span><br><span class="line">step = argcount + kwonlyargcount</span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x04</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># args</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x08</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># kwargs</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 虽然我们这里打印的是args和kwargs, 但主要取决定义的时候使用的名字</span></span><br><span class="line"><span class="comment"># 如果定义的时候是*ARGS和**KWARGS, 那么这里就是ARGS和KWARGS, 只不过一般我们都叫做*args和**kwargs</span></span><br></pre></td></tr></table></figure>

<p><strong>如果我们定义的不是*args，只是一个*，那么它就不是参数了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到此时只有a、b、c</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x04</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x08</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 显然此时也都为假</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们简单的分析了一下函数在底层对应的数据结构，以及如何创建一个函数，并且还在Python的层面上做了一些小trick。最后我们也分析了如何通过PyCodeObject对象来检索Python中的参数，以及相关种类，当然标准库中的inspect模块也是这么做的。当然说白了，其实是我们模仿人家的思路做的。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>16-闭包的底层实现</title>
    <url>/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="16-闭包的底层实现以及调用"><a href="#16-闭包的底层实现以及调用" class="headerlink" title="16-闭包的底层实现以及调用"></a>16-闭包的底层实现以及调用</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>上一篇我们看了函数是如何调用的，这一次我们看一下函数中局部变量的访问、以及闭包相关的知识。</strong></p>
<h3 id="函数中局部变量的访问"><a href="#函数中局部变量的访问" class="headerlink" title="函数中局部变量的访问"></a>函数中局部变量的访问</h3><p><strong>我们说过函数的参数和函数内部定义的变量都属于局部变量，所以它也一样是通过静态的方式进行访问。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a和b是局部变量，x是全局变量，因此是2</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_nlocals)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar2</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar2.__code__.co_nlocals)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到，无论是参数还是内部新创建的变量，本质上都是局部变量。并且我们发现如果函数内部定义的变量如果和函数参数一致，那么参数就没用了，很好理解，因为本质上就相当于重新赋值罢了，此时外面无论给bar2函数的a、b参数传递什么，最终都会变成1和2。所以其实局部变量的实现机制和函数参数的实现机制是一致的。</strong></p>
<p><strong>按照我们的理解，当访问一个全局变量的时候，会去访问 global 名字空间，而这也确实如此。但是当访问函数内的局部变量的时候，是不是访问其内部的 local 名字空间呢？ 之前我们说过 Python 变量的访问是有规则的，按照<code>本地</code>、<code>闭包</code>、<code>全局</code>、<code>内置</code>的顺序去查找，所以首当其冲当然去 local 名字空间去查找啊。但不幸的是，在调用函数期间，Python 通过 <code>_PyFrame_New_NoTrack</code> 创建 PyFrameObject 对象时，这个至关重要的 local 名字空间并没有被创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在前面对函数调用时的 global 名字空间的解析中，我们看到，当 Python 虚拟机执行 <code>xxx.py</code> 的时候，f_locals 和 f_globals 指向的是同一个 PyDictObject 对象，然而现在在函数里面 f_locals 则变成了NULL，那么的话，那些重要的符号到底存储在什么地方呢？<code>(显然我们知道是符号表co_varnames中, 但你们就装作不知道配合我一下好吧(#^.^#))</code>。别急，我们先来看看使用局部变量的函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>看一下它的字节码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x0000013E31511450</span>, file <span class="string">&quot;local&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">3</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">16</span> POP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_CONST               <span class="number">4</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">20</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x0000013E31511450</span>, file <span class="string">&quot;local&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">4</span> BINARY_ADD</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">2</span> (c)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">2</span> (c)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们说 f_localsplus  这段内存虽然是连续的，但它是给四个老铁使用的，分别是：局部变量、cell对象、free对象、运行时栈，而我们看到字节码偏移量为 6 和 10  的两条指令分别是：STORE_FAST 和 LOAD_FAST，所以它和我们之前分析参数的时候是一样的，都是存储在 f_localsplus  中运行时栈前面的那段内存中。</strong></p>
<p><strong>此时我们对局部变量 c  的藏身之处已经了然于心。但是为什么在函数的实现中没有使用 local  名字空间呢？其实函数内部的局部变量有多少，在编译的时候就已经确定了，个数是不会变的。因此编译时就能确定局部变量使用的内存空间位置，也能确定访问局部变量的字节码指令应该如何访问内存。有了这些信息，Python 就能使用静态的方法来实现局部变量的查找，而不需要借助于动态查找 PyDictObject 对象的技术，尽管 PyDictObject  是被高度优化的，但肯定没有静态的方法快啊，而且 Python  里面函数是对象，也是一等公民，并且函数使用的太普遍了。至于在后面的类的剖析中，由于类的特殊性，无论是类的实例对象、还是类对象本身，都是可以在运行时动态修改属性的，那么我们知道显然 Python 就不会再对类使用静态属性查找的方式了。</strong></p>
<p><strong>并且我们还可以从 Python 的层面来验证这个结论：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">globals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>我们在函数内部访问了 global 名字空间，而 global 空间显然是全局唯一的，在 Python 层面上就是一个 dict 对象，那么我们修改 x，在外部再打印 x 肯定会变。但是，我要说但是了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们按照相同的套路，却并没有成功，这是为什么？原因就是我们刚才解释的那样，函数内部的局部变量在编译时就已经确定好了，存储在符号表 co_varnames 中，查询的时候是静态查找的，而不是从 locals() 中查找。locals() 不像  globals()，globals() 虽然和 locals() 都是一个 PyDictObject 对象，但是全局变量的访问是从  globals() 这个字典里面访问的，并且全局唯一，我们调用 globals()  就直接访问到了存放全局变量的字典，一旦做了更改，肯定会影响外面的全局变量。但是locals()  则不会，因为局部变量压根就不是从它这里访问的，尽管它和 globals() 类似，在函数中也唯一，也会随着当前的上下文动态改变。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">locals</span>()))</span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">locals</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;x&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">2459571657088</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">2459571657088</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们看到真的就是类似于全局名字空间一样, 前后地址没有变化, 但是键值对的个数在增加</span></span><br><span class="line"><span class="comment"># 因为 locals() 底层会执行 PyEval_GetLocals, 实际上拿到就是当前栈帧对象的 f_locals 属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以这里可以看到一个比较奇特的现象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b</span>):</span><br><span class="line">    d = <span class="built_in">locals</span>()</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    <span class="built_in">print</span>(d[<span class="string">&quot;d&quot;</span>] <span class="keyword">is</span> d[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>] <span class="keyword">is</span> d[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>][<span class="string">&quot;d&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;d&#x27;: &#123;...&#125;&#125;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 可能有人好奇了, d 里面不是没有 &quot;d&quot; 这个 key 吗?</span></span><br><span class="line"><span class="comment"># 我们执行 d[&quot;d&quot;] 之前再次调用了 locals, 由于此时局部空间多了一个键值对 &quot;d&quot;: locals(), 所以 locals() 对应的字典被更新了</span></span><br><span class="line"><span class="comment"># 但我们说 locals() 在局部空间又是唯一的, 所以 d1 指向的空间也变了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于字典这个现象, 其实可以类似于 globals 与 __builtins__ 之间的关系</span></span><br><span class="line">x = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;x&quot;</span>])  <span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 之所以能够形成这个现象, 原因就在于字典里面的 key、value 存储的都是 PyObject * 泛型指针</span></span><br></pre></td></tr></table></figure>

<p><strong>再看一个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>此时会得到什么结果估计不用我说了，因为内部、外部、builtin都没有变量 x。在编译的时候，没有找到类似于 <code>x = 1</code> 这样的字眼。因此尽管在locals()里面，但是我们说局部变量的值不是从它这里获取的，而是 f_localsplus 前面的那段内存里面，然后那段内存并没有，而且符号表中就没有 ‘x’ 这个符号，所以报错。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p><strong>原因不再废话了，一句话：foo函数里面没有 x 这个变量，所以打印的是全局变量，因此输出123。</strong></p>
<p><strong>另外关于局部变量的查找，再来看看最后一个栗子，搭配 exec 可以说明一切：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;&#125;</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;&#x27;x&#x27;: 1&#125;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;x&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>尽管 locals() 变了，但是依旧访问不到 x，因为  Python 在将 foo 对应的 block 编译成 PyCodeObject  对象时，并不知道这是创建了一个局部变量，它只知道这是一个函数调用。而 exec(“x &#x3D; 1”) 相当于创建一个变量 x &#x3D;  1，但它默认影响的是当前所在的作用域，所以 exec(“x &#x3D; 1”) 的效果就是改变了局部名字空间，里面多了一个 “x”: 1  键值对。但关键的是，局部变量 x 的访问不是从局部名字空间中查找的，exec 终究还是错付了人。由于函数 foo 对应的  PyCodeObject 对象的符号表中并没有 x 这个符号，所以报错了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 这么做是可以的, 因为 exec 默认是影响当前作用域, 这里是全局作用域</span></span><br><span class="line"><span class="comment"># 而全局变量的查找是从字典中获取的, 所以这里是可以获取的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们把上面的例子改一下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="comment"># 此时 exec 影响的就是全局名字空间</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 123&quot;</span>, <span class="built_in">globals</span>())</span><br><span class="line">    <span class="comment"># 这里不会报错, 但是此时的 x 不是局部变量, 而是全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题又来了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>])</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面打印 1, 显然这是没有问题的, 因为 &quot;x&quot;: 1 这个键值对已经在 local 空间中了</span></span><br><span class="line"><span class="comment"># 但是, 是的我又要说但是了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File .....</span></span><br><span class="line"><span class="string">    bar()</span></span><br><span class="line"><span class="string">  File .....</span></span><br><span class="line"><span class="string">    print(locals()[&quot;x&quot;])</span></span><br><span class="line"><span class="string">KeyError: &#x27;x&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这就比较尴尬了，为啥会出现这种效果？解决这个问题首先要明确两点：</strong></p>
<ul>
<li><code>1. 函数内的局部变量在编译的时候已经确定, 由语法规则所决定的, 并存储在对应的 PyCodeObject 对象的符号表 (co_varnames) 中;</code></li>
<li><code>2. 函数内的局部变量在其整个作用域范围内都是可见的;</code></li>
</ul>
<p><strong>举一个常见的错误：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">调用 foo 没有问题, 但调用 bar 的时候会报出如下错误 </span></span><br><span class="line"><span class="string">	UnboundLocalError: local variable &#x27;x&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">原因就在于我们之前说的两个点, 函数内的局部变量在编译的时候已经确定, 所以对于 bar 函数而言, 符号表中是存在 &quot;x&quot; 这个符号的 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_varnames)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_varnames)  <span class="comment"># (&#x27;x&#x27;,)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">而函数内的局部变量在整个作用域内都是可见的, 因此对于bar而言, 在 print(x) 的时候知道符号表中存在 &quot;x&quot; 这个符号</span></span><br><span class="line"><span class="string">那么它也就认为局部作用域存在 x 这个局部变量, 因此就不会去找全局变量了, 而是去找局部变量</span></span><br><span class="line"><span class="string">但是显然 print(x) 是在 x = 2 之前发生的, 所以此时 print(x) 的时候就报错了</span></span><br><span class="line"><span class="string">       UnboundLocalError: 局部变量 &#x27;x&#x27; 在赋值（x = 2）之前被引用（print(x)）了</span></span><br><span class="line"><span class="string">因为 print(x) 的时候, 常量池中还没有对应的值与之绑定, 或者说 x 此时还是 C 中的 NULL(空指针), 并没有指向一块合法的内存</span></span><br><span class="line"><span class="string">当 x = 2 之后, x 才会和 2 这个 PyLongObject 对象进行绑定, 只可以我们在绑定之前就使用 x 这个变量了, 显然这是不合法的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>那么我们的那个问题就很好解释了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;x&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">bar()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 对于 foo 而言, 结果符合我们的预期, 但是对于 bar 而言, 只是多了一个赋值语句, 结果局部空间就变成空字典了</span></span><br><span class="line"><span class="comment"># 原因在于 &#x27;x&#x27; 已经在符号表当中了, exec(&quot;x = 1&quot;) 并没有往局部空间中加入这个键值对</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">有兴趣可以查看解释器源代码: Python\bltinmodule.c 中的 builtin_exec_impl 函数, 看看 exec 底层到底是如何执行的</span></span><br><span class="line"><span class="string">因为 exec 里面的字符串实际上是作为一个独立的编译单元去执行的, 里面的可以写很多很多内容</span></span><br><span class="line"><span class="string">要是再加上它是如何影响当前作用域的, 那么背后会牵扯非常多的内容, 从头到尾分析下来需要的工作量不敢想象, 因此这里不深入展开了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 但是访问 locals() 又是在 x = 123 之前发生的, 因此打印的是空字典, locals[&#x27;x&#x27;] 自然就出现 KeyError 了</span></span><br><span class="line"><span class="comment"># 如果将 x = 123, 改成 y = 123 的话, 显然 foo 和 bar 里面的打印结果是一样的</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套函数、闭包与decorator"><a href="#嵌套函数、闭包与decorator" class="headerlink" title="嵌套函数、闭包与decorator"></a>嵌套函数、闭包与decorator</h3><p><strong>我们之前一直反复提到了四个字，名字空间。一段代码执行的结果不光取决于代码中的符号，更多取决于代码中符号的语义，而这个运行时的语义正是由名字空间决定的。名字空间是在运行时由Python虚拟机动态维护的，但是有时我们希望将命名空间静态化。换句话说，我们希望有的代码不受命名空间变换带来的影响，始终保持一致的功能该怎么办呢？</strong></p>
<p><strong>比如下面的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">name, password, nickname</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (name == <span class="string">&quot;satori&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拜拜&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;欢迎:<span class="subst">&#123;nickname&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;夏色祭&quot;</span>))  <span class="comment"># 欢迎:夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;白上吹雪&quot;</span>))  <span class="comment"># 欢迎:白上吹雪</span></span><br></pre></td></tr></table></figure>

<p><strong>我们注意到每次都需要输入username和password，于是我们可以只设置一次基准值，通过使用嵌套函数来实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">name, password</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">nickname</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (name == <span class="string">&quot;satori&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拜拜&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;欢迎:<span class="subst">&#123;nickname&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = wrap(<span class="string">&quot;satori&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;夏色祭&quot;</span>))  <span class="comment"># 欢迎:夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(index(<span class="string">&quot;白上吹雪&quot;</span>))  <span class="comment"># 欢迎:白上吹雪</span></span><br></pre></td></tr></table></figure>

<p><strong>尽管我们调用index的时候，local名字空间<code>(对应那片内存)</code>里面没有name和password，但是warp里面有。也就是说，index函数作为wrap函数的返回值被传递的时候，有一个名字空间<code>(wrap的local名字空间)</code>就已经和index紧紧地绑定在一起了，在执行内层函数index的时候，在自己的local空间找不到，就会从和自己绑定的local空间里面去找，这就是一种名字空间静态化的方法。这个名字空间和内层函数捆绑之后的结果我们就称之为闭包<code>(closure)</code></strong></p>
<blockquote>
<p><strong>闭包：外部作用域 + 内层函数。</strong></p>
</blockquote>
<p><strong>在前面我们也知道了，PyFunctionObject是Python虚拟机专门为字节码指令准备的大包袱，global名字空间，默认参数都能在PyFunctionObject中与字节码指令捆绑在一起，同样的，PyFunctionObject也是Python中闭包的具体体现。</strong></p>
<h4 id="实现闭包的基石"><a href="#实现闭包的基石" class="headerlink" title="实现闭包的基石"></a>实现闭包的基石</h4><p><strong>闭包的创建通常是利用嵌套的函数来完成的，在PyCodeObject中，与嵌套函数相关的属性是co_cellvars和co_freevars，两者的具体含义如下：</strong></p>
<ul>
<li><code>co_cellvars:通常是一个tuple，保存了嵌套的作用域中使用的变量名的集合;</code></li>
<li><code>co_freevars:通常是一个tuple，保存了使用了的外层作用域中的变量名集合;</code></li>
</ul>
<p><strong>光看概念的话比较抽象，实际演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;mashiro&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="keyword">nonlocal</span> age</span><br><span class="line">        <span class="built_in">print</span>(gender)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_cellvars)  <span class="comment"># (&#x27;age&#x27;, &#x27;gender&#x27;, &#x27;name&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_freevars)  <span class="comment"># (&#x27;age&#x27;, &#x27;gender&#x27;, &#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_freevars)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_cellvars)  <span class="comment"># ()</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现无论是外层函数还是内层函数都有co_cellvars和co_freevars，但是无论是co_cellvars还是co_freevars，得到结果是一样的，都是内层函数使用nonlocal声明的变量、以及内层函数使用的外层函数的变量。只不过外层函数需要使用co_cellvars获取，内层函数需要使用co_freevars获取。如果使用外层函数获取co_freevars的话，那么得到的结果显然就是个空元组的，除非foo也作为某个函数的内层函数，并且内部有nonlocal声明、或者使用外层函数的某个变量，同理内层也是一样的道理。</strong></p>
<p><strong>在PyFrameObject对象中，也有一个属性和闭包的实现相关，这个属性就是f_localsplus，这样一说，是不是有些隐隐约约察觉到了呢？其实在<code>_PyFrame_New_NoTrack</code>就有一行代码泄漏了天机。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">    Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">    ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">    nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">	<span class="comment">//玄机在这里，extras正是f_localsplus指向的那片内存的大小，这里已经清晰的说明了</span></span><br><span class="line">    <span class="comment">//这片内存是属于四个老铁的：运行时栈，局部变量，cell对象(对应co_cellvars)，free对象(对应co_freevars)，但是各自的顺序不是按照这个顺序来的</span></span><br><span class="line">    extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>虽然之前我们就见过f_localsplus的结构，但是到现在为止，其面纱才算是真正被揭开。</strong></p>
<h4 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h4><p><strong>在介绍了实现闭包的基石之后，我们可以开始追踪闭包的具体实现过程了，当然还是要先看一下闭包对应的字节码，老规矩嘛。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def get_func():</span></span><br><span class="line"><span class="string">    value = &quot;inner&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def func():</span></span><br><span class="line"><span class="string">        print(value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return func</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">show_value = get_func()</span></span><br><span class="line"><span class="string">show_value()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>首先这个py文件执行之后，肯定会打印出”inner”这个字符串，下面让我们来看看它的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object get_func at <span class="number">0x000001AAB6F4AB30</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;get_func&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (get_func)</span><br><span class="line"></span><br><span class="line"> <span class="number">11</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (get_func)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">1</span> (show_value)</span><br><span class="line"></span><br><span class="line"> <span class="number">12</span>          <span class="number">14</span> LOAD_NAME                <span class="number">1</span> (show_value)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object get_func at <span class="number">0x000001AAB6F4AB30</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_DEREF              <span class="number">0</span> (value)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>           <span class="number">4</span> LOAD_CLOSURE             <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">6</span> BUILD_TUPLE              <span class="number">1</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (&lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;get_func.&lt;locals&gt;.func&#x27;</span>)</span><br><span class="line">             <span class="number">12</span> MAKE_FUNCTION            <span class="number">8</span> (closure)</span><br><span class="line">             <span class="number">14</span> STORE_FAST               <span class="number">0</span> (func)</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">16</span> LOAD_FAST                <span class="number">0</span> (func)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;:</span><br><span class="line">  <span class="number">6</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_DEREF               <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>相信里面大部分的指令你都认识，我们直接介绍构建闭包对应的指令、以及调用内层函数对应的指令，先来看看前者：</strong></p>
<ul>
<li><code>0 LOAD_CONST    1 (&#39;inner&#39;): 把字符串&#39;inner&#39;这个常量load进来;</code></li>
<li><code>2 STORE_DEREF    0 (value): 这个STORE_DEREF是什么鬼？从功能来看应该类似于STORE_FAST,具体是啥暂时不用管;</code></li>
<li><code>4 LOAD_CLOSURE    0 (value): 又是一条未见过的指令，不过这个我们从名字上可以看出来是load一个闭包;</code></li>
<li><code>6 BUILD_TUPLE    1: build一个元组, 为什么? 显然是为了存储内层函数(闭包)的</code></li>
<li><code>8 LOAD_CONST    2 (&lt;code object func...: LOAD字节码,显然是内层函数func的字节码;</code></li>
<li><code>10 LOAD_CONST    3 (&#39;get_func.&lt;locals&gt;.func&#39;): 又是一个LOAD_CONST,我们按照之前的分析，这次LOAD的应该是外层的local名字空间;</code></li>
<li><code>12 MAKE_FUNCTION    8 (closure): MAKE_FUNCTION,构造一个函数, 参数是8; 而且括号里面写着closure, 表示这是个闭包;</code></li>
<li><code>14 STORE_FAST    0 (func):  调用STORE_FAST，将符号func和之前的PyFunctionObject组合成entry存储起来,  当然我们知道这里不是存在字典里面的;符号func是在符号表中, PyFunctionObject对象是在常量池中,  并且它们在各自数组中的索引是相等的;</code></li>
<li><code>16 LOAD_FAST    0 (func): 因为我们返回了func,所以LOAD_CONST的参数是func;</code></li>
<li><code>18 RETURN_VALUE: 返回func;</code></li>
</ul>
<p><strong>最后再来看看调用内层函数执行的指令：</strong></p>
<ul>
<li><code>0 LOAD_GLOBAL     0 (print): 首先是LOAD_GLOBAL得到print函数，这不需要多说;</code></li>
<li><code>2 LOAD_DEREF    0 (value): 关键是这条LOAD_DEREF指令，显然和上面的STORE_DEREF是一组，关系应该是类似于LOAD_FAST和STORE_FAST之间的关系那样, 我们猜测;</code></li>
<li><code>4 CALL_FUNCTION     1: 调用函数, 参数个数为1;</code></li>
</ul>
<p><strong>虽然我们看到了几个不认识的指令，不过不用慌，我们下面会顺藤摸瓜，沿着那美丽动人的曲线慢慢地、逐一探索。目前只需要知道，在Python虚拟机执行<code>8 LOAD_CONST    2 (&lt;code object func...</code>指令的时候，就已经开始为closure的实现悄悄地添砖加瓦了。</strong></p>
<h5 id="创建closure"><a href="#创建closure" class="headerlink" title="创建closure"></a>创建closure</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()</span><br></pre></td></tr></table></figure>

<p><strong>我们前面介绍了，虚拟机在执行CALL_FUNCTION指令时，会进入 *_PyFunction_FastCallDict* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    <span class="comment">//......    </span></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p><strong>而在 *_PyFunction_FastCallDict* 中，由于当前的PyCodeObject为函数get_func对应的PyCodeObject。对于有闭包的函数来说，显然这个条件是不满足的，因此不会进入快速通道，而是会进入 *_PyEval_EvalCodeWithName* 。而且当前的这个PyCodeObject的co_cellvars是有东西的，可能这里有人奇怪了，我们没看到代码里面使用nonlocal声明啊，其实之前说了，除了使用nonlocal声明的变量外，还有内层函数使用的外层作用域中的变量。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value1 = <span class="string">&quot;inner&quot;</span></span><br><span class="line">    value2 = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        value2 = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(value1)</span><br><span class="line">        <span class="built_in">print</span>(value2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(get_func.__code__.co_cellvars)  <span class="comment"># (&#x27;value1&#x27;,)</span></span><br><span class="line"><span class="built_in">print</span>(get_func().__code__.co_freevars)  <span class="comment"># (&#x27;value1&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现了内层函数自己定义了value2，所以它不再co_cellvars中，但是value1在内层函数中没有，而是使用的外层函数内部的value1变量，所以它也在co_cellvars中。因此除了那些被nonlocal关键字声明的变量之外，还有被内层函数使用的外层函数的变量。</strong></p>
<p><strong>因此在 *_PyEval_EvalCodeWithName* 中，Python虚拟机会如同处理默认参数一样，将co_cellvars中的东西拷贝到新创建的PyFrameObject的f_localsplus里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) &#123;</span><br><span class="line">        <span class="comment">//声明 Cell 对象，这个 Cell 对象是什么后面就知道了</span></span><br><span class="line">        PyObject *c;</span><br><span class="line">        Py_ssize_t arg;</span><br><span class="line">        <span class="comment">/* 处理被嵌套函数共享的外层函数的局部变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_cell2arg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) &#123;</span><br><span class="line">            <span class="comment">//创建 Cell 对象</span></span><br><span class="line">            c = PyCell_New(GETLOCAL(arg));</span><br><span class="line">            SETLOCAL(arg, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = PyCell_New(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        SETLOCAL(co-&gt;co_nlocals + i, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 Cell 对象拷贝一份, 因为外层函数和内层函数都可以调用</span></span><br><span class="line"><span class="comment">       只不过一个是co_cellvars、一个是co_freevars */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">        PyObject *o = PyTuple_GET_ITEM(closure, i);</span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在 *_PyEval_EvalCodeWithName* 中，Python虚拟机会如同处理默认参数一样，将co_cellvars中的东西拷贝到新创建的PyFrameObject的f_localsplus里面。</strong></p>
<p><strong>嵌套函数有时候很复杂，如果嵌套的层数比较多的话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">foo3</span>():</span><br><span class="line">            x = <span class="number">2</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">foo4</span>():</span><br><span class="line">                <span class="built_in">print</span>(x)</span><br><span class="line">            <span class="keyword">return</span> foo4</span><br><span class="line">        <span class="keyword">return</span> foo3</span><br><span class="line">    <span class="keyword">return</span> foo2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1()()()()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>但是无论多少层，我们之前说的结论是不会变的。之前我们提到了，Cell 对象在python底层也是一个对象，那它必然也是一个PyObject，我们看一下它的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *ob_ref;       <span class="comment">/* Content of the cell or NULL when empty */</span></span><br><span class="line">&#125; PyCellObject;</span><br></pre></td></tr></table></figure>

<p><strong>这个对象似乎出乎意料的简单，仅仅维护了一个PyObject_HEAD，和一个ob_ref<code>(指向某个对象的指针)</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCell_New</span><span class="params">(PyObject *obj)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个PyCellObject对象</span></span><br><span class="line">    PyCellObject *op;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//为这个PyCellObject申请空间，类型是PyCell_Type</span></span><br><span class="line">    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这里的obj是什么呢？显然是上面_PyEval_EvalCodeWithName里面的GETLOCAL(arg)或者NULL</span></span><br><span class="line">    <span class="comment">//说白了，就是我们之前说的那些被内层函数引用的外层函数的局部变量，或者NULL，如果没人引用的话就是NULL</span></span><br><span class="line">    op-&gt;ob_ref = obj;</span><br><span class="line">    Py_XINCREF(obj);</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是实际上一开始是不知道这个ob_ref指向的是谁的，什么时候才知道呢？是在我们一开始的闭包代码中，那句<code>value = &#39;inner&#39;</code>指令指令的时候，才会真正知道ob_ref指向的是谁。随后这个cell对象被拷贝到了新创建的PyFrameObject对象的f_localsplus中，并且位置是<code>co-&gt;co_nlocals+i</code>，说明在f_localsplus中，cell对象的位置是在局部变量之后的，这完全符合我们之前说的f_localsplus的内存布局。另外图中画错了，指向应该是一个字符串 “inner”，但我不知道为啥画成了整数 10</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065426762-1258006550.png" alt="img"></p>
<p><strong>但是我们发现了一个奇怪的地方，那就是我们发现这个cell对象<code>(value)</code>好像没有设置名字诶。实际上这个和我们之前提到的Python虚拟机将对局部变量符号的访问方式从PyDictObject的查找变成了对PyTupleObject的索引是一个道理。在get_func这个函数执行的过程中，对value这个cell对象是通过基于索引访问在f_localsplus中完成，因此完全不需要知道cell对象的名字。这个cell对象的名字实际上是在处理被内层函数引用外层函数的默认参数是产生的。我们说参数和内部的创建的变量都是局部变量，在处理默认参数的时候，就把value这个cell对象一并处理了。</strong></p>
<p><strong>在处理了cell对象之后，Python虚拟机将正式进入PyEval_EvalFrameEx，从而正式开始对函数get_func的调用过程。再看一下字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_DEREF              <span class="number">0</span> (value)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>           <span class="number">4</span> LOAD_CLOSURE             <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">6</span> BUILD_TUPLE              <span class="number">1</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (&lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;get_func.&lt;locals&gt;.func&#x27;</span>)</span><br><span class="line">             <span class="number">12</span> MAKE_FUNCTION            <span class="number">8</span> (closure)</span><br><span class="line">             <span class="number">14</span> STORE_FAST               <span class="number">0</span> (func)</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">16</span> LOAD_FAST                <span class="number">0</span> (func)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object func at <span class="number">0x000001AAB6F51450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">5</span>&gt;:</span><br><span class="line">  <span class="number">6</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_DEREF               <span class="number">0</span> (value)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到执行<code>0 LOAD_CONST 1 (&#39;inner&#39;)</code>之后，会将PyUnicodeObject对象’inner’压入到运行时栈，紧接着便执行一条我们从未见过的全新的字节码指令–<code>STORE_DEREF</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">	freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_DEREF)</span>: &#123;</span><br><span class="line">            <span class="comment">//这里pop弹出的显然是运行时栈的PyUnicodeObject对象&#x27;inner&#x27;</span></span><br><span class="line">            PyObject *v = POP();</span><br><span class="line">             <span class="comment">//获取cell，也就是闭包; 注意：这里要和之前说的cell对象区分一下，之前的cell对象是变量</span></span><br><span class="line">            <span class="comment">//这里的cell则是闭包(内层函数+外层函数的局部作用域)</span></span><br><span class="line">            PyObject *cell = freevars[oparg];</span><br><span class="line">            <span class="comment">//获取老的cell对象</span></span><br><span class="line">            PyObject *oldobj = PyCell_GET(cell);</span><br><span class="line">            <span class="comment">//我们看到了一个PyCell_SET，那么玄机肯定就在这里面了</span></span><br><span class="line">            PyCell_SET(cell, v);</span><br><span class="line">            Py_XDECREF(oldobj);</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们发现，ob_ref指向的对象似乎就是通过PyCell_SET设置的，没错，这家伙就是干这个勾当的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cellobject.h</span></span><br><span class="line">PyAPI_FUNC(<span class="type">int</span>) PyCell_Set(PyObject *, PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cellobject.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyCell_Set</span><span class="params">(PyObject *op, PyObject *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject* oldobj;</span><br><span class="line">    <span class="keyword">if</span> (!PyCell_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oldobj = PyCell_GET(op);</span><br><span class="line">    Py_XINCREF(obj);</span><br><span class="line">    PyCell_SET(op, obj);</span><br><span class="line">    Py_XDECREF(oldobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如此一来，f_localsplus就发生了变化。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065435213-2141751147.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()</span><br></pre></td></tr></table></figure>

<p><strong>现在在get_func的环境中我们知道了value符号对应着一个PyUnicodeObject对象，但是closure是要将这个约束进行冻结，为了在嵌套函数func中被调用的时候还可以使用这个约束。这一次，我们的工具人PyFunctionObject就又登场了，在执行接下来的<code>def func()</code>表达式对应的字节码时，python虚拟机就会将<code>(value, &#39;inner&#39;)</code>这个约束塞到PyFunctionObject中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_CLOSURE)</span>: &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];</span><br><span class="line">    Py_INCREF(cell);</span><br><span class="line">    PUSH(cell);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>4 LOAD_CLOSURE</code>会将刚刚放置好的PyCellObject对象取出，并压入运行时栈，紧接着<code>6 BUILD_TUPLE</code>指令将PyCellObject对象打包进一个PyTupleObject对象，显然这个PyTupleObject对象中可以存放多个PyCellObject对象，只不过我们的例子中只有一个PyCellObject对象。</strong></p>
<p><strong>随后Python虚拟机通过<code>8 LOAD_CONST</code>和<code>10 LOAD_CONST</code>将内层函数func对应PyCodeObject和符号LOAD进来，压入运行时栈，紧接着以一个<code>12 MAKE_FUNCTION 8</code>指令完成约束和PyCodeObject之间的绑定，注意这里的字节码指令依旧是<code>MAKE_FUNCTION</code>，但是参数是8，我们再次看看<code>MAKE_FUNCTION</code>这个指令，还记得这个指令在哪里吗？没错，之前说了只要是字节码指令，都在<code>ceval.c</code>中</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(MAKE_FUNCTION) &#123;</span><br><span class="line">    <span class="comment">//弹出名字</span></span><br><span class="line">    PyObject *qualname = POP();</span><br><span class="line">    <span class="comment">//弹出PyCodeObject</span></span><br><span class="line">    PyObject *codeobj = POP();</span><br><span class="line">    <span class="comment">//根据PyCodeObject对象、global命名空间、名字构造出PyFunctionObject</span></span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//我们看到参数是8，因此这个条件是成立的</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        <span class="comment">//弹出闭包需要使用的变量信息，将该信息写入到func_closure中</span></span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是处理注解的：只在python3.6+中存在</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理关键字参数</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理默认参数</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//压入运行时栈</span></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时便将约束<code>(内层函数需要使用的作用域信息)</code>和内层函数绑定在了一起。然后执行<code>14 STORE_FAST</code>将新创建的PyFunctionObject对象放置到了f_localsplus当中。这样的话，f_localsplus就又发生了变化。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065442949-1280274412.png" alt="img"></p>
<p><strong>从图上我们发现内层函数居然在get_func的局部变量里面，是的没有错。其实按照我们之前说的，函数即变量，所以函数和普通变量一样，都是在上一级栈帧的f_localsplus里面的。最后这个新建的PyFunctionObject对象被压入到了上一级栈帧的运行时栈中，并且被作为上一个栈帧的返回值返回了。显然有人就能猜到下一步要介绍什么了，既然拿到了闭包、或者说内层函数对应的PyFunctionObject，那么肯定要使用啊。而且估计有人猜到了，当外面拿到闭包的时候，调用，显然会找到对应的闭包，然后抽出里面的PyCodeObject对象继续创建栈帧。</strong></p>
<h5 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h5><p><strong>closure是在get_func函数中被创建的，而对closure的使用，则是在inner_func中。在执行<code>show_value()</code>对应的CALL_FUNCTION指令时，因为func对应的PyCodeObject对象的co_flags域中包含了CO_NESTED，因此在 *_PyFunction_FastCallDict* 函数中不会进入快速通道<code>function_code_fastcall</code>，而是会进入 *_PyEval_EvalCodeWithName* 、*PyEval_EvalFrameEx* 、继而进入 *_PyEval_EvalFrameDefault* 。不过问题是，Python是怎么知道co_flags域中包含了CO_NESTED呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line"><span class="built_in">print</span>(show_value.__code__.co_flags)  <span class="comment"># 19</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到func函数的字节码的co_flags是19，那么这个值是什么计算出来的呢？还是记得我们在介绍PyCodeObject对象和pyc文件那一章中，当时我们说，co_flags这个域主要用于mask，用来判断参数类型的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_OPTIMIZED    0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NEWLOCALS    0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARARGS      0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARKEYWORDS  0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NESTED       0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_GENERATOR    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NOFREE       0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_COROUTINE            0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_ITERABLE_COROUTINE   0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_ASYNC_GENERATOR      0x0200</span></span><br></pre></td></tr></table></figure>

<p><strong>函数没有参数，显然CO_VARARGS和CO_VARKEYWORDS是不存在的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0x0001</span> | <span class="number">0x0002</span> | <span class="number">0x0010</span>)  <span class="comment"># 19</span></span><br><span class="line"><span class="comment"># 因此闭包是包含CO_NESTED这个域的</span></span><br></pre></td></tr></table></figure>

<p><strong>根据之前说了，对于闭包来说，func对应的PyCodeObject中的co_freevars里面有引用了外层作用域中的符号名，在 *_PyEval_EvalCodeWithName* 中就会对这个co_freevars进行处理。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    <span class="comment">/* Copy closure variables to free variables */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">        PyObject *o = PyTuple_GET_ITEM(closure, i);</span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中的closure变量是作为倒数第三个参数传递进来的，我们可以看看到底传递了什么？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//funcobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFunction_GET_CLOSURE(func) \</span></span><br><span class="line"><span class="meta">        (((PyFunctionObject *)func) -&gt; func_closure)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs,</span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到了，是把PyFunctionObject对象的func_closure拿出来了，这个func_closure是啥还记得吗？之前说得，不记得了再看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET(MAKE_FUNCTION) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        <span class="comment">//弹出闭包需要使用的变量信息，将该信息写入到func_closure中</span></span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然这个func_closure就是PyFunctionObject对象中的、我们之前说得那个与对应PyCodeObject绑定的、装满了PyCellObject对象的PyTupleObject。所以在 *_PyEval_EvalCodeWithName* 中，进行的动作就是将这个PyTupleObject里面的PyCellObject对象一个一个的放到f_localsplus中相应的位置。在处理完之后，func对应的PyFrameObject中f_localsplus就变成了这样。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065450935-1586497820.png" alt="img"></p>
<p><strong>我们看到闭包使用的变量信息，被设置在了func_closure中，而这个函数是内层函数，那么我们可以通过__closure__进行获取。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line"><span class="comment"># cell是针对外层函数的</span></span><br><span class="line"><span class="comment"># free是针对内层函数的</span></span><br><span class="line"><span class="comment"># 我们看到在设置func_closure的时候是对内层函数进行设置的, 所以</span></span><br><span class="line"><span class="built_in">print</span>(get_func.__closure__)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(show_value.__closure__)  <span class="comment"># (&lt;cell at 0x000001E07D8382B0: str object at 0x000001E07D82D3F0&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到外层函数的__closure__为None, 内层函数的__closure__则不是None</span></span><br><span class="line"><span class="comment"># 因此相当于将所有的cell对象(指针)拷贝了一份, 存在了free区域, 那么如何获取cell对象的值呢</span></span><br><span class="line"><span class="built_in">print</span>(show_value.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># inner</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在func调用的过程中，当引用外层作用域的符号时，一定是到f_localsplus里面的free变量区域去获取对应PyCellObject，通过内部的ob_ref进而获取符号对应的值。这正是func函数中’print(value)’表达式对应的第一条字节码指令<code>0 LOAD_DEREF 0</code>的意义。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_DEREF)</span>: &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];  <span class="comment">//获取PyCellObject对象   </span></span><br><span class="line">    PyObject *value = PyCell_GET(cell);<span class="comment">//获取PyCellObject对象的ob_ref指向的对象 </span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        format_exc_unbound(tstate, co, oparg);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);<span class="comment">//压入运行时栈</span></span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以在func调用的过程中，当引用外层作用域的符号时，一定是到f_localsplus里面的free变量区域去获取对应PyCellObject，通过内部的ob_ref进而获取符号对应的值。这正是func函数中’print(value)’表达式对应的第一条字节码指令<code>0 LOAD_DEREF 0</code>的意义。</strong></p>
<p><strong>此外通过闭包，我们还可以玩出一些新花样，但是工作中不要这么做。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    value = <span class="string">&quot;inner&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()  <span class="comment"># inner</span></span><br><span class="line"></span><br><span class="line">show_value.__closure__[<span class="number">0</span>].cell_contents = <span class="string">&quot;内层函数&quot;</span></span><br><span class="line">show_value()  <span class="comment"># 内层函数</span></span><br></pre></td></tr></table></figure>

<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p><strong>装饰器算是Python中一个亮点，当然其实也不算什么亮点，本质上也是使用了闭包的思想，只不过给我们提供了一个优雅的语法糖。</strong></p>
<blockquote>
<p><strong>装饰器的本质就是高阶函数加上闭包，至于为什么要有装饰器，我觉得有句话说的非常好，装饰器存在的最大意义就是可以在不改动原函数的代码和调用方式的情况下，为函数增加一些新的功能。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;都闪开，我要开始装饰了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始了&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco    </span><span class="comment"># 这一步就等价于foo = deco(foo)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="comment"># 因此上来就会打印deco里面的print</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时再调用foo，已经不再是原来的foo了，而是deco里面的闭包inner</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体输出如下:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">都闪开，我要开始装饰了</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string">开始了</span></span><br><span class="line"><span class="string">1 2</span></span><br><span class="line"><span class="string">结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 根据输出的---------，我们知道deco里面的print是在装饰的时候就已经打印了</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以使用之前的方式：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;都闪开，我要开始装饰了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始了&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实@deco的方式就是一个语法糖，它本质上就是</span></span><br><span class="line">foo = deco(foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">都闪开，我要开始装饰了</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">开始了</span></span><br><span class="line"><span class="string">1 2</span></span><br><span class="line"><span class="string">结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以这个现象告诉我们，装饰器只是类似于<code>foo = deco(foo)</code>的一个语法糖罢了</strong></p>
<p><strong>装饰器本质上就是使用了闭包，两者的字节码很类似，这里就不再看了。还是那句话，<code>@</code>只是个语法糖，它和我们直接调用<code>foo = deco(foo)</code>是一样的，所以理解装饰器(decorator)的关键就在于理解闭包(closure)。</strong></p>
<blockquote>
<p><strong>当然函数在被装饰器装饰之后，整个函数其实就已经变了，为了保留原始信息我们一般会从functools中导入一个wraps函数。当然装饰器的使用方式、以及类装饰器，这些都属于Python层级的东西了，我们就不说了。</strong></p>
</blockquote>
<p><strong>当然，我们知道函数可以同时被多个装饰器装饰的。如果有多个装饰器，那么它们是怎么装饰的呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco1&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco1&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco2&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco2&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco3</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;deco3&gt;<span class="subst">&#123;func()&#125;</span>&lt;/deco3&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco1</span></span><br><span class="line"><span class="meta">@deco2</span></span><br><span class="line"><span class="meta">@deco3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hanser&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo())</span><br></pre></td></tr></table></figure>

<p><strong>请问它的输出结果是什么呢？</strong></p>
<blockquote>
<p><strong>可以先分析，解释器还是从上到下解释，但是发现了<code>@deco1</code>的时候，肯定要装饰了，但是发现在它下面的哥们不是函数也是一个装饰器，于是说：要不哥们，你先装饰。然后<code>@deco2</code>发现它下面还是一个装饰器，于是重复了刚才的话，但是当<code>@deco3</code>的时候，发现下面终于是一个普通的函数了。于是装饰了，当deco3装饰完毕之后，<code>foo = deco3(foo)</code>，然后deco2发现deco3已经装饰完毕了，然后对deco3装饰的结果再进行装饰，此时<code>foo = deco2(deco3(foo))</code>，同理再经过deco1的装饰，得到了<code>foo = deco1(deco2(deco3(foo)))</code></strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(foo())  <span class="comment"># &lt;deco1&gt;&lt;deco2&gt;&lt;deco3&gt;hanser&lt;/deco3&gt;&lt;/deco2&gt;&lt;/deco1&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="关于函数的面试题"><a href="#关于函数的面试题" class="headerlink" title="关于函数的面试题"></a>关于函数的面试题</h3><p>​        <strong>1. Python 中有几个名字空间，分别是什么？Python 变量以什么顺序进行查找？</strong>    </p>
<p><strong>Python总共有4个名字空间：</strong></p>
<ul>
<li><code>局部名字空间(local)</code></li>
<li><code>闭包名字空间(closure)</code></li>
<li><code>全局名字空间(global)</code></li>
<li><code>内建名字空间(builtin)</code></li>
</ul>
<p><strong>我们之前说过，*Python* 查找变量时，依次检查 局部 、闭包、全局、内建 这几个名字空间，直到变量被找到为止。如果几个空间都遍历完了还没找到，那么会抛出NameError。</strong></p>
<p>​        <strong>2. 如何在一个函数内部修改全局变量？</strong>    </p>
<p><strong>在函数内部用 *global* 关键字将变量声明为全局，然后再进行修改：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>或者获取global名字空间，然后通过字典进行修改，因为全局变量是通过字典来存储的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">globals</span>()[<span class="string">&quot;a&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>3. 不使用 def 关键字的话，还有什么办法可以创建函数对象？</strong>    </p>
<p><strong>根据 *Python* 对象模型，实例对象可以通过调用类型对象来创建。而函数类型对象，虽然没有直接暴露给我们，但我们可以通过函数对象找到：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__class__)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span>: <span class="literal">None</span>).__class__)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>事实上，*Python* 将函数类型对象暴露在 *types* 模块中，可通过模块属性 *FunctionType* 访问到：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(FunctionType)  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(f.__class__ <span class="keyword">is</span> FunctionType)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>然而它干的事情和我们本质上是一样的，我们看一下源码怎么实现的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(): <span class="keyword">pass</span></span><br><span class="line">FunctionType = <span class="built_in">type</span>(_f)</span><br></pre></td></tr></table></figure>

<p><strong>吱吱吱~~~</strong></p>
<p><strong>而创建函数的时候，可以根据PyCodeObject对象创建，我们之前已经见过了。当时我们传递了3个参数：PyCodeObject、名字空间、函数名。其实可以传递五个参数：</strong></p>
<ul>
<li><code>PyCodeObject对象</code></li>
<li><code>globals</code></li>
<li><code>name</code></li>
<li><code>argdef: 默认参数的值</code></li>
<li><code>closure: 闭包变量</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">global</span> value</span><br><span class="line">    value = v </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = &#123;&#125;</span><br><span class="line"><span class="comment"># 对于new_f而言, g就是它的全局名字空间, 所以设置的全局变量value会体现在g中</span></span><br><span class="line">new_f = <span class="built_in">type</span>(f)(f.__code__, g, <span class="string">&quot;new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line">new_f(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># &#123;&#x27;value&#x27;: 10&#125;</span></span><br><span class="line"></span><br><span class="line">new_f(<span class="string">&quot;夏色祭&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># &#123;&#x27;value&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>是不是奇怪的知识又增加了呢？但还是那句话，这种做法没有什么实际用途，只是让我们能够更好地理解函数的机制。</strong></p>
<p>​        <strong>4. 请介绍装饰器的运行原理，并说说你对 @xxxx 这种写法的理解？</strong>    </p>
<p><strong>装饰器用于包装函数对象，在不修改函数源码和调用方式的前提下、达到修改函数行为的目的。它的本质是高阶函数加上闭包，而@xxxx只是一个语法糖。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deco</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;++++++&quot;</span>)</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;******&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deco</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">++++++</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">******</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>还是那句话，装饰器本质是高阶函数加上闭包，而很多语言都有闭包，也可以多层函数嵌套。但是对于Python而言，装饰器显得格外的优雅。</strong></p>
<blockquote>
<p><strong>flask框架就用到了大量的装饰器，比如：@app.route(“&#x2F;“)，不得不说，flask的作者真的是非常喜欢使用装饰器，还有它们团队开发的、用于处理命令行参数的click模块，也是大量使用了装饰器。</strong></p>
</blockquote>
<p>​        <strong>5. Python 中的闭包变量(外层作用域的变量)可以被内部函数修改吗？</strong>    </p>
<p><strong>显然是可以的，有两种方式：一种是通过nonlocal关键字，另一种是通过获取闭包变量的方式。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = f1()</span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># 0</span></span><br><span class="line">f.__closure__[<span class="number">0</span>].cell_contents = <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># &gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>6. 请描述执行以下程序将输出什么内容？并试着解释其中的原因。</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n, l=[]</span>):</span><br><span class="line">    l.append(n)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">2</span>))  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>))  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>出现这种问题的原因就在于，*Python* 函数在创建时便完成了默认参数的初始化，并保存在函数对象的 *<strong>defaults</strong>* 字段中，并且是不变的，永远是那一个对象：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n, l=[]</span>):</span><br><span class="line">    l.append(n)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">2</span>))  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>))  <span class="comment"># [1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(add.__defaults__[<span class="number">0</span>])  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065459727-1555535085.png" alt="img"></p>
<p><strong>显然在函数执行的时候，如果我们没有传递参数，那么会从栈帧的f_localsplus中获取对应的默认值，当然这个默认值也在函数的__defaults__中。这个f_localsplus由局部变量、cell对象、free对象、运行时栈组成，运行时栈位于栈顶，*Python* 虚拟机负责从函数对象中取出默认参数并设置相关局部变量：</strong></p>
<p><strong>由于列表是可变对象，因此采用append的方式，那么显然每一次都会有变化的，因为操作的是同一个列表。</strong></p>
<p><strong>所以在设置默认参数的时候，不要设置成可变对象。如果你的IDE比较智能的话，比如pycharm，那么会给你抛出警告的。</strong></p>
<p><img src="/2023/04/02/16-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200829065507599-355200755.png" alt="img"></p>
<p><strong>我们看到飘黄了，因为默认参数的值是一个可变对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>到目前为止，我们关于函数的内容就算分析完了，可以好好体会一下函数的底层实现。我们下一篇将来分析Python中类的实现，又是一块难啃的骨头。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>15-函数在底层是如何被调用的</title>
    <url>/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/</url>
    <content><![CDATA[<h2 id="15-函数在底层是如何被调用的"><a href="#15-函数在底层是如何被调用的" class="headerlink" title="15-函数在底层是如何被调用的"></a>15-函数在底层是如何被调用的</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在上一篇博客中，我们说了Python函数的底层实现，并且还演示了如何自定义一个函数，虽然这在工作中没有太大意义，但是可以让我们深刻理解函数的行为。此外我们还介绍了如何获取函数的参数，而这一次我们就来看看函数如何调用的。</strong></p>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def foo():</span></span><br><span class="line"><span class="string">    a, b = 1, 2</span></span><br><span class="line"><span class="string">    return a + b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>我们以一个非常简单的函数为例，看看它的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object foo at <span class="number">0x00000219BA3F1450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">12</span> POP_TOP</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">16</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object foo at <span class="number">0x00000219BA3F1450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> ((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">              <span class="number">2</span> UNPACK_SEQUENCE          <span class="number">2</span></span><br><span class="line">              <span class="number">4</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (b)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> BINARY_ADD</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>还是那句话，模块有一个PyCodeObject对象，函数也有一个PyCodeObject对象，只不过后者是在前者的常量池当中。而且dis模块在显示字节码的时候，自动帮我们分开了，我们从上到下依次捋一遍。</strong></p>
<ul>
<li><code>0 LOAD_CONST	0 (&lt;code object......: 遇到def关键字知道这是一个函数, 所以会加载其对应的PyCodeObject对象</code></li>
<li><code>2 LOAD_CONST 	1 (&#39;foo&#39;): 加载函数名</code></li>
<li><code> 4 MAKE_FUNCTION    0: 通过MAKE_FUNCTION指令构造一个函数</code></li>
<li><code>6 STORE_NAME    0 (foo): 将符号&quot;foo&quot;和上一步得到的函数绑定起来, 存储在local空间中, 这个local空间显然是模块的local空间、即global空间</code></li>
<li><code>8 LOAD_NAME    0 (foo): 注意这一步是在调用的时候发生的, 将变量foo加载进来</code></li>
<li><code>10 CALL_FUNCTION    0: 通过CALL_FUNCTION指令调用该函数(我们后面将要分析的重点), 后面的0表示参数个数</code></li>
<li><code>12 POP_TOP: 将上一步函数的返回值从运行时栈的顶部弹出</code></li>
<li><code>14 LOAD_CONST    2 (None): 加载返回值None</code></li>
<li><code>16 RETURN_VALUE: 将返回值返回</code></li>
</ul>
<p><strong>模块对应的字节码就是上面那样，再来看看函数的，事实上对于现在的你来说已经很简单了。</strong></p>
<ul>
<li><code>0 LOAD_CONST    1 ((1, 2)): 从常量池中加载元组, 我们说对于列表而言是先将内部的元素一个一个加载进来、然后通过BUILD_LIST构建一个列表, 但是对于元组来说则可以直接加载, 原因就是元组内的元素指向对象的地址不可以变</code></li>
<li><code>2 UNPACK_SEQUENCE    2: 解包</code></li>
<li><code>4 STORE_FAST    0 (a): 将解包得到两个常量中的第一个常量赋值给a</code></li>
<li><code>6 STORE_FAST    0 (B): 将解包得到两个常量中的第二个常量赋值给b</code></li>
<li><code>8 LOAD_FAST    0 (a): 加载局部变量a</code></li>
<li><code>10 LOAD_FAST    1 (b): 加载局部变量b</code></li>
<li><code>12 BINARY_ADD: 执行加法运算</code></li>
<li><code>14 RETURN_VALUE: 将返回值返回</code></li>
</ul>
<p><strong>所以从目前来看，这些字节码已经没什么难度了，但是我们看到调用函数是用过CALL_FUNCTION指令，那么这个指令都做了哪些事情呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_FUNCTION)</span>: &#123;</span><br><span class="line">    PREDICTED(CALL_FUNCTION);</span><br><span class="line">    <span class="comment">//sp: 运行时栈栈顶指针</span></span><br><span class="line">    <span class="comment">//res: 函数的返回值, 一个PyObject *</span></span><br><span class="line">    PyObject **sp, *res;</span><br><span class="line">    <span class="comment">//指向运行时栈的栈顶</span></span><br><span class="line">    sp = stack_pointer;</span><br><span class="line">    <span class="comment">//调用函数, 将返回值赋值给res, tstate表示线程对象, &amp;sp显然是一个三级指针了, oparg表示指令的操作数</span></span><br><span class="line">    res = call_function(tstate, &amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">    stack_pointer = sp;</span><br><span class="line">    PUSH(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重点是call_function函数，我们来看一下，同样位于 *ceval.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyCFunction_Check(op) (Py_TYPE(op) == &amp;PyCFunction_Type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFunction_Check(op) (Py_TYPE(op) == &amp;PyFunction_Type)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(PyObject *) _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">call_function</span><span class="params">(PyThreadState *tstate, PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取PyFunctionObject对象，因为pp_stack是在CALL_FUNCTION指令中传入的栈顶指针</span></span><br><span class="line">    <span class="comment">//传入的oparg是0，kwnames是NULL，这里的pfunc就是MAKE_FUNCTION中创建的PyFunctionObject对象</span></span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里的func和pfunc是一样的</span></span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    PyObject *x, *w;</span><br><span class="line">    <span class="comment">//处理参数，对于我们当前的函数来说，这里的nkwargs和nargs都是0    </span></span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs;</span><br><span class="line">    <span class="comment">//移动栈指针</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//然后这里有两种执行方式, 我们后面会说, 但是我们看到将返回值赋值给了x</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;use_tracing) &#123;</span><br><span class="line">        x = trace_call_function(tstate, func, <span class="built_in">stack</span>, nargs, kwnames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = _PyObject_Vectorcall(func, <span class="built_in">stack</span>, nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert((x != <span class="literal">NULL</span>) ^ (_PyErr_Occurred(tstate) != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空函数栈</span></span><br><span class="line">    <span class="keyword">while</span> ((*pp_stack) &gt; pfunc) &#123;</span><br><span class="line">        w = EXT_POP(*pp_stack);</span><br><span class="line">        Py_DECREF(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">trace_call_function</span><span class="params">(PyThreadState *tstate,</span></span><br><span class="line"><span class="params">                    PyObject *func,</span></span><br><span class="line"><span class="params">                    PyObject **args, Py_ssize_t nargs,</span></span><br><span class="line"><span class="params">                    PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *x; <span class="comment">//返回值</span></span><br><span class="line">    <span class="comment">//调用_PyObject_Vectorcall, 将返回值设置给x</span></span><br><span class="line">    <span class="keyword">if</span> (PyCFunction_Check(func)) &#123;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func, args, nargs, kwnames));</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里暂时先不用管, 这里是调用一个方法, 显然它是和类相关, 我们在介绍类的时候会说</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Py_TYPE(func) == &amp;PyMethodDescr_Type &amp;&amp; nargs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *self = args[<span class="number">0</span>];</span><br><span class="line">        func = Py_TYPE(func)-&gt;tp_descr_get(func, self, (PyObject*)Py_TYPE(self));</span><br><span class="line">        <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func,</span><br><span class="line">                                        args+<span class="number">1</span>, nargs<span class="number">-1</span>,</span><br><span class="line">                                        kwnames));</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_Vectorcall(func, args, nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后会调用 *_PyFunction_FastCallDict* 函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func); <span class="comment">//获取PyCodeObject对象</span></span><br><span class="line">    PyObject *globals = PyFunction_GET_GLOBALS(func);<span class="comment">//获取global名字空间</span></span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);<span class="comment">//获取参数</span></span><br><span class="line">    PyObject *kwdefs, *closure, *name, *qualname; <span class="comment">//一些其它属性</span></span><br><span class="line">    PyObject *kwtuple, **k;</span><br><span class="line">    PyObject **d;</span><br><span class="line">    Py_ssize_t nd, nk;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(func != <span class="literal">NULL</span>);</span><br><span class="line">    assert(nargs &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(nargs == <span class="number">0</span> || args != <span class="literal">NULL</span>);</span><br><span class="line">    assert(kwargs == <span class="literal">NULL</span> || PyDict_Check(kwargs));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们观察一下下面的return</span></span><br><span class="line">    <span class="comment">//一个是function_code_fastcall，一个是最后的_PyEval_EvalCodeWithName</span></span><br><span class="line">    <span class="comment">//从名字上能看出来function_code_fastcall是一个快分支, 它适用于没有参数函数</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fast paths */</span></span><br><span class="line">        <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">            <span class="comment">//function_code_fastcall里面逻辑很简单</span></span><br><span class="line">            <span class="comment">//直接抽走当前PyFunctionObject里面PyCodeObject和函数运行时的global命名空间等信息</span></span><br><span class="line">            <span class="comment">//根据PyCodeObject对象直接为其创建一个PyFrameObject对象，然后PyEval_EvalFrameEx执行栈帧</span></span><br><span class="line">            <span class="comment">//也就是真正的进入了函数调用，执行函数里面的代码</span></span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, nargs, globals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)) &#123;</span><br><span class="line">            <span class="comment">/* function called with no arguments, but all parameters have</span></span><br><span class="line"><span class="comment">               a default value: use default values as arguments .*/</span></span><br><span class="line">            args = _PyTuple_ITEMS(argdefs);</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, PyTuple_GET_SIZE(argdefs),</span><br><span class="line">                                          globals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//适用于有参数的情况</span></span><br><span class="line">    nk = (kwargs != <span class="literal">NULL</span>) ? PyDict_GET_SIZE(kwargs) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nk != <span class="number">0</span>) &#123;</span><br><span class="line">        Py_ssize_t pos, i;</span><br><span class="line">        kwtuple = PyTuple_New(<span class="number">2</span> * nk);</span><br><span class="line">        <span class="keyword">if</span> (kwtuple == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = _PyTuple_ITEMS(kwtuple);</span><br><span class="line">        pos = i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(kwargs, &amp;pos, &amp;k[i], &amp;k[i+<span class="number">1</span>])) &#123;</span><br><span class="line">            Py_INCREF(k[i]);</span><br><span class="line">            Py_INCREF(k[i+<span class="number">1</span>]);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i / <span class="number">2</span> == nk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwtuple = <span class="literal">NULL</span>;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取相关参数</span></span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func);</span><br><span class="line">    closure = PyFunction_GET_CLOSURE(func);</span><br><span class="line">    name = ((PyFunctionObject *)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = _PyTuple_ITEMS(argdefs);</span><br><span class="line">        nd = PyTuple_GET_SIZE(argdefs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果有参数的话，现在会走这一步，逻辑会复杂一些，不过这些都是后话了</span></span><br><span class="line">    <span class="comment">//但是显然最终也会经过PyEval_EvalFrameEx, 进而进入哪一个大大的for循环</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs,</span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230612755-992873571.png" alt="img"></p>
<p><strong>因此我们看到，总共有两条路径，分别针对无参和有参，但是最终殊途同归、都会走到PyEval_EvalFrameEx那里。然后虚拟机在新的栈帧中执行新的PyCodeObject，而这个PyCodeObject就是函数对应的PyCodeObject。</strong></p>
<p><strong>但是到这里恐怕就有人有疑问了，我们之前说过PyFrameObject是根据PyCodeObject创建的，而PyFunctionObject也是根据PyCodeObject创建的，那么PyFrameObject和PyFunctionObject之间有啥关系呢？</strong></p>
<blockquote>
<p><strong>如果把PyCodeObject比喻成”妹子”的话，那么PyFunctionObject就是妹子的”备胎”，PyFrameObject就是妹子的”心上人”。其实PyEval_EvalFrameEx在栈帧中执行的时候，PyFunctionObject的影响就已经消失了，真正对栈帧产生影响的是PyFunctionObject里面的PyCodeObject对象和global名字空间。也就是说，最终是PyFrameObject对象和PyCodeObject对象两者如胶似漆，跟PyFunctionObject对象之间没有关系，所以PyFunctionObject辛苦一场，实际上是为别人做了嫁衣。PyFunctionObject主要是对PyCodeObject和global名字空间的一种打包和运输方式。</strong></p>
</blockquote>
<p><strong>另外我们这里提到了快速通道，那么函数是通过什么来判断是否可以进入快速通道呢？答案是通过函数参数的形式来决定是否可以进入快速通道，下面我们就来看看函数中参数的实现。</strong></p>
<h3 id="函数参数的实现"><a href="#函数参数的实现" class="headerlink" title="函数参数的实现"></a>函数参数的实现</h3><p><strong>函数最大的特点就是可以传入参数，否则就只能单纯的封装，这样未免太无趣了。对于Python来说，参数会传什么对于函数来说是不知道的，函数体内部只是利用参数做一些事情，比如调用参数的get方法，但是到底能不能调用get方法，就取决于你给参数传的值到底是什么了。因此可以把参数看成是一个占位符，我们假设有这么个东西，直接把它当成已存在的变量或者常量去进行操作，然后调用的时候，将某个值传进去赋给相应的参数，然后参数对应着传入的具体的值将逻辑走一遍即可。</strong></p>
<h4 id="参数类别"><a href="#参数类别" class="headerlink" title="参数类别"></a>参数类别</h4><p><strong>在Python中，调用函数时所传递的参数根据形式的不同可以分为四种类别：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>位置参数(positional argument)：</strong><code>foo(a, b), a和b通过位置参数传递</code></li>
<li><strong>关键字参数(keyword argument)：</strong><code>foo(a=1, b=2), a和b通过关键字参数</code></li>
<li><strong>扩展位置参数(excess positional argument)：</strong><code>foo(*args), args通过扩展位置参数传递</code></li>
<li>**扩展关键字参数(excess keyword argument)**：<code>foo(**kwargs), kwargs通过扩展位置参数传递</code></li>
</ul>
<p><strong>我们下面来看一下python的call_function是如何处理函数信息的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_LOCAL_INLINE(PyObject *) _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">call_function</span><span class="params">(PyThreadState *tstate, PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;</span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    PyObject *x, *w;</span><br><span class="line">    <span class="comment">/*当python虚拟机在开始执行MAKE_FUNCTION指令时，会先获取一个指令参数oparg</span></span><br><span class="line"><span class="comment">    oparg里面记录函数的参数个数信息，包括位置参数和关键字参数的个数。</span></span><br><span class="line"><span class="comment">    虽然扩展位置参数和扩展关键字参数是更高级的用法，但是本质上也是由多个位置参数、多个关键字参数组成的。</span></span><br><span class="line"><span class="comment">    这就意味着，虽然Python中存在四种参数，但是只要记录位置参数和关键字参数的个数，就能知道一共有多少个参数，进而知道一共需要多大的内存来维护参数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//nkwargs就是关键字参数的个数，nargs是位置参数的个数 </span></span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs;</span><br><span class="line">    PyObject **<span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br></pre></td></tr></table></figure>

<p><strong>而且Python的每个指令都是两个字节，第一个字节存放指令序列本身，第二个字节存放参数个数，既然是一个字节，说明最多只允许有255个参数，不过这已经足够了。但是在Python3.8中，这个限制被打破了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze3ik2oh85c6hanp0hmZ ~]<span class="comment"># python3 1.py </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;1.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">exec</span>(s))</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">SyntaxError: more than <span class="number">255</span> arguments</span><br><span class="line">[root@iZ2ze3ik2oh85c6hanp0hmZ ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p><strong>以我阿里云上的Python3.6为例，发现参数不能超过255个，但是在Python3.8的时候，即使有1000000个参数也是没问题的。所以Python3.8的源码变动是有些大的，3.6和3.7实际上是差不多的，虚拟机实现代码甚至和Python2也高度相似。但是在Python3.8，变动就有点大了。</strong></p>
<p><strong>Python函数内部局部变量信息，可以通过co_nlocals和co_argcount来获取。从名字也能看出来这个不是PyFunctionObject里面的，而是PyCodeObject里面的。co_nlocals，我们之前说过，这是函数内部局部变量的个数，co_argcount是参数的个数。实际上，函数参数和函数局部变量是非常密切的，某种意义上函数参数就是一种函数局部变量，它们在内存中是连续放置的。当Python需要为函数申请局部变量的内存空间时，就需要通过co_nlocals知道局部变量的总数。不过既然如此，那还要co_argcount干什么呢？别急，看个例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span></span>):</span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>函数的参数也是一个局部变量，因此co_nlocals是参数的个数加上函数体中新创建的局部变量的个数。注意函数参数也是一个局部变量，比如参数有一个a，但是函数体里面的变量还是a，相当于重新赋值了，因此还是相当于一个参数。但是co_argcount则是存储记录参数的个数。因此一个很明显的结论：<code>对于任意一个函数，co_nlocals至少是大于等于co_argcount的</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">1</span>, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><strong>另外我们看到，对于扩展位置参数、扩展关键字参数来说，co_argcount是不算在内的，因为你完全可以不传递，所以直接当成0来算。而对于co_nlocals来说，我们在函数体内部肯定是能拿到args和kwargs的，而这可以看成是两个参数。因此co_argcount是4，co_nlocals是6。其实所有的扩展位置参数是存在了一个PyTupleObject对象中的，所有的扩展关键字参数是存储在一个PyDictObject对象中的。而即使我们多传、或者不传，对于co_argcount和co_nlocals来说，都不会有任何改变了，因为这两者的值是在编译的时候就已经确定了的。</strong></p>
<h4 id="位置参数的传递"><a href="#位置参数的传递" class="headerlink" title="位置参数的传递"></a>位置参数的传递</h4><p><strong>下面我们就来看看位置参数是如何传递的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def f(name, age):</span></span><br><span class="line"><span class="string">    age = age + 5</span></span><br><span class="line"><span class="string">    print(name, age)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">age = 5</span></span><br><span class="line"><span class="string">f(&quot;satori&quot;, age)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis </span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;call_function&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>字节码如下，我们来分析一下，当然基础的就一笔带过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object f at <span class="number">0x00000224C3941450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (f)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>           <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (<span class="number">5</span>)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (age)</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;satori&#x27;</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_NAME                <span class="number">1</span> (age)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span> <span class="comment">//oparg是2, 表示调用的时候传递了两个参数</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">4</span> (None)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object f at <span class="number">0x00000224C3941450</span>, file <span class="string">&quot;call_function&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (age) <span class="comment">//此时age和对应的值已经存在函数的符号表和常量池当中了</span></span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)  <span class="comment">//加载常量5</span></span><br><span class="line">              <span class="number">4</span> BINARY_ADD</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">1</span> (age) <span class="comment">//相加之后, 重新使用age保存</span></span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_GLOBAL              <span class="number">0</span> (print) <span class="comment">//加载print</span></span><br><span class="line">             <span class="number">10</span> LOAD_FAST                <span class="number">0</span> (name) <span class="comment">//加载局部变量name和age</span></span><br><span class="line">             <span class="number">12</span> LOAD_FAST                <span class="number">1</span> (age)</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION            <span class="number">2</span>  <span class="comment">//函数调用,显然是print, 参数是两个</span></span><br><span class="line">             <span class="number">16</span> POP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">20</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码虽然解释完了， 但是最重要的还是没有说。<code>f(name, age)</code>，这里的name和age显然是外层定义的，但是外层定义的这两个变量是怎么传给函数f的。下面我们通过源码重新分析：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;satori&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> LOAD_NAME                <span class="number">1</span> (age)</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到<code>CALL_FUNCTION</code>上面有三条指令，其实当这三条指令执行完毕之后，函数需要的参数已经被压入了运行时栈中。</strong></p>
<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230620325-1367321592.png" alt="img"></p>
<p><strong>通过 *_PyFunction_FastCallDict* 函数，然后执行function_code_fastcall。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line"><span class="type">static</span> PyObject* _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">function_code_fastcall</span><span class="params">(PyCodeObject *co, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span></span><br><span class="line"><span class="params">                       PyObject *globals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *f; <span class="comment">//栈帧对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET(); <span class="comment">//线程状态对象</span></span><br><span class="line">    PyObject **fastlocals; <span class="comment">//f-&gt;localsplus, 后面会说</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(globals != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* XXX Perhaps we should create a specialized</span></span><br><span class="line"><span class="comment">       _PyFrame_New_NoTrack() that doesn&#x27;t take locals, but does</span></span><br><span class="line"><span class="comment">       take builtins without sanity checking them.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建与函数对应的PyFrameObject，我们看到参数是co，所以是根据字节码指令来创建的</span></span><br><span class="line">    <span class="comment">//然后还有一个globals, 表示global名字空间, 所以我们看到最后实际上没有PyFunctionObject什么事, 它只是起到一个输送的作用</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_INCREF(*args);</span><br><span class="line">        fastlocals[i] = *args++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键：拷贝函数参数，从运行时栈到PyFrameObject.f_localsplus</span></span><br><span class="line">    result = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_REFCNT(f) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++tstate-&gt;recursion_depth;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        --tstate-&gt;recursion_depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源码中我们看到通过 *_PyFrame_New_NoTrack*  创建了函数f对应的PyFrameObject对象，参数是co对应的PyFunctionObject对象中保存的PyCodeObject对象。随后，Python虚拟机将参数逐个拷贝到新建的PyFrameObject对象的f_localsplus中。可在分析Python虚拟机框架时，我们知道，这个f_localsplus所指向的内存块里面也存储了Python虚拟机所使用的那个运行时栈。那么参数所占的内存和运行时栈所占的内存有什么关联呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是_PyFrame_New_NoTrack，对外暴露的是PyFrame_New,但是本质上调用了这个</span></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">        ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">        nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">        extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        <span class="keyword">if</span> (free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//为f_localsplus申请内存空间, 大小为extras, 注意这个extras, 我们看到它实际上分为四个部分</span></span><br><span class="line">            <span class="comment">//分别是: 运行时栈、局部变量、cell对象、free对象, 注意:但在内存中它们可不是这个顺序</span></span><br><span class="line">            f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type,</span><br><span class="line">            extras);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(builtins);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        f-&gt;f_code = code;</span><br><span class="line">        <span class="comment">//获取局部变量的个数 + cell对象的个数 + free对象的个数</span></span><br><span class="line">        extras = code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">        f-&gt;f_valuestack = f-&gt;f_localsplus + extras;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;extras; i++)</span><br><span class="line">            f-&gt;f_localsplus[i] = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_locals = <span class="literal">NULL</span>;</span><br><span class="line">        f-&gt;f_trace = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前面提到，在函数对应的PyCodeObject对象的co_nlocals域中，包含着函数参数的个数，因为函数参数也是局部符号的一种。所以从f_localsplus开始，extras中一定有供函数参数使用的内存。或者说，函数的参数存放在运行时栈之前的那段内存中。</strong></p>
<p><strong>另外从_PyFrame_New_NoTrack当中我们可以看到，在数组f_localsplus中存储函数参数的空间和运行时栈的空间在逻辑上是分离的，并不是共享同一片内存，尽管它们是连续的，但这两者是鸡犬相闻，但又泾渭分明、老死不相往来。</strong></p>
<p><strong>在处理完参数之后，还没有进入PyEval_EvalFrameEx，所以此时运行时栈是空的。但是函数的参数已经位于f_localsplus中了。所以这时新建PyFrameObject对象的f_localsplus就是这样：</strong></p>
<p><img src="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/1229382-20200828230635471-1010256465.png" alt="img"></p>
<h4 id="位置参数的访问"><a href="#位置参数的访问" class="headerlink" title="位置参数的访问"></a>位置参数的访问</h4><p><strong>当参数拷贝的动作完成之后，就会进入新的PyEval_EvalFrameEx，开始真正的f的调用动作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (age) </span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)  </span><br><span class="line">            <span class="number">4</span> BINARY_ADD</span><br><span class="line">            <span class="number">6</span> STORE_FAST               <span class="number">1</span> (age) </span><br></pre></td></tr></table></figure>

<p><strong>首先对参数的读写，肯定是通过<code>LOAD_FAST</code>,<code>LOAD_CONST</code>,<code>STORE_FAST</code>这几条指令集完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个宏, 这里的fastlocals显然就是f -&gt; localsplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETLOCAL(i)     (fastlocals[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_FAST)</span>: &#123;</span><br><span class="line">            <span class="comment">//从fastlocals中获取索引为oparg的值</span></span><br><span class="line">            PyObject *value = GETLOCAL(oparg);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format_exc_check_arg(tstate, PyExc_UnboundLocalError,</span><br><span class="line">                                     UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                                     PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(STORE_FAST)</span>: &#123;</span><br><span class="line">            PREDICTED(STORE_FAST);</span><br><span class="line">            PyObject *value = POP(); <span class="comment">//弹出元素</span></span><br><span class="line">            SETLOCAL(oparg, value);  <span class="comment">//将索引为oparg的元素设置为value</span></span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们发现，LOAD_FAST和STORE_FAST这一对指令是以f_localsplus这一片内存为操作目标的，指令<code>0 LOAD_FAST 1 (age)</code>的结果是将f_localsplus[1]对应的对象压入到运行时栈中。而在完成加法操作之后，又将结果通过STORE_FAST放入到f_localsplus[1]中，这样就实现了对a的更新，那么以后在print(a)的时候，得到的结果就是10了。</strong></p>
<p><strong>现在关于Python的位置参数在函数调用时是如何传递的、在函数执行又是如何被访问的，已经真相大白了。在调用函数时，Python将函数参数的值从左至右依次压入到运行时栈中，而在call_function中通过调用 *_PyFunction_FastCallDict*  ，进而调用function_code_fastcall，而在function_code_fastcall中，又将这些参数依次拷贝到和PyFrameObject对象的f_localsplus中。最终的效果就是，Python虚拟机将函数调用时使用的参数，从左至右依次地存放在新建的PyFrameObject对象的f_localsplus中。</strong></p>
<p><strong>因此在访问函数参数时，python虚拟机并没有按照通常访问符号的做法，去查什么名字空间，而是直接通过一个索引<code>(偏移位置)</code>来访问f_localsplus中存储的符号对应的值，是的，f_localsplus存储的是符号<code>(变量名)</code>，并不是具体的值。因为我们说Python中的变量只是一个指针，至于值是否改变，则取决于对应的值是可变对象还是不可变对象，而不是像其他编程语言那样通过传值或者传指针来决定是否改变。因此这种通过索引<code>(偏移位置)</code>来访问参数的方式也正是位置参数的由来。</strong></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p><strong>Python函数的一个特点就是支持默认参数，这是非常方便的，我们来看看实现机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def foo(a=1, b=2):</span></span><br><span class="line"><span class="string">    print(a + b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">5</span> ((<span class="number">1</span>, <span class="number">2</span>))//我们看到在构造函数的时候就已经把默认值加载进来了</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">2</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x000002076ED83BE0</span>, file <span class="string">&quot;default&quot;</span>, line <span class="number">2</span>&gt;)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> MAKE_FUNCTION            <span class="number">1</span> (defaults) </span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">10</span> LOAD_NAME                <span class="number">0</span> (foo)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x000002076ED83BE0</span>, file <span class="string">&quot;default&quot;</span>, line <span class="number">2</span>&gt;:</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们对比一下开始的没有默认参数的函数，会发现相比于无默认参数的函数，有默认参数的函数，除了load函数体对应的PyCodeObject、和foo这个符号之外，会先将默认参数的值给load进来，将这三者都压入运行时栈。但是我们发现这是默认参数是组合成一个元组的形式入栈的，而且我们再来观察一下<code>MAKE_FUNCTION</code>这个指令，我们发现后面的参数是1 (defaults)，之前的都是0，那么这个1是什么呢？而且又提示了我们一个defaults，我们知道PyFunctionObject对象有一个func_defaults，这两者之间有关系吗？那么带着这些疑问再来看看<code>MAKE_FUNCTION</code>指令。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(MAKE_FUNCTION)</span>: &#123;</span><br><span class="line">    PyObject *qualname = POP();</span><br><span class="line">    PyObject *codeobj = POP();</span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////默认参数，我们发现确实是存储在func_defaults里面</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过以上命令我们很容易看出，<code>MAKE_FUNCTION</code>指令除了创建PyFunctionObject对象，并且还会处理参数的默认值。<code>MAKE_FUNCTION</code>指令参数表示当前运行时栈中是存在默认值的，但是默认值具体多少个通过参数是看不到的，因为默认值都会按照顺序塞到一个PyTupleObject对象里面，所以整体相当于是一个。然后会调用<code>PyFunction_SetDefaults</code>将该PyTupleObject对象设置为PyFunctionObject.func_defaults的值，在Python层面可以使用<code>__defaults__</code>访问。如此一来，函数参数的默认值也成为了PyFunctionObject对象的一部分，函数和其参数的默认值最终被Python虚拟机捆绑在了一起，它和PyCodeObject、global命名空间一样，也被塞进了PyFunctionObject这个大包袱。所以说PyFunctionObject这个嫁衣做的是很彻底的，工具人PyFunctionObject对象，给个赞。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyFunction_SetDefaults</span><span class="params">(PyObject *op, PyObject *defaults)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyFunction_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defaults == Py_None)</span><br><span class="line">        defaults = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (defaults &amp;&amp; PyTuple_Check(defaults)) &#123;</span><br><span class="line">        Py_INCREF(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError, <span class="string">&quot;non-tuple default args&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将PyFunctionObject对象的func_defaults成员设置为defaults</span></span><br><span class="line">    Py_XSETREF(((PyFunctionObject *)op)-&gt;func_defaults, defaults);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们还是以这个foo函数为例，看看不同的调用方式对应的底层实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a=<span class="number">1</span>, b=<span class="number">2</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>

<p>​        <strong>不传入参数，直接执行foo()</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyFunction_FastCallDict(PyObject *func, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                         PyObject *kwargs)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的PyCodeObject</span></span><br><span class="line">    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的global名字空间</span></span><br><span class="line">    PyObject *globals = PyFunction_GET_GLOBALS(func);</span><br><span class="line">    <span class="comment">//获取PyFunctionObject的默认值</span></span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);</span><br><span class="line">    <span class="comment">//一些额外属性</span></span><br><span class="line">    PyObject *kwdefs, *closure, *name, *qualname;</span><br><span class="line">    PyObject *kwtuple, **k;</span><br><span class="line">    PyObject **d;</span><br><span class="line">    Py_ssize_t nd, nk;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(func != <span class="literal">NULL</span>);</span><br><span class="line">    assert(nargs &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(nargs == <span class="number">0</span> || args != <span class="literal">NULL</span>);</span><br><span class="line">    assert(kwargs == <span class="literal">NULL</span> || PyDict_Check(kwargs));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里进行判断能否进入快速通道, 一个函数如果想进入快速通道必须要满足两个条件</span></span><br><span class="line">    <span class="comment">//1. 函数定义的时候不可以有默认参数; 2. 函数调用时，必须都通过位置参数指定。</span></span><br><span class="line">    <span class="comment">//所以这里检测co_kwonlyargcount和kwargs是否均为零</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (kwargs == <span class="literal">NULL</span> || PyDict_GET_SIZE(kwargs) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (co-&gt;co_flags &amp; ~PyCF_MASK) == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//然后继续检测: 这里的nargs是通过call_function函数传递的</span></span><br><span class="line">        <span class="comment">//而这个nargs在call_function函数中是Py_ssize_t nargs = oparg - nkwargs;</span></span><br><span class="line">        <span class="comment">//所以这里的nargs就是传递的参数个数减去通过关键字参数方式传递的参数个数</span></span><br><span class="line">        <span class="comment">//而co_argcount是函数参数的总个数，所以一旦哪怕有一个参数使用了关键字参数的方式传递，都会造成两者不相等，从而无法进入快速通道</span></span><br><span class="line">        <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, nargs, globals);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//但是这样的条件确实有点苛刻了，毕竟参数哪能没有默认值呢？所以Python还提供了一种进入快速通道的方式</span></span><br><span class="line">        <span class="comment">//我们发现在有默认的前提下，如果还能满足nargs==0 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)也能进入快速通道</span></span><br><span class="line">        <span class="comment">//co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)是要求函数的参数个数必须等于默认参数的个数，也就是函数参数全是默认参数</span></span><br><span class="line">        <span class="comment">//nargs==0则是需要传入的参数个数减去通过关键字参数传递的参数个数等于0，即要么不传参(都是用默认参数)、要么全部都通过关键字参数的方式传参。</span></span><br><span class="line">        <span class="comment">//这种方式也可以进入快速通道</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                 &amp;&amp; co-&gt;co_argcount == PyTuple_GET_SIZE(argdefs)) &#123;</span><br><span class="line">            args = _PyTuple_ITEMS(argdefs);</span><br><span class="line">            <span class="keyword">return</span> function_code_fastcall(co, args, PyTuple_GET_SIZE(argdefs),</span><br><span class="line">                                          globals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果以上两点都无法满足的话，那么就没办法了，只能走常规方法了</span></span><br><span class="line">    <span class="comment">//获取默认参数的信息</span></span><br><span class="line">    nk = (kwargs != <span class="literal">NULL</span>) ? PyDict_GET_SIZE(kwargs) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nk != <span class="number">0</span>) &#123;</span><br><span class="line">        Py_ssize_t pos, i;</span><br><span class="line"></span><br><span class="line">        kwtuple = PyTuple_New(<span class="number">2</span> * nk);</span><br><span class="line">        <span class="keyword">if</span> (kwtuple == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = _PyTuple_ITEMS(kwtuple);</span><br><span class="line">        pos = i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(kwargs, &amp;pos, &amp;k[i], &amp;k[i+<span class="number">1</span>])) &#123;</span><br><span class="line">            Py_INCREF(k[i]);</span><br><span class="line">            Py_INCREF(k[i+<span class="number">1</span>]);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i / <span class="number">2</span> == nk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwtuple = <span class="literal">NULL</span>;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是获取函数的一些属性，默认关键字参数、闭包等等</span></span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func);</span><br><span class="line">    closure = PyFunction_GET_CLOSURE(func);</span><br><span class="line">    name = ((PyFunctionObject *)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取默认参数的值的地址、以及默认参数的个数</span></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = _PyTuple_ITEMS(argdefs);</span><br><span class="line">        nd = PyTuple_GET_SIZE(argdefs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用_PyEval_EvalCodeWithName, 传入函数的PyCodeObject对象以及参数信息</span></span><br><span class="line">    result = _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                      args, nargs, </span><br><span class="line">                                      k, k != <span class="literal">NULL</span> ? k + <span class="number">1</span> : <span class="literal">NULL</span>, nk, <span class="number">2</span>,</span><br><span class="line">                                      d, nd, kwdefs,</span><br><span class="line">                                      closure, name, qualname);</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_PyEval_EvalCodeWithName</code>是一个非常重要的函数，在后面分析扩展位置参数和扩展关键字参数是还会遇到。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyCodeObject对象, 通过_PyFunction_FastCallDict中接收的func得到</span></span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;</span><br><span class="line">    <span class="comment">//栈帧</span></span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    PyObject *retval = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//f -&gt; localsplus, 和co -&gt; co_freevars, 这个co_freevars、以及co_freevars都是与闭包相关的</span></span><br><span class="line">    PyObject **fastlocals, **freevars;</span><br><span class="line">    PyObject *x, *u;</span><br><span class="line">    <span class="comment">//参数总个数: 可以通过位置参数传递的参数个数  +  只能通过关键字参数传递的参数个数</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount;</span><br><span class="line">    Py_ssize_t i, j, n;</span><br><span class="line">    PyObject *kwdict;</span><br><span class="line"></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();  <span class="comment">//获取线程状态对象</span></span><br><span class="line">    assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (globals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;PyEval_EvalCodeEx: NULL globals&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建栈帧</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//还记得这个co_flags吗? 我们说它是用来判断参数的, 如果它和0x08进行&quot;与运算&quot;结果为真, 那么说明有**kwargs</span></span><br><span class="line">    <span class="comment">//如果它和0x04进行&quot;与运算&quot;结果为真, 那么说明有*args</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        kwdict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        i = total_args;</span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        SETLOCAL(i, kwdict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwdict = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//argcount是实际传来的位置参数的个数，co-&gt;co_argcount则是可以通过位置参数传递的参数个数</span></span><br><span class="line">    <span class="comment">//如果argcount &gt; co-&gt;co_argcount，证明有扩展参数，否则没有    </span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        <span class="comment">//所以这里的n等于co-&gt;co_argcount</span></span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有扩展位置参数, 那么调用者通过位置参数的方式传了几个、n就是几</span></span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后我们仔细看一下这个n，假设我们定义了一个函数def foo(a, b, c=1,d=2, *args)</span></span><br><span class="line">    <span class="comment">//如果argcount &gt; co-&gt;co_argcount, 说明我们传递的位置参数的个数超过了4个，但n是4</span></span><br><span class="line">    <span class="comment">//但是如果我们只传递了两个，比如foo(&#x27;a&#x27;, &#x27;b&#x27;)，那么n显然为2</span></span><br><span class="line">    <span class="comment">//下面就是将已经传递的参数的值依次设置到f_localsplus里面去，这里的j就是索引，x就是值。</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        x = args[j];</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">        SETLOCAL(j, x);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面显然是扩展位置参数参数的逻辑，我们暂时先跳过，后面会说</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        u = _PyTuple_FromArray(args + n, argcount - n);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        SETLOCAL(total_args, u);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//关键字参数，同样后面说</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会再进行检测，argcount &gt; co-&gt;co_argcount说明我们多传递了, 然后检测是否存在*args</span></span><br><span class="line">    <span class="comment">//如果co-&gt;co_flags &amp; CO_VARARGS为False, 那么直接报错</span></span><br><span class="line">    <span class="keyword">if</span> ((argcount &gt; co-&gt;co_argcount) &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) &#123;</span><br><span class="line">        too_many_positional(tstate, co, argcount, defcount, fastlocals);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果传入的参数个数比函数定义的参数的个数少，那么证明有默认参数。</span></span><br><span class="line">    <span class="comment">//defcount表示设置了默认参数的个数</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &lt; co-&gt;co_argcount) &#123;</span><br><span class="line">        <span class="comment">//显然m = 参数总个数(不包括*args和**kwargs之外的所有形参的个数) - 默认参数的个数</span></span><br><span class="line">        Py_ssize_t m = co-&gt;co_argcount - defcount;</span><br><span class="line">        Py_ssize_t missing = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因此m就是需要传递的没有默认值的参数的总个数</span></span><br><span class="line">        <span class="keyword">for</span> (i = argcount; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//而i=argcount则是我们调用函数时传递的位置参数的总个数，很明显如果参数足够，那么 i &lt; m 是不会满足的</span></span><br><span class="line">            <span class="comment">//比如一个函数接收6个参数，但是有两个是默认参数，因此这就意味着调用者通过位置参数的方式传递的话，需要至少传递4个，那么m就是4</span></span><br><span class="line">            <span class="comment">//而如果我们也传递了四个，那么初始的i同样是 4</span></span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//但如果我们只传递了两个，那么通过GETLOCAL从f -&gt; f_localsplus中就会获取不到值</span></span><br><span class="line">                <span class="comment">//而一旦找不到，missing：缺少的参数个数就会+1</span></span><br><span class="line">                missing++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//那么按照我们上面的逻辑，显然还有两个没传递，但是它们会使用默认值</span></span><br><span class="line">        <span class="comment">//如果是只传递了3个参数, 那么显然还有3个参数没有传, 但默认值只有两个, 因此missing不为0</span></span><br><span class="line">        <span class="keyword">if</span> (missing) &#123;</span><br><span class="line">            <span class="comment">//直接抛出异常</span></span><br><span class="line">            missing_arguments(tstate, co, missing, defcount, fastlocals);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面可能难理解，我们说这个m，是需要由调用者传递的参数个数</span></span><br><span class="line">        <span class="comment">//而n是以位置参数的形式传递过来的参数的个数，如果比函数参数个数少，那么n就是传来的参数个数，如果比函数参数的个数大，那么n则是函数参数的个数。比如：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        def foo(a, b, c, d=1, e=2, f=3):</span></span><br><span class="line"><span class="comment">        	pass</span></span><br><span class="line"><span class="comment">        这是一个有6个参数的函数，显然m是3，实际上函数定义好了，m就是一个不变的值了，就是没有默认参数的参数总个数</span></span><br><span class="line"><span class="comment">        但是我们调用时可以是foo(1,2,3)，也就是只传递3个，那么这里的n就是3，</span></span><br><span class="line"><span class="comment">        foo(1, 2, 3, 4, 5)，那么显然n=5，而m依旧是3</span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">            <span class="comment">//因此现在这里的逻辑就很好理解了，假设调用时foo(1, 2, 3, 4, 5)</span></span><br><span class="line">            <span class="comment">//由于有3个是默认参数，那么调用只传递3个就可以了，但是这里传递了5个，前3个是必传的</span></span><br><span class="line">            <span class="comment">//至于后面两个，则说明我不想使用默认值，我想重新传递，而使用默认值的只有最后一个</span></span><br><span class="line">            <span class="comment">//所以这个i就是明明可以使用默认值、但却没有使用的参数的个数            </span></span><br><span class="line">            i = n - m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//另外如果按照位置参数传递的话，程序能走到这一步，说明已经不存在少传的情况了</span></span><br><span class="line">            <span class="comment">//因此这个n至少是&gt;=m的，因此如果n == m的话，那么i就是0</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; defcount; i++) &#123;     </span><br><span class="line">            <span class="comment">//默认参数的值一开始就已经被压入栈中，整体作为一个PyTupleObject对象，被设置到了func_defaults这个域中</span></span><br><span class="line">            <span class="comment">//但是对于函数的参数来讲，肯定还要设置到f_localsplus里面去，并且它只能是在后面。</span></span><br><span class="line">            <span class="comment">//因为默认参数的顺序要在非默认参数之后            </span></span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(m+i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//这里是把索引为i对应的值从func_defaults对应的PyTupleObject里面取出来</span></span><br><span class="line">                <span class="comment">//这个i要么是n-m，要么是0。还按照之前的例子，函数接收6个参数，但是我们传了5个</span></span><br><span class="line">                <span class="comment">//因此我们只需要将最后一个、也就是索引为2的元素拷贝到f_localsplus里面去即可。</span></span><br><span class="line">                <span class="comment">//而n=5，m=3，显然i = 2</span></span><br><span class="line">                <span class="comment">//那么如果我们传递了3个呢？</span></span><br><span class="line">                <span class="comment">//显然i是0，因为此时n==m嘛，那么就意味着默认参数都使用默认值，既然这样，那就从头开始开始拷呗。</span></span><br><span class="line">                <span class="comment">//同理传了4个参数，证明第一个默认参数的默认值是不需要的，那么就只需要再把后面两个拷过去就可以了</span></span><br><span class="line">                <span class="comment">//那么显然要从索引为1的位置拷到结束，而此时n-m、也就是i，正好为1</span></span><br><span class="line">                <span class="comment">//所以，n-m就是&quot;默认参数值组成的PyTupleObject对象中需要拷贝到f_localsplus中的第一个值的索引&quot;</span></span><br><span class="line">                <span class="comment">//然后i &lt; defcount; i++，一直拷到结尾                             </span></span><br><span class="line">                PyObject *def = defs[i];</span><br><span class="line">                Py_INCREF(def);</span><br><span class="line">                <span class="comment">//将值设置到f_localsplus里面，这里显然索引是m+i</span></span><br><span class="line">                <span class="comment">//比如：def foo(a,b,c,d=1,e=2,f=3)</span></span><br><span class="line">                <span class="comment">//foo(1, 2, 3, 4)，显然d不会使用默认值，那么只需要把后两个默认值拷给e和f即可</span></span><br><span class="line">                <span class="comment">//显然e和f根据顺序在f_localsplus中对应索引为4、5</span></span><br><span class="line">                <span class="comment">//m是3，i是n-m等于4-3等于1，所以m+i正好是4，</span></span><br><span class="line">                <span class="comment">//f_localsplus: [1, 2, 3, 4]</span></span><br><span class="line">                <span class="comment">//PyTupleObject:(1, 2, 3)</span></span><br><span class="line">                <span class="comment">//因此PyTupleObject中索引为i的元素，拷贝到f_localsplus中正好是对应m+i的位置               </span></span><br><span class="line">                SETLOCAL(m+i, def);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此通过以上我们就知道了位置参数的默认值是怎么一回事了。</strong></p>
<p>​        <strong>传入一个关键字参数，执行foo(b&#x3D;3)</strong>    </p>
<p><strong>在对foo进行第二次调用的时候，我们指定了b&#x3D;3，但是调用方式本质是一样的。在<code>CALL_FUNCTION</code>之前，python虚拟机将PyUnicodeObject对象b和PyLongObject对象3压入了运行时栈。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;	</span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历关键字参数，确定函数的def语句中是否出现了关键字参数的名字 */</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">        PyObject **co_varnames;  <span class="comment">//符号表</span></span><br><span class="line">        PyObject *keyword = kwnames[i]; <span class="comment">//获取参数名</span></span><br><span class="line">        PyObject *value = kwargs[i];  <span class="comment">//获取参数值</span></span><br><span class="line">        Py_ssize_t j;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//显然参数必须是字符串, 所以在字典中你可以这么做: &#123;**&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;&#125;</span></span><br><span class="line">        <span class="comment">//但你不可以这么做: dict(**&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">if</span> (keyword == <span class="literal">NULL</span> || !PyUnicode_Check(keyword)) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() keywords must be strings&quot;</span>,</span><br><span class="line">                          co-&gt;co_name);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里的逻辑我们后面会详细说, 总之核心就是检测一个参数是否同时通过位置参数和关键字参数传递了, 也就是判断是否传递了两次</span></span><br><span class="line">        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;</span><br><span class="line">        <span class="comment">//在函数的符号表中寻找关键字参数, 注意: 这里的j不是从0开始的, 而是从posonlyargcount开始</span></span><br><span class="line">        <span class="comment">//因为在Python3.8中引入了/, 在/前面的参数只能通过位置参数传递</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="keyword">if</span> (name == keyword) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 逻辑和上面一样 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="type">int</span> cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">        assert(j &gt;= total_args);</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//如果符号表中没有出现指定的符号, 那么表示出现了一个不需要的关键字参数(当然**kwargs后面说)</span></span><br><span class="line">            <span class="keyword">if</span> (co-&gt;co_posonlyargcount</span><br><span class="line">                &amp;&amp; positional_only_passed_as_keyword(tstate, co,</span><br><span class="line">                                                     kwcount, kwnames))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got an unexpected keyword argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItem(kwdict, keyword, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      kw_found:</span><br><span class="line">        <span class="keyword">if</span> (GETLOCAL(j) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got multiple values for argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        SETLOCAL(j, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在编译时：Python会将函数的def语句中出现的符号都记录在符号表(co_varnames)里面。由于我们已经看到，在foo(b&#x3D;3)的指令序列中，Python虚拟机在执行<code>CALL_FUNCTION</code>指令之前会将关键字参数的名字都压入到运行时栈，那么在<code>_PyEval_EvalCodeWithName</code>中就能利用运行时栈中保存的关键字参数的名字在Python编译时得到的co_varnames中进行查找。最妙的是，在co_varnames中定义的变量名的顺序是由规律的的。而且经过刚才的分析，我们也知道，在PyFrameObject对象的f_localsplus所维护的内存中，用于存储函数参数的内存也是按照相同规律排列的。所以在co_varnames中搜索到关键字参数的参数名时，我们可以直接根据所得到的序号信息直接设置f_localsplus中的内存，这就为默认参数设置了函数调用者希望的值。</strong></p>
<p><strong>因此我们可以再举个简单例子，总结一下。def foo(a, b, c,  d&#x3D;1,e&#x3D;2,  f&#x3D;3)，对于这样的一个函数。首先Python虚拟机知道调用者至少要给a、b、c传递参数。如果是foo(1)，那么1会传递给a，但是b和c是没有接受到值的，所以报错。但如果是foo(1, e&#x3D;4, c&#x3D;2,  b&#x3D;3)，还是老规矩1传递给a，发现依旧不够，这时候会把希望寄托于关键字参数上。并且我们说过f_localsplus维护的内存中存储的参数的顺序、co_varnames中参数的顺序都是一致的。所以关键字参数是不讲究顺序的，当找到了e&#x3D;4，那么Python虚拟机通过co_varnames符号表，就知道把e设置为f_localsplus中索引为4的地方，c&#x3D;2，设置为索引为2的地方，b&#x3D;3，设置为索引为1的地方。那么当位置参数和关键字参数都是设置完毕之后，python虚拟机会检测需要传递的参数、也就是没有默认值的参数，调用者有没有全部传递。</strong></p>
<blockquote>
<p><strong>但是这里再插一句，我们说关键字参数设置具体设置在f_localsplus中的哪一个地方，是通过将关键字参数名代入到co_varnames符号表里面查找所得到的的，但是如果这个关键字参数的参数名不在co_varnames里面，怎么办？另外在我们讲位置参数的时候，如果传递的位置参数，比co_argcount还要多，怎么办？对，聪明如你，肯定知道了，就是我们下面要介绍扩展关键字、扩展位置参数。</strong></p>
</blockquote>
<h4 id="扩展位置参数和扩展关键字参数"><a href="#扩展位置参数和扩展关键字参数" class="headerlink" title="扩展位置参数和扩展关键字参数"></a>扩展位置参数和扩展关键字参数</h4><p><strong>之前我们看到了使用扩展位置参数和扩展关键字参数时指令参数个数的值，我们还是再看一遍吧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>**我们看到对于co_nlocals来说，它统计的是所有局部变量的个数，结果是4；但是对于co_argcount来说，统计的是不包括*args个*<em>kwargs的所有参数的个数，因此结果是2。既然如此，那么也如我们之前所分析的，*args可以接收多个位置参数，但是最终这些参数都会放在args这个PyTupleObject对象里面；*<em>kwargs可以接收多个关键字参数，但是这些关键字参数会组成一个PyDictObject对象，由kwargs指向。事实上也确实如此，即使不从源码的角度来分析，从Python的实际使用中我们也能得出这个结论。</em></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">foo(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), **&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>*<em>当然啦，在传递的时候如果对一个元组或者列表、甚至是字符串使用*，那么会将这个可迭代对象直接打散，相当于传递了多个位置参数。同理如果对一个字典使用*<em>，那么相当于传递了多个关键字参数。</em></em></p>
<p><strong>下面我们就来看看扩展参数是如何实现的，首先还是进入到 *_PyEval_EvalCodeWithName* 这个函数里面来，当然这个函数应该很熟悉了，我们看看扩展参数的处理。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           <span class="comment">//位置参数的相关信息</span></span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           <span class="comment">//关键字参数的相关信息                 </span></span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep, <span class="comment">//关键字参数个数</span></span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           <span class="comment">//默认值、闭包、函数名、全限定名等信息              </span></span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;<span class="comment">//拿到PyFunctionObject的PyCodeObject</span></span><br><span class="line">    PyFrameObject *f;<span class="comment">//声明一个PyFrameObject</span></span><br><span class="line">    PyObject *retval = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **fastlocals, **freevars;</span><br><span class="line">    PyObject *x, *u;</span><br><span class="line">    <span class="comment">//获取总参数的个数</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount;</span><br><span class="line">    Py_ssize_t i, j, n;</span><br><span class="line">    PyObject *kwdict;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">//创建一个栈帧</span></span><br><span class="line">    f = _PyFrame_New_NoTrack(tstate, co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的所有参数</span></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    <span class="comment">//闭包</span></span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否传递扩展关键字参数，CO_VARKEYWORDS和下面的CO_VARARGS都是标识符</span></span><br><span class="line">    <span class="comment">//用于判断是否出现了扩展关键字参数和扩展位置参数</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        <span class="comment">//创建一个字典</span></span><br><span class="line">        kwdict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="comment">//i是参数总个数，假设值foo(a, b, c, *args, **kwargs)</span></span><br><span class="line">        i = total_args;</span><br><span class="line">        <span class="comment">//如果还传递了扩展位置参数，那么i要加上1</span></span><br><span class="line">        <span class="comment">//因为即使是扩展，关键字参数依旧要在位置参数后面</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//如果没有扩展位置参数，那么kwdict要处于索引为3的位置</span></span><br><span class="line">        <span class="comment">//有扩展位置参数，那么kwdit处于索引为4的位置，这显然是合理的</span></span><br><span class="line">        <span class="comment">//然后放到f_localsplus中        </span></span><br><span class="line">        SETLOCAL(i, kwdict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有的话，那么为NULL</span></span><br><span class="line">        kwdict = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里我们之前介绍了，是将位置参数拷贝到本地(显然这里不包含扩展位置参数) */</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        n = co-&gt;co_argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        x = args[j];</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">        SETLOCAL(j, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关键来了，将多余的位置参数拷贝到*args里面去 */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        <span class="comment">//申请一个argcount - n大小的元组</span></span><br><span class="line">        u = _PyTuple_FromArray(args + n, argcount - n);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放到f -&gt; f_localsplus里面去</span></span><br><span class="line">        SETLOCAL(total_args, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是拷贝扩展关键字参数，但是我们发现这里是从两个数组中分别得到符号和值的信息的</span></span><br><span class="line">    <span class="comment">//因此再结合最上面的变量声明，我们就明白了，我们传递的关键字参数并不是上来就设置到字典里面</span></span><br><span class="line">    <span class="comment">//而是将符号和值各自存储在对应的数组里面，显然就是下面的kwnames和kwargs</span></span><br><span class="line">    <span class="comment">//然后使用索引遍历，按照顺序依次取出，通过比较传递的关键字参数的符号是否已经出现在函数定义的参数中</span></span><br><span class="line">    <span class="comment">//来判断传递的这个参数究竟是普通的关键字参数，还是扩展关键字参数</span></span><br><span class="line">    <span class="comment">//比如:def foo(a, b, c, **kwargs)，那么foo(1, 2, c=3, d=4)</span></span><br><span class="line">    <span class="comment">//那么显然关键字参数有两个c=3和d=4，那么c已经出现在了函数定义的参数中，所以c就是一个普通的关键字参数</span></span><br><span class="line">    <span class="comment">//但是d没有，所有d同时也是扩展关键字参数，因此要设置到kwargs这个字典里面</span></span><br><span class="line">    kwcount *= kwstep;</span><br><span class="line">    <span class="comment">//按照索引，依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">        PyObject **co_varnames; <span class="comment">//符号表</span></span><br><span class="line">        PyObject *keyword = kwnames[i];<span class="comment">//关键字参数的key</span></span><br><span class="line">        PyObject *value = kwargs[i];<span class="comment">//关键字参数的value</span></span><br><span class="line">        Py_ssize_t j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyword == <span class="literal">NULL</span> || !PyUnicode_Check(keyword)) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() keywords must be strings&quot;</span>,</span><br><span class="line">                          co-&gt;co_name);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到符号表，得到所有的符号，这样就知道函数参数都有哪些</span></span><br><span class="line">        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;</span><br><span class="line">        <span class="comment">//我们看到内部又是一层for循环</span></span><br><span class="line">        <span class="comment">//首先外层循环是遍历所有的关键字参数，也就是我们传递的参数</span></span><br><span class="line">        <span class="comment">//而内层循环则是遍历函数的除了仅限位置参数之外的所有参数</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            <span class="comment">//将我们传来每一个关键字参数的符号都会和符号表中的所有符号进行比对</span></span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="comment">//如果相等，说明传递的是关键字参数，并不是扩展关键字参数</span></span><br><span class="line">            <span class="keyword">if</span> (name == keyword) &#123;</span><br><span class="line">                <span class="comment">//然后kw_found这个label中, 会检测对应的参数有没有通过位置参数传递</span></span><br><span class="line">                <span class="comment">//如果已经位置参数传递了, 那么显然一个参数被传递了两次</span></span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 逻辑和上面一样 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = co-&gt;co_posonlyargcount; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="type">int</span> cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(j &gt;= total_args);</span><br><span class="line">        <span class="comment">//走到这里，说明肯定传入了符号不在符号表co_varnames里面的关键字参数</span></span><br><span class="line">        <span class="comment">//如果kwdict是NULL，证明根本函数根本没定义扩展参数，那么就直接报错了</span></span><br><span class="line">        <span class="keyword">if</span> (kwdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (co-&gt;co_posonlyargcount</span><br><span class="line">                &amp;&amp; positional_only_passed_as_keyword(tstate, co,</span><br><span class="line">                                                     kwcount, kwnames))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got an unexpected keyword argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里将属于扩展关键字参数的keyword和value都设置到之前创建的字典里面去</span></span><br><span class="line">        <span class="comment">//然后continue进入下一个关键字参数逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItem(kwdict, keyword, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      kw_found:</span><br><span class="line">        <span class="comment">//之前我们说，如果不是扩展，而是普通关键字参数那么会走这一步</span></span><br><span class="line">        <span class="comment">//获取对应的符号，但是发现不为NULL，说明已经通过位置参数传递了</span></span><br><span class="line">        <span class="keyword">if</span> (GETLOCAL(j) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//那么这里就报出一个TypeError，表示某个参数接收了多个值</span></span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">&quot;%U() got multiple values for argument &#x27;%S&#x27;&quot;</span>,</span><br><span class="line">                          co-&gt;co_name, keyword);</span><br><span class="line">            <span class="comment">//比如说：def foo(a, b, c=1, d=2)</span></span><br><span class="line">            <span class="comment">//如果这样传递的foo(1, 2, c=3)，那么肯定没问题</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为开始会把位置参数拷贝到f_localsplus里面，所以此时f_localsplus是[a, b, NULL, NULL]</span></span><br><span class="line"><span class="comment">            然后设置关键字参数的时候，此时的j对应索引为2，那么GETLOCAL(j)是NULL，所以不会报错</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//但如果这样传递，foo(1, 2, 3, c=3)</span></span><br><span class="line">            <span class="comment">//那么不好意思，此时f_localsplus则是[a, b, c, NULL],GETLOCAL(j)是c，不为NULL</span></span><br><span class="line">            <span class="comment">//说明c这个位置已经有人传递了，那么关键字参数就不能传递了</span></span><br><span class="line">            <span class="comment">//还是那句话f_localsplus存储的是符号，每一个符号都会对应相应的值，这些顺序都是一致的            </span></span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        SETLOCAL(j, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里检测位置参数是否多传递了 */</span></span><br><span class="line">    <span class="keyword">if</span> ((argcount &gt; co-&gt;co_argcount) &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) &#123;</span><br><span class="line">        too_many_positional(tstate, co, argcount, defcount, fastlocals);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在对参数进行处理的时候，机制还是很复杂的。我们知道Python在定义函数的时候，通过&#x2F;可以使得&#x2F;前面的参数必须通过位置参数传递，通过*可以使得*后面的参数必须通过位置参数传递，而我们在分析的时候是没有考虑这一点的。</strong></p>
<blockquote>
<p>*<em>其实扩展关键字参数的传递机制和普通关键字参数的传递机制有很大的关系，我们之前分析函数参数的默认值机制已经看到了关键字参数的传递机制，这里我们再次看到了。对于关键字参数，不论是否扩展，都会把符号和值分别按照对应顺序放在两个数组里面。然后Python会按照索引的顺序，遍历存放符号的数组，对每一个符号都会和符号表co_varnames里面的符号逐个进行比对，发现在符号表中找不到我们传递的关键字参数的符号，那么就说明这是一个扩展关键字参数。然后就是我们在源码中看到的那样，如果函数定义了*<em>kwargs，那么kwdict就不为空，会把扩展关键字参数直接设置进去，否则就报错了，提示接收到了一个不期待的关键字参数。</em></em></p>
<p><strong>而且Python虚拟机也确实把该PyDictObject对象<code>(kwargs)</code>放到了f_localsplus中，这个f_localsplus里面包含了所有的参数，不管是什么参数，都会在里面。但是kwargs一定是在最后面，至于*args理论上是没有顺序的，你是可以这么定义的:<code>def foo(a, \*args, b)</code>，这样定义是完全没有问题的，只是此时的b就必须要通过关键字参数来传递了，因为如果不通过关键字参数的方式，那么无论多少个位置参数，都会止步于<code>\*args</code>。之前也介绍过，假设只需要name,age, gender这三个参数，并且gender必须要通过关键字参数指定的话，那么就可以这么设计：<code>def foo(name, age, \*, gender)</code>，我们看到连args都省去了，只保留一个<code>\*</code>，这是因为我们定义了args也用不到，我们只是保证后面的gender必须通过关键字方式传递，所以只需要一个<code>\*</code>就ok了。</strong></p>
<p><strong>另外在Python3.8中，注意只有Python3.8开始才支持，可以强制使用位置参数，语法是通过<code>/</code>。</strong></p>
<p><strong>当然访问传递过来的扩展位置参数和扩展关键字参数就通过args对应的PyTupleObject和kwargs对应的PyDictObject操作就可以了。</strong></p>
</blockquote>
<p><strong>此外，我们在分析参数的时候，一直是截取部分片段，没有从上到下整体分析，因此可以再对着源码自己看一遍。当然核心还是Python在处理函数参数时的机制，整体流程如下<code>(先不考虑/和\*)</code>：</strong></p>
<ul>
<li><strong>1. 获取所有通过位置参数传递的个数，然后循环遍历将它们从运行时栈依次拷贝到 f_localsplus 指定的位置中；</strong></li>
<li><strong>2.  计算出可以通过位置参数传递的参数个数，如果实际传递的位置参数个数大于可以通过位置参数传递个数，那么会检测是否存在  *args，如果存在，那么将多余的位置参数拷贝到一个元组中；不存在，则报错：TypeError: function() takes ‘m’  positional argument but ‘n’ were given，其中 n 大于 m，表示接收了多个位置参数；</strong></li>
<li><strong>3. 如果实际传递的位置参数个数小于等于可以通过位置参数传递个数，那么程序继续往下执行，检测关键字参数，它是通过两个数组来实现的，参数名和值是分开存储的；</strong></li>
<li><strong>4. 然后进行遍历，两层 for 循环，第一层 for 循环遍历存放关键字参数名的数组，第二层遍历符号表，会将传递参数名和符号表中的每一个符号进行比较；</strong></li>
<li>**5. 如果指定了不在符号表中的参数名，那么会检测是否定义了  *<em>kwargs，如果没有则报错：TypeError: function() got an unexpected keyword  argument ‘xxx’，接收了一个不期望的参数 xxx；如果定义了 *<em>kwargs，那么会设置在字典中；</em></em></li>
<li><strong>6. 如果参数名在符号表中存在，那么跳转到 kw_found  标签，然后获取该符号对应的 value，如果 value 不为 NULL，那么证明该参数已经通过位置参数传递了，会报错：TypeError:  function() got multiple values for argument ‘xxx’，提示函数的参数 xxx 接收了多个值；</strong></li>
<li><strong>7. 最终所有的参数都会存在 f_localsplus 中，然后检测是否存在对应的 value 为 NULL 的符号，如果存在，那么检测是否具有默认值，有则使用默认值，没有则报错：</strong></li>
</ul>
<p><strong>所以Python在处理参数的大致流程是上面那样的，具体细节层面也很好理解，只是要处理各种各样的情况，导致看起来让人有点头疼。当然Python中的生成器和异步生成器的逻辑也在这个函数里面，我们后续系列中会分析。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们分析了函数调用时候的场景，以及如何处理不同形式的参数，重点还是有一个整体性的认识。下一篇，我们将来分析闭包。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>13-剖析Python的流程控制语句</title>
    <url>/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"><a href="#13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制" class="headerlink" title="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"></a>13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在上一章中，我们介绍了Python虚拟机中常见的字节码指令。但我们的流程都是从上往下顺序执行的，在执行的过程中没有任何变化，但是显然这是不够的，因为怎么能没有流程控制呢。下面我们来看看Python所提供的流程控制手段，其中也包括异常检测机制。</strong></p>
<h3 id="Python虚拟机中的if控制流"><a href="#Python虚拟机中的if控制流" class="headerlink" title="Python虚拟机中的if控制流"></a>Python虚拟机中的if控制流</h3><h4 id="if字节码"><a href="#if字节码" class="headerlink" title="if字节码"></a>if字节码</h4><p><strong>if语句算是最简单也是最常用的控制流语句，那么它的字节码是怎么样的呢？当然我们这里的if语句指的是if、elif、elif…、else整体，里面的if、某个elif或者else叫做该if语句的分支。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">gender = &quot;男&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if gender == &quot;男&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;nice muscle&quot;)</span></span><br><span class="line"><span class="string">elif gender == &quot;女&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;白い肌&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;秀吉&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>反编译得到的字节码指令比较多，我们来慢慢分析。</strong></p>
<blockquote>
<p><strong>注意：到了现在，相信对字节码指令都已经熟悉了，因此之前说过的指令我们就不详细展开说了，只会简单提一下。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>) <span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)<span class="comment">//建立符号和对象的映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)<span class="comment">//加载变量gender</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;男&quot;进行==操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span><span class="comment">//这里的22表示如果为False, 就跳转到字节码偏移量、或者字节码的索引为22的地方</span></span><br><span class="line">    					  <span class="comment">//显然是下面的22 LOAD_NAME 0 (gender), 即：该if下面的elif</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//如果gender == &quot;男&quot;成立, 那么不会跳转, 直接往下执行, 加载符号print</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">18</span> POP_TOP	<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)<span class="comment">//if语句只会执行一个分支, 一旦执行了某个分支, 整个if语句就结束了</span></span><br><span class="line">    					          <span class="comment">//所以跳转到字节码偏移量为48的位置, 这里的22就表示相对于当前位置向前跳转了多少</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) <span class="comment">//显然这是elif的分支, 加载变量gender</span></span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)<span class="comment">//加载字符串常量&quot;女&quot;</span></span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;女&quot;进行==判断</span></span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span><span class="comment">//如果不成立就跳转到字节码偏移量为40的地方, 显然是elif下面的else</span></span><br><span class="line">    					  <span class="comment">//如果elif下面还有elif, 那么就跳转到下一个elif, 总之就是一个分支一个分支的往下跳转</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)<span class="comment">//走到这里说明gender == &quot;女&quot;成立, 加载变量print</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)<span class="comment">//加载字符串常量&quot;白い肌&quot;</span></span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用, 参数为1个</span></span><br><span class="line">           <span class="number">36</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)<span class="comment">//整个if语句结束, 还是跳转到字节码偏移量为48的位置</span></span><br><span class="line">    						  <span class="comment">//这里参数是8, 所以if的跳转是采用相对跳跃, 分支不同跳跃的指令数也不同</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//走到这里说明执行的是else分支, 加载符号print</span></span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)<span class="comment">//加载字符串常量&quot;秀吉&quot;</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去,如果是执行else分支并且执行完毕, 显然就不需要再跳转了,</span></span><br><span class="line">    		       <span class="comment">//因为else分支位于整个if语句的最后面</span></span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)<span class="comment">//这里便是整个if语句结束后的第一条指令, 加载常量None</span></span><br><span class="line">           <span class="number">50</span> RETURN_VALUE<span class="comment">//返回</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字节码中 “源代码行号” 和 “字节码偏移量” 之间有几个<code>&gt;&gt;</code>这样的符号，这是什么呢？仔细看一下应该就知道，这显然就是if语句中的每一个分支开始的地方，当然最后的<code>&gt;&gt;</code>是返回值。</strong></p>
<p><strong>但是经过分析，我们发现整个if语句的字节码指令还是很简单的。从上到下执行分支，如果某个分支成立，就执行该分支的代码，执行完毕后直接跳转到整个if语句下面的第一条指令；分支不成立那么就跳转到下一个分支。</strong></p>
<p><strong>核心指令就在于COMPARE_OP、POP_JUMP_IF_FALSE和JUMP_FORWARD，从结构上我们不难分析：</strong></p>
<ul>
<li><code>COMPARE_OP: 进行比较操作</code></li>
<li><code>POP_JUMP_IF_FALSE: 跳转到下一个分支</code></li>
<li><code>JUMP_FORWARD:跳转到整个if语句结束后的第一条指令</code></li>
</ul>
<p>​        <strong>我们首先分析COMPARE_OP，我们看到COMPARE_OP后面也是有参数的，比如 8 COMPARE_OP               2  (&#x3D;&#x3D;)，显然oparg<code>(字节码指令参数)</code>就是2，那么这个2代表啥呢？其实想都不用想，肯定代表的是&#x3D;&#x3D;，因为都已经告诉我们了。</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="comment">/* Rich comparison opcodes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LT 0 <span class="comment">//小于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LE 1 <span class="comment">//小于等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_EQ 2 <span class="comment">//等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_NE 3 <span class="comment">//不等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GT 4 <span class="comment">//大于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GE 5 <span class="comment">//大于等于</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//opcode.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cmp_op</span> &#123;</span>PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE,</span><br><span class="line">                PyCmp_GT=Py_GT, PyCmp_GE=Py_GE, PyCmp_IN, PyCmp_NOT_IN,</span><br><span class="line">                PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看，虚拟机中是如何进行比较操作的。另外本章中如果没有指定源码位置，那么默认是在Python&#x2F;ceval.c里面</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">cmp_outcome</span><span class="params">(<span class="type">int</span> op, PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//python中的is, 在C的层面直接判断两个指针是否相等即可        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的is not, , 在C的层面直接判断两个指针是否不相等即可    </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS_NOT:</span><br><span class="line">        res = (v != w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的in, 调用PySequence_Contains</span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的not in, 调用PySequence_Contains再取反        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_NOT_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        res = !res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的异常      </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_EXC_MATCH:</span><br><span class="line">        <span class="comment">//这里判断给定的类是不是异常类, 比如我们肯定不能except int as e, 异常类一定要继承BaseException</span></span><br><span class="line">        <span class="comment">//如果是元组的话, 那么元组里面都要是异常类</span></span><br><span class="line">        <span class="keyword">if</span> (PyTuple_Check(w)) &#123;</span><br><span class="line">            Py_ssize_t i, length;</span><br><span class="line">            length = PyTuple_Size(w);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i += <span class="number">1</span>) &#123;</span><br><span class="line">                PyObject *exc = PyTuple_GET_ITEM(w, i);</span><br><span class="line">                <span class="keyword">if</span> (!PyExceptionClass_Check(exc)) &#123;</span><br><span class="line">                    PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                    CANNOT_CATCH_MSG);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PyExceptionClass_Check(w)) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                CANNOT_CATCH_MSG);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断指定的异常能否捕获相应的错误</span></span><br><span class="line">        res = PyErr_GivenExceptionMatches(v, w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//然后进行比较操作, 传入两个对象以及操作符, 即上面的Py_LT、Py_LE...之一</span></span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Py_True和Py_False就相当于Python中的True和False, 本质上是一个PyLongObject</span></span><br><span class="line">    <span class="comment">//根据res的结果返回True和False</span></span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面的比较函数PyObject_RichCompare很重要，我们来看一下，该函数位于Object&#x2F;object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先有一个PyObject_RichCompareBool, 它是用来判断两个对象是否相等或不等的</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyObject_RichCompareBool</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="type">int</span> ok;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果v和w相等的话, 说明这两个变量指向同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (v == w) &#123;</span><br><span class="line">        <span class="comment">//那么如果op是==, 显然返回True</span></span><br><span class="line">        <span class="keyword">if</span> (op == Py_EQ)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果op是!=, 显然返回False</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == Py_NE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有人问如果我们重写了__eq__怎么办? 所以这个方法只适用于内建的类的实例对象</span></span><br><span class="line">    <span class="comment">//如果是我们自定义的类会直接调用这里的PyObject_RichCompare</span></span><br><span class="line">    <span class="comment">//另外我们看到即便是内置的类的实例对象, 如果两个对象不相等, 或者相等、但是op不是==和!=的时候也会走这里的PyObject_RichCompare</span></span><br><span class="line">    res = PyObject_RichCompare(v, w, op);</span><br><span class="line">    <span class="comment">//通过PyObject_RichCompare进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果返回的是布尔值, 那么判断是否和Py_True相等, 返回的是True那么比较的结果也是True, 否则是False</span></span><br><span class="line">    <span class="keyword">if</span> (PyBool_Check(res))</span><br><span class="line">        ok = (res == Py_True);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//返回的不是布尔值, 那么调用PyObject_IsTrue, 显然这相当于Python中的bool(res)</span></span><br><span class="line">        <span class="comment">//不是0的整数、长度不为0的字符串、元组、列表等等也是True</span></span><br><span class="line">        ok = PyObject_IsTrue(res);</span><br><span class="line">    Py_DECREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点来了, 我们来看看PyObject_RichCompare</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_RichCompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">//首先会对op进行判断, 要确保Py_LT &lt;= op &lt;= Py_GE, 即0 &lt;= op &lt;= 5, 要保证op是几个操作符中的一个</span></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="comment">//首先v和w不能是C的空指针, 要确保它们都指向一个具体的PyObject, 但是说实话底层的这些检测我们在Python的层面基本不会遇到</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PyErr_Occurred())</span><br><span class="line">            PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以核心是下面的do_richcompare, 但是在do_richcompare之前我们看到这里调用了Py_EnterRecursiveCall</span></span><br><span class="line">    <span class="comment">//这和函数和递归有关, 比如我们在__eq__中又对self使用了==, 那么会不断调用__eq__, 这是会无限递归的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_EnterRecursiveCall(<span class="string">&quot; in comparison&quot;</span>))</span><br><span class="line">        <span class="comment">//所以Py_EnterRecursiveCall是让解释器追踪递归的深度的</span></span><br><span class="line">	    <span class="comment">//如果递归层数过多, 超过了指定限制(默认是999, 可以通过sys.getrecursionlimit()查看), 那么能够及时抛出异常, 从递归中摆脱出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用do_richcompare, 还是这三个参数, 得到比较的结果</span></span><br><span class="line">    res = do_richcompare(v, w, op);</span><br><span class="line">    <span class="comment">//离开递归调用</span></span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    <span class="comment">//返回res, 执行PyObject_RichCompareBool中下面的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到核心其实是do_richcompare, 我们需要继续往下看</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">do_richcompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    richcmpfunc f; <span class="comment">//富比较函数</span></span><br><span class="line">    PyObject *res; <span class="comment">//比较结果</span></span><br><span class="line">    <span class="type">int</span> checked_reverse_op = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果type(v)和type(w)不一样 &amp;&amp; type(w)是type(v)的子类 &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type != w-&gt;ob_type &amp;&amp;</span><br><span class="line">        PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type) &amp;&amp;</span><br><span class="line">        (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        checked_reverse_op = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//那么直接调用type(w)的to_richcompare进行比较</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(v)和type(w)不同, 或者 type(w) 不是 type(v) 的子类, 或者type(w)中没有定义tp_richcompare</span></span><br><span class="line">    <span class="comment">//如果type(v)定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> ((f = v-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用type(v)的tp_richcompare方法</span></span><br><span class="line">        res = (*f)(v, w, op);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(w) 不是 type(v) 的子类 &amp;&amp; type(v)中没有定义tp_richcompare &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (!checked_reverse_op &amp;&amp; (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//那么执行w的tp_richcompare</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以以上三种情况就相当于: 如果type(w) 是 type(v) 的子类, 那么优先调用w的tp_richcompare</span></span><br><span class="line">    <span class="comment">//否则，type(v) 和 type(w) 中谁的tp_richcompare不为空就调用谁的</span></span><br><span class="line">    <span class="comment">//如果都没有那么就走下面的逻辑了</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//直接比较两者是否相等</span></span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        res = (v == w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//比较两者是否不等        </span></span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">        res = (v != w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//显然此时的两个对象只能判断相等或者不等, 如果是比大小那么显然是报错的, 下面的信息你一定很熟悉</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;&#x27;%s&#x27; not supported between instances of &#x27;%.100s&#x27; and &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                     opstrings[op],</span><br><span class="line">                     v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                     w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，这里面又出现了tp_richcompare，如果我们自定义的类没有重写的话，那么默认调用的是基类object的tp_richcompare，包括内置的类也是调用object的tp_richcompare，有兴趣可以看一下。</strong></p>
<p>​        <strong>然后我们再来看看POP_JUMP_IF_FALSE</strong>    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)</span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">18</span> POP_TOP</span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) </span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)</span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)</span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">36</span> POP_TOP</span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)</span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">46</span> POP_TOP</span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">50</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下10 POP_JUMP_IF_FALSE       22这条字节码，这表是if语句不成立，那么会跳转到字节码偏移量为22的位置，所以这里有一个指令跳跃的动作。那么Python虚拟机是如何完成指令跳跃的呢？关键就在于一个名为 *predict* 的宏里面。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DYNAMIC_EXECUTION_PROFILE) || USE_COMPUTED_GOTOS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op)             <span class="keyword">if</span> (0) goto PRED_##op</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op) \</span></span><br><span class="line"><span class="meta">    do&#123; \</span></span><br><span class="line"><span class="meta">        _Py_CODEUNIT word = *next_instr; \</span></span><br><span class="line"><span class="meta">        opcode = _Py_OPCODE(word); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (opcode == op)&#123; \</span></span><br><span class="line"><span class="meta">            oparg = _Py_OPARG(word); \</span></span><br><span class="line"><span class="meta">            next_instr++; \</span></span><br><span class="line"><span class="meta">            goto PRED_##op; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICTED(op)           PRED_##op:</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python中，有一些字节码指令通常都是按照顺序出现的，通过上一个字节码指令直接预测下一个字节码指令是可能的。比如COMPARE_OP的后面通常都会紧跟着POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE，这在上面的字节码中可以很清晰的看到。</strong></p>
<p><strong>为什么要有这样的一个预测功能呢？因为当字节码之间的指令搭配出现的概率非常高时，如果预测成功，能够省去很多无谓的操作，使得执行效率大幅提高。我们可以看到， <code>PREDICTED(POP_JUMP_IF_FALSE);</code>实际上就是检查下一条待处理的字节码是否是POP_JUMP_IF_FALSE。如果是，那么程序会直接跳转到PRED_POP_JUMP_IF_FALSE那里，如果将COMPARE_OP这个宏展开，可以看得更加清晰。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_FALSE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_FALSE;</span><br><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_TRUE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_TRUE</span><br></pre></td></tr></table></figure>

<p><strong>但是问题又来了，PRED_POP_JUMP_IF_TRUE和PRED_POP_JUMP_IF_FALSE这些标识在哪里呢？我们知道指令跳跃的目的是为了绕过一些无谓的操作，直接进入POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE指令对应的case语句之前。</strong></p>
<p><strong>首先<code>if gender == &quot;男&quot;</code>这条字节码序列中，存在POP_JUMP_IF_FALSE指令，那么在COMPARE_OP指令的实现代码的最后，将执行<code>goto PRED_POP_JUMP_IF_FALSE;</code>，而显然这句代码要在<code>POP_JUMP_IF_FALSE</code>之前执行。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PREDICTED(POP_JUMP_IF_FALSE);</span><br><span class="line">TARGET(POP_JUMP_IF_FALSE) &#123;</span><br><span class="line">    <span class="comment">//取出之前比较的结果。</span></span><br><span class="line">    PyObject *cond = POP();</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="comment">//比较结果为True，顺序执行</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_True) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较结果为False，进行跳转</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_False) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    err = PyObject_IsTrue(cond);</span><br><span class="line">    Py_DECREF(cond);</span><br><span class="line">    <span class="keyword">if</span> (err &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到这里的调用跳转使用的<code>JUMPTO</code>，在for循环中我们还会见到，这是一个宏。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_Py_CODEUNIT 是 uint16_t 的别名 typedef uint16_t _Py_CODEUNIT，占两个字节; </span></span><br><span class="line"><span class="comment">从名字也能看出这表示字节码的指令单元, 一条指令两个字节, 所以字节码指令对应的偏移量是0 2 4 6 8..., 每次增加2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另外这里的first_str指向字节码偏移量为0的位置, 也就是第一条指令</span></span><br><span class="line"><span class="comment">next_str表示在first_str基础上跳转之后的指令, 所以如果x是12的话, 那么next_str = 0 + 6, 显然就是第7条指令</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Python虚拟机中的for循环控制流"><a href="#Python虚拟机中的for循环控制流" class="headerlink" title="Python虚拟机中的for循环控制流"></a>Python虚拟机中的for循环控制流</h3><p><strong>我们在if语句中已经见识了最基本的控制，但是我们发现if里面只能向前，不管是哪个分支，都是通过<code>JUMP_FORWARD</code>。下面介绍for循环，我们会见到指令时可以回退的。但是在if语句的分支中，我们看到无论哪个分支、其指令的跳跃距离通常都是当前指令与目标指令的距离，相当于向前跳了多少步。那么指令回退时，是不是相当于向后跳了多少步呢？带着疑问，我们来往下看。</strong></p>
<h4 id="for字节码"><a href="#for字节码" class="headerlink" title="for字节码"></a>for字节码</h4><p><strong>我们来看看一个简单的for循环的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">lst = [1, 2]</span></span><br><span class="line"><span class="string">for item in lst:</span></span><br><span class="line"><span class="string">    print(item)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) //加载常量<span class="number">1</span></span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) //加载常量<span class="number">2</span></span><br><span class="line">              <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     //构建PyListObject对象, 元素个数为<span class="number">2</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) //使用符号<span class="string">&quot;lst&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) //加载变量lst</span><br><span class="line">             <span class="number">10</span> GET_ITER					   //获取对应的迭代器</span><br><span class="line">        &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)//开始<span class="keyword">for</span>循环, 循环结束跳转到字节码偏移量为<span class="number">26</span>的地方</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) //将元素迭代出来, 使用符号<span class="string">&quot;item&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">print</span>) //加载函数<span class="built_in">print</span></span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) //加载变量item</span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        //函数调用</span><br><span class="line">             <span class="number">22</span> POP_TOP						    //从栈顶弹出<span class="built_in">print</span>函数的返回值, 这里是<span class="literal">None</span></span><br><span class="line">             <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 //<span class="keyword">for</span>循环遍历一圈之后, 继续跳转回去, 遍历下一圈, 直到结束</span><br><span class="line">        &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>) //走到这里<span class="keyword">for</span>循环就结束了, 加载常量<span class="literal">None</span>, 然后返回</span><br><span class="line">             <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们再来详细分析一下上面的指令：</strong></p>
<blockquote>
<p><strong><code>lst = [1, 2]</code>我们就不分析了，当  for item in  lst:的时候，肯定首先要找到lst，所以指令是LOAD_NAME是没问题的。但是下面出现了GET_ITER，从字面上我们知道这是获取迭代器，其实即使不从源码的角度，我相信有的小伙伴对于for循环的机制也不是很了解。</strong></p>
<p><strong>实际上我们for循环遍历一个对象的时候，首先要满足后面的对象是一个可迭代对象，遍历这个对象的时候，会先调用这个对象的__iter__方法，把它变成一个迭代器。然后不断地调用这个迭代器的__next__方法，一步一步将里面的值全部迭代出来，然后再进行一次迭代出现StopIteration异常，for循环捕捉，然后退出。注意：for item in lst是先将lst对应的迭代器中的元素迭代出来，然后交给变量item。所以字节码中先是<code>12 FOR_ITER</code>，然后才是<code>14 STORE_NAME</code>。因此10个元素的迭代器，是需要迭代11次才能结束的，因为Python不知道迭代10次就能结束，它需要再迭代一次发现没有元素可以迭代、从而抛出StopIteration异常、再被for循环捕捉之后才能结束。</strong></p>
<p><strong>所以for循环后面如果跟的是一个迭代器，那么直接调用__next__方法，如果是可迭代对象，会先调用其内部的__iter__方法将其变成一个迭代器，然后再调用该迭代器的__next__方法。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表、字符串、元组、字典、集合等等都是可迭代对象</span></span><br><span class="line"><span class="comment"># 但它们不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterator))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要调用__iter__之后才是一个迭代器, 当然迭代器也是可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到 24 JUMP_ABSOLUTE，它是跳转到字节码偏移量为12、也就是FOR_ITER的位置，并没有跳到GET_ITER那里，所以for循环在遍历的时候只会创建一次迭代器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">lst_iter = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst_iter:</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">iter</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我们看到结果是一样的, for item in iter(lst)和for item in lst是等价的</span></span><br><span class="line"><span class="comment"># 都会先创建迭代器, 并且只创建一次, 然后遍历这个迭代器</span></span><br></pre></td></tr></table></figure>

<h4 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h4><p><strong>Python虚拟机通过<code>LOAD_NAME 0 (lst)</code>指令，将刚创建的PyListObject对象压入运行时栈。然后再通过<code>GET_ITER</code>指令来获取PyListObject对象的迭代器。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(GET_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">/* before: [obj]; after [getiter(obj)] */</span></span><br><span class="line">    <span class="comment">//从运行时栈获取PyListObject对象</span></span><br><span class="line">    PyObject *iterable = TOP();</span><br><span class="line">    <span class="comment">//获取该PyListObject对象的iterator</span></span><br><span class="line">    PyObject *iter = PyObject_GetIter(iterable);</span><br><span class="line">    Py_DECREF(iterable);</span><br><span class="line">    <span class="comment">//将iterator压入栈中, 设置在栈顶</span></span><br><span class="line">    SET_TOP(iter);</span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    PREDICT(FOR_ITER);</span><br><span class="line">    PREDICT(CALL_FUNCTION);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到获取迭代器是调用了PyObject_GetIter函数，我们看看这个函数长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> PyObject *(*getiterfunc) (PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/abstract.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GetIter</span><span class="params">(PyObject *o)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取对象的类型</span></span><br><span class="line">    PyTypeObject *t = o-&gt;ob_type;</span><br><span class="line">    <span class="comment">//一个函数指针, 接收一个PyObject *, 返回一个PyObject *</span></span><br><span class="line">    getiterfunc f;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用类型对象的tp_iter</span></span><br><span class="line">    f = t-&gt;tp_iter;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果f是NULL, 并且还不是序列型对象, 那么直接抛出异常, &#x27;xxx&#x27; object is not iterable</span></span><br><span class="line">        <span class="keyword">if</span> (PySequence_Check(o))</span><br><span class="line">            <span class="keyword">return</span> PySeqIter_New(o);</span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">&quot;&#x27;%.200s&#x27; object is not iterable&quot;</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用tp_iter, 传入对象获取迭代器。我们获取迭代器是通过iter(lst)或者lst.__iter__()</span></span><br><span class="line">        <span class="comment">//但是在底层相当于list.__iter__(lst), 所以&quot;实例.方法(*args, **kwargs)&quot;等价于&quot;类.函数(self, *args, **kargs)&quot;</span></span><br><span class="line">        PyObject *res = (*f)(o);</span><br><span class="line">        <span class="comment">//如果res不为空、并且还不是迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span> &amp;&amp; !PyIter_Check(res)) &#123;</span><br><span class="line">            <span class="comment">//那么报错TypeError, __iter__返回了一个非迭代器</span></span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">&quot;iter() returned non-iterator &quot;</span></span><br><span class="line">                         <span class="string">&quot;of type &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                         res-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">            res = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以看到，PyObject_GetIter是调用对象对应的类型对象中的tp_iter操作来获取与对象关联的迭代器的。我们说Python一切皆对象，那么这些迭代器也是一个实实在在的对象，那么也必然会有对应的类型对象，因为Python中对象对应的结构体都继承了PyObject，所以任何一个对象都有引用计数和类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD <span class="comment">//迭代器显然是不可变对象</span></span><br><span class="line">    Py_ssize_t it_index; <span class="comment">//迭代的元素的索引, 初始为0, 每迭代1个元素it_index就加1</span></span><br><span class="line">    PyListObject *it_seq; <span class="comment">//指向一个PyListObject对象, 显然迭代的就是这个PyListObject对象里面的元素, 当元素迭代完毕之后it_seq会被设置成NULL</span></span><br><span class="line">&#125; listiterobject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyTypeObject PyListIter_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list_iterator&quot;</span>,                            <span class="comment">/* tp_name */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后PyList_Type中tp_iter域被设置为list_iter，显然这是PyObject_GetIter中的那个f，而这也正是创建迭代器的关键所在。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_iter</span><span class="params">(PyObject *seq)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//列表对应的迭代器的指针</span></span><br><span class="line">    listiterobject *it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果seq不是列表，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(seq)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为listiterobject申请空间</span></span><br><span class="line">    it = PyObject_GC_New(listiterobject, &amp;PyListIter_Type);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//迭代器的索引, 用来遍历列表的, 初始为0</span></span><br><span class="line">    it-&gt;it_index = <span class="number">0</span>;</span><br><span class="line">    Py_INCREF(seq);</span><br><span class="line">    <span class="comment">//这里的seq就是之前的PyListObject对象</span></span><br><span class="line">    it-&gt;it_seq = (PyListObject *)seq;</span><br><span class="line">    _PyObject_GC_TRACK(it);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到PyListObject的迭代器对象只是对PyListObject对象做了一个简单的包装，在迭代器中，维护了迭代是要访问的元素在PyListObject对象中的索引：<code>it_index</code>。通过这个索引，listiterobject对象就可以实现PyListObject的遍历。</strong></p>
<blockquote>
<p><strong>所以我们看到迭代器的实现真的很简单，创建谁的迭代器就对谁进行一层包装罢了，迭代器内部有一个索引。每迭代1次索引就加1，迭代完毕之后将指针设置为NULL，然后再迭代就抛出异常。</strong></p>
</blockquote>
<p><strong>所以任何一个列表对应的迭代器的内存大小都是32字节，PyObject是16字节，再加上一个Py_ssize_t和一个指针，总共32字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;夏色祭&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 6074 32</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__(), <span class="built_in">iter</span>(lst).__sizeof__())  <span class="comment"># 24040 32</span></span><br><span class="line"></span><br><span class="line">tpl = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(tpl.__sizeof__(), <span class="built_in">iter</span>(tpl).__sizeof__())  <span class="comment"># 24024 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不光是列表, 包括字符串、元组也是一样的, 都是32字节</span></span><br></pre></td></tr></table></figure>

<p><strong>但是字典有些特殊，因为它的底层是通过哈希表存储的，它需要额外维护一些信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/dictobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyDictObject *di_dict; <span class="comment">/* Set to NULL when iterator is exhausted */</span></span><br><span class="line">    Py_ssize_t di_used;</span><br><span class="line">    Py_ssize_t di_pos;</span><br><span class="line">    PyObject* di_result; <span class="comment">/* reusable result tuple for iteritems */</span></span><br><span class="line">    Py_ssize_t len;</span><br><span class="line">&#125; dictiterobject;</span><br></pre></td></tr></table></figure>

<p><strong>所以字典对应的迭代器是56字节，集合对应的迭代器则是48字节，关于集合可以去源码中查看，看看为什么会占48字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">range</span>(<span class="number">100000</span>), <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(d.__sizeof__(), <span class="built_in">iter</span>(d).__sizeof__())  <span class="comment"># 5242952 56</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 4194504 48</span></span><br></pre></td></tr></table></figure>

<p><strong>在指令<code>GET_ITER</code>完成之后，Python虚拟机开始了<code>FOR_ITER</code>指令的预测动作，如你所知，这样的预测动作是为了提高执行的效率。</strong></p>
<h4 id="迭代控制"><a href="#迭代控制" class="headerlink" title="迭代控制"></a>迭代控制</h4><p><strong>源代码中的for循环，在虚拟机层面也一定对应着一个相应的循环控制结构。因为无论进行怎样的变换，都不可能在虚拟机层面利用顺序结构来实现源码层面上的循环结构，这也可以看成是程序的拓扑不变性。显然正如我们刚才分析的，当创建完迭代器之后，就正式开始进入for循环了，没错就是从<code>FOR ITER</code>开始，进入了Python虚拟机层面上的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">//指令预测</span></span><br><span class="line">    PREDICTED(FOR_ITER);</span><br><span class="line">    <span class="comment">/* before: [iter]; after: [iter, iter()] *or* [] */</span></span><br><span class="line">    <span class="comment">/* 从栈顶获取iterator对象 */</span></span><br><span class="line">    PyObject *iter = TOP();</span><br><span class="line">    <span class="comment">//调用迭代器类型对象的tp_iternext方法、传入迭代器, 迭代出当前索引对应的元素, 然后索引+1, 然后下次迭代下一个元素</span></span><br><span class="line">    PyObject *next = (*iter-&gt;ob_type-&gt;tp_iternext)(iter);</span><br><span class="line">    <span class="comment">//如果next不为NULL, 那么将元素压入运行时栈, 显然要赋值给for循环的变量了</span></span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUSH(next);</span><br><span class="line">        PREDICT(STORE_FAST);</span><br><span class="line">        PREDICT(UNPACK_SEQUENCE);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">        <span class="comment">//如果出现异常、并且没有捕获到, 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tstate指的是线程对象, 我们会后面分析, 这里与回溯栈相关</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj, tstate, f);</span><br><span class="line">        &#125;</span><br><span class="line">        _PyErr_Clear(tstate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 走到这里说明本次迭代正常结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">    Py_DECREF(iter);</span><br><span class="line">    JUMPBY(oparg);</span><br><span class="line">    PREDICT(POP_BLOCK);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FOR_ITER的指令代码会首先从运行时栈中获得PyListObject对象的迭代器，然后调用迭代器的tp_iternext开始进行迭代，迭代出元素的同时将索引+1。如果抵达了迭代器的结束位置，那么tp_iternext将返回NULL，这个结果预示着遍历结束。</strong></p>
<p><strong>FOR_ITER的指令代码会检查tp_iternext的返回结果，如果得到的是一个有效的元素<code>(next!=NULL)</code>，那么将获得的这个元素压入到运行时栈中，并开始进行一系列的字节码预测动作。在我们当前的例子中，显然会预测失败，因此会执行<code>STORE_NAME</code>。那么如何获取迭代器的下一个元素呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">listiter_next</span><span class="params">(listiterobject *it)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *seq;</span><br><span class="line">    PyObject *item;</span><br><span class="line"></span><br><span class="line">    assert(it != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//seq：显然是获取迭代器对象的PyListObject对象的指针</span></span><br><span class="line">    seq = it-&gt;it_seq;</span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//一定是一个PyListObject对象</span></span><br><span class="line">    assert(PyList_Check(seq));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//当前的索引小于列表的长度、即当前索引小于等于最大索引</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index &lt; PyList_GET_SIZE(seq)) &#123;</span><br><span class="line">        <span class="comment">//获得索引为it_index的对应元素</span></span><br><span class="line">        item = PyList_GET_ITEM(seq, it-&gt;it_index);</span><br><span class="line">        <span class="comment">//调整index, 使其自增1, 然后下一次遍历得到下一个元素</span></span><br><span class="line">        ++it-&gt;it_index;</span><br><span class="line">        <span class="comment">//增加引用计数、返回</span></span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代完毕之后，设置为NULL，所以迭代器只能够顺序迭代一次</span></span><br><span class="line">    it-&gt;it_seq = <span class="literal">NULL</span>;</span><br><span class="line">    Py_DECREF(seq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后python虚拟机将沿着字节码的顺序一条一条的执行下去，从而完成输出的动作。但是我们知道，for循环中肯定会有指令回退的动作，我们之前从字节码中也看到了，for循环遍历一次之后，会再次跳转到<code>FOR_ITER</code>，而跳转所使用的指令就是<code>JUMP_ABSOLUTE</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(JUMP_ABSOLUTE)</span>: &#123;</span><br><span class="line">            PREDICTED(JUMP_ABSOLUTE);</span><br><span class="line">            <span class="comment">//显然这里的oparg表示字节码偏移量, 表示直接跳转到偏移量为oparg的位置上</span></span><br><span class="line">            JUMPTO(oparg);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FAST_LOOPS</span></span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到和if不一样，for循环使用的是绝对跳跃。JUMP_ABSOLUTE是强制设置next_instr的值，将next_instr设定到距离<code>f-&gt;f_code-&gt;co_code</code>开始地址的某一特定偏移的位置。这个偏移的量由JUMP_ABSOLUTE的指令参数决定，所以这条参数就成了for循环中指令回退动作的最关键的一点。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) </span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) </span><br><span class="line">            <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     </span><br><span class="line">            <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) </span><br><span class="line">           <span class="number">10</span> GET_ITER					   </span><br><span class="line">      &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)</span><br><span class="line">           <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) </span><br><span class="line">           <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        </span><br><span class="line">           <span class="number">22</span> POP_TOP						    </span><br><span class="line">           <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 </span><br><span class="line">      &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (None) </span><br><span class="line">           <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到JUMP_ABSOLUTE的参数是12，<code>next_str = 0 + 12 / 2 = 6</code>，表示跳转到字节码偏移量为12、或者说第7条指令的位置上，也就是<code>12 FOR_ITER</code>这条指令，那么Python虚拟机的下一步动作就是执行<code>FOR_ITER</code>指令，即通过PyListObject对象的迭代器获取PyListObject对象中的元素，然后依次向前，执行输出，遇到JUMP_ABSOLUTE再跳转回去。因此FOR_ITER指令和JUMP_ABSOLUTE指令之间构造出了一个循环结构，这个循环结构正是对应源码中的for循环结构。</strong></p>
<p><strong>但是我们发现，FOR_ITER后面跟了一个参数，这里是12，可是目前为止我们并没有看到有地方使用了这个12啊，那么它代表啥含义呢。其实，聪明如你肯定能猜到，因为从后面(to 26)也能看到，这是用于终止迭代的。表示从当前位置跳跃12个偏移量、等于24，或者在当前指令的基础上再跳转6条指令，也就是到达<code>26 LOAD_CONST</code>的位置。</strong></p>
<h4 id="终止迭代"><a href="#终止迭代" class="headerlink" title="终止迭代"></a>终止迭代</h4><p><strong>“天下没有不散的宴席”，for循环也是要退出的，不用想这个退出的动作只能落在FOR_ITER的身上。在FOR_ITER指令执行的过程中，如果通过PyListObject对象的迭代器获取的下一个元素不是有效的元素(会是NULL)，这就意味着迭代结束了。这个结果将直接导致Python虚拟机会将迭代器对象从运行时栈中弹出，同时执行一个JUMPBY的动作，向前跳跃，在字节码的层面上是向下，就是字节码偏移量增大的方向。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPBY(x)       (next_instr += (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//走到这里说明循环结束了</span></span><br><span class="line">            STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">            Py_DECREF(iter);</span><br><span class="line">            <span class="comment">//直接进行跳转</span></span><br><span class="line">            JUMPBY(oparg);</span><br><span class="line">            PREDICT(POP_BLOCK);</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="python虚拟机中的while循环控制结构"><a href="#python虚拟机中的while循环控制结构" class="headerlink" title="python虚拟机中的while循环控制结构"></a>python虚拟机中的while循环控制结构</h3><p><strong>会了if、for，那么再来看while就简单了。不仅如此，我们还要分析两个关键字：break、continue，当然goto就别想了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a = 0</span></span><br><span class="line"><span class="string">while a &lt; 10:</span></span><br><span class="line"><span class="string">    a += 1</span></span><br><span class="line"><span class="string">    if a == 5:</span></span><br><span class="line"><span class="string">        continue</span></span><br><span class="line"><span class="string">    if a == 7:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    print(a)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>指令方面，while和for有很多是类似的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)  <span class="comment">//加载常量0</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)  <span class="comment">//使用变量a存储</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>     &gt;&gt;    <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//进入while循环了, 首先是a &lt; 10, 加载变量a</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="number">10</span>) <span class="comment">//加载常量10</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">0</span> (&lt;)  <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">50</span>  <span class="comment">//为False直接结束循环, 跳转到字节码偏移量为50的位置, 也就是第26条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//这里是进入循环了, 加载变量a</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>) <span class="comment">//加载常量1</span></span><br><span class="line">           <span class="number">16</span> INPLACE_ADD 		       <span class="comment">//执行a += 1操作, 这里相当于先执行了a + 1</span></span><br><span class="line">           <span class="number">18</span> STORE_NAME               <span class="number">0</span> (a) <span class="comment">//然后在重新让变量a指向相加之后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">20</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//进入a == 5, 加载变量a</span></span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">3</span> (<span class="number">5</span>) <span class="comment">//加载常量5</span></span><br><span class="line">           <span class="number">24</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">26</span> POP_JUMP_IF_FALSE       <span class="number">30</span>  <span class="comment">//如果为False, 那么直接跳转到偏移量为30的位置, 也就是当前if语句的下一条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>          <span class="number">28</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//如果a == 5成立, 那么绝对跳转, 跳到字节码偏移量为4的位置, 所以continue对一个绝对跳转, 目标是循环开始的地方</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>     &gt;&gt;   <span class="number">30</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//走到这里说明a == 5不成立, 判断a == 7, 加载变量a</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">4</span> (<span class="number">7</span>) <span class="comment">//加载常量7</span></span><br><span class="line">           <span class="number">34</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较是否相等</span></span><br><span class="line">           <span class="number">36</span> POP_JUMP_IF_FALSE       <span class="number">40</span>  <span class="comment">//如果为False, 跳转到偏移量为40的位置, 也就是print(a)</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>          <span class="number">38</span> JUMP_ABSOLUTE           <span class="number">50</span>  <span class="comment">//如果a == 5成立, 那么也是跳转到字节码偏移量为50的地方, 因为是break, 也是结束循环</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//加载变量print</span></span><br><span class="line">           <span class="number">42</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//加载变量a</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span>  <span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP		            <span class="comment">//从栈顶弹出返回值</span></span><br><span class="line">           <span class="number">48</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//走到这里说明while循环执行一圈了, 那么再度跳转到while a &lt; 10的地方</span></span><br><span class="line">      &gt;&gt;   <span class="number">50</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">52</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>所以有了for循环，再看while循环就简单多了，整体逻辑和for高度相似，当然里面还结合了if。另外我们看到break和continue都是使用了JUMP_ABSOLUTE实现的。JUMP_ABSOLUTE是跳转到指定位置，通过绝对跳转实现的。break是跳转到while语句结束后的第一条指令；continue则是跳转到while循环的开始位置。</strong></p>
<p><strong>然后执行一圈之后，遇到了<code>48 JUMP_ABSOLUTE </code>，再度跳转回去。当循环不满足的时候，通过<code>10 POP_JUMP_IF_FALSE       50</code>直接结束循环，所以while事实上比for还是要简单一些的。</strong></p>
<h3 id="Python虚拟机中的异常控制流"><a href="#Python虚拟机中的异常控制流" class="headerlink" title="Python虚拟机中的异常控制流"></a>Python虚拟机中的异常控制流</h3><p><strong>异常这个东西应该是最常见的了，程序在运行的过程中经常会遇到大量的错误，而Python中也定义了大量的异常类型供我们使用，下面我们来看看Python中的异常机制，因为这也是一个控制语句。</strong></p>
<h4 id="Python中的异常机制"><a href="#Python中的异常机制" class="headerlink" title="Python中的异常机制"></a>Python中的异常机制</h4><p>​        <strong>Python虚拟机自身抛出异常</strong>    </p>
<p><strong>Python有一套内建的异常捕捉机制，即使在python的脚本文件中没有出现try语句，python脚本执行出现的异常还是会被虚拟机捕捉到。首先我们就从<code>ZeroDivisionError</code>这个异常来分析。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 / 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  2           0 LOAD_CONST               0 (1)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (0)</span></span><br><span class="line"><span class="string">              4 BINARY_TRUE_DIVIDE</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看第3条字节码指令，异常也正是在执行这条指令的时候触发的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_TRUE_DIVIDE)</span>: &#123;</span><br><span class="line">    <span class="comment">//co_consts -&gt; (0, 1)</span></span><br><span class="line">    PyObject *divisor = POP(); <span class="comment">//1</span></span><br><span class="line">    PyObject *dividend = TOP();<span class="comment">//0</span></span><br><span class="line">    <span class="comment">//调用__truediv__</span></span><br><span class="line">    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    <span class="comment">//将结果设置在栈顶</span></span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="comment">//如果结果是NULL, 那么就报错了</span></span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑很简单， 就是获取两个值，然后调用<code>PyNumber_TrueDivide</code>进行除法运算。正常情况下得到的肯定是一个数值，如果不能相除那么就返回NULL，如果接收的<code>quotient</code>是NULL，那么抛异常。因此我们来看看<code>PyNumber_TrueDivide</code>都干了些啥？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//longobject.c</span></span><br><span class="line"><span class="comment">//最终调用的是long_true_divide</span></span><br><span class="line"><span class="comment">//代码很长我们截取一部分</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_true_divide</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//都是在计算除法时需要的临时变量</span></span><br><span class="line">    PyLongObject *a, *b, *x;</span><br><span class="line">    Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;</span><br><span class="line">    digit mask, low;</span><br><span class="line">    <span class="type">int</span> inexact, negate, a_is_small, b_is_small;</span><br><span class="line">    <span class="type">double</span> dx, result;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(v, w);</span><br><span class="line">    <span class="comment">//将v和w中维护的整数值转存到a和b中</span></span><br><span class="line">    a = (PyLongObject *)v;</span><br><span class="line">    b = (PyLongObject *)w;</span><br><span class="line">    a_size = Py_ABS(Py_SIZE(a));</span><br><span class="line">    b_size = Py_ABS(Py_SIZE(b));</span><br><span class="line">    negate = (Py_SIZE(a) &lt; <span class="number">0</span>) ^ (Py_SIZE(b) &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取b_size, 就是b对应的ob_size, 我们在分析PyLongObject对象时说过, 如果这个对象维护的值为0，那么ob_size就是0，这是个特殊情况</span></span><br><span class="line">    <span class="comment">//并且这个ob_size还可以体现出维护的值的正负</span></span><br><span class="line">    <span class="comment">//我们看到如果b_size == 0, 那么抛出PyExc_ZeroDivisionError</span></span><br><span class="line">    <span class="keyword">if</span> (b_size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ZeroDivisionError,</span><br><span class="line">                        <span class="string">&quot;division by zero&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果除以0，那么直接设置异常信息。另外我们说过Python中一切皆对象，那么异常也是一个对象，是一个PyObject类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pyerrors.h</span></span><br><span class="line"><span class="comment">//这里面定义了大量的异常, 比如:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">&#125; PyBaseExceptionObject; <span class="comment">//BaseException, 所有异常的基类, Exception也继承自它</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *filename;</span><br><span class="line">    PyObject *lineno;</span><br><span class="line">    PyObject *offset;</span><br><span class="line">    PyObject *text;</span><br><span class="line">    PyObject *print_file_and_line;</span><br><span class="line">&#125; PySyntaxErrorObject; <span class="comment">//语法异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *path;</span><br><span class="line">&#125; PyImportErrorObject; <span class="comment">//导包异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *encoding;</span><br><span class="line">    PyObject *object;</span><br><span class="line">    Py_ssize_t start;</span><br><span class="line">    Py_ssize_t end;</span><br><span class="line">    PyObject *reason;</span><br><span class="line">&#125; PyUnicodeErrorObject;<span class="comment">//Unicode异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *value;</span><br><span class="line">&#125; PyStopIterationObject; <span class="comment">//StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>在线程状态对象中记录异常信息(线程的知识后续会说)</strong>    </p>
<p><strong>我们之前看到，异常信息是通过<code>PyErr_SetString(异常类型, 异常信息)</code>来设置的，而除了这个<code>PyErr_SetString</code>，还会经过<code>PyErr_SetObject</code>，最终到达<code>PyErr_Restore</code>。在<code>PyErr_Restore</code>中，Python将这个异常放置到了一个安全的地方。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Restore</span><span class="params">(PyObject *type, PyObject *value, PyObject *traceback)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取线程对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Restore(tstate, type, value, traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Restore(PyThreadState *tstate, PyObject *type, PyObject *value,</span><br><span class="line">               PyObject *traceback)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//异常类型、异常值、异常的回溯栈, 对应Python中sys.exc_info()返回的元组里面的3个元组</span></span><br><span class="line">    PyObject *oldtype, *oldvalue, *oldtraceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果traceback不为空并且不是回溯栈, 那么将其设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (traceback != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(traceback)) &#123;</span><br><span class="line">        Py_DECREF(traceback);</span><br><span class="line">        traceback = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取以前的异常信息</span></span><br><span class="line">    oldtype = tstate-&gt;curexc_type;</span><br><span class="line">    oldvalue = tstate-&gt;curexc_value;</span><br><span class="line">    oldtraceback = tstate-&gt;curexc_traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置当前的异常信息</span></span><br><span class="line">    tstate-&gt;curexc_type = type;</span><br><span class="line">    tstate-&gt;curexc_value = value;</span><br><span class="line">    tstate-&gt;curexc_traceback = traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将之前的异常信息的引用计数分别减1</span></span><br><span class="line">    Py_XDECREF(oldtype);</span><br><span class="line">    Py_XDECREF(oldvalue);</span><br><span class="line">    Py_XDECREF(oldtraceback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后在tstate<code>(PyThreadState对象)</code>的curexc_type中存下了<code>PyExc_ZeroDivisionError</code>，而cur_value中存下了字符串<code>division by zero</code>，curexc_traceback存下了回溯栈。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type)  <span class="comment"># &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(exc_value)  <span class="comment"># division by zero</span></span><br><span class="line">    <span class="built_in">print</span>(exc_tb)  <span class="comment"># &lt;traceback object at 0x000001C43F29F4C0&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># exc_tb也可以通过e.__traceback__获取</span></span><br><span class="line">    <span class="built_in">print</span>(e.__traceback__ <span class="keyword">is</span> exc_tb)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再来看看PyThreadState对象<code>(这里先简单看一下，后续会详细说)</code>，这个之前说了是与线程有关的，但是它只是线程信息的一个抽象描述，而真实的线程及状态肯定是由操作系统来维护和管理的。因为Python虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。而PyThreadState对象正是Python为线程准备的、在虚拟机层面保存线程状态信息的对象<code>(后面简称线程状态对象、或者线程对象)</code>。在这里，当前活动线程<code>(OS原生线程)</code>对应的PyThreadState对象可以通过PyThreadState_GET获得，在得到了线程状态对象之后，就将异常信息存放到线程状态对象中。</strong></p>
<p>​        <strong>展开栈帧</strong>    </p>
<p><strong>首先我们知道异常已经被记录在了线程的状态中了，现在可以回头看看，在跳出了分派字节码指令的switch块所在的for循环之后，发生了什么动作。</strong></p>
<blockquote>
<p><strong>我们知道在Python&#x2F;ceval.c中有一个 *_PyEval_EvalFrameDefault* 函数，它是执行字节码指令的。里面有一个for循环，会依次遍历每一条字节码，在这个for循环里面有一个巨型switch，里面case了所有指令出现的情况。当所有指令执行完毕之后，这个for循环就结束了。</strong></p>
</blockquote>
<p><strong>但这里还存在一个问题，那就是导致跳出那个巨大的switch块所在的for循环的原因：”1. 可以是执行完了所有的字节码之后正常跳出”，”2. 也可以是发生异常后跳出”，那么Python虚拟机到底如何区分这是哪一种呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">error: <span class="comment">//一旦出现异常, 会使用goto语句跳转到error标签这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                             <span class="string">&quot;error return without exception set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        assert(_PyErr_Occurred(tstate));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果在执行switch语句的时候出现了异常，那么会跳转到error这里，否则会跳转到其它地方。当跳转到error标签的时候就代表出现异常了，注意：是在执行过程中出现异常之后Python虚拟机才获取到异常信息。</strong></p>
<p><strong>那么问题就来了，  如果在在涉及到函数调用的时候发生了异常该怎么办呢？首先在python虚拟机意识到有异常发生后，它就要开始进入异常处理的流程，这个流程会涉及到我们介绍PyFrameObject对象时所提到的那个PyFrameObject对象链表。在介绍PyFrameObject对象的时候，我们说过PyFrameObject实际上就是对栈帧的模拟，当发生函数函数调用，python会新创建一个栈帧，并将其内部的f_back连接到调用者对应的PyFrameObject，这样就形成了一条栈帧链。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是脚本运行时产生的输出，我们看到了函数调用的信息：比如在源代码的哪一行调用了哪一个函数，那么这些信息是从何而来的呢？而且我们发现输出的信息是一个链状的结构，是不是和栈帧链比较相似啊。没错，在Python虚拟机处理异常的时候，涉及到了一个traceback对象，在这个对象中记录栈帧链表的信息，Python虚拟机利用这个对象来将栈帧链表中的每一个栈帧的状态进行可视化，这个可视化的结果就是上面输出的异常信息。</strong></p>
<p><strong>回到我们的例子，当异常发生时，当前活动的栈帧是函数h对应的栈帧。在Python虚拟机开始处理异常的时候，它首先的动作就是创建一个traceback对象，用于记录异常发生时活动栈帧的状态。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里tstate还是我们之前提到的与当前活动线程对应的线程对象</span></span><br><span class="line">        <span class="comment">//其中的c_tracefunc是用户自定义的追踪函数，主要用于编写python的debugger。</span></span><br><span class="line">        <span class="comment">//但是通常情况下这个值都是NULL，所以不考虑它。</span></span><br><span class="line">        <span class="comment">//我们主要看上面的PyTraceBack_Here(f)，它到底使用PyFrameObject对象创建了一个怎样的traceback</span></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/traceback.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyTraceBack_Here</span><span class="params">(PyFrameObject *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *exc, *val, *tb, *newtb;</span><br><span class="line">    <span class="comment">//获取线程中保存线程状态的traceback对象, 进行设置</span></span><br><span class="line">    PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);</span><br><span class="line">    <span class="comment">//_PyTraceBack_FromFrame创建新的traceback对象</span></span><br><span class="line">    newtb = _PyTraceBack_FromFrame(tb, frame);</span><br><span class="line">    <span class="keyword">if</span> (newtb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_ChainExceptions(exc, val, tb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的traceback对象交给线程状态对象</span></span><br><span class="line">    PyErr_Restore(exc, val, newtb);</span><br><span class="line">    Py_XDECREF(tb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原来traceback对象是保存在线程状态对象之中的，我们来看看这个traceback对象究竟长得什么样：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/cpython/traceback.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> *<span class="title">tb_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">tb_frame</span>;</span></span><br><span class="line">    <span class="type">int</span> tb_lasti;</span><br><span class="line">    <span class="type">int</span> tb_lineno;</span><br><span class="line">&#125; PyTracebackObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到里面有一个tb_next，所以很容易想到这个traceback也是一个链表结构。其实这个PyTracebackObject对象的链表结构应该跟PyFrameObject对象的链表结构是同构的、或者说一一对应的，即一个PyFrameObject对象应该对应一个PyTracebackObject对象。我们看看这个链表是怎么产生的，在PyTraceBack_Here函数中我们看到它是通过_PyTraceBack_FromFrame创建的，那么秘密就隐藏在这个函数中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/traceback.h</span></span><br><span class="line">PyObject*</span><br><span class="line">_PyTraceBack_FromFrame(PyObject *tb_next, PyFrameObject *frame)</span><br><span class="line">&#123;</span><br><span class="line">    assert(tb_next == <span class="literal">NULL</span> || PyTraceBack_Check(tb_next));</span><br><span class="line">    assert(frame != <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//底层调用了tb_create_raw, 参数分别是下一个traceback、当前栈帧、当前f_lasti、以及源代码行号</span></span><br><span class="line">    <span class="keyword">return</span> tb_create_raw((PyTracebackObject *)tb_next, frame, frame-&gt;f_lasti,</span><br><span class="line">                         PyFrame_GetLineNumber(frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">tb_create_raw</span><span class="params">(PyTracebackObject *next, PyFrameObject *frame, <span class="type">int</span> lasti,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> lineno)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTracebackObject *tb;</span><br><span class="line">    <span class="keyword">if</span> ((next != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(next)) ||</span><br><span class="line">                    frame == <span class="literal">NULL</span> || !PyFrame_Check(frame)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    tb = PyObject_GC_New(PyTracebackObject, &amp;PyTraceBack_Type);</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//建立链表</span></span><br><span class="line">        Py_XINCREF(next);</span><br><span class="line">        <span class="comment">//这里的tb_next就是下一个traceback</span></span><br><span class="line">        tb-&gt;tb_next = next;</span><br><span class="line">        Py_XINCREF(frame);</span><br><span class="line">        <span class="comment">//设置栈帧, 所以我们可以通过e.__traceback__.tb_frame获取栈帧</span></span><br><span class="line">        tb-&gt;tb_frame = frame;</span><br><span class="line">        <span class="comment">//执行完毕时字节码偏移量</span></span><br><span class="line">        tb-&gt;tb_lasti = lasti;</span><br><span class="line">        <span class="comment">//源代码行号</span></span><br><span class="line">        tb-&gt;tb_lineno = lineno;</span><br><span class="line">        <span class="comment">//加入GC追踪, 参与垃圾回收</span></span><br><span class="line">        PyObject_GC_Track(tb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源码中我们看到，tb_next是将两个traceback连接了起来，不过这个和PyFrameObject里面f_back正好相反。f_back指向的是上一个栈帧，而tb_next指向的是下一个traceback。另外在新创建的对象中，还使用tb_frame和对应的PyFrameObject对象建立了联系，当然还有最后执行完毕的字节码偏移量以及其在源代码中对应的行号。话说还记得PyCodeObject对象中的那个co_lnotab吗，这里的tb_lineno就是通过co_lnotab获取的。</strong></p>
<p><strong>Python虚拟机意识到有异常抛出，并创建了traceback对象之后，它会在当前栈帧中寻找except语句，来执行开发人员指定的捕捉异常的动作。如果没有找到，那么Python虚拟机将退出当前的活动栈帧，并沿着栈帧链回退到上一个栈帧，在上一个栈帧中寻找except语句。就像我们之前说的，出现函数调用会创建栈帧，当函数执行完毕或者出现异常的时候，会回退到上一级栈帧。一层一层创建、一层一层返回。至于回退的这个动作，则是在<code>PyEval_EvalFrameEx</code>的最后完成，当然准确的说应该是其内部调用的<code>_PyEval_EvalFrameDefault</code>的最后。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opcode)&#123;</span><br><span class="line">            <span class="comment">//巨型switch</span></span><br><span class="line">        &#125;</span><br><span class="line">exception_unwind:</span><br><span class="line">    <span class="comment">//如果发生了异常, 这里会将异常进行展开, 然后试图进行捕获</span></span><br><span class="line">    <span class="comment">//注意: exception_unwind是位于这个大大的for循环的内部的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//里面是和异常捕获相关的逻辑, 后面会分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//retval表示_PyEval_EvalFrameDefault函数的返回值, 返回值为NULL, 那么表示有异常发生	</span></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">exit_eval_frame:</span><br><span class="line">    <span class="keyword">if</span> (PyDTrace_FUNCTION_RETURN_ENABLED())</span><br><span class="line">        dtrace_function_return(f);</span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将线程状态对象中的活动栈帧设置为上一个栈帧, 完成栈帧回退的动作</span></span><br><span class="line">    tstate-&gt;frame = f-&gt;f_back;</span><br><span class="line">    <span class="keyword">return</span> _Py_CheckFunctionResult(<span class="literal">NULL</span>, retval, <span class="string">&quot;PyEval_EvalFrameEx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>如果开发人员没有任何的捕获异常的动作，那么将通过break跳出python执行字节码的那个for循环。最后，由于没有捕获到异常， 其返回值被设置为NULL，同时通过将当前线程状态对象中的活动栈帧，设置为上一级栈帧，从而完成栈帧回退的动作。</strong></p>
<p><strong>此时我们的例子就很好解释了，当虚拟机执行函数f时，它是在PyEval_EvalFrameEx<code>(内部调用的_PyEval_EvalFrameDefault)</code>中执行与f对应的<code>PyFrameObject</code>对象中的字节码指令序列。当在函数f中调用g时，Python虚拟机又会为函数g创建新的<code>PyFrameObject</code>对象，会把控制权交给函数g对应的<code>PyFrameObject</code>，当然调用的也是<code>PyEval_EvalFrameEx</code>，只不过这次是在执行与g对应的<code>PyFrameObject</code>对象中的字节码指令序列了。同理函数g调用函数h的时候，也是一样的。所以当在函数h中发生异常，没有异常捕获、导致<code>PyEval_EvalFrameEx</code>结束时，自然要返回到、或者把控制权再交给与函数g对应的<code>PyFrameObject</code>，由<code>PyEval_EvalFrameEx</code>继续执行。由于在返回时，retval被设置为NULL，所以回到g中，Python虚拟机再次意识到有异常产生，可由于函数g中调用的时候也没有异常捕获，那么同样也要退出，再把<code>PyEval_EvalFrameEx</code>执行栈帧的控制权交给函数f对应的栈帧，如果还没有异常捕获，那么回到py文件对应的栈帧，再没有的话就直接报错了。</strong></p>
<p><strong>这个沿着栈帧链不断回退的过程我们称之为<code>栈帧展开</code>，在这个栈帧展开的过程中，Python虚拟机不断地创建与各个栈帧对应的traceback，并将其链接成链表。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012533952-1339104654.png" alt="img"></p>
<p><strong>由于我们没有设置任何的异常捕获的代码，那么python虚拟机的执行流程会一直返回到<code>PyRun_SimpleFileExFlags</code>中，这个<code>PyRun_SimpleFileExFlags</code>是干啥的我们先不管，以后分析Python运行时候的初始化时，就可以看到这个函数的作用了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_SimpleFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                        PyCompilerFlags *flags)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">       <span class="comment">//执行pyc文件 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* When running from stdin, leave __main__.__loader__ alone */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, <span class="string">&quot;&lt;stdin&gt;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            set_main_loader(d, filename, <span class="string">&quot;SourceFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用了PyRun_FileExFlags</span></span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyRun_FileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, <span class="type">int</span> start, PyObject *globals,</span></span><br><span class="line"><span class="params">                  PyObject *locals, <span class="type">int</span> closeit, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了run_mod</span></span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    Py_XDECREF(filename);</span><br><span class="line">    <span class="keyword">if</span> (arena != <span class="literal">NULL</span>)</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用run_eval_code_obj</span></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_eval_code_obj</span><span class="params">(PyCodeObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCode</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (!v &amp;&amp; PyErr_Occurred() == PyExc_KeyboardInterrupt) &#123;</span><br><span class="line">        _Py_UnhandledKeyboardInterrupt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/ceval.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCode</span><span class="params">(PyObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCodeEx</span></span><br><span class="line">    <span class="keyword">return</span> PyEval_EvalCodeEx(co,</span><br><span class="line">                      globals, locals,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCodeEx</span><span class="params">(PyObject *_co, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *args, <span class="type">int</span> argcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *kws, <span class="type">int</span> kwcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *defs, <span class="type">int</span> defcount,</span></span><br><span class="line"><span class="params">                  PyObject *kwdefs, PyObject *closure)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了_PyEval_EvalCodeWithName</span></span><br><span class="line">    <span class="keyword">return</span> _PyEval_EvalCodeWithName(_co, globals, locals,</span><br><span class="line">                                    args, argcount,</span><br><span class="line">                                    kws, kws != <span class="literal">NULL</span> ? kws + <span class="number">1</span> : <span class="literal">NULL</span>,</span><br><span class="line">                                    kwcount, <span class="number">2</span>,</span><br><span class="line">                                    defs, defcount,</span><br><span class="line">                                    kwdefs, closure,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalFrameEx, 里面的f就是在该函数中创建的栈帧对象</span></span><br><span class="line">    <span class="comment">//还记得这个返回值retval吗? 如果它是NULL, 那么代表该栈帧中有异常发生了</span></span><br><span class="line">    retval = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fail: </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//返回retval</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrameEx</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个线程对象, 里面会调用其它函数创建一个线程</span></span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET_UNSAFE();</span><br><span class="line">    <span class="comment">//执行线程对象的eval_frame</span></span><br><span class="line">    <span class="keyword">return</span> interp-&gt;eval_frame(f, throwflag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pystate.c</span></span><br><span class="line">PyInterpreterState *</span><br><span class="line"><span class="title function_">PyInterpreterState_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//你看到了什么? interp-&gt;eval_frame被设置成了_PyEval_EvalFrameDefault</span></span><br><span class="line">    interp-&gt;eval_frame = _PyEval_EvalFrameDefault;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到兜了这么多圈，最终<code>PyRun_SimpleFileExFlags</code>返回的值就是<code>PyEval_EvalFrameEx</code>返回的那个retval<code>(当然出现异常的话，就是NULL)</code>。所以接下来会调用<code>PyErr_Print</code>，然后在<code>PyErr_Print</code>中，Python虚拟机取出其维护的traceback，并遍历traceback链表，逐个输出其中的信息，也就是我们在python中看到的那个打印的异常信息。并且这个顺序是：.py文件、函数f、函数g、函数h，不是函数h、函数g、函数f、py文件。因为每一个栈帧对应一个traceback，而且是按照顺序遍历的，所以是：.py文件、函数f、g、h的顺序，当然从打印这一点也能看出来。</strong></p>
<blockquote>
<p><strong>因为是在函数h中报的错，所以退到函数g的栈帧中寻找异常捕获；如果retval为NULL，那么在退到函数f的栈帧中寻找异常捕获，再没有的话则退到模块对应的栈帧中。</strong></p>
<p><strong>模块中也没有异常捕获，那么报错。所以获取模块栈帧对应的traceback，打印异常信息，然后通过tb_next找到 *f*  对应的traceback打印其信息，依次下去……。事实上稍微想一下就能理解，虽然是在 *h* 中报的错，但根本原因是我们在模块中调用了 *f*，所以依次打印模块、f、g、h中traceback的异常信息。</strong></p>
</blockquote>
<h4 id="Python中的异常捕获"><a href="#Python中的异常捕获" class="headerlink" title="Python中的异常捕获"></a>Python中的异常捕获</h4><p><strong>目前我们知道了Python中的异常在虚拟机级别是什么，抛出异常这个动作在虚拟机层面上是怎样的一个行为，最后我们还知道了Python在处理异常时候的栈帧展开行为。但这只是Python虚拟机中内建的处理异常的动作，并没有使用Python语言中提供的异常捕获，下面我们就来看一下Python提供的异常捕获机制是如何影响Python虚拟机的异常处理流程的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    raise Exception(&quot;raise an exception&quot;)</span></span><br><span class="line"><span class="string">except Exception as e:</span></span><br><span class="line"><span class="string">    print(e)</span></span><br><span class="line"><span class="string">finally:</span></span><br><span class="line"><span class="string">    print(&quot;finally code&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;exception&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> SETUP_FINALLY           <span class="number">60</span> (to <span class="number">62</span>)</span><br><span class="line">              <span class="number">2</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;raise an exception&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> POP_BLOCK</span><br><span class="line">             <span class="number">14</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">58</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>     &gt;&gt;   <span class="number">16</span> DUP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">             <span class="number">20</span> COMPARE_OP              <span class="number">10</span> (exception <span class="keyword">match</span>)</span><br><span class="line">             <span class="number">22</span> POP_JUMP_IF_FALSE       <span class="number">56</span></span><br><span class="line">             <span class="number">24</span> POP_TOP</span><br><span class="line">             <span class="number">26</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">28</span> POP_TOP</span><br><span class="line">             <span class="number">30</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">32</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">36</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">38</span> POP_TOP</span><br><span class="line">             <span class="number">40</span> POP_BLOCK</span><br><span class="line">             <span class="number">42</span> BEGIN_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">44</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">46</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">48</span> DELETE_NAME              <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">50</span> END_FINALLY</span><br><span class="line">             <span class="number">52</span> POP_EXCEPT</span><br><span class="line">             <span class="number">54</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">58</span>)</span><br><span class="line">        &gt;&gt;   <span class="number">56</span> END_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">58</span> POP_BLOCK</span><br><span class="line">             <span class="number">60</span> BEGIN_FINALLY</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>     &gt;&gt;   <span class="number">62</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">64</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;finally code&#x27;</span>)</span><br><span class="line">             <span class="number">66</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">68</span> POP_TOP</span><br><span class="line">             <span class="number">70</span> END_FINALLY</span><br><span class="line">             <span class="number">72</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">74</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先这个指令集比较复杂，因为要分好几种情况。try里面没有出现异常；try里面出现了异常、但是except语句没有捕获到；try里面出现了异常，except语句捕获到了。但我们知道无论是哪种情况，都要执行finally。</strong></p>
<p><strong>我们先看上面的SETUP_FINALLY指令，这里为包含finally语句做准备的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(SETUP_FINALLY)</span>: &#123;</span><br><span class="line">            <span class="comment">/* <span class="doctag">NOTE:</span> If you add any new block-setup opcodes that</span></span><br><span class="line"><span class="comment">               are not try/except/finally handlers, you may need</span></span><br><span class="line"><span class="comment">               to update the PyGen_NeedsFinalizing() function.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            <span class="comment">//我们看到仅仅是调用了一个PyFrame_BlockSetup函数</span></span><br><span class="line">            PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,</span><br><span class="line">                               STACK_LEVEL());</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/frameobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyFrame_BlockSetup</span><span class="params">(PyFrameObject *f, <span class="type">int</span> type, <span class="type">int</span> handler, <span class="type">int</span> level)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个PyTryBlock *</span></span><br><span class="line">    PyTryBlock *b;</span><br><span class="line">    <span class="comment">//这个f_iblock为当前指令在f_blockstack上的索引, 还记得这个f_blockstack吗?我们在介绍栈帧的时候说过的,它可以用于try代码块</span></span><br><span class="line">    <span class="comment">//f_blockstack是一个数组, 内部存储了多个PyTryBlock对象</span></span><br><span class="line">    <span class="comment">//PyTryBlock f_blockstack[CO_MAXBLOCKS]; CO_MAXBLOCKS是一个宏，为20</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_iblock &gt;= CO_MAXBLOCKS)</span><br><span class="line">        Py_FatalError(<span class="string">&quot;XXX block stack overflow&quot;</span>);</span><br><span class="line">    <span class="comment">//这里我们算是真正意义上第一次使用栈帧中的f_blockstack属性</span></span><br><span class="line">    <span class="comment">//这里得到的b显然是个PyTryBlock结构体实例</span></span><br><span class="line">    b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++];</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    b-&gt;b_type = type;</span><br><span class="line">    b-&gt;b_level = level;</span><br><span class="line">    b-&gt;b_handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//frameobject.h</span></span><br><span class="line"><span class="comment">//我们看看PyTryBlock长什么样</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> b_type;                 <span class="comment">/* what kind of block this is */</span></span><br><span class="line">    <span class="type">int</span> b_handler;              <span class="comment">/* where to jump to find handler */</span></span><br><span class="line">    <span class="type">int</span> b_level;                <span class="comment">/* value stack level to pop to */</span></span><br><span class="line">&#125; PyTryBlock;</span><br><span class="line"><span class="comment">//显然PyFrameObject对象中的f_blockstack是一个由PyTryBlock对象组成的数组，而SETUP_FINALLY指令所做的就是从这个数组中获得了一块PyTryBlock对象</span></span><br><span class="line"><span class="comment">//并在这个对象中存放了一些Python虚拟机当前的状态信息。比如当前执行的字节码指令，当前运行时栈的深度等等。</span></span><br><span class="line"><span class="comment">//那么这个结构在try控制结构中起着什么样的作用呢？我们后面就会知晓</span></span><br><span class="line"><span class="comment">//我们注意到PyTryBlock中有一个b_type域，注释写着这个域是用来表示是block的种类, 也就意味着存在着多种不同用途的PyTryBlock对象。</span></span><br><span class="line"><span class="comment">//从PyFrame_BlockSetup中可以看到，这个b_type实际上被设置为当前Python虚拟机正在执行的字节码指令，以字节码指令作为区分PyTryBlock的不同用途</span></span><br></pre></td></tr></table></figure>

<p><strong>但我们看到开头有两个SETUP_FINALLY，其实在Python3.8之前，第二个SETUP_FINALLY应该是SETUP_EXCEPT，但是在3.8中都变成了SETUP_FINALLY。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012542306-595809675.png" alt="img"></p>
<p><strong>在这里分出两块PyTryBlock，肯定是要在捕捉异常的时候用。不过别着急，我们先回到抛出异常的地方看看：<code>10 RAISE_VARARGS 1</code>。在<code>RAISE_VARARGS</code>之前，通过<code>LOAD_NAME</code>、<code>LOAD_CONST</code>、<code>CALL_FUNCTION</code>构造出了一个异常对象，当然尽管Exception是一个类，但调用的指令也同样是CALL_FUNCTION<code>(至于这个指令的剖析和对象的创建后面章节会介绍，这里只需要知道一个异常已经被创建出来了)</code>，并将这个异常压入栈中。而<code>RAISE_VARARGS</code>指令的工作就从把这个异常对象从运行时栈取出开始。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(RAISE_VARARGS)</span>: &#123;</span><br><span class="line">    PyObject *cause = <span class="literal">NULL</span>, *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (oparg) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cause = POP(); <span class="comment">/* cause */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        exc = POP(); <span class="comment">/* exc */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (do_raise(tstate, exc, cause)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;bad RAISE_VARARGS oparg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里RAISE_VARARGS后面的参数是1，所以直接将异常对象取出赋给exc，然后调用do_raise函数。在do_raise中，最终调用之前的说过的<code>PyErr_Restore</code>函数，将异常对象存储到当前的线程对象中。在经过了一系列繁复的动作之后<code>(比如创建并设置traceback)</code>，通过do_raise，Python虚拟机将携带着<code>(f_iblock=2)</code>信息抵达真正捕捉异常的代码，我们看到跳转到了标签为exception_unwind的地方进行异常捕获，并且在最后，Python虚拟机通过一个break的动作跳出了分发字节码指令的那个巨大的switch语句所在的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">exception_unwind:</span><br><span class="line">        <span class="comment">/* Unwind stacks if an exception occurred */</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            PyTryBlock *b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock];</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;b_type == SETUP_FINALLY) &#123;</span><br><span class="line">                PyObject *exc, *val, *tb;</span><br><span class="line">                <span class="type">int</span> handler = b-&gt;b_handler;</span><br><span class="line">                _PyErr_StackItem *exc_info = tstate-&gt;exc_info;</span><br><span class="line">                <span class="comment">/* Beware, this invalidates all b-&gt;b_* fields */</span></span><br><span class="line">                PyFrame_BlockSetup(f, EXCEPT_HANDLER, <span class="number">-1</span>, STACK_LEVEL());</span><br><span class="line">                PUSH(exc_info-&gt;exc_traceback);</span><br><span class="line">                PUSH(exc_info-&gt;exc_value);</span><br><span class="line">                <span class="keyword">if</span> (exc_info-&gt;exc_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    PUSH(exc_info-&gt;exc_type);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Py_INCREF(Py_None);</span><br><span class="line">                    PUSH(Py_None);</span><br><span class="line">                &#125;</span><br><span class="line">                _PyErr_Fetch(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="comment">/* Make the raw exception data</span></span><br><span class="line"><span class="comment">                   available to the handler,</span></span><br><span class="line"><span class="comment">                   so a program can emulate the</span></span><br><span class="line"><span class="comment">                   Python main loop. */</span></span><br><span class="line">                _PyErr_NormalizeException(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="keyword">if</span> (tb != <span class="literal">NULL</span>)</span><br><span class="line">                    PyException_SetTraceback(val, tb);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    PyException_SetTraceback(val, Py_None);</span><br><span class="line">                Py_INCREF(exc);</span><br><span class="line">                exc_info-&gt;exc_type = exc;</span><br><span class="line">                Py_INCREF(val);</span><br><span class="line">                exc_info-&gt;exc_value = val;</span><br><span class="line">                exc_info-&gt;exc_traceback = tb;</span><br><span class="line">                <span class="keyword">if</span> (tb == <span class="literal">NULL</span>)</span><br><span class="line">                    tb = Py_None;</span><br><span class="line">                Py_INCREF(tb);</span><br><span class="line">                PUSH(tb);</span><br><span class="line">                PUSH(val);</span><br><span class="line">                PUSH(exc);</span><br><span class="line">                JUMPTO(handler);</span><br><span class="line">                <span class="comment">/* Resume normal execution */</span></span><br><span class="line">                <span class="keyword">goto</span> main_loop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">/* unwind stack */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* End the loop as we still have an error */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">/* main loop */</span></span><br><span class="line"></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机首先从当前的<code>PyFrameObject</code>对象中的<code>f_blockstack</code>中弹出一个<code>PyTryBlock</code>来，从代码中能看到弹出的是<code>b_type = SETUP_FINALLY, b_handler=16</code>的PyTryBlock。另一方面，Python虚拟机通过<code>PyErr_Fetch</code>得到了当前线程状态对象中存储的最新的异常对象和traceback对象：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Fetch</span><span class="params">(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Fetch(tstate, p_type, p_value, p_traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Fetch(PyThreadState *tstate, PyObject **p_type, PyObject **p_value,</span><br><span class="line">             PyObject **p_traceback)</span><br><span class="line">&#123;</span><br><span class="line">    *p_type = tstate-&gt;curexc_type;</span><br><span class="line">    *p_value = tstate-&gt;curexc_value;</span><br><span class="line">    *p_traceback = tstate-&gt;curexc_traceback;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;curexc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_traceback = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回到exception_unwind，我们看到之后python虚拟机调用PUSH将tb、val、exc分别压入运行时栈中，而且Python知道此时程序猿已经为异常处理做好了准备，所以接下来的异常处理工作，则需要交给程序员指定的代码来解决，这个动作通过JUMP_FORWARD<code>(JUMPTO(b-&gt;b_handler))</code>来完成。JUMPTO其实仅仅是进行了一下指令的跳跃，将Python虚拟机将要执行的下一条指令设置为异常处理代码编译后所得到的第一条字节码指令。</strong></p>
<p><strong>因为f_blockstack是从后往前弹出的，所以第一个弹出的是PyTryBlock中b_handler为16的SETUP_FINALLY，那么Python虚拟机将要执行的下一条指令就是偏移量为16的那条指令，而这条指令就是DUP_TOP，异常处理代码对应的第一条字节码指令。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(DUP_TOP)</span>: &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    PUSH(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们<code>except Exception</code>，毫无疑问要LOAD_NAME，把这个异常给load进来，然后调用指令COMPARE_OP，这个显然就是比较我们指定捕获的异常和运行时栈中存在的那个被捕获的异常是否匹配。POP_JUMP_IF_FALSE如果为Py_True表示匹配，那么继续往下执行print(e)对应的字节码指令，POP_TOP将异常从栈顶弹出，赋值给e，然后打印等等。如果POP_JUMP_IF_FALSE为Py_False表示不匹配，那么我们发现直接跳转到了<code>56 END_FINALLY</code>，因为异常不匹配的话，那么异常的相关信息还是要重新放回线程对象当中，让Python重新引发异常，而这个动作就由END_FINALLY完成，通过PyErr_Restore函数将异常信息重新写回线程对象中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(END_FINALLY)</span>: &#123;</span><br><span class="line">    PREDICTED(END_FINALLY);</span><br><span class="line">    <span class="comment">/* At the top of the stack are 1 or 6 values:</span></span><br><span class="line"><span class="comment">       Either:</span></span><br><span class="line"><span class="comment">        - TOP = NULL or an integer</span></span><br><span class="line"><span class="comment">       or:</span></span><br><span class="line"><span class="comment">        - (TOP, SECOND, THIRD) = exc_info()</span></span><br><span class="line"><span class="comment">        - (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject *exc = POP();</span><br><span class="line">    <span class="keyword">if</span> (exc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyLong_CheckExact(exc)) &#123;</span><br><span class="line">        <span class="type">int</span> ret = _PyLong_AsInt(exc);</span><br><span class="line">        Py_DECREF(exc);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; _PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        JUMPTO(ret);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(PyExceptionClass_Check(exc));</span><br><span class="line">        PyObject *val = POP();</span><br><span class="line">        PyObject *tb = POP();</span><br><span class="line">        <span class="comment">//将异常信息又写入到了线程状态对象当中了</span></span><br><span class="line">        _PyErr_Restore(tstate, exc, val, tb);</span><br><span class="line">        <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然而不管异常是否匹配，最终处理异常的两条岔路都会在<code>58 POP_BLOCK</code>处汇合。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PREDICTED(POP_BLOCK);</span><br><span class="line">TARGET(POP_BLOCK) &#123;</span><br><span class="line">    <span class="comment">//这里将当前PyFrameObject的f_blockstack中还剩下的那个与SETUP_FINALLY对应的PyTryBlock对象弹出</span></span><br><span class="line">    <span class="comment">//然后python虚拟机的流程就进入了与finally表达式对应的字节码指令了。</span></span><br><span class="line">    PyTryBlock *b = PyFrame_BlockPop(f);</span><br><span class="line">    UNWIND_BLOCK(b);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在Python异常机制的实现中，最终要的就是虚拟机状态以及PyFrameObject对象中f_blockstack里存放的PyTryBlock对象了。首先根据Python虚拟机状态可以判断当前是否发生了异常，而PyTryBlock对象则告诉python虚拟机，程序员是否为异常设置了except代码块和finally代码块，python虚拟机异常处理的流程就是在虚拟机所处的状态和PyTryBlock的共同作用下完成的。</strong></p>
<blockquote>
<p><strong>还是那句话，在3.8之前Python的指令集中存在一个SETUP_EXCEPT，但是在3.8的时候只有SETUP_FINALLY了。</strong></p>
</blockquote>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012551427-2065530599.png" alt="img"></p>
<p><strong>总之Python中一旦出现异常了，那么会将异常类型、异常值、异常回溯栈设置在线程状态对象中，然后栈帧一步一步的后退寻找异常捕获代码<code>(从内向外)</code>。如果退到了模块级别还没有发现异常捕获，那么从外向内打印traceback中的信息，当走到最后一层的时候再将线程中设置的异常类型和异常值打印出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先是在模块中调用了f、f调用了g、g调用了h, 所以在h中出现了异常、发现又没有异常捕获, 所以将执行权交给函数g对应的栈帧</span></span><br><span class="line"><span class="comment"># 但是g也没有异常捕获, 所以再将执行权交给函数f对应的栈帧, 所以调用的时候栈帧一层一层创建, 执行完毕、或者出现异常, 栈帧一层一层向后退</span></span><br><span class="line"><span class="comment"># 所以h的f_back指向g、g的f_back指向f、f的f_back指向模块、模块的f_back为None</span></span><br><span class="line"><span class="comment"># 但是对应的traceback则是模块的tb_next指向f、f的tb_next指向g、g的tb_next指向h、h的tb_next为None</span></span><br><span class="line"><span class="comment"># 而我们说栈帧层层后退, 退到模块对应的栈帧的时候要是还没有发现异常捕获, 那么就报错了</span></span><br><span class="line"><span class="comment"># 所以此时会打印模块对应的traceback的信息, 然后依次是f、g、h, 因为栈帧是从&quot;函数h到模块&quot;、但traceback则是从&quot;模块到函数h&quot;</span></span><br><span class="line"><span class="comment"># 所以我们仔细观察一下输出的异常信息, 不难印证我们的结论</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):  # traceback回溯栈</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;  # 打印模块的traceback</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f  # 打印f的traceback</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g   # 打印g的traceback</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h   # 打印h的traceback</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero  # h的tb_next为None, 证明是在h中发生了错误, 所以再将之前设置线程状态对象中异常类型和异常值打印出来即可</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>至于Python在处理异常的时候都经历哪些历程，我们虽然分析了，但其实还不够详细。因为Python的异常机制牵扯到底层的方方面面，并且涉及到了很多的宏，有兴趣可以自己再仔细深入研究。另外需要注意的是：Python3.8变化还是比较大的，在字节码方面你通过和3.7对比就可以发现。</strong></p>
<p>​        <strong>最后再看一个思考题</strong>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># NameError: name &#x27;e&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>why？我们发现在外面打印e的时候，告诉我们e没有被定义。这是为什么呢？首先可以肯定的是，肯定是<code>except Exception as e</code>导致的，因为我们as的也是e，和外面的e重名了，如果我们as的是e1呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="built_in">print</span>(e1)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># 2.718</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到as的是e1就没有问题了，但是为什么呢？即便不知道原因，也能推测出来。因为外面的变量叫e，而我们捕获异常as的也是e，此时e的指向就变了，而当异常处理结束的时候，e这个变量就被销毁了，所以外面就找不到了。然而事实上也确实如此。我们可以看一下字节码，通过观察我们上面例子的字节码，就能很清晰地看出端倪了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2.718</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">6</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;我要引发异常了&#x27;</span>)</span><br><span class="line">           <span class="number">10</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">12</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">           <span class="number">14</span> POP_BLOCK</span><br><span class="line">           <span class="number">16</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>     &gt;&gt;   <span class="number">18</span> DUP_TOP</span><br><span class="line">           <span class="number">20</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">           <span class="number">22</span> COMPARE_OP              <span class="number">10</span> (exception match)</span><br><span class="line">           <span class="number">24</span> POP_JUMP_IF_FALSE       <span class="number">58</span></span><br><span class="line">           <span class="number">26</span> POP_TOP</span><br><span class="line">           <span class="number">28</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">30</span> POP_TOP</span><br><span class="line">           <span class="number">32</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">46</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">36</span> LOAD_NAME                <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">38</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">40</span> POP_TOP</span><br><span class="line">           <span class="number">42</span> POP_BLOCK</span><br><span class="line">           <span class="number">44</span> BEGIN_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">46</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">48</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">50</span> DELETE_NAME              <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">52</span> END_FINALLY</span><br><span class="line">           <span class="number">54</span> POP_EXCEPT</span><br><span class="line">           <span class="number">56</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">60</span>)</span><br><span class="line">      &gt;&gt;   <span class="number">58</span> END_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">60</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">62</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码很长，但是我们只需要看偏移量为50的那个字节码即可。你看到了什么，<code>DELETE_NAME</code>直接把e这个变量给删了，所以我们就找不到了，因此代码相当于下面这样：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> e</span><br></pre></td></tr></table></figure>

<p><strong>因此在异常处理的时候，如果把异常赋予了一个变量，那么这个变量异常处理结束会被删掉，因此只能在except里面使用，这就是原因。但是原因有了，可动机呢？Python这么做的动机是什么？根据官网文档解释：</strong></p>
<blockquote>
<p><strong>当使用 as 将目标赋值为一个异常时，它将在 except  子句结束时被清除，这意味着异常必须赋值给一个不同的名称(不同于外部指定的变量)，才能在 except  子句之后引用它(外部指定的变量)。异常会被清除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变量保持存活直到发生下一次垃圾回收。</strong></p>
</blockquote>
<p>​        <strong>try、except、finally的返回值问题</strong>    </p>
<p><strong>我们看看这三者的返回值之间的关系：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于没有发生异常, 所以返回了try指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时发生异常, 所以返回了except指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># 456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的还是try指定的返回值, 因为finally中没有指定返回值</span></span><br><span class="line"><span class="built_in">print</span>(f3())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f4</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦finally中出现了return, 那么在没有报错的情况下返回的都是finally指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f4())  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f5</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们函数一旦出现了return, 那么就表示结束函数直接返回了</span></span><br><span class="line"><span class="comment"># 但是return如果是在try中, 那么可以认为将返回值存起来了, 执行完finally之后再返回</span></span><br><span class="line"><span class="comment"># 如果finally也指定了return, 那么会返回finally指定的返回值, 否则还是返回之前的</span></span><br><span class="line"><span class="comment"># 总之一句话, 只要在try或者except中出现了return(前提是没有异常、或者异常被成功捕获)</span></span><br><span class="line"><span class="comment"># 那么在finally执行完毕之后, 会立即返回, 不会执行finally下面的代码</span></span><br><span class="line"><span class="built_in">print</span>(f5())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f6</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常, 所以except的return没啥卵用, 但是try和finally中也没有return</span></span><br><span class="line"><span class="comment"># 所以程序会继续往下走</span></span><br><span class="line"><span class="built_in">print</span>(f6())  <span class="comment"># 789</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们就分析了Python的控制语句，if、for、while都比较简单。但Python中的异常捕获算是比较复杂的，主要是牵扯的东西比较多，有时候分析某一个地方需要跳好几个源文件，进行查找。因此有兴趣的话，可以杀进源码中自由翱翔，但是注意Python的版本，我们说3.8版本和3.8之前的版本之间区别还是蛮大的。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Python字符串的底层实现</title>
    <url>/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="07-Python字符串的底层实现"><a href="#07-Python字符串的底层实现" class="headerlink" title="07-Python字符串的底层实现"></a>07-Python字符串的底层实现</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这一次我们分析一下Python中的字符串，首先Python中的字符串是一个变长对象，因为不同长度的字符串所占的内存空间是不一样的；但同时字符串又是一个不可变对象，因为一旦创建就不可以再修改了。</strong></p>
<p><strong>而Python中的字符串是通过unicode来表示的，因此在底层对应的结构体是PyUnicodeObject。但是为什么需要unicode呢?</strong></p>
<blockquote>
<p><strong>首先计算机存储的基本单位是字节，由8个比特位组成，由于英文字母算上大小写只有52个，再加上若干字符，数量不会超过256个，因此一个字节完全可以表示，这些字符称之为ASCII字符。但是随着非英文字符的出现，导致一个字节已经无法表示了，只能曲线救国，对于一个字节无法表示的字符，使用多个字节表示。</strong></p>
<p><strong>但是这样会出现两个问题：</strong></p>
<ul>
<li><code>不支持多国语言，例如中文的编码不可以包含日文；</code></li>
<li><code>没有统一标准，例如中文有GB2312、GBK、GB18030等多个标准；</code></li>
</ul>
<p><strong>所以由于编码不统一，开发人员经常在不同的编码间来回转换，会错误频出。为了彻底解决这个问题，unicode标准诞生了。unicode对世界上的文字系统进行了系统的整理、编码，让计算机可以用统一的方式处理文本，而且目前已经支持超过13万个字符，天然地支持多国语言。</strong></p>
</blockquote>
<p><strong>但是问题来了，unicode能表示这么多的字符，那么占用的内存一定不低吧。是的，根据当时的编码，一个unicode字符最高会占用到4字节。但是对于西方人来说，明明一个字符就够用了，为啥需要那么多。于是又出现了utf-8，它是为unicode提供的新一个新的编码规则，具有可变长的功能。对于1个ASCII字符那么会使用一个字节存储，对于非ASCII字符会使用3个字节存储。</strong></p>
<p><strong>但Python3中表示unicode字符串时，使用的却不是utf-8，至于原因我们下面来分析一下。国外有一篇文章，题目翻译过来说的是”Python在存储字符串的时候如何节省内存”，写的非常好，我们来看看。</strong></p>
<h3 id="Python在存储字符串的时候如何节省内存"><a href="#Python在存储字符串的时候如何节省内存" class="headerlink" title="Python在存储字符串的时候如何节省内存"></a>Python在存储字符串的时候如何节省内存</h3><p><strong>从Python3开始，str类型使用的是Unicode。而根据编码的不同，Unicode的每个字符最大可以占到4字节，从内存的角度来说， 这种编码有时会比较昂贵。</strong></p>
<p><strong>为了减少内存消耗并且提高性能，python的内部使用了三种编码方式表示Unicode。</strong></p>
<ul>
<li><code>Latin-1 编码：每个字符一字节;</code></li>
<li><code>UCS2 编码：每个字符两字节;</code></li>
<li><code>UCS4 编码：每个字符四字节;</code></li>
</ul>
<p><strong>在Python编程中，所有字符串的行为都是一致的，而且大多数时间我们都没有注意到差异。然而在处理大文本的时候，这种差异就会变得异常显著、甚至有些让人出乎意料。</strong></p>
<p><strong>为了看到内部表示的差异，我们使用<code>sys.getsizeof</code>函数，返回一个对象所占的字节数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 50</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 76</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 80</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到都是一个字符，但是它们占用的内存却是不一样的。</strong></p>
<p><strong>正如你所见，Python面对不同的字符会采用不同的编码。需要注意的是，Python中的每一个字符串都需要额外占用49-80字节，因为要存储一些额外信息，比如：哈希、长度、字节长度、编码类型等等。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于ASCII字符，显然一个占1字节，显然此时编码是Latin-1编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;ab&quot;</span>) - sys.getsizeof(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于汉字，日文等等，一个占用2字节，此时是UCS2编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨憨&quot;</span>) - sys.getsizeof(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;です&quot;</span>) - sys.getsizeof(<span class="string">&quot;で&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 像emoji，则是一个占4字节 ，此时是UCS4编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;💻💻&quot;</span>) - sys.getsizeof(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p><strong>而采用不同的编码，那么底层结构体实例额外的部分也会占用不同大小的内存。如果编码是Latin-1，那么这个结构体实例额外的部分会占49个字阶；编码是UCS2，占74个字节；编码是UCS4，占76个字节。然后字符串所占的字节数就等于：<code>额外的部分 + 字符个数 \* 单个字符所占的字节</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以一个空字符串占用49个字节, 此时会采用占用内存最小的Latin-1编码</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;&quot;</span>))  <span class="comment"># 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时使用UCS2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;憨&quot;</span>) - <span class="number">2</span>)  <span class="comment"># 74</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UCS4</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴&quot;</span>) - <span class="number">4</span>)  <span class="comment"># 76</span></span><br></pre></td></tr></table></figure>

<h4 id="为什么python底层存储字符串不使用utf-8编码"><a href="#为什么python底层存储字符串不使用utf-8编码" class="headerlink" title="为什么python底层存储字符串不使用utf-8编码"></a>为什么python底层存储字符串不使用utf-8编码</h4><p><strong>我们先来抛出一个问题：****首先我们知道Python支持通过索引查找一个字符串中指定位置的字符，而且Python中默认是以</strong>字符<strong>为单位的，不是</strong>字节**<code>(我们后面还会提)</code>，比如s[2]搜索的就是字符串s中的第3个字符。**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;My姫様&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>])  <span class="comment"># 姫</span></span><br></pre></td></tr></table></figure>

<p><strong>那么问题来了，我们知道Python中通过索引查找字符串的指定字符，时间复杂度为O(1)，那么Python是怎么通过索引、比如这里的s[2]，一下子就跳到第3个字符呢？显然是通过指针的偏移，用索引乘上每个字符占的字节数，得到偏移量，然后从头部向后偏移指定数量的字节即可，这样就能在定位到指定字符的同时保证时间复杂度为O(1)，但是这就需要一个前提：字符串中每个字符所占的大小必须是相同的，如果字符占的大小不同<code>(比如有的占用1字节、有的占用3字节)</code>，显然无法通过指针偏移的方式了，这个时候还想准确定位的话，只能按顺序对所有字符都逐个扫描，但这样的话时间复杂度肯定不是O(1)，而是O(n)。</strong></p>
<p><strong>我们以golang为例，golang中的字符串默认就是使用的utf-8。</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200807233641141-741445258.png" alt="img"></p>
<blockquote>
<p><strong>惊了，我们看到打印的并不是我们希望的结果。因为golang底层使用的是utf-8，不同的字符可能会占用不同的编码。但是golang中通过索引定位的时候，时间复杂度是O(1)，所以golang它就无法定位到准确的字符。</strong></p>
<p><strong>golang的字符串在通过索引定位的时候，比如这里的s[2]，会跳转两个字节，因为不同字符占的字节可能是不同的，因此在计算偏移量的时候只能以占用最小的、ASCII字符所占的字节为单位，即1个字节，所以计算的。只不过前面两个字符碰巧都是英文，每个占1字节，所以跳到了”姫”这个位置上。如果出现了非ASCII字符，那么是绝对跳不准的。而且在获取的时候，也只能获取1个字节。但是使用utf-8的话，非ASCII字符是占3个字节，显然一个字节是无法表示的。</strong></p>
</blockquote>
<p><strong>所以Python会使用3个编码，对应编码的字符分别是1、2、4字节。因此Python在创建字符串的时候，会先扫描。或者尝试使用占字节数最少的Latin1编码存储，但是范围肯定有限。如果发现了存储不下的字符，只能改变编码，使用UCS2，继续扫描。但是又发现了新的字符，这个字符UCS2也无法存储，因为两个字节最多存储65535个不同的字符，所以会再次改变编码，使用ucs4存储。ucs4占四个字节，肯定能存下了。</strong></p>
<p><strong>一旦改变编码，字符串中的所有字符都会使用同样的编码，因为它们不具备可变长功能。比如这个字符串：”hello古明地觉”，肯定都会使用UCS2，不存在说”hello”使用Latin1，”古明地觉”使用UCS2，因为一个字符串只能有一个编码。当通过索引获取的时候，会将索引乘上每个字符占的字节数，这样就能跳到准确位置上，因为字符串里面的所有字符占用的字节都是一样的，然后获取也会获取指定的字节数。比如：使用UCS2编码，那么定位到某个字符的时候，会取两个字节，这样才能表示一个完整的字符。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时全部是ascii字符，那么Latin1编码可以存储</span></span><br><span class="line"><span class="comment"># 所以结构体实例额外的部分占49个字节</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># 有5个字符，一个字符一个字节，所以加一起是54个字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s1))  <span class="comment"># 54</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现了汉字，那么Latin肯定存不下，于是使用UCS2</span></span><br><span class="line"><span class="comment"># 所以此时结构体实例额外的部分占74个字节</span></span><br><span class="line"><span class="comment"># 但是别忘了此时的英文字符也是ucs2，所以也是一个字符两字节</span></span><br><span class="line">s2 = <span class="string">&quot;hello憨&quot;</span></span><br><span class="line"><span class="comment"># 6个字符，74 + 6 * 2 = 86</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s2))  <span class="comment"># 86</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个牛逼了，ucs2也存不下，只能ucs4存储了</span></span><br><span class="line"><span class="comment"># 所以结构体实例额外的部分占76个字节</span></span><br><span class="line">s3 = <span class="string">&quot;hello憨💻&quot;</span></span><br><span class="line"><span class="comment"># 此时所有字符一个占4字节，7个字符</span></span><br><span class="line"><span class="comment"># 76 + 7 * 4 = 104</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s3))  <span class="comment"># 104</span></span><br></pre></td></tr></table></figure>

<p><strong>除此之外，我们再举一个例子更形象地证明这个现象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;a&quot;</span> * <span class="number">1000</span></span><br><span class="line">s2 = <span class="string">&quot;a&quot;</span> * <span class="number">1000</span> + <span class="string">&quot;💻&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到s2只比s1多了一个字符</span></span><br><span class="line"><span class="comment"># 但是两者占的内存，s2却将近是s1的四倍。</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s1), sys.getsizeof(s2))  <span class="comment"># 1049 4080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们知道s2和s1的差别只是s2比s1多了一个字符，但就是这么一个字符导致s2比s1多占了3031个字节</span></span><br><span class="line"><span class="comment"># 显然这多出来的3031个字节不可能是多出来的字符所占的大小，什么字符一个会占到三千多个字节</span></span><br><span class="line"><span class="comment"># 尽管如此，但它也是罪魁祸首，不过前面的1000个字符也是共犯</span></span><br><span class="line"><span class="comment"># 我们说Python会根据字符串选择不同的编码，s1全部是ascii字符，所以Latin1能存下，因此一个字符只占一个字节</span></span><br><span class="line"><span class="comment"># 所以大小就是49 + 1000 = 1049 </span></span><br><span class="line"><span class="comment"># 但是对于s2，python发现前1000个字符Latin1能存下，但是不幸的是，最后一个字符发现存不下了，只能使用UCS4</span></span><br><span class="line"><span class="comment"># 而字符串的所有字符只能有一个编码，为了保证索引查找的时候，时间复杂度为O(1)，这是Python的设计策略</span></span><br><span class="line"><span class="comment"># 因此导致前面一个字节就能存下的字符，每一个也变成了4个字节。</span></span><br><span class="line"><span class="comment"># 而我们说使用UCS4，结构体额外的内存会占76个字节</span></span><br><span class="line"><span class="comment"># 因此s2的大小就是：76 + 1001 * 4 = 76 + 4004 = 4080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相信下面你肯定能分析出来</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;爷的青春回来了&quot;</span>))  <span class="comment"># 88</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴的青春回来了&quot;</span>))  <span class="comment"># 104</span></span><br></pre></td></tr></table></figure>

<p><strong>所以如果字符串中的所有字符对应的ASCII码都在0~255范围内，则使用1字节Latin1对其进行编码。基本上，Latin1能表示前256个Unicode字符。它支持多种拉丁语，如英语、瑞典语、意大利语、挪威语。但是它们不能存储非拉丁语言，比如汉语、日语、希伯来语、西里尔语。这是因为它们的代码点(数字索引)定义在1字节(0-255)范围之外。</strong></p>
<p><strong>大多数流行的自然语言都可以采用2字节(UCS2)编码。当字符串包含特殊符号、emoji或稀有语言时，使用4字节(UCS4)编码。Unicode标准有将近300个块(范围)。你可以在0XFFFF块之后找到4字节块。假设我们有一个10G的ASCII文本，我们想把它加载到内存中，但如果我们在文本中插入一个表情符号，那么字符串的大小将增加4倍。这是一个巨大的差异，你可能会在实践当中遇到，比如处理NLP问题。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># 25000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;💻&quot;</span>))  <span class="comment"># 128187</span></span><br></pre></td></tr></table></figure>

<p><strong>所以最著名和最流行的Unicode编码都是utf-8，但是python不在内部使用它，而是使用Latin1、UCS2、UCS4。至于原因我们上面已经解释的很清楚了，主要是Python的索引是基于字符：</strong></p>
<blockquote>
<p><strong>当一个字符串使用utf-8编码存储时，根据它所表示的字符，每个字符会根据自身选择一个合适的编码。这是一种存储效率很高的编码，但是它有一个明显的缺点。由于每个字符的字节长度可能不同，因此就导致无法按照索引瞬间定位到单个字符，即便能定位，也无法定位准确。如果想准，那么只能逐个扫描所有字符。</strong></p>
<p><strong>因此要对使用utf-8编码的字符串执行一个简单的操作，比如s[5]，就意味着Python需要扫描每一个字符，直到找到需要的字符，这样效率是很低的。但如果是固定长度的编码就没有这样的问题，所以当Latin 1存储的”hello”，在和”憨色儿”组合之后，整体每一个字符都会向大的方向扩展、变成了2字节。这样定位字符的时候，只需要将”索引 *  2”计算出偏移的字节数、然后跳转该字节数即可。但如果原来的”hello”还是一个字节、而汉字是2字节，那么只通过索引是不可能定位到准确字符的，因为不同类型字符的编码不同，必须要扫描整个字符串才可以。但是扫描字符串，效率又比较低。所以python内部才会使用这个方法，而不是使用utf-8。</strong></p>
</blockquote>
<p><strong>所以对于golang来讲，如果想像Python一样，那么需要这么做：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;My姫様&quot;</span></span><br><span class="line">	<span class="comment">//我们看到长度为8, 因为它使用utf-8编码</span></span><br><span class="line">	<span class="comment">//底层一个非ascii字符占3字节, 所以总共8字节</span></span><br><span class="line">	fmt.Println(s, <span class="built_in">len</span>(s))  <span class="comment">// My姫様 8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果想像Python一样,那么golang中提供了一个rune, 相当于int32, 此时直接使用4个字节</span></span><br><span class="line">	r := []<span class="type">rune</span>(s)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(r), <span class="built_in">len</span>(r))  <span class="comment">// My姫様 4</span></span><br><span class="line">	<span class="comment">//虽然打印的内容是一样的，但是此时每个字符都使用4字节存储</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时跳转会和Python一样偏移 2 * 4 个字节, 然后获取也会获取4个字节, 因为一个字符占4个字节</span></span><br><span class="line">	<span class="comment">//所以不光索引跳转会将索引乘上4, 在获取的时候也会一次获取4个字节</span></span><br><span class="line">	<span class="comment">//因为都知道一个字符占4字节了,所以肯定获取指定数量的字节，这样才能表示完整字符</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(r[<span class="number">2</span>]))  <span class="comment">//姫</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实可以想一下C中的数组，比如int类型的数组，那么数组指针在往后偏移一个单位的时候，偏移的也是1个int<code>(4字节)</code>，而不是1个字节，这是显然的；然后获取的时候也会一次获取4个字节，因为这样才能表示一个int。但是utf-8表示的unicode字符串里面的字符可能占用不同的字节，那么显然没办法实现Python中字符串的索引查找效果，所以Python内部的字符串没有使用utf-8。</strong></p>
<p><strong>因此Python才会提供了三种编码，先使用占用最小的Latin1，不行的话再使用UCS2、UCS4，总之会确保每个字符占用的字节是一样的，原因的话我们上面分析的很透彻了。并且无论是索引还是切片、还是计算长度等等，都是基于字符的，显然这也符合人类的思维习惯。</strong></p>
<p>​        <strong>然后字符串还有intern机制，原文中也提到了，但是我们会在本文的后面介绍。下面先看字符串底层的结构，以及支持的相关操作是如何实现的。</strong>    </p>
<h3 id="字符串的底层实现"><a href="#字符串的底层实现" class="headerlink" title="字符串的底层实现"></a>字符串的底层实现</h3><p><strong>我们之前提到了，字符串采用不同的编码，底层的结构体实例所占用的额外内存是不一样的。其实本质上是，字符串会根据内容的不同，而选择不同的存储单元。</strong></p>
<p><strong>至于到底是怎么做到的，我们只能去源码中寻找答案了，与str相关的源码：<code>Include/unicodeobject.h</code>和<code>Objects/unicodeobject.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/unicodeobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PyUnicode_Kind</span> &#123;</span></span><br><span class="line"><span class="comment">/* String contains only wstr byte characters.  This is only possible</span></span><br><span class="line"><span class="comment">   when the string was created with a legacy API and _PyUnicode_Ready()</span></span><br><span class="line"><span class="comment">   has not been called yet.  */</span></span><br><span class="line">    PyUnicode_WCHAR_KIND = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* Return values of the PyUnicode_KIND() macro: */</span></span><br><span class="line">    PyUnicode_1BYTE_KIND = <span class="number">1</span>,</span><br><span class="line">    PyUnicode_2BYTE_KIND = <span class="number">2</span>,</span><br><span class="line">    PyUnicode_4BYTE_KIND = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们在unicodeobject.h中看到，str对象根据底层存储会根据unicode的不同而分为以下几类：</strong></p>
<ul>
<li><code>PyUnicode_1BYTE_KIND：所有字符码位均在 U+0000 到 U+00FF 之间</code></li>
<li><code>PyUnicode_2BYTE_KIND：所有字符码位均在 U+0000 到 U+FFFF 之间，且至少一个大于 U+00FF(否则每个字符就用1字节了)</code></li>
<li><code>PyUnicode_4BYTE_KIND：所有字符码位均在 U+0000 到 U+10FFFF 之间，且至少一个大于 U+FFFF</code></li>
</ul>
<p><strong>如果文本字符码位均在 *U+0000* 到 *U+00FF* 之间，单个字符只需 *1* 字节来表示；而码位在 *U+0000* 到 *U+FFFF* 之间的文本，单个字符则需要 2 字节才能表示；以此类推。这样一来，根据文本码位范围，便可为字符选用尽量小的存储单元，以最大限度节约内存。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Py_UCS4; <span class="comment">//我们看到4字节使用的是无符号32位整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Py_UCS2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> Py_UCS1;  <span class="comment">//Latin-1</span></span><br></pre></td></tr></table></figure>

<p><strong>既然unicode内部的存储结构会因字符而异，那么unicode底层就必须有成员来维护相应的信息，所以Python内部定义了若干标志位：</strong></p>
<ul>
<li><code>interned：是否被intern机制维护，这个机制我们会在本文后面介绍</code></li>
<li><code>kind：类型，用于区分字符底层存储单元的大小。如果是Latin1编码,那么就是1;UCS2编码则是2;UCS4编码则是4</code></li>
<li><code>compact：内存分配方式，对象与文本缓冲区是否分离</code></li>
<li><code>ascii：字符串是否是纯ASCII字符串, 如果是1就是1, 否则就是0。注意:  虽然每个字符都会对应ASCII码，但是只有对应的ASCII码为0~127之间的才是ASCII字符。所以虽然一个字节可表示的范围是0~255，但是128~255之间的并不是ASCII字符。</code></li>
</ul>
<p><strong>而为unicode字符串申请空间，底层可以调用一个叫PyUnicode_New的函数，这也是一个特型API。比如：元组申请空间可以使用PyTuple_New，列表申请空间可以使用PyList_New等等，会传入一个整型，创建一个能够容纳指定数量元素的结构体实例。而PyUnicode_New则接受一个字符个数以及最大字符maxchar初始化unicode字符串对象，之所以会多出一个maxchar，是因为要根据它来为unicode字符串对象选择最紧凑的字符存储单元，以及结构体。</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200807233651483-1686148361.png" alt="img"></p>
<p><strong>下面我们就来分析字符串底层对应的结构体。</strong></p>
<h4 id="PyASCIIObject"><a href="#PyASCIIObject" class="headerlink" title="PyASCIIObject"></a>PyASCIIObject</h4><p><strong>如果 *str* 对象保存的文本均为 *ASCII* ，即 maxchar&lt;128，则底层由 PyASCIIObject 结构进行存储：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject</span></span><br><span class="line"><span class="comment">   structure. state.ascii and state.compact are set, and the data</span></span><br><span class="line"><span class="comment">   immediately follow the structure. utf8_length and wstr_length can be found</span></span><br><span class="line"><span class="comment">   in the length field; the utf8 pointer is equal to the data pointer. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          <span class="comment">/* Number of code points in the string */</span></span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* Hash value; -1 if not set */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> interned:<span class="number">2</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> kind:<span class="number">3</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> compact:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ascii:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ready:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> :<span class="number">24</span>;</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="type">wchar_t</span> *wstr;              <span class="comment">/* wchar_t representation (null-terminated) */</span></span><br><span class="line">&#125; PyASCIIObject;</span><br></pre></td></tr></table></figure>

<p><strong>PyASCIIObject结构体也是其他 *Unicode* 底层结构体的基础，所有字段均为 *Unicode* 公共字段：</strong></p>
<ul>
<li><code>ob_refcnt：引用计数</code></li>
<li><code>ob_type：类型指针</code></li>
<li><code>length：字符串长度</code></li>
<li><code>hash：字符串的哈希值</code></li>
<li><code>state：unicode对象标志位，包括intern、kind、ascii、compact等</code></li>
<li><code>wstr：一个指针，指向由宽字符组成的字符数组。字符串和字节序列一样，底层都是通过字符数组来维护具体的值。</code></li>
</ul>
<p><strong>以字符串”abc”为例，看看它在底层的存储结构：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001754094-209875044.png" alt="img"></p>
<p><strong>注意：state 成员后面有一个 4  字节的空洞，这是结构体字段内存对齐造成的现象。在 64 位机器上，指针大小为 8 字节，为优化内存访问效率，必须以 8  字节对齐。现在我们知道一个空字符串为什么占据49个字节了，因为ob_refcnt、ob_type、length、hash、wstr 都是 8  字节，所以总共 40 字节；而 state 是 4 字节，但是留下了 4 字节的空洞，加起来也是 8 字节，所以总共占 40 + 8 &#x3D; 48  个字节，但是 Python 的 unicode 字符串在 C 中也是使用字符数组来存储的，只不过此时的字符不再是 char 类型，而是  wchar_t。但是它的内部依旧有一个 ‘\0’，所以还要加上一个 1，总共 49 字节。</strong></p>
<p><strong>对于 “abc” 这个 unicode 字符串来说，占的总字节数就是 49 + 3 &#x3D; 52。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># 52</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度为n的ASCII字符串, 大小就是49 + n</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;a&quot;</span> * <span class="number">1000</span>))  <span class="comment"># 1049</span></span><br></pre></td></tr></table></figure>

<h4 id="PyCompactUnicodeObject"><a href="#PyCompactUnicodeObject" class="headerlink" title="PyCompactUnicodeObject"></a>PyCompactUnicodeObject</h4><p><strong>如果文本不全是 *ASCII* ，Unicode 对象底层便由 *PyCompactUnicodeObject* 结构体保存：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Non-ASCII strings allocated through PyUnicode_New use the</span></span><br><span class="line"><span class="comment">  PyCompactUnicodeObject structure. state.compact is set, and the data</span></span><br><span class="line"><span class="comment">  immediately follow the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   PyASCIIObject _base;</span><br><span class="line">   Py_ssize_t utf8_length;     <span class="comment">/* Number of bytes in utf8, excluding the</span></span><br><span class="line"><span class="comment">                                * terminating \0. */</span></span><br><span class="line">   <span class="type">char</span> *utf8;                 <span class="comment">/* UTF-8 representation (null-terminated) */</span></span><br><span class="line">   Py_ssize_t wstr_length;     <span class="comment">/* Number of code points in wstr, possible</span></span><br><span class="line"><span class="comment">                                * surrogates count as two code points. */</span></span><br><span class="line">&#125; PyCompactUnicodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyCompactUnicodeObject是在PyASCIIObject的基础上增加了3个字段。</strong></p>
<ul>
<li><code>utf8_length：字符串的utf-8编码长度</code></li>
<li><code>utf8：字符串使用utf-8编码的结果，这里是缓存起来从而避免重复的编码运算</code>  <font color="red">这里为什么占四个字节呢？不理解</font></li>
<li><code>wstr_length：宽字符的数量</code></li>
</ul>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221004825671-1176090938.png" alt="img"></p>
<p><strong>我们说 PyCompactUnicodeObject  只是多了3个字段，显然多出了 24 字节。那么之前的 49+24 等于 73，咦不对啊，我们不是说一个是 74 一个 76 吗？你忘记了  ‘\0’，如果使用 UCS2，那么 ‘\0’ 也占两个字节，所以应该是 73 -1 + 2 &#x3D; 74；同理 UCS4 是 73 - 1 + 4 &#x3D; 76，所以此时 unicode 字符串所占内存我们算是分析完了。然后我们再来看看这几种不同编码下对应的字符串结构吧。</strong></p>
<h4 id="PyUnicode-1BYTE-KIND"><a href="#PyUnicode-1BYTE-KIND" class="headerlink" title="PyUnicode_1BYTE_KIND"></a>PyUnicode_1BYTE_KIND</h4><p><strong>如果 <code>128 &lt;= maxchar &lt; 256</code>，虽然一个字节可以存储的下，但*Unicode* 对象底层也会由 *PyCompactUnicodeObject* 结构体保存，字符存储单元为 *Py_UCS1*<code>(Latin-1)</code> ，大小为 *1* 字节。以字符串 “sator¡” 为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001807029-644388608.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然此时所有的字符都占一个 1 字节，但是只有当 maxchar &lt; 128 的时候，才会使用 PyASCIIObject</span></span><br><span class="line"><span class="comment"># 如果大于等于 128, 那么会使用 PyCompactUnicodeObject 存储, 只不过内部字符依旧每个占一字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;sator¡&quot;</span>))  <span class="comment"># 79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们知道对于使用 UCS2 的 PyCompactUnicodeObject 来说, 空字符串会占 74 字节</span></span><br><span class="line"><span class="comment"># 而 \0 占了两个字节，所以除去 \0，额外部分是 72 字节</span></span><br><span class="line"><span class="comment"># 而这里是 Latin-1，\0 是一个字节，所以一个空字符串应该占 73 字节，加上这里的 6 个字符，总共是 79 字节。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此当使用 Latin1 编码的时候，不一定就是 PyASCIIObject, 只有当 0 &lt; maxchar &lt; 128 的时候才会使用 PyASCIIObject</span></span><br><span class="line"><span class="comment"># 所以如果将上面的 &quot;sator¡&quot; 改成 &quot;satori&quot;，那么就会使用 PyASCIIObject 存储了。</span></span><br><span class="line"><span class="comment"># 此外还要注意所占的内存, 因为 Latin1 和 UCS2、UCS4 三个编码都可以对应 PyCompactUnicodeObject</span></span><br><span class="line"><span class="comment"># 而不包括 \0 的话，那么一个 PyCompactUnicodeObject 是占据72字节的，如果算上 \0</span></span><br><span class="line"><span class="comment"># 那么使用 Latin1 编码的空字符串就是 73 字节，使用 UCS2 编码的空字符串就是 74 字节，使用 UCS4 编码的空字符串就是 76 字节，因为 \0 分别占 1、2、4 字节</span></span><br></pre></td></tr></table></figure>

<h4 id="PyUnicode-2BYTE-KIND"><a href="#PyUnicode-2BYTE-KIND" class="headerlink" title="PyUnicode_2BYTE_KIND"></a>PyUnicode_2BYTE_KIND</h4><p><strong>如果 <code>256 &lt;= maxchar &lt; 65536</code>，*Unicode* 对象底层同样由 *PyCompactUnicodeObject* 结构体保存，但字符存储单元为 *UCS2* ，大小为 *2* 字节。以字符串 “My姫様” 为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001812326-402012918.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 74 + 4 * 2, 或者72 + 5 * 2</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;My姫様&quot;</span>))  <span class="comment"># 82</span></span><br></pre></td></tr></table></figure>

<p><strong>当文本中包含了 Latin1 无法存储的字符时，会使用两字节的 UCS  保存，但是连前面的英文字符也变成两字节了。至于原因我们上面已经分析的很透彻了，因为定位的时候是获取的字符，但如果采用变长的 utf-8  方式存储导致不同字符占的内存大小不一，那么就无法在 O(1) 的时间内取出准确的字符了，只能从头到尾依次遍历。而 Go 基于  utf-8，因此它无法获取准确的字符，只能转成 rune，此时内部一个字符直接占4字节。</strong></p>
<h4 id="PyUnicode-4BYTE-KIND"><a href="#PyUnicode-4BYTE-KIND" class="headerlink" title="PyUnicode_4BYTE_KIND"></a>PyUnicode_4BYTE_KIND</h4><p><strong>如果 <code>65536 &lt;= maxchar &lt; 429496296</code>，便只能使用4字节存储单元的UCS4了，以字符串”👴青回”为例：</strong></p>
<p><img src="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20210221001819534-1633513290.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 76 + 3 * 4, 或者72 + 4 * 4</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;👴青回&quot;</span>))  <span class="comment"># 88</span></span><br></pre></td></tr></table></figure>

<p><strong>因此此时每个字符都采用UCS4编码，因此每个字符占四个字节，这是Python内部采取的策略。</strong></p>
<p><strong>我们后面通过分析字符串的一些操作的时候，会更加深刻的体会到。</strong></p>
<h4 id="PyUnicodeObject"><a href="#PyUnicodeObject" class="headerlink" title="PyUnicodeObject"></a>PyUnicodeObject</h4><p><strong>不是说Python中字符串底层对应PyUnicodeObject吗？目前出现了PyASCIIObject和PyCompactUnicodeObject，那么PyUnicodeObject呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyCompactUnicodeObject _base;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *any;</span><br><span class="line">        Py_UCS1 *latin1;</span><br><span class="line">        Py_UCS2 *ucs2;</span><br><span class="line">        Py_UCS4 *ucs4;</span><br><span class="line">    &#125; data;                     <span class="comment">/* Canonical, smallest-form Unicode buffer */</span></span><br><span class="line">&#125; PyUnicodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这便是 PyUnicodeObject 的定义了，里面 data 是一个共同体，这里我们没有必要关注，我们直接把它当成 PyCompactUnicodeObject 来用即可。</strong></p>
<h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><p><strong>先来看看str类型对象在底层的定义吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/unicodeobject.c</span></span><br><span class="line">PyTypeObject PyUnicode_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;str&quot;</span>,              	    <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyUnicodeObject),    <span class="comment">/* tp_size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    unicode_repr,           	<span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;unicode_as_number,         <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;unicode_as_sequence,       <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;unicode_as_mapping,        <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>首先哈希操作<code>(unicode_hash)</code>之类的肯定是支持的，然后我们关注一下tp_as_number、tp_as_sequence、tp_as_mapping，我们看到三个操作簇居然都满足。不过有了bytes的经验，我们知道tp_as_number里面的实际上只有取模，也就是格式化<code>(bytes和str在很多行为上都是相似的,但是这两者的区别我们后面会说,目前认为str对象可以编码成bytes对象,bytes对象可以解码成str对象即可)</code>。</strong></p>
<p><strong>我们来看一下这几个操作簇吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不出我们所料, 只有一个取模</span></span><br><span class="line"><span class="type">static</span> PyNumberMethods unicode_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    unicode_mod,    <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到这个和bytes对象是几乎一样的，因为我们说了str对象和bytes都是不可变的变长对象,并且可以相互转化</span></span><br><span class="line"><span class="comment">//它们的行为时高度相似的</span></span><br><span class="line"><span class="type">static</span> PySequenceMethods unicode_as_sequence = &#123;</span><br><span class="line">    (lenfunc) unicode_length,       	 <span class="comment">/* sq_length */</span></span><br><span class="line">    PyUnicode_Concat,           		 <span class="comment">/* sq_concat */</span></span><br><span class="line">    (ssizeargfunc) unicode_repeat,  	 <span class="comment">/* sq_repeat */</span></span><br><span class="line">    (ssizeargfunc) unicode_getitem,      <span class="comment">/* sq_item */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_slice */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_ass_item */</span></span><br><span class="line">    <span class="number">0</span>,                  				<span class="comment">/* sq_ass_slice */</span></span><br><span class="line">    PyUnicode_Contains,        			 <span class="comment">/* sq_contains */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也和bytes对象一样</span></span><br><span class="line"><span class="type">static</span> PyMappingMethods unicode_as_mapping = &#123;</span><br><span class="line">    (lenfunc)unicode_length,        <span class="comment">/* mp_length */</span></span><br><span class="line">    (binaryfunc)unicode_subscript,  <span class="comment">/* mp_subscript */</span></span><br><span class="line">    (objobjargproc)<span class="number">0</span>,           <span class="comment">/* mp_ass_subscript */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们先来重点看一下PyUnicode_Concat这个操作，它是用来将两个字符串相加、组合成一个新的字符串。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyUnicode_Concat</span><span class="params">(PyObject *left, PyObject *right)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//参数left和right显然指向两个unicode字符串</span></span><br><span class="line">    <span class="comment">//result则是指向相加之后的字符串</span></span><br><span class="line">    PyObject *result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还记得这个Py_UCS4吗, 它是相当于一个无符号32位整型</span></span><br><span class="line">    Py_UCS4 maxchar, maxchar2;</span><br><span class="line">    <span class="comment">//显然是left的长度、right的长度、相加之后的长度</span></span><br><span class="line">    Py_ssize_t left_len, right_len, new_len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测是否是PyUnicodeObject</span></span><br><span class="line">    <span class="keyword">if</span> (ensure_unicode(left) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(right)) &#123;</span><br><span class="line">        <span class="comment">//如果右边不是str对象的话，报错</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;can only concatenate str (not \&quot;%.200s\&quot;) to str&quot;</span>,</span><br><span class="line">                     right-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//属性的初始化, ensure_unicode实际上是调用了PyUnicode_Check和PyUnicode_READY这两部</span></span><br><span class="line">    <span class="comment">//当然这些都是Python内部做的检测，我们不用太关心</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_READY(right) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里快分支</span></span><br><span class="line">    <span class="comment">//如果其中一方为空的话，那么直接返回另一方即可，显然这里的快分支命中率就没那么高了，但还是容易命中的</span></span><br><span class="line">    <span class="keyword">if</span> (left == unicode_empty)</span><br><span class="line">        <span class="keyword">return</span> PyUnicode_FromObject(right);</span><br><span class="line">    <span class="keyword">if</span> (right == unicode_empty)</span><br><span class="line">        <span class="keyword">return</span> PyUnicode_FromObject(left);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//计算left的长度和right的长度</span></span><br><span class="line">    left_len = PyUnicode_GET_LENGTH(left);</span><br><span class="line">    right_len = PyUnicode_GET_LENGTH(right);</span><br><span class="line">    <span class="comment">//如果相加超过PY_SSIZE_T_MAX，那么会报错, 因为要维护字符串的长度，显然长度是有范围的</span></span><br><span class="line">    <span class="comment">//但是几乎不存在字符串的长度会超过PY_SSIZE_T_MAX的</span></span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; PY_SSIZE_T_MAX - right_len) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;strings are too large to concat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的长度</span></span><br><span class="line">    new_len = left_len + right_len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//计算存储单元占用的字节数</span></span><br><span class="line">    maxchar = PyUnicode_MAX_CHAR_VALUE(left);</span><br><span class="line">    maxchar2 = PyUnicode_MAX_CHAR_VALUE(right);</span><br><span class="line">    <span class="comment">//取大的那一方，因为一个是UCS2一个是UCS4，那么相加之后肯定会选择UCS4</span></span><br><span class="line">    maxchar = Py_MAX(maxchar, maxchar2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过PyUnicode_New申请能够容纳new_len宽字符的PyUnicodeObject, 并且字符的存储单元是大的那一方</span></span><br><span class="line">    result = PyUnicode_New(new_len, maxchar);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将left拷进去</span></span><br><span class="line">    _PyUnicode_FastCopyCharacters(result, <span class="number">0</span>, left, <span class="number">0</span>, left_len);</span><br><span class="line">    <span class="comment">//将right拷进去</span></span><br><span class="line">    _PyUnicode_FastCopyCharacters(result, left_len, right, <span class="number">0</span>, right_len);</span><br><span class="line">    assert(_PyUnicode_CheckConsistency(result, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和bytes对象一样，+的效率非常低下，所以官方建议通过join的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyUnicode_Join</span><span class="params">(PyObject *separator, PyObject *seq)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    PyObject *fseq;</span><br><span class="line">    Py_ssize_t seqlen;</span><br><span class="line">    PyObject **items;</span><br><span class="line"></span><br><span class="line">    fseq = PySequence_Fast(seq, <span class="string">&quot;can only join an iterable&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items = PySequence_Fast_ITEMS(fseq);</span><br><span class="line">    seqlen = PySequence_Fast_GET_SIZE(fseq);</span><br><span class="line">    res = _PyUnicode_JoinArray(separator, items, seqlen);</span><br><span class="line">    Py_DECREF(fseq);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyUnicode_JoinArray(PyObject *separator, PyObject *<span class="type">const</span> *items, Py_ssize_t seqlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码比较长，但是逻辑不难理解，这里就不贴了。就是获取列表或者元组里面的每一个unicode字符串对象的长度，然后加在一起，并取最大的存储单元，然后一次性申请对应的空间，再逐一进行拷贝。所以拷贝是避免不了的，+这种方式导致低效率的主要原因就在于大量PyUnicodeObject的创建和销毁。</strong></p>
<p><strong>因此如果我们要拼接大量的PyUnicodeObject，那么使用join列表或者元组的方式；如果数量不多，还是可以使用+的，毕竟维护一个列表也是需要资源的。使用join的方式，只有在PyUnicodeObject的数量非常多的时候，优势才会凸显出来。</strong></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​        <strong>然后我们在看看PyUnicodeObject的初始化，Python很多方式，从C中原生的字符串创建PyUnicodeObject对象。比如：PyUnicode_FromString、PyUnicode_FromStringAndSize、PyUnicode_FromUnicodeAndSize、PyUnicode_FromUnicode、PyUnicode_FromWideChar等等</strong>     </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyUnicode_FromString(<span class="type">const</span> <span class="type">char</span> *u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">strlen</span>(u);</span><br><span class="line">    <span class="comment">// PY_SSIZE_T_MAX是一个与平台相关的数值，在64位系统下是4GB</span></span><br><span class="line">    <span class="comment">//如果创建的字符串的长度超过了这个值，那么会报错</span></span><br><span class="line">    <span class="comment">//个人觉得这种情况应该不会发生，就跟变量的引用计数一样</span></span><br><span class="line">    <span class="comment">//只要不是吃饱了撑的，写恶意代码，基本不会超过这个阈值</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">&quot;input too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会进行检测字符串是哪种编码格式，从而决定分配几个字节</span></span><br><span class="line">    <span class="keyword">return</span> PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串对象的intern机制"><a href="#字符串对象的intern机制" class="headerlink" title="字符串对象的intern机制"></a>字符串对象的intern机制</h3><p><strong>如果字符串的interned标识位为1，那么Python虚拟机将为其开启interned机制。那么，什么是interned机制呢？</strong></p>
<blockquote>
<p><strong>在Python中，某些字符串也可以像小整数对象池中的整数一样，共享给所有变量使用，从而通过避免重复创建来降低内存使用、减少性能开销，这便是intern机制。</strong></p>
</blockquote>
<p><strong>Python的做法是在内部维护一个全局字典，所有开启intern机制的字符串均会保存在这里，后续如果需要使用的话，会先尝试在全局字典中获取，从而实现避免重复创建的功能。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/unicodeobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyUnicode_InternInPlace</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *s = *p;</span><br><span class="line">    PyObject *t;</span><br><span class="line">    <span class="comment">//对PyUnicodeObjec进行类型和状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(s))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//检测interned标识位, 判断是否开启intern机制</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CHECK_INTERNED(s))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//创建intern机制的dict</span></span><br><span class="line">    <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear(); <span class="comment">/* Don&#x27;t leave an exception */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_ALLOW_RECURSION</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面的内容单独分析</span></span><br><span class="line">    t = PyDict_SetDefault(interned, s, s);</span><br><span class="line">    Py_END_ALLOW_RECURSION</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(t == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != s) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</span><br><span class="line">    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>PyDict_SetDefault</code>函数中首先会进行一系列的检查，包括类型检查、因为intern共享机制只能用在字符串对象上，所以检查传入的对象是否已经被intern机制处理过了。</strong></p>
<p><strong>我们在代码中看到了<code>interned = PyDict_New()</code>，这个<code>PyDict_New()</code>是python中的dict对象，因此可以发现在程序中有一个key、value映射关系的集合。</strong></p>
<p><strong>intern机制中的PyUnicodObject采用了特殊的引用计数机制，将一个PyUnicodeObject对象a的PyObject指针作为key和valu添加到intered中时，PyDictObjec对象会通过这两个指针对a的引用计数进行两次+1操作。这会造成a的引用计数在python程序结束前永远不会为0，这也是最后面<code>Py_REFCNT(s) -= 2;</code> 要将计数减2的原因。</strong></p>
<p><strong>Python在创建一个字符串时，会首先检测是否已经有该字符串对应的PyUnicodeObject对象了，如果有，就不用创建新的，这样可以节省空间。但其实不是这样的，事实上，节省内存空间是没错的，可Python并不是在创建PyUnicodeObject的时候就通过intern机制实现了节省空间的目的。从PyUnicode_FromString中我们可以看到，无论如何一个合法的PyUnicodeObject总是会被创建的，而intern机制也只对PyUnicodeObject起作用。</strong></p>
<p><strong>对于任何一个字符串，Python总是会为它创建对应的PyUnicodeObject，尽管创建出来的对象所维护的字符数组，在intern机制中已经存在了<code>(有另外的PyUnicodeObject也维护了相同的字符数组)</code>。而这正是关键所在，通常Python在运行时创建了一个PyUnicodeObject对象temp之后，基本上都会调用PyUnicode_InternInPlace对temp进行处理，如果维护的字符数组有其他的PyUnicodeObject维护了，或者说其他的PyUnicodeObject对象维护了一个与之一模一样的字符数组，那么temp的引用计数就会减去1。temp由于引用计数为0而被销毁，只是昙花一现，然后归于湮灭。</strong></p>
<blockquote>
<p><strong>所以现在我们就明白了intern机制，并不是说先判断是否存在，如果存在，就不创建。而是先创建，然后发现已经有其他的PyUnicodeObject维护了一个与之相同的字符数组，于是intern机制将引用计数减一，导致引用计数为0，最终被回收。</strong></p>
</blockquote>
<p><strong>但是这么做的原因是什么呢？为什么非要创建一个PyUnicodeObject来完成intern操作呢？这是因为PyDictObject必须要求必须以PyObject *作为key。</strong></p>
<p><strong>关于PyUnicodeObject对象的intern机制，还有一点需要注意。实际上，被intern机制处理过后的字符串分为两类，一类处于<code>SSTATE_INTERNED_IMMORTAL</code>，另一类处于<code>SSTATE_INTERNED_MORTAL</code>状态，这两种状态的区别在<code>unicode_dealloc</code>中可以清晰的看到，<code>SSTATE_INTERNED_IMMORTAL</code>状态的PyUnicodeObject是永远不会被销毁的，它与python解释器共存亡。</strong></p>
<p><strong>PyUnicode_InternInPlace只能创建<code>SSTATE_INTERNED_MORTAL</code>的PyUnicodeObject对象，如果想创建<code>SSTATE_INTERNED_IMMORTAL</code>对象，必须通过另外的接口来强制改变PyUnicodeObject的intern状态。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyUnicode_InternImmortal</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyUnicode_InternInPlace(p);</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) &#123;</span><br><span class="line">        _PyUnicode_STATE(*p).interned = SSTATE_INTERNED_IMMORTAL;</span><br><span class="line">        Py_INCREF(*p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>但是问题来了，什么样的字符才会开启intern机制呢？</strong>     </p>
<p><strong>在Python3.8中，如果一个字符串的所有字符都位于0 ~ 127之间，那么会开启intern机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;abc&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;abc&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 之前的话是不超过20个字符，但是在Python3.8中这个限制被扩大了很多</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;abc&quot;</span> * <span class="number">2000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;abc&quot;</span> * <span class="number">2000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span>  <span class="comment"># 显然3 * 2000,6000个字符是不会开启intern机制的，所以长度限制是多少，有兴趣可以自己试一下</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在Python3.8中，如果一个字符串只有一个字符，并且位于0~255之间，那么会开启intern机制。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">chr</span>(<span class="number">255</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">chr</span>(<span class="number">255</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 不位于0~127之间，所以不是ASCII字符，因此没有开启intern机制</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">chr</span>(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">chr</span>(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 但如果只有一个字符的话，则会开启</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 另外，空字符串也会开启</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>实际上，存储单个字符这种方式有点类似于bytes对象中的缓存池。是的，正如整数有小整数对象池、bytes对象有字符缓存池一样，字符串也有其对应的PyUnicodeObject缓存池。</strong></p>
<p><strong>在Python中的整数对象中，小整数的对象池是在Python初始化的时候被创建的，而字符串对象体系中的缓存池则是以静态变量的形式存在的。在Python初始化完成之后，缓冲池的所有PyUnicodeObject指针都为空。</strong></p>
<p><strong>当创建一个PyUnicodeObject对象时，如果字符串只有一个字符，且位于0~255。那么会先对该字符串进行intern操作，再将intern的结果缓存到池子当中。同样当再次创建PyUnicodeObject对象时，检测维护的是不是只有一个字符，然后检查字符是不是存在于缓存池中，如果存在，直接返回。</strong></p>
<h3 id="str对象和bytes对象之间的关系"><a href="#str对象和bytes对象之间的关系" class="headerlink" title="str对象和bytes对象之间的关系"></a>str对象和bytes对象之间的关系</h3><p><strong>首先str对象我们称之为字符串，bytes对象我们称之为字节序列，把字符串中的每一个字符都转成对应的编码，那么得到就是字节序列了。因为计算机存储和网络通讯的基本单位都是字节，所以字符串必须以字节序列的形式进行存储或传输。</strong></p>
<p><strong>那么如何转化呢？首先我们需要清楚两个概念：字符集和编码。</strong></p>
<blockquote>
<p><strong>字符集顾名思义就是由字符组成的集合，每个字符在集合中都有唯一编号，像ASCII、unicode都是字符集。只不过 ASCII 能够容纳的字符是有限的，而 unicode 可以容纳世界上所有的字符。</strong></p>
<p><strong>而编码则负责告诉你字符在字符集中对应的编号，编码有：gbk、utf-8等等</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;姫様&quot;</span></span><br><span class="line"><span class="comment"># 采用utf-8编码, encode成bytes对象</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># b&#x27;\xe5\xa7\xab\xe6\xa7\x98&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> s.encode(<span class="string">&quot;utf-8&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">229</span></span><br><span class="line"><span class="string">167</span></span><br><span class="line"><span class="string">171</span></span><br><span class="line"><span class="string">230</span></span><br><span class="line"><span class="string">167</span></span><br><span class="line"><span class="string">152</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 说明&quot;姫&quot;对应的ASCII码是: 229 167 171, 因为utf-8编码的话, 一个汉字占3个字节</span></span><br><span class="line"><span class="comment"># 我们使用utf-8解码, 也能得到对应的字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 姫様</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytearray</span>([<span class="number">229</span>, <span class="number">167</span>, <span class="number">171</span>, <span class="number">230</span>, <span class="number">167</span>, <span class="number">152</span>]).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 姫様</span></span><br></pre></td></tr></table></figure>

<p><strong>因此字符串和字节序列在某种程度上是很相似的，字符串按照指定的编码进行encode即可得到字节序列<code>(将字符转成ASCII码)</code>，字节序列按照相同的编码decode即可得到字符串<code>(将ASCII码转成字符)</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如我有一个gbk编码的字节序列，但是在传输的时候需要utf-8编码的字节序列</span></span><br><span class="line">b = <span class="string">b&#x27;\xc4\xe3\xba\xc3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们就按照gbk解码成字符串，因为不同的编码会得到不同的ASCII码</span></span><br><span class="line"><span class="comment"># 因此encode和decode都要使用同一种编码, 如果前后使用了不同的编码，那么在decode的时候会因为无法正确解析而报错</span></span><br><span class="line">s = b.decode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 你好</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我们使用utf-8进行encode</span></span><br><span class="line">b = s.encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;我很可爱&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用utf-8进行decode</span></span><br><span class="line"><span class="built_in">print</span>(b.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 你好我很可爱</span></span><br></pre></td></tr></table></figure>

<p><strong>但是对于ASCII字符来说，由于不管采用哪一种编码，它们得到的ASCII码都是固定的，所以在显示的时候直接以字符本身显示了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># a对应的ASCII码是97, 所以你在C中写char c = &#x27;a&#x27;和char c = 97是完全等价的</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># b&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytearray</span>([<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们创建一个字节序列的时候，也可以这么做</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;abc&quot;</span>)  <span class="comment"># b&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是我们不可以b&#x27;憨&#x27;, 因为&#x27;憨&#x27;这个字符不是ASCII字符, ASCII字符要求对应的ASCII码唯一、并且小于128</span></span><br><span class="line"><span class="comment"># 所以在不同的编码下会对应不同的ASCII码,比如gbk编码的话对应两个ASCII码, utf-8对应三个ASCII码</span></span><br><span class="line"><span class="comment"># 因此b&#x27;憨&#x27;的话，由于不知道使用哪一种编码, 所以Python不允许这么做，而是通过&#x27;憨&#x27;.encode的方式来手动指定编码</span></span><br><span class="line"><span class="comment"># 而&#x27;abc&#x27;都是纯ASCII字符，不管采用哪一种编码都会得到相同的ASCII码，所以Python允许这么做</span></span><br><span class="line"><span class="comment"># 当然对ASCII字符使用ASCII码也是可以的</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>字符串的内容还是比较多的，在源码中有一万六千多行，显然我们没办法一步一步地全部分析完，有兴趣的可以自己深入研究一下。其实我们能把字符串的存储搞明白，其实已经是前进了一大步了。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>Flexible and Optimal Dependency Management via Max-SMT</title>
    <url>/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/</url>
    <content><![CDATA[<h2 id="Flexible-and-Optimal-Dependency-Management-via-Max-SMT"><a href="#Flexible-and-Optimal-Dependency-Management-via-Max-SMT" class="headerlink" title="Flexible and Optimal Dependency Management via Max-SMT"></a>Flexible and Optimal Dependency Management via Max-SMT</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Flexible and Optimal Dependency Management via Max-SMT (通过Max-SMT实现灵活和最佳依赖管理)</li>
<li>Authors: Donald Pinckney, Federico Cassano, Arjun Guha, Jon Bell, Massimiliano Culpo, Todd Gamblin</li>
<li>Affiliation: Northeastern University, Boston, MA, USA (作者Donald Pinckney, Federico Cassano, Arjun Guha, Jon Bell所在的机构为美国马萨诸塞州波士顿东北大学)</li>
<li>Keywords: dependency management, optimization, package manager (依赖管理、优化、包管理器)</li>
<li>Urls: <a href="https://dl.acm.org/doi/pdf/10.1145/3415506.3420079">https://dl.acm.org/doi/pdf/10.1145/3415506.3420079</a>, Github:None</li>
<li>Repo: <a href="https://github.com/donald-pinckney/pacsolve">https://github.com/donald-pinckney/pacsolve</a></li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h3><ul>
<li><p>a. background:</p>
<ul>
<li>PACSOLVE和MAXNPM是旨在解决NPM依赖性解析器的一些限制的新工具。虽然NPM是软件开发的重要工具，但它具有一些缺点，使得开发人员难以实现其目标。</li>
</ul>
</li>
<li><p>b. past methods and problems:</p>
<ul>
<li>NPM使用的贪心算法可能会导致重复依赖和膨胀的代码，对于需要最小化代码大小的Web应用程序来说尤其糟糕。 此外，NPM的漏洞修复算法也是贪心的，甚至可能引入新的漏洞，并且NPM的复制依赖能够破坏有状态框架，需要大量解决方法。</li>
</ul>
</li>
<li><p>c. methodology</p>
<ul>
<li>PACSOLVE通过一个高级DSL来规定包版本、版本约束、优化目标等的语法和语义，并使用一个基于求解器的语言来生成Max-SMT 求解器的问题，确保与NPM的贪心方法进行比较的最优解。</li>
</ul>
</li>
<li><p>d. task and performance</p>
<ul>
<li>通过一个多目标优化的依赖性解析实验，MAXNPM通常优于NPM和特定工具，从而在33% 的情况下减少依赖中的漏洞，在14% 的情况下选择更新的依赖，并在21% 的情况下减少了依赖的数量。</li>
</ul>
</li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h3><p>现有工作的问题：</p>
<p><font color="red">npm官方漏洞修复工具audit</font></p>
<p>NPM内置的工具npm  audit通过查询GitHub安全咨询数据库检查有漏洞的依赖项。该工具还可以通过升级依赖项而不违反版本限制来修复漏洞。但是，该工具有几个缺点。</p>
<ul>
<li>首先，每次运行只尝试修复一个漏洞。过去，NPM的贪婪算法常常导致重复依赖和膨胀的代码，NPM的漏洞修复算法也是贪心的，会引入新的漏洞。</li>
<li>其次，它仅升级有漏洞的依赖项，即使有一个无漏洞的版本可以满足版本限制。</li>
<li>第三，尽管CVSS漏洞评分可在GitHub安全咨询数据库中获得，但该工具并不按漏洞分数进行优先修复。漏洞评分（CVSS）是一种用于评估计算机系统和网络设备漏洞风险的开放标准，它为安全研究人员、企业和政府提供了一种简单、标准化的方法来评估漏洞的严重程度。</li>
<li>最后，该工具不会基于漏洞的严重性进行妥协。例如，一个修复可能会引入比原漏洞更严重的新漏洞。</li>
</ul>
<p>以往的研究忽略了软件开发的复杂性，特别是在需求多元化的情况下，开发人员需要更好的依赖性解析器。在复杂的软件开发中，需要更好的依赖性解析器来确保开发人员实现其目标。</p>
<p><font color="red">Webpack、Browserify或Parcel</font></p>
<p>Bundler（如Webpack、Browserify或Parcel）是一个与NPM协同工作的工具，用于管理前端Web应用程序的依赖项。主要任务是将所有依赖项打包成要通过Web加载的文件，而不是本地文件系统。然而，Bundler的功能不止于此，还包括通过各种技术来尽可能减少页面加载时间。减少代码大小是减少页面加载时间的简单方法。不幸的是，NPM容易重复包，从而导致代码大小增加[1]。现代打包器采用了各种技术，从代码压缩到统一相同内容的单个文件。然而，这些技术并不总是可靠的，并且已知会破坏广泛使用的前端框架[2]，[3]。</p>
<p><font color="red">管理状态依赖项</font></p>
<p>NPM选择同一依赖项的多个版本的能力在使用某些有状态框架时也是无助的。例如，React是一种常用的Web框架，它依赖于内部全局状态来安排视图更新。如果程序依赖于两个传递依赖于React的不同版本的软件包，则很可能会遇到运行时错误或静默失败。避免这个问题的唯一方法是，如果所有软件包作者都小心地将其对React的依赖标记为peer dependency：即由项目中的其他软件包安装的依赖项。然而，无法确定所有第三方依赖项是否正确使用peer  dependencies。还很难确定一个软件包是否永远不会被用作依赖项，因此不应使用peer dependencies。<font color="cornflowerblue">What?</font></p>
<p>我们的关键见解是，所有这些问题都可以被定义为一个更普遍的问题的实例：最优依赖解决，其中优化目标和约束的选择决定了哪些目标的优先级。由于NPM生态系统中存在广泛的目标，本文认为NPM应该允许开发人员定制和结合多个目标。例如，开发人员应该能够指定策略，如“依赖关系不能存在任何重要漏洞”，“不应重复使用任何软件包”，并将这些与“选择满足所有约束条件的最新软件包版本”的基本目标相结合。为了使这种定制和结合的目标成为可能并评估其有效性，我们提出了MAXNPM：一个完整的、可以直接替代NPM的工具，它使开发人员能够结合多个目标。</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods:"></a>Methods:</h3><ul>
<li>a. Study’s theoretical basis<ul>
<li>PACSOLVE 通过一个高级DSL来规定包版本、版本约束、优化目标等的语法和语义，并使用一个基于求解器的语言来生成Max-SMT 求解器的问题。   (DSL是指领域特定语言（Domain-Specific  Language），也称为专用领域语言。DSL是一种针对特定领域的编程语言，用于解决该领域中的特定问题。与通用编程语言不同，DSL的语法、语义和功能都是为了满足特定领域的需求而设计的。DSL的目标是使编写和阅读代码更加容易，减少出错的可能性。)</li>
</ul>
</li>
<li>b. Article’s technical route (step by step)<ul>
<li>PACSOLVE和MAXNPM为依赖解决提供了一个统一的框架和实现，可让开发者自定义约束和优化目标。MAXNPM允许开发者在安装依赖关系时组合多个目标，例如更喜欢新的依赖项，减少代码大小并最小化安全漏洞数量或其严重程度。</li>
</ul>
</li>
</ul>
<p><font color="green">A. Describing a Dependency Solver with  PACSOLVE</font></p>
<p>PACSOLVE是一种基于约束优化的依赖关系解决器，旨在解决软件依赖项管理领域中的复杂问题。它是一个用Python编写的开源项目，可以自定义和组合多个优化目标和约束条件来优化软件依赖项的选择。</p>
<p>PACSOLVE的目标是提供一种灵活、可扩展的依赖项解决方案，可以满足各种不同类型的开发项目。它支持多种优化目标，如最小化软件包数量、最大化软件包的版本稳定性、最小化安全漏洞数量等。此外，PACSOLVE还支持自定义约束条件，如依赖项版本的范围限制、禁止特定依赖项的使用等。</p>
<p>PACSOLVE的优势在于它使用的是约束优化算法，可以在满足所有约束条件的前提下找到最优解。它还可以解决由于重复软件包、版本冲突和安全漏洞等问题而引起的依赖项选择困难的问题。同时，PACSOLVE还支持与其他依赖项管理工具和构建系统集成，可以方便地应用于各种不同类型的软件项目。</p>
<p><font color="green">B. The Semantics of PACSOLVE</font></p>
<p><font color="green">C. Synthesizing Solution Graphs with PACSOLVE</font></p>
<p>Max-SMT求解器高效实现PACSOLVE</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation:"></a>Evaluation:</h3><p>数据集：Top 1000没有漏洞的npm软件包  和  715个CVSS得分高的包的Vuln715数据集</p>
<p><strong>RQ1</strong>: Can MAXNPM find better solutions than NPM when given different optimization objectives?</p>
<p>a.更多减少漏洞  比较npm和PACSOLVE的CVSS得分</p>
<p>b.找到更新的npm包：</p>
<p>c.减少代码膨胀，利用重复的package</p>
<p><strong>RQ2</strong>: Do MAXNPM solutions pass existing test suites?  </p>
<p>NPM通过， MAXNPM大多数能通过</p>
<p><strong>RQ3</strong>: Does MAXNPM successfully solve packages that NPM solves?</p>
<p>成功构建了972&#x2F;1000个包，有可比性？和npm对比多构建了多少个包？</p>
<p><strong>RQ4</strong>*: Does using MAXNPM <em>substantially increase solving</em> time</p>
<p>多增加了2-4s的额外时间</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ul>
<li>a. Work significance<ul>
<li>PACSOLVE和MAXNPM提供了一种解决NPM依赖解决器限制的有效方法，使开发人员能够实现其目标，同时确保最优性并支持可自定义的约束和目标。</li>
</ul>
</li>
<li>b. Innovation, performance, and workload<ul>
<li>PACSOLVE的创新性在于使用了一个高级DSL来规定语法和语义，并利用一个基于求解器的语言生成问题，以便使用Max-SMT解决器求解问题，确保最优性和可扩展性。MAXNPM在多个目标优化中常常优于NPM和特定工具，在减少依赖漏洞、选择更新依赖和减少依赖项数量方面显著。</li>
</ul>
</li>
<li>c. Research conclusions (list points)<ul>
<li>PACSOLVE和MAXNPM为依赖解决提供了一个统一的框架和实现；</li>
<li>通过使用PACSOLVE和MAXNPM，开发人员可以根据其自定义的约束和目标进行多目标优化的依赖解决；</li>
<li>实验表明，MAXNPM在多个目标优化中常常优于NPM和特定工具，在减少依赖漏洞、选择更新依赖和减少依赖项数量方面显著。</li>
</ul>
</li>
</ul>
<h3 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h3><p>1、相关工作做的不够充分</p>
<p> ICSE 2022 - Demystifying the Vulnerability Propagation and Its Evolutionvia Dependency Trees in the NPM Ecosystem</p>
<p>TSE 2023 - Plumber_Boosting_the_Propagation_of_Vulnerability_Fixes_in_the_npm_Ecosystem 都没有提及</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>17-Python类机制深度解析-回顾Python中的对象模型</title>
    <url>/2023/04/10/17-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E5%9B%9E%E9%A1%BEPython%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="17-Python类机制深度解析-回顾Python中的对象模型"><a href="#17-Python类机制深度解析-回顾Python中的对象模型" class="headerlink" title="17-Python类机制深度解析-回顾Python中的对象模型"></a>17-Python类机制深度解析-回顾Python中的对象模型</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这一次我们就来看看Python中类是怎么实现的，我们知道C不是一个面向对 象语言，而Python却是一个面向对象的语言，那么在Python的底层，是如何使用C来支持Python实现面向对象的功能呢？带着这些疑问，我们下面开始剖析python中类的实现机制。另外，在Python2中存在着经典类(classic class)和新式类(new style  class)，但是到Python3中，经典类已经消失了。并且python2官方都不维护了，因此我们这一章只会介绍新式类。</strong></p>
<p><strong>另外关于类，我们在最开始介绍对象关系模型的时候其实说了不少，这里会再简单温习一遍。</strong></p>
<h3 id="Python中的对象模型"><a href="#Python中的对象模型" class="headerlink" title="Python中的对象模型"></a>Python中的对象模型</h3><p><strong>我们在最开始介绍对象的时候就说了，在面向对象的理论中，有两个核心的概念：类和实例。类可以看成是一个模板，那么实例就是根据这个模板创建出来的对象。可以想象成docker的镜像和容器。但是在Python中，一切都是对象，所以类和实例都是对象，类叫做类对象，实例叫做实例对象。如果想用大白话来描述清楚的话，这无疑是一场灾难，我们还是需要使用一些专业术语来描述：</strong></p>
<p><strong>首先我们这里把python中的对象分为三种：</strong></p>
<ul>
<li><code>内建对象: Python中的内建对象、或者叫内置对象, 比如int、str、list、type、object等等;</code></li>
<li><code>class对象: 程序员通过Python中的class关键字定义的类。当然后面我们也会把内建对象和class对象统称为类对象;</code></li>
<li><code>实例对象：由类对象(内建对象或者class对象)创建的实例;</code></li>
</ul>
<p><strong>而对象之间存在着以下两种关系：</strong></p>
<ul>
<li><code>is-kind-of: 对应面向对象理论中父类和子类之间的关系;</code></li>
<li><code>is-instance-of: 对应面向对象理论中类和实例之间的关系;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(girl.say())  <span class="comment"># まつりさんじょう</span></span><br></pre></td></tr></table></figure>

<p><strong>这段代码中便包含了上面的三种对象：object(内建对象)，Girl(class对象)，girl(实例对象)。显然Girl和object之间是<code>is-kind-of</code>关系，即object是Girl的父类。另外值得一提的是，在python3中所有定义的类都是默认继承自object，即便我们这里不显式继承object，也会默认继承的，为了说明，我们就写上了。除了object是Girl的父类，我们还能看出girl和Girl存在<code>is-instance-of</code>关系，即girl是Girl的实例。当然如果再进一步的话，girl和object之间也存在<code>is-instance-of</code>关系，girl也是object的实例。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(girl.say())  <span class="comment"># まつりさんじょう</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Girl, <span class="built_in">object</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(girl))  <span class="comment"># &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(girl, Girl))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(girl, <span class="built_in">object</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>girl是Girl这个类实例化得到的，所以type(girl)得到的是类对象Girl，但girl也是object的实例对象，因为Girl继承了object，至于这其中的原理，我们会慢慢介绍到。</strong></p>
<p><strong>Python中的类型检测</strong></p>
<p><strong>Python提供了一些方法可以探测这些关系，除了我们上面的type之外，还可以使用对象的__class__属性探测一个对象和其它的哪些对象之间存在<code>is-instance-of</code>关系，而通过对象的__bases__属性则可以探测一个对象和其它的哪些对象之间存在着<code>is-kind-of</code>关系。此外python还提供了两个方法issubclass和isinstance来验证两个对象之间是否存在着我们期望的关系。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(girl.say())  <span class="comment"># まつりさんじょう</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(girl.__class__)  <span class="comment"># &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__class__)  <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 另外__class__是查看自己的类型是什么,也就是生成自己的类。</span></span><br><span class="line"><span class="comment"># 而在介绍Python对象的时候,我们就看到了,任何一个对象都至少具备两个东西: 一个是引用计数、一个是类型</span></span><br><span class="line"><span class="comment"># 所以__class__在Python中，是所有的对象都具备的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __base__只显示继承的第一个类</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__base__)  <span class="comment"># &lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="comment"># __bases__会显示继承的所有类</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__bases__)  <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/17-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E5%9B%9E%E9%A1%BEPython%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1229382-20200829221420657-1965272346.png" alt="img"></p>
<p><strong>关于type和object的关系，我们在最开始介绍Python中的对象模型的时候已经说过了。我们type底层的结构是PyType_Type、object底层的结构体是PyBaseObject_Type，在创建object的时候，将内部的ob_type设置成了PyType_Type；在创建type的时候，将内部的tp_base设置成为了PyBaseObject_Type。因此这两者的定义是彼此依赖的，两者是同时出现的，我们后面还会看到。</strong></p>
<p><strong>紧接着我们考察一下类Girl的行为，我们看到它支持属性设置：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Girl, <span class="string">&quot;name&quot;</span>))  <span class="comment"># False</span></span><br><span class="line">Girl.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Girl, <span class="string">&quot;name&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(Girl.name)  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>一个类都已经定义完了，我们后续还可以进行属性的添加，这在其它的静态语言中是不可能做到的。那么Python是如何做到的呢？我们说能够对于属性进行动态添加，你会想到什么？是不是字典呢？正如global名字空间一样，我们猜测类应该也有自己的属性字典，往类里面设置一些属性的时候，等价于向字典中添加一个键值对，同理其它操作也是如此。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到确实如此, 每一个类都有自己的属性字典</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__dict__)  <span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;say&#x27;: &lt;function Girl.say at 0x0000015CE71E1160&gt;, ...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.__dict__.get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;不存在&quot;</span>))  <span class="comment"># 不存在</span></span><br><span class="line">Girl.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__dict__.get(<span class="string">&quot;name&quot;</span>))  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到和操作全局变量是类似的, 但是有一点需要注意: 我们不能直接通过类的属性字典来设置属性</span></span><br><span class="line"><span class="comment"># Girl.name = &quot;夏色祭&quot; 是可以的, 但是 Girl.__dict__[&quot;name&quot;] = &quot;夏色祭&quot; 则不可以, 虽然这两者是等价的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    Girl.__dict__[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是通过字典访问是可以的</span></span><br></pre></td></tr></table></figure>

<p><strong>除了设置属性之外，我们还可以设置函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Girl.info = <span class="keyword">lambda</span> name, age: <span class="string">f&quot;我叫<span class="subst">&#123;name!r&#125;</span>, 今年<span class="subst">&#123;age&#125;</span>岁&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Girl.info(<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>))  <span class="comment"># 我叫&#x27;神乐mea&#x27;, 今年38岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是此时实例对象调用的话, 会和我们想象的不太一样</span></span><br><span class="line"><span class="comment"># 因为实例调用的话会将函数包装成方法(后面会重点说, 以及为什么实例调用的时候会自动将自身作为self传进去)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(Girl().info(<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &lt;lambda&gt;() takes 2 positional arguments but 3 were given</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到实例在调用的时候会将自身也作为参数传进去, 所以第一个参数name实际上接收的是Girl的实例对象</span></span><br><span class="line"><span class="comment"># 只不过第一个参数按照规范来讲应该叫做self, 但即便你起别的名字也是无所谓的</span></span><br><span class="line"><span class="built_in">print</span>(Girl().info(<span class="number">38</span>))  <span class="comment"># 我叫&lt;__main__.Girl object at 0x00000164B90782B0&gt;, 今年38岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们应该这么做, 将其包装成一个静态方法, 这样类和实例都可以调用了</span></span><br><span class="line">Girl.info = <span class="built_in">staticmethod</span>(<span class="keyword">lambda</span> name, age: <span class="string">f&quot;我叫<span class="subst">&#123;name!r&#125;</span>, 今年<span class="subst">&#123;age&#125;</span>岁&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Girl.info(<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>))  <span class="comment"># 我叫&#x27;神乐mea&#x27;, 今年38岁</span></span><br><span class="line"><span class="built_in">print</span>(Girl().info(<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>))  <span class="comment"># 我叫&#x27;神乐mea&#x27;, 今年38岁</span></span><br></pre></td></tr></table></figure>

<p><strong>此外我们还可以通过type来动态地往类里面进行属性的增加、修改和删除。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;まつりさんじょう&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Girl, <span class="string">&quot;say&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 等价于delattr(Girl, &quot;say&quot;)</span></span><br><span class="line"><span class="built_in">type</span>.__delattr__(Girl, <span class="string">&quot;say&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Girl, <span class="string">&quot;say&quot;</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到Girl这个类里面已经没有&quot;say&quot;这个属性或者函数了</span></span><br><span class="line"><span class="comment"># 事实上调用getattr、setattr、delattr等价于调用其类型对象的__getattr__、__setattr__、__delattr__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们设置一个属性吧, 等价于Girl.name = &quot;神乐mea&quot;</span></span><br><span class="line"><span class="built_in">setattr</span>(Girl, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;神乐mea&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Girl.name)  <span class="comment"># 神乐mea</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们说过，一个对象有哪些行为，取决于其类型对象中定义了哪些操作。此外我们通过对象的类型对象，可以动态地给该对象进行属性的设置。所以Python中所有的类型对象的类型对象都是type，通过type我们便可以控制类的生成过程，即便类已经创建完毕了，也依旧可以进行属性设置。但是注意：这些仅仅针对于我们自己自定义的类，内置的类是不行的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;int&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__add__ = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;int&#x27;    </span></span><br></pre></td></tr></table></figure>

<p><strong>因为内建对象在解释器启动之后，就已经初始化好了。所以内建的类和使用class定义的类本质上是一样的，都是PyTypeObject对象，它们的类型都是type，但区别就是内建的类在底层是静态初始化的，我们不能进行属性的动态设置。</strong></p>
<blockquote>
<p><strong>这里多提一句，我们看到报错信息提示：不可以设置内建类和扩展类的属性，这里的扩展类就是我们使用Python&#x2F;C API编写的扩展模块中的类，它和内建类是等价的。</strong></p>
<p><strong>但是为什么不可以对内建类和扩展类进行属性的设置呢？首先我们要知道Python的动态特性是解释器(虚拟机)赐予的，而虚拟机的工作就是将Python的PyCodeObject对象解释成C的代码进行执行，所以Python的动态特性就是在这一步发生的。而内建的类(int、str、list等等)在解释器启动之后就已经静态初始化好了，直接指向C一级的数据结构，同理扩展类也是如此。它们相当于绕过了解释执行这一步，所以它们的属性是没有办法动态添加的。</strong></p>
</blockquote>
<p><strong>不光内建的类，其实例对象也是如此。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(a, <span class="string">&quot;__dict__&quot;</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到它连自己的属性字典都没有，因为整数在底层对应的是PyLongObject对象，像这些实例对象都有哪些属性，解释器记得清清楚楚。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们介绍了Python中的对象模型，比较简单，主要之前也说过了，相当于再温习一遍。</strong></p>
<p><strong>关于类，要说的内容还是非常非常多的，我们分几个部分来说吧，下一篇介绍类的继承和属性查找。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>18-Python类机制深度解析-类的多继承与属性查找</title>
    <url>/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="18-Python类机制深度解析-类的多继承与属性查找"><a href="#18-Python类机制深度解析-类的多继承与属性查找" class="headerlink" title="18-Python类机制深度解析-类的多继承与属性查找"></a>18-Python类机制深度解析-类的多继承与属性查找</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这次我们来看一下Python中类的继承与属性查找机制，我们说Python是支持类的多继承的，在查找属性的时候会沿着继承链不断找下去。那么下面我们就来深入地考察一下类的继承与属性查找在底层是如何实现的。</strong></p>
<h3 id="深入class"><a href="#深入class" class="headerlink" title="深入class"></a>深入class</h3><p><strong>我们知道Python里面有很多以双下划线开头、双下划线结尾的方法，我们称之为魔法方法。Python中的每一个操作符，都被抽象成了一个魔法方法。比如整数3，整数可以相减，这就代表int这个类里面肯定定义了__sub__函数。字符串不能相减，代表str这个类里面没有__sub__函数；而整数和字符串都可以执行加法操作，显然int、str内部都定义了__add__函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.__sub__(self, other) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = MyInt(<span class="number">4</span>)</span><br><span class="line">b = MyInt(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a - b)  <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<p><strong>我们自己实现了一个类，继承自int。当我执行a -  b的时候，肯定执行对应的__sub__方法，然后调用int的__sub__方法，得到结果之后再乘上3，逻辑上没有问题。但是问题来了，首先调用int.__sub__的时候，我们知道Python肯定是调用long_as_number中的long_sub指向的函数，这些在之前已经说过了，但我想问的是<code>int.__sub__(self, other)</code>里面的参数类型显然都应该是int，但是我们传递的是MyInt，那么Python虚拟机是怎么做的呢？</strong></p>
<p><strong>目前带着这些疑问，先来看一张草图，我们后面会一点一点揭开：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184211047-206605120.png" alt="img"></p>
<p><strong>图中的”<strong>sub</strong>“对应的value并不是一个直接指向long_sub函数的指针，而是一个别的什么东西，对其进行调用，调用的结果指向long_sub函数。至于这个东西是什么，以及具体细节，我们后面会详细说。</strong></p>
<p><strong>另外我们知道，一个对象能否被调用，取决于它的类型对象中是否定义了__call__函数。因此：所谓调用，就是执行类型对象中的tp_call指向的函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是CALL，我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a())  <span class="comment"># 我是CALL，我被尻了</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python底层，实际上是通过一个PyObject_Call函数对实例对象a进行操作。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a()</span><br><span class="line"><span class="comment"># TypeError: &#x27;int&#x27; object is not callable</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一个整数对象是不可调用的，这显然意味着int这个类里面没有__call__函数，换言之PyLongObject结构体对应的ob_type域里面的tp_call为NULL。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 但是我们通过反射打印的时候,发现int是有__call__函数的啊</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(<span class="built_in">int</span>, <span class="string">&quot;__call__&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但其实这个__call__不是int里面的,而是type的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">type</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__call__)  <span class="comment"># &lt;method-wrapper &#x27;__call__&#x27; of type object at 0x00007FFAE22C0D10&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hasattr和类的属性查找一样，如果找不到会自动到对应的类型对象里面去找</span></span><br><span class="line"><span class="comment"># int的类型是type, 而type里面有__call__, 因此即便int里面没有, hasattr(int, &quot;__call__&quot;)依旧是True</span></span><br><span class="line">a1 = <span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">a2 = <span class="built_in">int</span>.__call__(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">a3 = <span class="built_in">type</span>.__call__(<span class="built_in">int</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment"># 以上三者的本质是一样的</span></span><br><span class="line"><span class="built_in">print</span>(a1, a2, a3)  <span class="comment"># 123 123 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前说过, 当一个对象加上括号的时候, 本质上调用其类型对象里面的__call__函数</span></span><br><span class="line"><span class="comment"># a = 3</span></span><br><span class="line"><span class="comment"># 那么a()就相当于调用int里面的__call__函数，但是int里面没有，就直接报错了</span></span><br><span class="line"><span class="comment"># 可能这里就有人问了, 难道不会到type里面找吗？答案是不会的，因为type是元类, 是用来生成类的</span></span><br><span class="line"><span class="comment"># 如果还能到type里面找, 那么调用type的__call__生成的结果到底算什么呢？是类对象？可它又明明是实例对象加上括号调用的。显然这样就乱套了</span></span><br><span class="line"><span class="comment"># 因此实例对象找不到, 会到类对象里面找, 如果类对象再找不到, 就不会再去元类里面找了, 而是会去父类里面找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;__main__.C object at 0x000002282F3D9B80&gt;</span></span><br><span class="line"><span class="string">我被尻了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 此时我们看到, 给C的实例对象加括号的时候, C里面没有__call__函数, 这个时候是不会到元类里面找的</span></span><br><span class="line"><span class="comment"># 还是之前的结论,实例对象找不到属性,会去类对象里面找,然而即便此时类对象里面也没有,也不会到元类type里面找,这时候就看父类了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看对于我们上面的例子，给C的实例对象加括号的时候，会执行C这个类里面的__call__</span></span><br><span class="line"><span class="comment"># 但是它没有，所以找不到。然而它继承的父类里面有__call__</span></span><br><span class="line"><span class="comment"># 因此会执行继承的父类的__call__方法, 并且里面的self还是C的实例对象</span></span><br></pre></td></tr></table></figure>

<p><strong>因此一个对象的属性查找，我们可以得到如下规律：首先从对象本身进行查找，没有的话会从该对象的类型对象中进行查找，还没有的话就从类型对象所继承的父类中进行查找。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c())</span><br></pre></td></tr></table></figure>

<p><strong>还是以这段代码为例：当调用类型对象C的时候，本质上是执行类型对象C的类型对象(type)里面的__call__函数。当调用实例对象c的时候，本质上是执行类型对象C里面的__call__函数，但是C里面没有，这个时候怎么做？显然是沿着继承链进行属性查找，去找C继承的类里面的__call__函数。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184220438-2140987487.png" alt="img"></p>
<p><strong>可能有人好奇，为什么没有object？答案是object内部没有__call__函数，所以object.__call__实际上就是type.__call__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__call__)  <span class="comment"># &lt;method-wrapper &#x27;__call__&#x27; of type object at 0x00007FFD0A896B50&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>因为object的类型是type，所以调用object的时候，实际上执行的是type.<strong>call</strong>(object)。</strong></p>
<p><strong>所以所有的类对象都是可以调用的，因为type是它们的类型对象，而type内部是有__call__函数的。但是默认情况下实例对象是不可调用的，如果实例对象的类型对象、以及该类型对象所继承的类中没有定义__call__函数的话，因为沿着继承链查找的时候，会挨个进行搜索，当搜索到object时发现还没有__call__函数的话，那么就报错了。</strong></p>
<p><strong>所以一个整数对象是不可调用的，但是我们发现这并不是在编译的时候就能够检测出来的错误，而是在运行时才能检测出来、会在运行时通过函数 *PyObject_CallFunctionObjArgs* 确定。所以<code>a = 1;a()</code>明明会报错，但Python还是成功编译了。</strong></p>
<p><strong>为什么会是这样呢？我们知道一个对象对应的类型对象都会有tp_dict这个域，这个域指向一个PyDictObject，表示这个对象支持哪些操作，而这个PyDictObject对象必须要在运行时动态构建。所以都说Python效率慢，一个原因是所有对象都分配在堆上，还有一个原因就是一个对象很多属性或者操作、甚至是该对象是什么类型都需要在运行时动态构建，从而也就造成了Python运行时效率不高。</strong></p>
<p><strong>而且我们发现，像int、str、dict等内建对象可以直接使用。这是因为Python解释器在启动时，会对这些内建对象进行初始化的动作。这个初始化的动作会动态地在这些内建对象对应的PyTypeObject中填充一些重要的东西，其中当然也包括填充tp_dict，从而让这些内建对象具备生成实例对象的能力。这个对内建对象进行初始化的动作就从函数 *PyType_Ready* 拉开序幕。</strong></p>
<p><strong>Python底层通过调用函数 *PyType_Ready* 对内建对象进行初始化，实际上， *PyType_Ready* 不仅仅是处理内建对象，还会处理class对象，并且 *PyType_Ready* 对于内建对象和class对象的作用还不同。比如PyList_Type，它在底层是已经被定义好了的，所以在解释器启动的时候就直接创建，并且是全局对象。只不过我们说它还是不够完善，还需要再打磨一下，而这一步就交给了 *PyType_Ready* 。</strong></p>
<p><strong>但是对于我们自定义的类就不同了，我们说内建的类在底层都是定义好了的，随着解释器启动的时候就已经创建了，已经具备了绝大部分功能，然后再交给 *PyType_Ready* 完善一下，内建的类就形成了；但是对于我们自定义的类来说， *PyType_Ready* 做的工作只是很小的一部分，因为我们使用class定义的类、假设是class  A，Python一开始是并不知道的。Python解释器在启动的时候，不可能直接就创建一个PyA_Type出来，因此对于我们自定义的类来说，需要在解释执行的时候进行申请内存、创建、初始化整个动作序列等等一系列步骤。</strong></p>
<p><strong>下面我们就以Python中的type类型对象入手，因为它比较特殊。Python中的type在底层对应PyType_Type，我们说Python中type是int、str、dict、object、type等内建对象的元类。但是在底层，这些所有的内建类型都是一个PyTypeObject对象。</strong></p>
<ul>
<li><code>int: PyLong_Type</code></li>
<li><code>str: PyUnicode_Type</code></li>
<li><code>tuple: PyTuple_Type</code></li>
<li><code>dict: PyDict_Type</code></li>
<li><code>type: PyType_Type</code></li>
</ul>
<p><strong>从名字也能看出来规律，这些内建对象在Python底层中，都是一个PyTypeObject对象、或者说一个PyTypeObject结构体实例。尽管在Python中说type是所有类对象<code>(所有内建对象+class对象)</code>的元类，但是在Python底层它们都是同一个类型、也就是同一个结构体的不同实例。</strong></p>
<h3 id="处理基类和type信息"><a href="#处理基类和type信息" class="headerlink" title="处理基类和type信息"></a>处理基类和type信息</h3><p><strong>我们来看一下 *PyType_Ready* ，它位于 *Objects &#x2F; typeobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这里的参数显然是类型对象, 以&lt;class &#x27;type&#x27;&gt;为例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//__dict__和__bases__, 因为可以继承多个类, 所以是bases, 当然不用想这些基类也都是PyTypeObject对象</span></span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还是继承的基类，显然这个是object，对应PyBaseObject_Type，因为py3中，所有的类都是默认继承的</span></span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类型对象中tp_base域指定的基类</span></span><br><span class="line">    base = type-&gt;tp_base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span> &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        <span class="comment">//如果基类为空、并且该类本身不是object, 那么将该类的基类设置为object、即PyBaseObject_Type</span></span><br><span class="line">        <span class="comment">//所以我们之前看一些类型对象的底层定义的时候, 发现源码中tp_base域对应的是0, 因为tp_base是在这里进行设置的</span></span><br><span class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果基类不是NULL, 但是基类的属性字典是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span> &amp;&amp; base-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//那么对基类进行初始化, 所以这里是一个是一个递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(base) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该类型对象的ob_type为空NULL但是基类不为NULL, 那么将该类型对象的ob_type设置为基类的ob_type</span></span><br><span class="line">    <span class="comment">//为什么要做这一步, 我们后面会详细说</span></span><br><span class="line">    <span class="comment">//但其实base != NULL是没必要的, 因为只有当类型为PyBaseObject_type时, base才为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(type) == <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span>)</span><br><span class="line">        Py_TYPE(type) = Py_TYPE(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是设置__bases__, 后面说</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>)</span><br><span class="line">            bases = PyTuple_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bases = PyTuple_Pack(<span class="number">1</span>, base);</span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_bases = bases;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造属性字典, 后面说</span></span><br><span class="line">    dict = type-&gt;tp_dict;</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_dict = dict;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于指定了tb_base的类对象，当然就使用指定的基类，而对于没有指定tp_base的类对象，Python将为其指定一个默认的基类： *PyBaseObject_Type*  ，当然这个东西就是Python中的object。现在我们看到PyType_Type的tp_base指向了PyBaseObject_Type，这在Python中体现的就是type继承自object、或者说object是type的父类。但是所有的类底层对应的结构体的ob_type域又都指向了PyType_Type，包括object，因此我们又说type是包括object在内的所有类的类<code>(元类)</code>。</strong></p>
<p><strong>在获得了基类之后，就会判断基类是否被初始化，如果没有，则需要先对基类进行初始化。可以看到， 判断初始化是否完成的条件是<code>base-&gt;tp_dict</code>是否为NULL，这符合之前的描述。对于内建对象的初始化来说，在Python解释器启动的时候，就已经作为全局对象存在了，剩下的就是小小的完善一下，比如对tp_dict进行填充。</strong></p>
<p><strong>然后设置ob_type信息，实际上这个ob_type就是__class__返回的信息。首先 *PyType_Ready* 函数里面接收的是一个PyTypeObject对象，我们知道这个在Python中就是类对象。因此这里是设置这些类对象的ob_type，那么对应的ob_type显然就是元类metaclass，我们自然会想象到Python中的type。但是我们发现<code>Py_TYPE(type) = Py_TYPE(base);</code>这一行代码是把父类的ob_type设置成了当前类的ob_type，那么这一步的意义何在呢？我们使用Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(B))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到B继承了A，而A的类型是MyType，那么B的类型也成了MyType。也就是说A类是由<code>XX</code>生成的，那么B在继承A的时候，B也会由<code>XX</code>生成，所以源码中的那一步就是用来做这件事情的。另外，这里之所以用<code>XX</code>代替，是因为Python中不仅仅type可以是元类，那些继承了type的子类也可以是元类。</strong></p>
<p><strong>而且如果你熟悉flask的话，你会发现flask源码里面就有类似于这样的操作：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attrs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        关于第一个参数我们需要说一下, 对于一般的类来说这里应该是cls</span></span><br><span class="line"><span class="string">        但我们这里是元类, 所以用mcs代替</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 我们额外设置一些属性吧, 关于元类我们后续会介绍</span></span><br><span class="line">        <span class="comment"># 不过个人觉得既然要学习解释器, 那么首先至少应该在Python层面上知道用法</span></span><br><span class="line">        <span class="comment"># 尽管不知道底层实现, 但至少使用方法应该知道</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&quot;G&quot;</span>):</span><br><span class="line">            <span class="comment"># 如果类名以G开头, 那么就设置一些属性吧</span></span><br><span class="line">            attrs.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_metaclass</span>(<span class="params">meta, bases=(<span class="params"><span class="built_in">object</span>, </span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> meta(<span class="string">&quot;&quot;</span>, bases, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(with_metaclass(MyType, (<span class="built_in">int</span>,))):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Girl))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(Girl, <span class="string">&quot;name&quot;</span>))  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>所以个位应该明白下面的代码是做什么的了，Python虚拟机就是将基类的metaclass设置为子类的metaclass。对于当前的PyType_Type来说，其metaclass就是object的metaclass，也是它自己，而在源码的PyBaseObject_Type中可以看到其ob_type是被设置成了PyType_Type的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置type信息</span></span><br><span class="line">   <span class="keyword">if</span> (Py_TYPE(type) == <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span>)</span><br><span class="line">       Py_TYPE(type) = Py_TYPE(base);</span><br></pre></td></tr></table></figure>

<p><strong>既然继承了PyBaseObject_Type，那么便会首先初始化PyBaseObject_Type，我们下面来看看这个PyBaseObject_Type、Python中的object是怎么被初始化的。</strong></p>
<h3 id="处理基类列表"><a href="#处理基类列表" class="headerlink" title="处理基类列表"></a>处理基类列表</h3><p><strong>接下来，Python虚拟机会处理类型的基类列表，因为Python支持多重继承，所以每一个Python的类对象都会有一个基类、或者说父类列表。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取tp_base中指定的基类</span></span><br><span class="line">    base = type-&gt;tp_base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span> &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理bases：基类列表</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    <span class="comment">//如果bases为空</span></span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果base也为空，说明这个类型对象一定是PyBaseObject_Type</span></span><br><span class="line">        <span class="comment">//因为Python中任何类都继承自object，除了object自身</span></span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//那么这时候bases就是个空元组，元素个数为0</span></span><br><span class="line">            bases = PyTuple_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则的话，就申请只有一个空间的元素，然后将PyBaseObject_Type塞进去</span></span><br><span class="line">            bases = PyTuple_Pack(<span class="number">1</span>, base);</span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">//设置bases</span></span><br><span class="line">        type-&gt;tp_bases = bases;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到有两个属性，一个是tp_base，一个是tp_bases，我们看看这俩在Python中的区别。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(C.__base__)  <span class="comment"># &lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(C.__bases__)  <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.__base__)  <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(B.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.A&#x27;&gt;,)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到D同时继承多个类，那么tp_base就是先出现的那个基类，而tp_bases则是继承的所有基类，但是基类的基类是不会出现的，比如object。对于class B也是一样的。然后我们看看class  C，因为C没有显式地继承任何类，那么tp_bases就是NULL，但是Python3中所有的类都默认继承了object，所以tp_base就是PyBaseObject_Type，那么就会把tp_base拷贝到tp_bases里面，因此也就出现了这个结果。</strong></p>
<h3 id="填充tp-dict"><a href="#填充tp-dict" class="headerlink" title="填充tp_dict"></a>填充tp_dict</h3><p><strong>在设置完类型和基类之后，下面Python虚拟机就进入了激动人心的tp_dict的填充阶段，也就是设置属性字典，这是一个极其繁复、极其繁复、极其繁复的过程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......   </span></span><br><span class="line">    <span class="comment">//初始化tp_dict</span></span><br><span class="line">    dict = type-&gt;tp_dict;</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_dict = dict;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将与type相关的操作加入到tp_dict中</span></span><br><span class="line">    <span class="comment">//注意: 这里的type是PyType_Ready的参数中的type, 所以它可以是Python中的&lt;class &#x27;type&#x27;&gt;、也可以是&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (add_operators(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_methods != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_methods(type, type-&gt;tp_methods) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_members != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_members(type, type-&gt;tp_members) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_getset != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_getset(type, type-&gt;tp_getset) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在这个阶段，完成了将<code>(&quot;__sub__&quot;, &amp;long_sub)</code>加入tp_dict的过程，里面的 *add_operators* 、 *add_methods* 、 *add_members* 、 *add_getset* 都是完成填充tp_dict的动作。那么这时候一个问题就出现了，Python是如何知道__add__和long_add之间存在关联的呢？其实这种关联显然是一开始就已经定好了的，而且存放在一个名为 *slotdefs* 的数组中。</strong></p>
<h4 id="slot与操作排序"><a href="#slot与操作排序" class="headerlink" title="slot与操作排序"></a>slot与操作排序</h4><p><strong>在进入填充tp_dict的复杂操作之前，我们先来看一下Python中的一个概念：slot。在Python内部，slot可以视为表示PyTypeObject中定义的操作，一个操作对应一个slot，但是slot又不仅仅包含一个函数指针，它还包含一些其它信息，我们看看它的结构。在Python内部，slot是通过slotdef这个结构体来实现的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> <span class="title">slotdef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//descrobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">void</span> *function;</span><br><span class="line">    wrapperfunc wrapper;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *doc;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    PyObject *name_strobj;</span><br><span class="line">&#125;;  <span class="comment">//从定义上看, 我们发现slot不是一个PyObject</span></span><br></pre></td></tr></table></figure>

<p><strong>在一个slot中，就存储着PyTypeObject中一种操作对应的各种信息，比如：int实例对象<code>(PyLongObject)</code>支持哪些行为，就看类型对象int<code>(PyLong_Type)</code>定义了哪些操作，而PyTypeObject对象中的一个操作就会有一个slot与之对应。slot里面的name就是操作对应的名称，比如字符串__sub__，offset则是操作的函数地址在PyHeapTypeObject中的偏移量，而function则指向一种名为slot function的函数。</strong></p>
<p><strong>Python中提供了多个宏来定义一个slot，其中最基本是TPSLOT和ETSLOT。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    &#123;NAME, offsetof(PyTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \</span></span><br><span class="line"><span class="meta">     PyDoc_STR(DOC)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    &#123;NAME, offsetof(PyHeapTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \</span></span><br><span class="line"><span class="meta">     PyDoc_STR(DOC)&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现 *PyHeapTypeObject* 的第一个域就是 *PyTypeObject* ，因此可以发现TPSLOT计算出的也是 *PyHeapTypeObject* 的偏移量。</strong></p>
<p><strong>对于一个 *PyTypeObject* 来说，有的操作，比如long_add，其函数指针是在 *PyNumberMethods* 里面存放的，而 *PyTypeObject* 中却是通过一个tp_as_number指针指向另一个 *PyNumberMethods* 结构，因此这种情况是没办法计算出long_add在 *PyTypeObject* 中的偏移量的，只能计算出在 *PyHeapTypeObject* 中的偏移量，这种时候TPSLOT就失效了。</strong></p>
<p><strong>因此与long_add对应的slot必须是通过ETSLOT来定义的，但是我们说 *PyHeapTypeObject* 里面的offset表示的是基于 *PyHeapTypeObject* 得到的偏移量，而PyLong_Type却是一个 *PyTypeObject* 对象，那么通过这个偏移量显然无法得到PyLong_Type中为int准备的long_add，那~~~这个offset有什么用呢？</strong></p>
<p><strong>答案非常诡异，这个offset是用来对操作进行排序的。排序？我整个人都不好了，不过在理解为什么需要对操作进行排序之前，需要先看看Python底层预先定义的slot集合–slotdefs。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    ETSLOT(NAME, as_sequence.SLOT, FUNCTION, WRAPPER, DOC)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> slotdef slotdefs[] = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不同操作名(__add__、__radd__)对象, 对应相同操作nb_add</span></span><br><span class="line">    <span class="comment">//这个nb_add在PyLong_Type就是long_add,表示 +</span></span><br><span class="line">    BINSLOT(<span class="string">&quot;__add__&quot;</span>, nb_add, slot_nb_add,</span><br><span class="line">           <span class="string">&quot;+&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__radd__&quot;</span>, nb_add, slot_nb_add,</span><br><span class="line">           <span class="string">&quot;+&quot;</span>),</span><br><span class="line">    BINSLOT(<span class="string">&quot;__sub__&quot;</span>, nb_subtract, slot_nb_subtract,</span><br><span class="line">           <span class="string">&quot;-&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__rsub__&quot;</span>, nb_subtract, slot_nb_subtract,</span><br><span class="line">           <span class="string">&quot;-&quot;</span>),</span><br><span class="line">    BINSLOT(<span class="string">&quot;__mul__&quot;</span>, nb_multiply, slot_nb_multiply,</span><br><span class="line">           <span class="string">&quot;*&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__rmul__&quot;</span>, nb_multiply, slot_nb_multiply,</span><br><span class="line">           <span class="string">&quot;*&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相同操作名(__getitem__)对应不同操作(mp_subscript、mp_ass_subscript)</span></span><br><span class="line">    MPSLOT(<span class="string">&quot;__getitem__&quot;</span>, mp_subscript, slot_mp_subscript,</span><br><span class="line">           wrap_binaryfunc,</span><br><span class="line">           <span class="string">&quot;__getitem__($self, key, /)\n--\n\nReturn self[key].&quot;</span>),</span><br><span class="line">    SQSLOT(<span class="string">&quot;__getitem__&quot;</span>, sq_item, slot_sq_item, wrap_sq_item,</span><br><span class="line">           <span class="string">&quot;__getitem__($self, key, /)\n--\n\nReturn self[key].&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>其中BINSLOT，SQSLOT等这些宏实际上都是对ETSLOT的一个简单包装，并且在slotdefs中可以发现，操作名<code>(比如__add__)</code>和操作并不是一一对应的，存在多个操作对应同一个操作名、或者多个操作名对应同一个操作的情况，那么在填充tp_dict时，就会出现问题，比如对于__getitem__，在tp_dict中与其对应的是mp_subscript还是sq_item呢？</strong></p>
<p><strong>为了解决这个问题，就需要利用slot中的offset信息对slot(也就是操作)进行排序。回顾一下前面列出的 *PyHeapTypeObject* 的代码，它与一般的struct定义不同，其中定义中各个域的顺序是非常关键的，在顺序中隐含着操作优先级的问题。比如在 *PyHeapTypeObject* 中，*PyMappingMethods* 的位置在 *PySequenceMethods* 之前，mp_subscript是 *PyMappingMethods* 中的一个域：PyObject *，而sq_item又是 *PySequenceMethods* 中的的一个域：PyObject *，那么最终计算出的偏移量就存在如下关系：<code>offset(mp_subscript) &lt; offset(sq_item)</code>。因此如果在一个PyTypeObject中，既定义了mp_subscript，又定义了sq_item，那么Python虚拟机将选择mp_subscript与__getitem__发生关系。</strong></p>
<p><strong>而对slotdefs的排序在init_slotdefs中完成：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> slotdefs_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_slotdefs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    slotdef *p;</span><br><span class="line">    <span class="comment">//init_slotdefs只会进行一次</span></span><br><span class="line">    <span class="keyword">if</span> (slotdefs_initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; p++) &#123;</span><br><span class="line">        <span class="comment">/* Slots must be ordered by their offset in the PyHeapTypeObject. */</span></span><br><span class="line">        <span class="comment">//注释也表名：slots一定要通过它们在PyHeapTypeObject中的offset进行排序</span></span><br><span class="line">        <span class="comment">//而且是从小到大排</span></span><br><span class="line">        assert(!p[<span class="number">1</span>].name || p-&gt;offset &lt;= p[<span class="number">1</span>].offset);</span><br><span class="line">        p-&gt;name_strobj = PyUnicode_InternFromString(p-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;name_strobj || !PyUnicode_CHECK_INTERNED(p-&gt;name_strobj))</span><br><span class="line">            Py_FatalError(<span class="string">&quot;Out of memory interning slotdef names&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排完序之后将值赋为1, 这样的话下次执行的时候, 执行到上面的if时,由于条件为真就直接return了</span></span><br><span class="line">    slotdefs_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从slot到descriptor"><a href="#从slot到descriptor" class="headerlink" title="从slot到descriptor"></a>从slot到descriptor</h4><p><strong>在slot中，包含了很多关于一个操作的信息，但是很可惜，在tp_dict中，与”<strong>getitem</strong>“关联在一起的，一定不会是slot，因为它不是一个PyObject，无法将其指针放在dict对象中。当然如果再深入思考一下，会发现slot也无法被调用。因为slot不是一个PyObject，那么它就没有ob_type这个域，也就无从谈起什么tp_call了，所以slot是无论如也无法满足Python中的可调用这一条件的。前面我们说过，Python虚拟机在tp_dict找到__getitem__对应的操作后，会调用该操作，所以tp_dict中与__getitem__对应的只能是包装了slot的PyObject。在Python中，我们称之为descriptor。</strong></p>
<p><strong>在Python内部，存在多种descriptor，与descriptor相对应的是 *PyWrapperDescrObject* 。在后面的描述中也会直接使用descriptor代表 *PyWrapperDescrObject* 。一个descriptor包含一个slot，其创建是通过 *PyDescr_NewWrapper* 完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//descrobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDescr_COMMON PyDescrObject d_common</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyTypeObject *d_type;</span><br><span class="line">    PyObject *d_name;</span><br><span class="line">    PyObject *d_qualname;</span><br><span class="line">&#125; PyDescrObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyDescr_COMMON;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> *<span class="title">d_base</span>;</span></span><br><span class="line">    <span class="type">void</span> *d_wrapped; <span class="comment">/* This can be any function pointer */</span></span><br><span class="line">&#125; PyWrapperDescrObject;</span><br><span class="line"><span class="comment">//descrobject.c</span></span><br><span class="line"><span class="type">static</span> PyDescrObject *</span><br><span class="line"><span class="title function_">descr_new</span><span class="params">(PyTypeObject *descrtype, PyTypeObject *type, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDescrObject *descr;</span><br><span class="line"></span><br><span class="line">    descr = (PyDescrObject *)PyType_GenericAlloc(descrtype, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_XINCREF(type);</span><br><span class="line">        descr-&gt;d_type = type;</span><br><span class="line">        descr-&gt;d_name = PyUnicode_InternFromString(name);</span><br><span class="line">        <span class="keyword">if</span> (descr-&gt;d_name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(descr);</span><br><span class="line">            descr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            descr-&gt;d_qualname = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDescr_NewWrapper</span><span class="params">(PyTypeObject *type, <span class="keyword">struct</span> wrapperbase *base, <span class="type">void</span> *wrapped)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyWrapperDescrObject *descr;</span><br><span class="line"></span><br><span class="line">    descr = (PyWrapperDescrObject *)descr_new(&amp;PyWrapperDescr_Type,</span><br><span class="line">                                             type, base-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        descr-&gt;d_base = base;</span><br><span class="line">        descr-&gt;d_wrapped = wrapped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)descr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python内部的各种descriptor都将包含 *PyDescr_COMMON* ，其中的d_type被设置为PyDescr_NewWrapper的参数type，而d_wrapped则存放着最重要的信息：操作对应的函数指针，比如对于PyList_Type来说，其<code>tp_dict[&quot;__getitem__&quot;].d_wrapped</code>就是&amp;mp_subscript。而slot则被存放在了d_base中。</strong></p>
<p><strong>当然， *PyWrapperDescrObject* 里面的type是 *PyWrapperDescr_Type* ，其中的tp_call是 *wrapperdescr_call* ，当Python虚拟机调用一个descriptor时，也就会调用 *wrapperdescr_call* 。对于descriptor的调用过程，我们将在后面详细介绍。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__sub__)  <span class="comment"># &lt;slot wrapper &#x27;__sub__&#x27; of &#x27;int&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__getitem__)  <span class="comment"># &lt;slot wrapper &#x27;__getitem__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到它们都是一个slot wrapper，也就是对slot包装之后的descriptor(描述符)。</strong></p>
<h4 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h4><p><strong>排序后的结果仍然存放在slotdefs中，python虚拟机这下就可以从头到尾遍历slotdefs，基于每一个slot建立一个descriptor，然后在tp_dict中建立从操作名到descriptor的关联，这个过程是在add_operators中完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">add_operators</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict = type-&gt;tp_dict;</span><br><span class="line">    slotdef *p;</span><br><span class="line">    PyObject *descr;</span><br><span class="line">    <span class="type">void</span> **ptr;</span><br><span class="line">    <span class="comment">//对slotdefs进行排序</span></span><br><span class="line">    init_slotdefs();</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; p++) &#123;</span><br><span class="line">        <span class="comment">//如果slot中没有指定wrapper，则无需处理</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;wrapper == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//获得slot对应的操作在PyTypeObject中的函数指针</span></span><br><span class="line">        ptr = slotptr(type, p-&gt;offset);</span><br><span class="line">        <span class="keyword">if</span> (!ptr || !*ptr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果tp_dict中已经存在操作名，则放弃</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_GetItemWithError(dict, p-&gt;name_strobj))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptr == (<span class="type">void</span> *)PyObject_HashNotImplemented) &#123;</span><br><span class="line">            <span class="comment">/* Classes may prevent the inheritance of the tp_hash</span></span><br><span class="line"><span class="comment">               slot by storing PyObject_HashNotImplemented in it. Make it</span></span><br><span class="line"><span class="comment">               visible as a None value for the __hash__ attribute. */</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_SetItem(dict, p-&gt;name_strobj, Py_None) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建descriptor</span></span><br><span class="line">            descr = PyDescr_NewWrapper(type, p, *ptr);</span><br><span class="line">            <span class="keyword">if</span> (descr == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//将(操作名，descriptor)放入tp_dict中</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_SetItem(dict, p-&gt;name_strobj, descr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_DECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_DECREF(descr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_tp_new_wrapper(type) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在add_operators中，首先调用前面剖析过的init_slotdefs对操作进行排序，然后遍历排序完成后的slotdefs结构体数组，对其中的每一个slot(slotdef)，通过slotptr获得该slot对应的操作在PyTypeObject中的函数指针，，并接着创建descriptor，在tp_dict中建立从操作名(slotdef.name_strobj)到操作(descriptor)的关联。</strong></p>
<p><strong>但是需要注意的是，在创建descriptor之前，Python虚拟机会检查在tp_dict中操作名是否存在，如果存在了，则不会再次建立从操作名到操作的关联。不过也正是这种检查机制与排序机制相结合，Python虚拟机在能在拥有相同操作名的多个操作中选择优先级最高的操作。</strong></p>
<p><em><em>在add_operators中，上面的动作都很简单、直观，而最难的动作隐藏在slotptr这个函数当中。它的功能是完成从slot到slot对应操作的真实函数指针的转换。我们知道，在slot中存放着用来操作的offset，但不幸的是，这个offset是相对于 *PyHeapTypeObject* 的偏移，而操作的真实函数指针却是在 *PyTypeObject* 中指定的，而且 *PyTypeObject* 和 *PyHeapTypeObject* 不是同构的，因为 *PyHeapTypeObject* 中包含了 *PyNumberMethods* 结构体，但 *PyTypeObject* 只包含了 *PyNumberMethods *</em> 指针。所以slot中存储的关于操作的offset对 *PyTypeObject* 来说，不能直接用，必须通过转换。</em>*</p>
<blockquote>
<p><strong>举个栗子，假如说调用<code>slotptr(&amp;PyList_Type, offset(PyHeapTypeObject, mp_subscript))</code>，首先判断这个偏移量大于<code>offset(PyHeapTypeObject, as_mapping)</code>，所以会先从PyTypeObject对象中获得as_mapping指针p，然后在p的基础上进行偏移就可以得到实际的函数地址。</strong></p>
<p><strong>所以偏移量delta为：<code>offset(PyHeapTypeObject, mp_subscript) - offset(PyHeapTypeObject, as_mapping)</code>。</strong></p>
</blockquote>
<p><strong>而这个复杂的过程就在slotptr中完成：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> **</span><br><span class="line"><span class="title function_">slotptr</span><span class="params">(PyTypeObject *type, <span class="type">int</span> ioffset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">long</span> offset = ioffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note: this depends on the order of the members of PyHeapTypeObject! */</span></span><br><span class="line">    assert(offset &gt;= <span class="number">0</span>);</span><br><span class="line">    assert((<span class="type">size_t</span>)offset &lt; offsetof(PyHeapTypeObject, as_buffer));</span><br><span class="line">    <span class="comment">//从PyHeapTypeObject中排在后面的PySequenceMethods开始判断,然后向前,依次判断PyMappingMethods和PyNumberMethods呢。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为什么要这么做呢？假设我们首先从PyNumberMethods开始判断</span></span><br><span class="line"><span class="comment">    如果一个操作的offset大于在PyHeapTypeObject中的as_numbers在PyNumberMethods的偏移量，那么我们还是没办法确认这个操作到底是属于谁的。只有从后往前进行判断,才能解决这个问题。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_sequence)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_sequence;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_mapping)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_mapping;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_mapping);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_number)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_number;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_async)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_async;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_async);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">        ptr += offset;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> **)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好了，我想到现在我们应该能够摸清楚Python在改造PyTypeObject对象时对tp_dict做了什么了，我们以PyList_Type举例说明：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184229028-495891242.png" alt="img"></p>
<p><strong>在add_operators完成之后，PyList_Type如图所示。从PyList_Type.tp_as_mapping中延伸出去的部分是在编译时就已经确定好了的，而从tp_dict中延伸出去的部分则是在Python运行时环境初始化的时候才建立的。</strong></p>
<p><strong>另外， *PyType_Ready* 在通过add_operators添加了 *PyTypeObject* 对象中定义的一些operator后，还会通过add_methods、add_numbers和add_getsets添加 *PyTypeObject* 中定义的tp_methods、tp_members和tp_getset函数集。这些过程和add_operators类似，不过最后添加到tp_dict中descriptor就不再是 *PyWrapperDescrObject* ，而分别是 *PyMethodDescrObject* 、*PyMemberDescrObject* 、 *PyGetSetDescrObject* 。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;list&#x27; objects&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__getitem__)  <span class="comment"># &lt;slot wrapper &#x27;__getitem__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.__getitem__)  <span class="comment"># &lt;method &#x27;__getitem__&#x27; of &#x27;list&#x27; objects&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到对于list的__getitem__来说, 就不再是PyWrapperDescrObject(slot wrapper)了</span></span><br><span class="line"><span class="comment"># 而是一个PyMethodDescrObject</span></span><br></pre></td></tr></table></figure>

<p><strong>从目前来看，基本上算是解析完了，但是还有一点：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># xxx</span></span><br></pre></td></tr></table></figure>

<p><strong>显然当我们print(a)的时候，应该调用A.tp_repr函数，对照PyList_Type的布局，应该调用list_repr这个函数，然而事实却并非如此，Python虚拟机调用的是我们在A中重写的__repr__方法。这意味着Python在初始化A的时候，对tp_repr进行了特殊处理。为什么Python虚拟机会知道要对tp_repr进行特殊处理呢？当然肯定有人会说：这是因为我们重写了__repr__方法啊，确实如此，但这是Python层面上的，在底层的话，答案还是在slot身上。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> slotdef slotdefs[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    TPSLOT(<span class="string">&quot;__repr__&quot;</span>, tp_repr, slot_tp_repr, wrap_unaryfunc,</span><br><span class="line">           <span class="string">&quot;__repr__($self, /)\n--\n\nReturn repr(self).&quot;</span>),</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机在初始化A时，会检查A的tp_dict中是否存在__repr__，在后面剖析自定义class对象的创建时会看到，因为在定义class  A的时候，重写了__repr__这个操作。所以在A.tp_dict中，__repr__一开始就会存在，Python虚拟机会检测到，然后会根据__repr__对应的slot顺藤摸瓜，找到tp_repr，并且将这个函数指针替换为slot中指定的&amp;slot_tp_repr。所以当后来虚拟机找A.tp_repr的时候，实际上找的是slot_tp_repr。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">slot_tp_repr</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *res;</span><br><span class="line">    _Py_IDENTIFIER(__repr__);</span><br><span class="line">    <span class="type">int</span> unbound;</span><br><span class="line">    <span class="comment">//查找__repr__属性</span></span><br><span class="line">    func = lookup_maybe_method(self, &amp;PyId___repr__, &amp;unbound);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用__repr__对应的对象</span></span><br><span class="line">        res = call_unbound_noarg(unbound, func, self);</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_Clear();</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromFormat(<span class="string">&quot;&lt;%s object at %p&gt;&quot;</span>,</span><br><span class="line">                               Py_TYPE(self)-&gt;tp_name, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在slot_tp_repr中，会寻找__repr__属性对应的对象，正好就会找到在A中重写的函数，后面会看到，这个对象实际上就一个PyFunctionObject对象。这样一来，就完成了对默认的list的repr行为的替换。所以对于A来说，内存布局就是下面这样。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184238908-954719114.png" alt="img"></p>
<p><strong>当然这仅仅是针对于__repr__，对于其他的操作还是会指向PyList_Type中指定的函数，比如tp_iter还是会指向list_iter。因为我们的类A继承list，所以如果某个函数在A里面没有的话，那么会 从PyList_Type中寻找。</strong></p>
<p><strong>对于A来说，这个变化是在 *fixup_slot_dispatchers* 这个函数中完成的，对于内建对象则不会进行此操作，因为内建对象是被静态初始化的，它不允许属性的动态设置。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">fixup_slot_dispatchers</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    slotdef *p;</span><br><span class="line"></span><br><span class="line">    init_slotdefs();</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; )</span><br><span class="line">        p = update_one_slot(type, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="确定MRO"><a href="#确定MRO" class="headerlink" title="确定MRO"></a>确定MRO</h4><p><strong>MRO，即method resolve  order，说白了就是类继承之后、属性或方法的查找顺序。如果Python是单继承的话，那么这就不是问题了，直接一层一层网上找就可以了。但是Python是支持多继承的，那么在多继承时，继承的顺序就成为了一个必须考虑的问题。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        self.bar()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bar C&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(C, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bar D&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">C</span></span><br><span class="line"><span class="string">bar D</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先我们看到，打印的是C，说明调用的是C的foo函数，这说明把C写在前面，会调用C的方法。但是下面打印了bar  D，这是因为C里面的self，实际上是D的实例对象。D在找不到foo函数的时候，会到父类里面找，但是同时也会将self传递过去，所以调用self.bar的时候，还是会先到D里面找，如果找不到再去父类里面找。</strong></p>
<p><strong>在底层则是先在PyType_Ready中通过mro_internal确定mro的顺序，Python虚拟机将创建一个PyTupleObject对象，里面存放一组类对象，这些类对象的顺序就是虚拟机确定的mro的顺序，最终这个PyTuple对象会被保存在PyTypeObject.tp_mro中。</strong></p>
<p><strong>由于mro_internal内部的实现机制相当复杂，所以我们将会只从python的代码层面来理解。首先我们说python早期有经典类和新式类两种类，现在则只存在新式类。而经典类的类搜索方式采用的是深度优先，而新式类则是广度优先<code>(当然现在用的是新的算法，具体什么算法后面说，暂时理解为广度优先即可)</code>，举个例子：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184248486-285345738.png" alt="img"></p>
<p><strong>图中的箭头表示继承关系，比如：A继承B和C、B继承D、C继承E。</strong></p>
<p><strong>对于上图来说，经典类和新式类的查找方式是一样的：先从A找到I，再从C找到G。对于上图这种继承结构，经典类和新式类是一样的，至于两边是否一样多则不重要。我们实际演示一下，由于经典类只在Python2中存在，所以下面我们演示新式类。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里是python3.8 新式类</span></span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (I,), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H,), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (), &#123;&#125;)</span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (F,), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G,), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D,), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于A继承两个类，这个两个类分别继续继承，如果最终没有继承公共的类<code>(暂时先忽略object)</code>，那么经典类和新式类是一样的。像这种泾渭分明、各自继承各自的，都是先一条路找到黑，然后再去另外一条路去找。</strong></p>
<p><strong>但如果是下面这种，最终分久必合、两者最终又继承了同一个类，那么经典类还是跟以前一样，按照每一条路都走到黑的方式。但是对于新式类，则是先从A找到H，而I这个两边最终继承的类不找了，然后从C找到I，也就是在另一条路找到头。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184256704-1205529691.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新式类</span></span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (I,), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H,), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (I,), &#123;&#125;)   <span class="comment"># 这里让G继承I</span></span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (F,), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G,), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D,), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此对于最下面的类继承两个类，然后继承的两个类再次继承的时候，向上只继承一个类，对于这种模式，那么结论、也就是mro顺序就是我们上面分析的那样。不过对新式类来说，因为所有类默认都是继承object，所以第一张图中，即使我们没画完，但是也能想到，两条泾渭分明的继承链的上方最终应该都指向object。那么我们依旧可以用刚才的理论来解释，在第一条继承链中找到object的前一个类不找了，然后在第二条继承链中一直找到object。</strong></p>
<p><strong>但是Python的多继承远比我们想象的要复杂，原因就在于可以任意继承，如果B和C再分别继承两个类呢？那么我们这里的线路就又要多出两条了，不过既然要追求刺激，就贯彻到底喽。但是下面我们就只会介绍新式类了，经典类了解一下就可以了。</strong></p>
<p><strong>另外我们之前说新式类采用的是广度优先，但是实际上这样有一个问题：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184305360-627592971.png" alt="img"></p>
<p><strong>假设我们调用A的foo方法，但是A里面没有，那么理所应当会去B里面找，但是B里面也没有，而C和D里面有，那么这个时候是去C里面找还是去D里面找呢？根据我们之前的结论，显然是去D里面找，可如果按照广度优先的逻辑来说，那么应该是去C里面找啊。所以广度优先理论在这里就不适用了，因为B继承了D，而B和C并没有直接关系，我们应该把B和D看成一个整体。因此Python中的广度优先实际上是采用了一种叫做C3的算法。</strong></p>
<p><strong>这个C3算法比较复杂(其实也不算复杂)，只不过我个人总结出一个更加好记的结论，如下：</strong></p>
<blockquote>
<p><strong>当沿着一条继承链寻找类时，默认会沿着该继承链一直找下去，但如果发现某个类出现在了另一条继承链当中，那么当前的继承链的搜索就会结束，然后在”最开始”出现分歧的地方转向下一条继承链的搜索。</strong></p>
</blockquote>
<p><strong>这是我个人总结的，或许光看字面意思的话会比较难理解，但是通过例子就能明白了。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184314745-606414853.png" alt="img"></p>
<p><strong>这个箭头表示继承关系，继承顺序是从左到右，比如这里的A就相当于<code>class A(B, C)</code>，下面我们来从头到尾分析一下。</strong></p>
<ul>
<li><code>1. 首先最开始的顺序是A, 如果我们获取A的mro的话;</code></li>
<li><code>2. 然后A继承B和C, 由于是两条路, 因此我们说A这里就是一个分歧点。但是由于B在前, 所以接下来是B, 所以现在mro的顺序是A B;</code></li>
<li><code>3. 但是B这里也出现了分歧点, 不过不用管, 因为我们说会沿着继承链不断往下搜索, 现在mro的顺序是A B D;</code></li>
<li><code>4. 然后从D开始寻找, 这里注意了, 按理说会找G的, 但是G不止被一个类继承, 也就是意味着沿着当前的继承链查找G时, G还出现在了其它的继承链当中。怎么办？显然要回到最初的分歧点, 转向下一条继承链的搜索;</code></li>
<li><code>5. 最初的分歧点是A, 那么该去找C了, 现在mro的顺序就是A B D C;</code></li>
<li><code>6. 注意C这里出现了分歧点, 而A的两条分支已经结束了, 所以现在C就是最初的分歧点了。而C继承自E和F, 显然要搜索E, 那么此时mro的顺序就是A B D C E;</code></li>
<li><code>7. 然后从E开始搜索, 显然要搜索G, 此时mro顺序是A B D C E G;</code></li>
<li><code>8. 从G要搜索I, 此时mro顺序是A B D C E G I;</code></li>
<li><code>9. 从I开始搜索谁呢？由于J出现在了其它的继承链中, 那么要回到最初分歧的地方, 也就是C, 那么下面显然要找F, 此时mro顺序是A B D C E G I F;</code></li>
<li><code>10. F只继承了H, 那么肯定要找H, 此时mro顺序是 A B D C E G I F H;</code></li>
<li><code>11. H显然只能找J了, 因此最终A的mro顺序就是A B D C E G I F H J object;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">J = <span class="built_in">type</span>(<span class="string">&quot;J&quot;</span>, (<span class="built_in">object</span>, ), &#123;&#125;)</span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (J, ), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (J, ), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (I, ), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H, ), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G, H), &#123;&#125;)</span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (G, ), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E, F), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D, E), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A B D C E G I F H J</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.J&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再看一个复杂的例子感受一下：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184324735-2139321706.png" alt="img"></p>
<p><strong>看起来很花里胡哨的，但其实很简单，就按照之前说的那个结论不断推导下去即可。</strong></p>
<ul>
<li><code>1. 首先是A, A继承B1、B2、B3, 会先走B1, 此时mro是A B1, 注意现在A是分歧点;</code></li>
<li><code>2. 从B1本来该找C1, 但是C1还被其他类继承, 也就是出现在了其它的继承链当中, 因此要回到最初分歧点A, 从下一条继承链开始找, 显然要找B2, 此时mro就是A B1 B2;</code></li>
<li><code>3. 从B2开始, 显然要找C1, 此时mro顺序就是A B1 B2 C1;</code></li>
<li><code>4. 从C1开始, 显然要找D1, 因为D1只被C1继承, 所以它没有出现在另一条继承链当中, 因此此时mro顺序是A B1 B2 C1 D1;</code></li>
<li><code>5. 从D1显然不会找E的, 咋办? 回到最初的分歧点, 注意这里显然还是A, 因为A的分支还没有走完。显然此时要走B3, 那么mro顺序就是A B1 B2 C1 D1 B3;</code></li>
<li><code>6. 从B3开始找, 显然要找C2, 注意: A的分支已经走完, 此时B3就成了新的最初分歧点。现在mro顺序是A B1 B2 C1 D1 B3 C2;</code></li>
<li><code>7. C2会找D2吗? 显然不会, 因为它还被C3继承, 所以它出现在了其他的继承链中。所以要回到最初分歧点, 这里是B3, 显然下面要找C3, 另外由于B3的分支也已经走完, 所以现在C3就成了新的最初分歧点。此时mro顺序是A B1 B2 C1 D1 B3 C2  C3;</code></li>
<li><code>8. 从C3开始, 显然要找D2, 此时mro顺序是A B1 B2 C1 D1 B3 C2 C3 D2;</code></li>
<li><code>9. 但是D2不会找E, 因此回到最初分歧点C3, 下面就找D3, 然后显然只能再找E了, 显然最终mro顺序A B1 B2 C1 D1 B3 C2 C3 D2 D3 E object;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (), &#123;&#125;)</span><br><span class="line">D1 = <span class="built_in">type</span>(<span class="string">&quot;D1&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">D2 = <span class="built_in">type</span>(<span class="string">&quot;D2&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">D3 = <span class="built_in">type</span>(<span class="string">&quot;D3&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">C1 = <span class="built_in">type</span>(<span class="string">&quot;C1&quot;</span>, (D1, D2), &#123;&#125;)</span><br><span class="line">C2 = <span class="built_in">type</span>(<span class="string">&quot;C2&quot;</span>, (D2,), &#123;&#125;)</span><br><span class="line">C3 = <span class="built_in">type</span>(<span class="string">&quot;C3&quot;</span>, (D2, D3), &#123;&#125;)</span><br><span class="line">B1 = <span class="built_in">type</span>(<span class="string">&quot;B1&quot;</span>, (C1,), &#123;&#125;)</span><br><span class="line">B2 = <span class="built_in">type</span>(<span class="string">&quot;B2&quot;</span>, (C1, C2), &#123;&#125;)</span><br><span class="line">B3 = <span class="built_in">type</span>(<span class="string">&quot;B3&quot;</span>, (C2, C3), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B1, B2, B3), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此Python的多继承并没有我们想象的那么复杂，当然底层源码我们就不再看了，这个东西分析起来没什么太大必要，有兴趣可以自己去看一下。个人觉得，关于多继承从目前这个层面上来理解已经足够了。</strong></p>
<p><strong>不过需要注意的是，在执行父类函数时传入的self参数，这一点是很多初学者容易犯的错误。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A: foo&quot;</span>)</span><br><span class="line">        self.bar()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C().foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A: foo</span></span><br><span class="line"><span class="string">C: bar</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先C的实例对象在调用foo的时候，首先会去C里面查找，但是C没有，所以按照mro顺序会去A里面找。而A里面存在，所以调用，但是：调用时传递的self是C的实例对象，因为是C的实例对象调用的。所以里面的self.bar，这个self还是C的实例对象，那么调用bar的时候，会去哪里找呢？显然还是从C里面找，所以 self.bar() 的时候打印的是”C: bar”，而不是”A: bar”。</strong></p>
<p><strong>同理再来看看一个关于super的栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(A, self).foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B: foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    A().foo()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;super&#x27; object has no attribute &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先A的父类是object, 所以super(A, self).foo()的时候回去执行object的foo</span></span><br><span class="line"><span class="comment"># 但是object没有foo, 所以报错了, 报错信息中的&#x27;super&#x27;指的就是A的父类</span></span><br><span class="line"><span class="comment"># 但是, 是的, 我要说但是了</span></span><br><span class="line">C().foo()  <span class="comment"># B: foo</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果是C()调用foo的话, 最终却执行了B的foo函数, 这是什么原因呢?</span></span><br><span class="line"><span class="string">首先C里面里面没有foo, 那么会去执行A的foo, 但是执行时候的self是C的实例对象, super里面的self也是C里面的self</span></span><br><span class="line"><span class="string">然后我们知道对于C而言, 其mro是 C、A、B、object</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以super(A, self).foo() 就表示: 沿着继承链 C、A、B、object的顺序去找foo函数</span></span><br><span class="line"><span class="string">但是super里面有一个A, 表示不要从头开始找, 而是从A的后面开始找, 所以下一个就找到B了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以说super不一定就是父类，而是要看里面的self是谁。总之：<code>super(xxx, self)</code>一定是type(self)对应的mro中，xxx的下一个类。</strong></p>
<h4 id="继承基类操作"><a href="#继承基类操作" class="headerlink" title="继承基类操作"></a>继承基类操作</h4><p><strong>python虚拟机确定了mro顺序列表之后，就会遍历mro列表(第一个类对象会是其自身，比如A.__mro__的第一个元素就是A本身，所以遍历是从第二项开始的)。在mro列表中实际上存储的就是类对象的所有直接基类、间接基类，Python虚拟机会将自身没有、但是基类<code>(注意：包括间接基类，比如基类的基类)</code>中存在的操作拷贝到该类当中，从而完成对基类操作的继承动作。</strong></p>
<p><strong>而这个继承操作的动作是发生在inherit_slots中</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    bases = type-&gt;tp_mro;</span><br><span class="line">    assert(bases != <span class="literal">NULL</span>);</span><br><span class="line">    assert(PyTuple_Check(bases));</span><br><span class="line">    n = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        PyObject *b = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">        <span class="keyword">if</span> (PyType_Check(b))</span><br><span class="line">            inherit_slots(type, (PyTypeObject *)b);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在inherit_slots中会拷贝相当多的操作，这里就拿nb_add<code>(整型则对应long_add)</code>来举个栗子:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">inherit_slots</span><span class="params">(PyTypeObject *type, PyTypeObject *base)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *basebase;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SLOTDEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYSLOT</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYNUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYSEQ</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYBUF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOTDEFINED(SLOT) \</span></span><br><span class="line"><span class="meta">    (base-&gt;SLOT != 0 &amp;&amp; \</span></span><br><span class="line"><span class="meta">     (basebase == NULL || base-&gt;SLOT != basebase-&gt;SLOT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYSLOT(SLOT) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!type-&gt;SLOT &amp;&amp; SLOTDEFINED(SLOT)) type-&gt;SLOT = base-&gt;SLOT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYASYNC(SLOT) COPYSLOT(tp_as_async-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYNUM(SLOT) COPYSLOT(tp_as_number-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYSEQ(SLOT) COPYSLOT(tp_as_sequence-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYMAP(SLOT) COPYSLOT(tp_as_mapping-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYBUF(SLOT) COPYSLOT(tp_as_buffer-&gt;SLOT)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This won&#x27;t inherit indirect slots (from tp_as_number etc.)</span></span><br><span class="line"><span class="comment">       if type doesn&#x27;t provide the space. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp; base-&gt;tp_as_number != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        basebase = base-&gt;tp_base;</span><br><span class="line">        <span class="keyword">if</span> (basebase-&gt;tp_as_number == <span class="literal">NULL</span>)</span><br><span class="line">            basebase = <span class="literal">NULL</span>;</span><br><span class="line">        COPYNUM(nb_add);</span><br><span class="line">        COPYNUM(nb_subtract);</span><br><span class="line">        COPYNUM(nb_multiply);</span><br><span class="line">        COPYNUM(nb_remainder);</span><br><span class="line">        COPYNUM(nb_divmod);</span><br><span class="line">        COPYNUM(nb_power);</span><br><span class="line">        COPYNUM(nb_negative);</span><br><span class="line">        COPYNUM(nb_positive);</span><br><span class="line">        COPYNUM(nb_absolute);</span><br><span class="line">        COPYNUM(nb_bool);</span><br><span class="line">        COPYNUM(nb_invert);</span><br><span class="line">        COPYNUM(nb_lshift);</span><br><span class="line">        COPYNUM(nb_rshift);</span><br><span class="line">        COPYNUM(nb_and);</span><br><span class="line">        COPYNUM(nb_xor);</span><br><span class="line">        COPYNUM(nb_or);</span><br><span class="line">        COPYNUM(nb_int);</span><br><span class="line">        COPYNUM(nb_float);</span><br><span class="line">        COPYNUM(nb_inplace_add);</span><br><span class="line">        COPYNUM(nb_inplace_subtract);</span><br><span class="line">        COPYNUM(nb_inplace_multiply);</span><br><span class="line">        COPYNUM(nb_inplace_remainder);</span><br><span class="line">        COPYNUM(nb_inplace_power);</span><br><span class="line">        COPYNUM(nb_inplace_lshift);</span><br><span class="line">        COPYNUM(nb_inplace_rshift);</span><br><span class="line">        COPYNUM(nb_inplace_and);</span><br><span class="line">        COPYNUM(nb_inplace_xor);</span><br><span class="line">        COPYNUM(nb_inplace_or);</span><br><span class="line">        COPYNUM(nb_true_divide);</span><br><span class="line">        COPYNUM(nb_floor_divide);</span><br><span class="line">        COPYNUM(nb_inplace_true_divide);</span><br><span class="line">        COPYNUM(nb_inplace_floor_divide);</span><br><span class="line">        COPYNUM(nb_index);</span><br><span class="line">        COPYNUM(nb_matrix_multiply);</span><br><span class="line">        COPYNUM(nb_inplace_matrix_multiply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p><strong>我们在里面看到很多熟悉的东西，如果你常用魔法方法的话。而且我们知道PyBool_Type中并没有设置nb_add，但是PyLong_Type中却设置了nb_add操作，而bool继承int。所以对布尔类型是可以直接进行运算的，当然和整型、浮点型运算也是可以的。所以在numpy中，判断一个数组中多少个满足条件的元素，可以使用numpy提供的机制进行比较，会得到一个同样长度的数组，里面的每一个元素为是否满足条件所对应的布尔值。然后直接通过sum运算即可，因为运算的时候，True会被解释成1，False会被解释成0。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(arr &gt; <span class="number">4</span>)  <span class="comment"># [False False  True False  True]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(arr &gt; <span class="number">4</span>))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2.2</span> + <span class="literal">True</span>)  <span class="comment"># 3.2</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在python中，整型是可以和布尔类型进行运算的，看似不可思议，但又在情理之中。</strong></p>
<h4 id="填充基类中的子类列表"><a href="#填充基类中的子类列表" class="headerlink" title="填充基类中的子类列表"></a>填充基类中的子类列表</h4><p><strong>到这里，PyType_Ready还剩下最后一个重要的动作了：设置基类中的子类列表。在每一个PyTypeObject中，有一个tp_subclasses，这个东西在PyType_Ready完成之后，将会是一个list对象。其中存放着所有直接继承自类的类对象，PyType_Ready是通过调用add_subclass完成向这个tp_subclasses中填充子类的动作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//填充基类的子类列表</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    n = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        PyObject *b = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">        <span class="keyword">if</span> (PyType_Check(b) &amp;&amp;</span><br><span class="line">            add_subclass((PyTypeObject *)b, type) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(object.__subclasses__())</span><br><span class="line"># [&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakref</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakcallableproxy</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakproxy</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytearray</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">NoneType</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">NotImplementedType</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">traceback</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">super</span>&#x27;&gt;</span>, ... ... ...</span><br></pre></td></tr></table></figure>

<p><strong>果然，python里面的object不愧是万物之父，这么多的内建对象都是继承自object的。到了这里，我们才算是完整的剖析了PyType_Ready的动作，可以看到，python虚拟机对python的内建对象对应的PyTypeObject进行了多种繁杂的改造工作，可以包括以下几部分：</strong></p>
<ul>
<li><code>设置type信息，基类及基类列表;</code></li>
<li><code>填充tp_dict;</code></li>
<li><code>确定mro列表;</code></li>
<li><code>基于mro列表从基类继承操作;</code></li>
<li><code>设置子类列表;</code></li>
</ul>
<p><strong>不同的类型，有些操作也会有一些不同的行为，但整体是一致的。因此具体某个特定类型，可以自己跟踪PyType_Ready的操作。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>我们看到类的属性查找虽然看起来简单，但是底层实现起来还是很复杂的。当然关于自定义的类是如何构建的，我们将在下一篇博客中进行剖析。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>19-Python类机制深度解析：自定义类的底层实现以及Metaclass</title>
    <url>/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/</url>
    <content><![CDATA[<h2 id="19-Python类机制深度解析：自定义类的底层实现以及metaclass"><a href="#19-Python类机制深度解析：自定义类的底层实现以及metaclass" class="headerlink" title="19-Python类机制深度解析：自定义类的底层实现以及metaclass"></a>19-Python类机制深度解析：自定义类的底层实现以及metaclass</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python除了给我提供了很多的类之外，还支持我们定义属于自己的类，那么Python底层是如何做的呢？我们下面就来看看。</strong></p>
<h3 id="自定义class"><a href="#自定义class" class="headerlink" title="自定义class"></a>自定义class</h3><p><strong>老规矩，如果想知道底层是怎么做的，那么就必须要通过观察字节码来实现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line">girl.f()</span><br><span class="line">girl.g(<span class="string">&quot;神乐mea&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">神乐mea</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过之前对函数机制的分析中，我们知道对于一个包含函数定义的Python源文件，在编译之后会得到一个和源文件对应的PyCodeObject对象，其内部的常量池中存储了函数编译之后的PyCodeObject对象。那么对于包含类的Python源文件，编译之后的结果又是怎么样的呢？</strong></p>
<p><strong>显然我们可以照葫芦画瓢，根据以前的经验我们可以猜测模块对应的PyCodeObject对象的常量池中肯定存储了类对应的PyCodeObject对象，类对应的PyCodeObject对象的常量池中则存储了__init__、f、g三个函数对应的PyCodeObject对象。然而事实也确实如此。</strong></p>
<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005722023-2010359374.png" alt="img"></p>
<p><strong>在介绍函数的时候，我们看到函数的声明(def语句)和函数的实现代码虽然是一个逻辑整体，但是它们的字节码指令却是分离在两个PyCodeObject对象中的。在类中，同样存在这样的分离现象。声明类的class语句，编译后的字节码指令存储在模块对应的PyCodeObject中，而类的实现、也就是类里面的逻辑，编译后的字节码指令序列则存储在类对应的的PyCodeObject中。所以我们在模块级别中只能找到类，无法直接找到类里面的成员。</strong></p>
<p><strong>另外还可以看到，类的成员函数和一般的函数相同，也会有这种声明和实现分离的现象。其实也很好理解，就把类和函数想象成变量就行了，类名、函数名就是变量名，而类、函数里面的逻辑想象成值，一个变量对应一个值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;class Girl:</span></span><br><span class="line"><span class="string">    name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        print(&quot;__init__&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def f(self):</span></span><br><span class="line"><span class="string">        print(&quot;f&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def g(self, name):</span></span><br><span class="line"><span class="string">        self.name = name</span></span><br><span class="line"><span class="string">        print(self.name)&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的code显然是模块对应的PyCodeObject对象</span></span><br><span class="line">code = <span class="built_in">compile</span>(s, <span class="string">&quot;class&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(code)  <span class="comment"># &lt;code object &lt;module&gt; at 0x000001B588101450, file &quot;class&quot;, line 1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常量池里面存储了Girl对应的PyCodeObject对象</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>])  <span class="comment"># &lt;code object Girl at 0x0000024BB6C7ABE0, file &quot;class&quot;, line 1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Girl的PyCodeObject对象的常量池里面存储了几个函数的PyCodeObject对象</span></span><br><span class="line"><span class="comment"># 至于它们的位置我们暂时不需要关心</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>].co_consts[<span class="number">6</span>])  <span class="comment"># &lt;code object g at 0x000001FAC40A82F0, file &quot;class&quot;, line 10&gt;</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>].co_consts[<span class="number">6</span>].co_varnames)  <span class="comment"># (&#x27;self&#x27;, &#x27;name&#x27;)</span></span><br></pre></td></tr></table></figure>

<h4 id="class对象的动态元信息"><a href="#class对象的动态元信息" class="headerlink" title="class对象的动态元信息"></a>class对象的动态元信息</h4><p><strong>class对象(class关键字创建的类)的元信息指的就是关于class的信息，比如说class的名称、它所拥有的的属性、方法，该class实例化时要为实例对象申请的内存空间大小等。对于模块中定义的class Girl来说，我们必须知道相应的信息：比如在class  Girl中，有一个符号f，这个f对应一个函数；还有一个符号g，这个g也对应了一个函数。有了这些元信息，才能创建class对象，否则我们是没办法创建的。元信息是一个非常重要的概念，比如说Hive，数据的元信息就是存储在MySQL里面的，而在编程语言中，正是通过元信息才实现了反射等动态特性。而在Python中，元信息的概念被发挥的淋漓尽致，因此Python也提供了其他编程语言所不具备的高度灵活的动态特征。</strong></p>
<p><strong>老规矩，下面还是看一下字节码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br></pre></td></tr></table></figure>

<p><strong>这里我们先不涉及调用，只看类的创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">16</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (__name__)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (__module__)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">2</span> (__qualname__)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">3</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (&lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;Girl.__init__&#x27;</span>)</span><br><span class="line">             <span class="number">16</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">18</span> STORE_NAME               <span class="number">4</span> (__init__)</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>          <span class="number">20</span> LOAD_CONST               <span class="number">4</span> (&lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;)</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;Girl.f&#x27;</span>)</span><br><span class="line">             <span class="number">24</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">26</span> STORE_NAME               <span class="number">5</span> (f)</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>          <span class="number">28</span> LOAD_CONST               <span class="number">6</span> (&lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;)</span><br><span class="line">             <span class="number">30</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;Girl.g&#x27;</span>)</span><br><span class="line">             <span class="number">32</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">34</span> STORE_NAME               <span class="number">6</span> (g)</span><br><span class="line">             <span class="number">36</span> LOAD_CONST               <span class="number">8</span> (None)</span><br><span class="line">             <span class="number">38</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;:</span><br><span class="line">  <span class="number">5</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;__init__&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;:</span><br><span class="line">  <span class="number">8</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;:</span><br><span class="line"> <span class="number">11</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (name)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (self)</span><br><span class="line">              <span class="number">4</span> STORE_ATTR               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line"> <span class="number">12</span>           <span class="number">6</span> LOAD_GLOBAL              <span class="number">1</span> (print)</span><br><span class="line">              <span class="number">8</span> LOAD_FAST                <span class="number">0</span> (self)</span><br><span class="line">             <span class="number">10</span> LOAD_ATTR                <span class="number">0</span> (name)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码比较长，我们逐行分析，当然很多字节码我们都见过了，因此有的字节码介绍的时候就不会特别详细了。我们仔细观察一下字节码，会发现分为五个部分：模块的字节码、class Girl的字节码、class的三个函数的字节码。</strong></p>
<p><strong>我们先来看看模块的字节码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">            <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">           <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">           <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">16</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_BUILD_CLASS: 我们注意到这又是一条我们没见过的新指令，从名字也能看出来这是要构建一个类;</code></li>
<li><code>2 LOAD_CONST: 加载Girl对应的PyCodeObject对象;</code></li>
<li><code>4 LOAD_CONST: 加载字符串&quot;Girl&quot;</code></li>
<li><code>6 MAKE_FUNCTION: 问题来了, 我们看到出现了MAKE_FUNCTION, 不是说要构建类吗? 为什么是MAKE_FUNCTION呢? 别急, 往下看;</code></li>
<li><code>8 LOAD_CONST: 再次加载字符串&quot;Girl&quot;;</code></li>
<li><code>10 CALL_FUNCTION: 你看到了什么?函数调用?是的, 这个CALL_FUNCTION是用来构建类的, 至于怎么构建我们后面会说;</code></li>
<li><code>12 STORE_NAME: 将上一步构建好的类使用符号Girl保存;</code></li>
</ul>
<p><strong>我们看一下LOAD_BUILD_CLASS这个指令都干了哪些事情吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_BUILD_CLASS)</span>: &#123;</span><br><span class="line">    _Py_IDENTIFIER(__build_class__);</span><br><span class="line"></span><br><span class="line">    PyObject *bc;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">        <span class="comment">//从f_builtins里面获取PyId___build_class__</span></span><br><span class="line">        bc = _PyDict_GetItemIdWithError(f-&gt;f_builtins, &amp;PyId___build_class__);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">                _PyErr_SetString(tstate, PyExc_NameError,</span><br><span class="line">                                 <span class="string">&quot;__build_class__ not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(bc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyObject *build_class_str = _PyUnicode_FromId(&amp;PyId___build_class__);</span><br><span class="line">        <span class="keyword">if</span> (build_class_str == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        bc = PyObject_GetItem(f-&gt;f_builtins, build_class_str);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_PyErr_ExceptionMatches(tstate, PyExc_KeyError))</span><br><span class="line">                _PyErr_SetString(tstate, PyExc_NameError,</span><br><span class="line">                                 <span class="string">&quot;__build_class__ not found&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    PUSH(bc);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LOAD_BUILD_CLASS做的事情很简单，就是从Python的内置函数中取得__build_class__将其入栈，然后下面的几个指令很好理解，但是却出现了一个CALL_FUNCTION，显然它是调用__build_class__创建类的。我们看到它的参数个数是2个，这两个参数分别是：A的PyFunctionObject、字符串”A”，因此：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在底层将会被翻译成</span></span><br><span class="line">A = __build_class__(&lt;PyFunctionObject A&gt;, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在底层将会被翻译成</span></span><br><span class="line">A = __build_class__(&lt;PyFunctionObject A&gt;, <span class="string">&quot;A&quot;</span>, <span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们实际操作一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Python中我们可以导入 builtins 来调用__build_class__，也可以直接使用</span></span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个类, 叫MyInt, 继承自int</span></span><br><span class="line">c = builtins.__build_class__(<span class="keyword">lambda</span>: <span class="literal">None</span>, <span class="string">&quot;MyInt&quot;</span>, <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__name__)  <span class="comment"># MyInt</span></span><br><span class="line"><span class="built_in">print</span>(c.__base__)  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c(<span class="number">3</span>) * c(<span class="number">5</span>))  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005728755-1725864266.png" alt="img"></p>
<p><strong>如果参数类型不正确的话，就会报出如下错误：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: not enough arguments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: func must be a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__(<span class="keyword">lambda</span>: <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: name is not a string</span></span><br></pre></td></tr></table></figure>

<p><strong>记住这几个报错信息，后面马上就会看到。此外我们也看到，这个函数的一个参数叫func、第二个参数叫name。</strong></p>
<p><strong>所以现在就明白为什么会出现CALL_FUNCTION这条指令，__build_class__就是用来将一个函数对象变成一个class对象。</strong></p>
<p><strong>class对象的字节码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (__name__)</span><br><span class="line">             <span class="number">2</span> STORE_NAME               <span class="number">1</span> (__module__)</span><br><span class="line">             <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">6</span> STORE_NAME               <span class="number">2</span> (__qualname__)</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>           <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> STORE_NAME               <span class="number">3</span> (name)</span><br><span class="line"></span><br><span class="line"> <span class="number">4</span>          <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (&lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;)</span><br><span class="line">            <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;Girl.__init__&#x27;</span>)</span><br><span class="line">            <span class="number">16</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">18</span> STORE_NAME               <span class="number">4</span> (__init__)</span><br><span class="line"></span><br><span class="line"> <span class="number">7</span>          <span class="number">20</span> LOAD_CONST               <span class="number">4</span> (&lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;)</span><br><span class="line">            <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;Girl.f&#x27;</span>)</span><br><span class="line">            <span class="number">24</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">26</span> STORE_NAME               <span class="number">5</span> (f)</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>          <span class="number">28</span> LOAD_CONST               <span class="number">6</span> (&lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;)</span><br><span class="line">            <span class="number">30</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;Girl.g&#x27;</span>)</span><br><span class="line">            <span class="number">32</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">34</span> STORE_NAME               <span class="number">6</span> (g)</span><br><span class="line">            <span class="number">36</span> LOAD_CONST               <span class="number">8</span> (None)</span><br><span class="line">            <span class="number">38</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>对于一个类而言，调用其__module__属性，可以获取所在的模块。所以开始的LOAD_NAME和STORE_NAME是将符号__module__和全局命名空间中符号__name__的值关联了起来，并放入到该类的local名字空间中。</strong></p>
<p><strong>需要说明的是，我们在介绍函数的时候提过，当时我们说：”函数的局部变量是不可变的，在编译的时候就已经确定了，是以一种静态方式放在了运行时栈前面的那段内存中，并没有放在f_locals中，f_locals其实是一个NULL，我们通过locals()拿到的只是对运行时栈前面的内存的一个拷贝，函数里面的局部变量是通过静态方式来访问的”。但是类则不一样，类是可以动态修改的，可以随时增加属性、方法，这就意味着类是不可能通过静态方式来查找属性的。而事实上也确实如此，类也有一个f_locals，但它指向的就不再是NULL了，而和f_globals一样，也是一个PyDictObject对象。然后是LOAD_CONST，将字符串”Girl”加载进来，和__qualname__组成一个entry存储在Girl的local空间中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># __main__</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__module__)  <span class="comment"># __main__</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__qualname__)  <span class="comment"># Girl</span></span><br></pre></td></tr></table></figure>

<p><strong>所以整体过程就是：先将PyCodeObject构建成函数，再通过__build_class__将函数变成一个类，当然__build_class__结束之后我们的Girl这个类就横空出世了。</strong></p>
<p><strong>因此剩下的来问题就是__build_class__是如何将一个函数变成类的，想要知道答案，那么只能去源码中一探究竟了。不过在看源码之前，我们还需要了解一样东西：metaclass。</strong></p>
<h4 id="回顾metaclass"><a href="#回顾metaclass" class="headerlink" title="回顾metaclass"></a>回顾metaclass</h4><p><strong>元类，被誉为是深度的魔法，但是个人觉得有点夸张了。首先元类是做什么的，它是用来控制我们类的生成过程的，默认情况下，我们自定义的类都是由type创建的。但是我们可以手动指定某个类的元类，但是在介绍元类之前，我们还需要看一下Python中的两个特殊的魔法方法：__new__和__init__。</strong></p>
<h5 id="new-和-init"><a href="#new-和-init" class="headerlink" title="new__和__init"></a><strong>new__和__init</strong></h5><p><strong>类在实例化的时候会自动调用__init__，但其实在调用__init__之前会先调用__new__。</strong></p>
<ul>
<li><code>__new__: 为实例对象申请一片内存;</code></li>
<li><code>__init__: 为实例对象设置属性;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A()  <span class="comment"># __new__</span></span><br></pre></td></tr></table></figure>

<p><strong>然而我们看到只有__new__被调用了，__init__则没有。原因就在于__new__中必须将A的实例对象返回，才会执行__init__，并且执行的时候会自动将__new__的返回值作为参数传给self。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="comment"># 这里的参数cls就表示A这个类本身</span></span><br><span class="line">        <span class="comment"># object.__new__(cls) 便是根据cls创建cls的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 然后执行__init__, 里面的self指的就是实例对象</span></span><br><span class="line">        <span class="comment"># 在执行__init__的时候, __new__的返回值会自动作为参数传递给这里的self</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A()  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一个对象是什么，取决于其类型对象的__new__返回了什么。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="comment"># 这里必须返回A的实例对象, 否则__init__函数是不会执行的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a + <span class="number">1</span>)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">124</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到A在实例化之后得到的是一个整型，原因就是__new__返回了123。最后一个就是参数问题，首先我们说__new__是创建实例对象的，__init__是为实例对象绑定属性的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, age</span>):</span><br><span class="line">        <span class="comment"># __new__里面的参数一定要和__init__是匹配的, 除了第一个参数之外</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 我们这里传入了两个参数, 那么: A、&quot;夏色祭&quot;、-1 就会组合起来, 分别传给__new__的 cls、name、age</span></span><br><span class="line"><span class="comment"># 然后__new__里面返回了一个实例对象</span></span><br><span class="line"><span class="comment"># 那么: object.__new__(cls)、__new__接收的name、__new__接收的age 会组合起来, 分别传给__init__的 self、name、age</span></span><br></pre></td></tr></table></figure>

<h5 id="创建类的另一种方式"><a href="#创建类的另一种方式" class="headerlink" title="创建类的另一种方式"></a>创建类的另一种方式</h5><p><strong>创建类的时候可以使用class关键字创建，除了class关键字之外，我们还可以使用type这个古老却又强大的类来创建。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type这个类里面可以接收一个参数或者三个参数</span></span><br><span class="line"><span class="comment"># 如果接收一个参数, 那么表示查看类型; 如果接收三个参数, 那么表示创建一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># type() takes 1 or 3 arguments</span></span><br></pre></td></tr></table></figure>

<p><strong>告诉我们type要么接收一个参数，要么接收三个参数。显然接收一个参数查看类型不需要再说了，我们看看怎么用来用type创建一个类。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type接收的三个参数: 类名、继承的基类、属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这个类翻译过来就是</span></span><br><span class="line">val = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (<span class="built_in">list</span>, ), &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(val)  <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(val.__name__)  <span class="comment"># A</span></span><br><span class="line"><span class="built_in">print</span>(val.__base__)  <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(val.name)  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>所以还是很简单的，我们还可以自定义一个类继承自type。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        <span class="built_in">print</span>(bases)</span><br><span class="line">        <span class="built_in">print</span>(attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定metaclass, 表示A这个类由MyType创建</span></span><br><span class="line"><span class="comment"># 我们说__new__是为实例对象开辟内存的, 那么MyType的实例对象是谁呢? 显然就是这里的A</span></span><br><span class="line"><span class="comment"># 因为A指定了metaclass为MyType, 所以A的类型就是MyType</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="built_in">int</span>, <span class="built_in">object</span>, metaclass=MyType):</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A</span></span><br><span class="line"><span class="string">(&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;A&#x27;, &#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到一个类在创建的时候会向元类的__new__中传递三个值</span></span><br><span class="line"><span class="comment"># 分别是类名、继承的基类、类的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是此时A并没有被创建出来</span></span><br><span class="line"><span class="built_in">print</span>(A)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们说__new__一定要将创建的实例对象返回才可以, 这里的MyType是元类</span></span><br><span class="line"><span class="string">所以类对象A就等于MyType的实例对象, MyType的__new__就负责为类对象A分配空间</span></span><br><span class="line"><span class="string">但是显然我们这里并没有分配, 而且返回的还是一个None, 如果我们返回的是123, 那么print(a)就是123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以元类和类之间的关系 和 类与实例对象的关系，之间是很相似的，因为完全可以把类对象看成是元类的实例对象。因此A既然指定了metaclass为MyType，表示A这个类由MyType创建，那么MyType的__new__函数返回了什么，A就是什么。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;嘿嘿嘿&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + <span class="string">&quot;哟哟哟&quot;</span>)  <span class="comment"># 嘿嘿嘿哟哟哟</span></span><br></pre></td></tr></table></figure>

<p><strong>这便是Python语言具备的高度动态特性，那么问题来了，如果我想把A创建出来、像普通的类一样使用的话，该咋办呢？因为默认情况下是由type创建，底层帮你做好了，但是现在是我们手动指定元类，那么一切就需要我们来手动指定了。显然，这里创建还是要依赖于type，只不过需要我们手动指定，而且在手动指定的同时我们还可以增加一些我们自己的操作。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        name = name * <span class="number">2</span></span><br><span class="line">        bases = (<span class="built_in">list</span>,)</span><br><span class="line">        attr.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里直接交给type即可, 然后type来负责创建</span></span><br><span class="line">        <span class="comment"># 所以super().__new__实际上会调用type.__new__</span></span><br><span class="line">        <span class="comment"># type(name, bases, attr) 等价于 type.__new__(type, name, bases, attr)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line">        <span class="comment"># 但是这里我们将__new__的第一个参数换成了mcs, 也就是这里的MyType</span></span><br><span class="line">        <span class="comment"># 等价于type.__new__(mcs, name, bases, attr)表示将元类设置成MyType</span></span><br><span class="line">        <span class="comment"># 注意: 不能写type(name, bases, attr), 因为这样的话类还是由type创建的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到类的名字变了, 默认情况下是Girl, 但是我们在创建的时候将name成了个2</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__name__)  <span class="comment"># GirlGirl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么显然Girl这里也要继承自list</span></span><br><span class="line"><span class="built_in">print</span>(Girl(<span class="string">&quot;你好呀&quot;</span>))  <span class="comment"># [&#x27;你&#x27;, &#x27;好&#x27;, &#x27;呀&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理Girl还有两个属性</span></span><br><span class="line"><span class="built_in">print</span>(Girl.name, Girl.nickname)  <span class="comment"># 神乐mea 屑女仆</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前还说过，一个类在没有指定的metaclass的时候，如果它的父类指定了，那么这个类的metaclass等于父类的metaclass。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        name = name * <span class="number">2</span></span><br><span class="line">        bases = (<span class="built_in">list</span>,)</span><br><span class="line">        attr.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Girl</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.__class__)  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(A.__name__)  <span class="comment"># AA</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前还举了个flask的例子，一种更加优雅的写法。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_metaclass</span>(<span class="params">meta, bases</span>):</span><br><span class="line">    <span class="keyword">return</span> meta(<span class="string">&quot;tmp&quot;</span>, bases, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with_metaclass(MyType, (list,))便会返回一个类</span></span><br><span class="line"><span class="comment"># 这个类由MyType创建, 并且继承自list</span></span><br><span class="line"><span class="comment"># 那么Girl再继承这个类, 等价于Girl也是有MyType创建, 并且也会继承自list</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(with_metaclass(MyType, (<span class="built_in">list</span>,))):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.__class__)  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.tmp&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__mro__)  <span class="comment"># (&lt;class &#x27;__main__.Girl&#x27;&gt;, &lt;class &#x27;__main__.tmp&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以with_metaclass(meta, bases)只是为了帮助我们找到元类和继承的类</span></span><br><span class="line"><span class="comment"># 至于其本身并没有太大的意义, 但我们毕竟继承它了, 就意味着我们也可以找到它的属性</span></span><br><span class="line"><span class="built_in">print</span>(Girl.gender)  <span class="comment"># female</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：我们说创建类的对象是元类，元类要么是type、要么是继承自type的子类。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># type直接加括号表示由type创建, 我们需要通过__new__手动指定</span></span><br><span class="line">Girl = <span class="built_in">type</span>.__new__(MyType, <span class="string">&quot;GirlGirlGirl&quot;</span>, (<span class="built_in">list</span>,), &#123;<span class="string">&quot;foo&quot;</span>: <span class="keyword">lambda</span> self, value: value + <span class="number">123</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(Girl.__name__)  <span class="comment"># GirlGirlGirl</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g.foo(<span class="number">123</span>))  <span class="comment"># 246</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">type</span>.__new__(<span class="built_in">int</span>, <span class="string">&quot;A&quot;</span>, (<span class="built_in">object</span>,), &#123;&#125;)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 指定为int则报错, 告诉我们int不是type的子类</span></span><br><span class="line">    <span class="comment"># 因为只有两种情况: 要么是type、要么是type的子类</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># type.__new__(int): int is not a subtype of type</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是觉得元类很简单呢？其实元类没有什么复杂的。</strong></p>
<p><strong>再举个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;f&quot;</span> <span class="keyword">in</span> attr:</span><br><span class="line">            attr.pop(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;f&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl().g())  <span class="comment"># g</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(Girl().f())</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;Girl&#x27; object has no attribute &#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">惊了, 我们看到居然没有f这个属性, 我们明显定义了啊, 原因就是我们在创建类的时候将其pop掉了</span></span><br><span class="line"><span class="string">首先创建一个类需要三个元素: 类名、继承的基类、类的一些属性(以字典的形式, 属性名: 属性值)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后会将这三个元素交给元类进行创建, 但是我们在创建的时候偷偷地将f从attr里面给pop掉了</span></span><br><span class="line"><span class="string">因此创建出来的类是没有f这个函数的 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong>元类确实蛮有趣的，而且也没有想象中的那么难，可以多了解一下。</strong></p>
<h5 id="特殊的魔法函数"><a href="#特殊的魔法函数" class="headerlink" title="特殊的魔法函数"></a>特殊的魔法函数</h5><p><strong>此外我们再来看两个和元类有关的魔法函数：</strong></p>
<p><strong><strong>prepared</strong></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__prepared__&quot;</span>)</span><br><span class="line">        <span class="comment"># 必须返回一个mapping, 至于它是干什么的我们后面说</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__prepared__</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到__prepare__会在__new__方法之前被调用，那么它是做什么的呢？答案是添加属性的，我们解释一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;f&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.name)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你应该知道__prepare__是干什么的了吧, 它接收一个name、一个bases, 返回有个mapping</span></span><br><span class="line"><span class="comment"># 我们说name、bases、attr会传递给__new__, 但是在__new__之前会先经过__prepared__</span></span><br><span class="line"><span class="comment"># __prepared__返回一个字典(mapping), 假设叫m吧, 那会将attr和m合并, 相当于执行了attr.update(m)</span></span><br><span class="line"><span class="comment"># 然后再将 name、bases、attr交给__new__</span></span><br></pre></td></tr></table></figure>

<p><strong>此外__prepared__这个方法是被classmethod装饰的，另外里面一定要返回一个mapping，否则报错：TypeError: MyType.<strong>prepare</strong>() must return a mapping, not xxx</strong></p>
<p><strong><strong>init_subclass</strong></strong></p>
<p><strong>它类似于一个钩子函数，在一些简单地场景下可以代替元类。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当A被创建的时候, 会触发其父类的__init_subclass__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt; &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Base, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt; &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以父类的__init_subclass__里面的cls并不是父类本身，而是继承它的类。kwargs，就是额外设置的一些属性。因此我们可以实现一个属性添加器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(cls, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(Base, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span>, __str__=<span class="keyword">lambda</span> self: <span class="string">&quot;__str__&quot;</span> ):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.name, A.age)  <span class="comment"># 夏色祭 -1</span></span><br><span class="line"><span class="built_in">print</span>(A())  <span class="comment"># __str__</span></span><br></pre></td></tr></table></figure>

<p><strong>除了属性添加器，我们还可以实现一个属性拦截器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;yoyoyo&quot;</span>) <span class="keyword">and</span> <span class="built_in">hasattr</span>(cls.yoyoyo, <span class="string">&quot;__code__&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;<span class="subst">&#123;cls.__name__&#125;</span>不允许定义&#x27;yoyoyo&#x27;函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    yoyoyo = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于在创建类的时候就会触发, 所以必须加上try语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">yoyoyo</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># B不允许定义&#x27;yoyoyo&#x27;函数</span></span><br></pre></td></tr></table></figure>

<p><strong>有了这些元类相关的知识，我们后面在分析源码的时候就会轻松一些。</strong></p>
<h4 id="源码分析类机制与metaclass"><a href="#源码分析类机制与metaclass" class="headerlink" title="源码分析类机制与metaclass"></a>源码分析类机制与metaclass</h4><p><strong>我们说LOAD_BUILD_CLASS是将一个PyFunctionObject变成一个类，尽管它写在最前面，但实际上是需要将class  A对应的PyCodeObject对象包装成一个PyFunctionObject对象之后才能执行。我们说__build_class__是用来将PyFunctionObject变成类的函数，我们来看看它长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//python/bltinmodule.c</span></span><br><span class="line"><span class="type">static</span> PyMethodDef builtin_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__build_class__&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___build_class__,</span><br><span class="line">     METH_FASTCALL | METH_KEYWORDS, build_class_doc&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">builtin___build_class__(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                        PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *name, *bases, *mkw, *meta, *winner, *prep, *ns, *orig_bases;</span><br><span class="line">    PyObject *cls = <span class="literal">NULL</span>, *cell = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> isclass = <span class="number">0</span>;   <span class="comment">/* initialize to prevent gcc warning */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们说了底层调用的是builtin___build_class__</span></span><br><span class="line">    <span class="comment">//class A: 会被翻译成builtin.__build_class__(PyFunctionObject, &quot;class name&quot;)</span></span><br><span class="line">    <span class="comment">//所以这个函数至少需要两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//参数不足，报错，还记的这个报错信息吗？上面测试过的</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: not enough arguments&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类对应的PyFunctionObject</span></span><br><span class="line">    func = args[<span class="number">0</span>];   <span class="comment">/* Better be callable */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyFunction_Check(func)) &#123;</span><br><span class="line">        <span class="comment">//如果不是PyFunctionObject，报错，这个信息有印象吗？</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: func must be a function&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类对应的名字，__build_class__的时候 总要给类起一个名字吧</span></span><br><span class="line">    name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name)) &#123;</span><br><span class="line">        <span class="comment">//如果不是一个PyUnicodeObject，报错，这个有印象吗？</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: name is not a string&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原始基类</span></span><br><span class="line">    orig_bases = _PyTuple_FromArray(args + <span class="number">2</span>, nargs - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (orig_bases == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取class的基类列表</span></span><br><span class="line">    bases = update_bases(orig_bases, args + <span class="number">2</span>, nargs - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(orig_bases);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (kwnames == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        meta = <span class="literal">NULL</span>;</span><br><span class="line">        mkw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mkw = _PyStack_AsDict(args + nargs, kwnames);</span><br><span class="line">        <span class="keyword">if</span> (mkw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里获取meta</span></span><br><span class="line">        meta = _PyDict_GetItemIdWithError(mkw, &amp;PyId_metaclass);</span><br><span class="line">        <span class="keyword">if</span> (meta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(meta);</span><br><span class="line">            <span class="keyword">if</span> (_PyDict_DelItemId(mkw, &amp;PyId_metaclass) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_DECREF(meta);</span><br><span class="line">                Py_DECREF(mkw);</span><br><span class="line">                Py_DECREF(bases);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* metaclass is explicitly given, check if it&#x27;s indeed a class */</span></span><br><span class="line">            isclass = PyType_Check(meta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            Py_DECREF(mkw);</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果meta为NULL，这意味着用户没有指定metaclass</span></span><br><span class="line">    <span class="keyword">if</span> (meta == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//然后尝试获取基类，如果没有基类</span></span><br><span class="line">        <span class="keyword">if</span> (PyTuple_GET_SIZE(bases) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//指定metaclass为type</span></span><br><span class="line">            meta = (PyObject *) (&amp;PyType_Type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则获取第一个继承的基类的metaclass</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            PyObject *base0 = PyTuple_GET_ITEM(bases, <span class="number">0</span>);<span class="comment">//拿到第一个基类</span></span><br><span class="line">            meta = (PyObject *) (base0-&gt;ob_type);<span class="comment">//拿到第一个基类的__class__</span></span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(meta);<span class="comment">//meta也是一个类</span></span><br><span class="line">        isclass = <span class="number">1</span>;  <span class="comment">/* meta is really a class */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果设置了元类, 那么isclass为1, 会执行下面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (isclass) &#123;</span><br><span class="line">        <span class="comment">//既然已经选择出了元类, 那么这一步是做什么的呢?</span></span><br><span class="line">        <span class="comment">//这一步是为了解决元类冲突的, 假设有两个继承type的元类MyType1和MyType2, 然后Base1的元类是MyType1、Base2的元类是MyType2</span></span><br><span class="line">        <span class="comment">//那么如果class A(Base1, Base2)的话, 就会报错</span></span><br><span class="line">        <span class="comment">//在Python中有一个要求, 假设class A(Base1, Base2, ..., BaseN), Base1的元类叫Type1、BaseN的元类叫TypeN</span></span><br><span class="line">        <span class="comment">//那么必须满足：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Type1是Type2的子类或者父类;</span></span><br><span class="line"><span class="comment">        Type1是Type3的子类或者父类;</span></span><br><span class="line"><span class="comment">        Type1是Type4的子类或者父类;</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        Type1是TypeN的子类或者父类;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//而之所以存在这一限制, 原因就是为了避免属性冲突</span></span><br><span class="line">        winner = (PyObject *)_PyType_CalculateMetaclass((PyTypeObject *)meta,</span><br><span class="line">                                                        bases);</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(meta);</span><br><span class="line">            Py_XDECREF(mkw);</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (winner != meta) &#123;</span><br><span class="line">            Py_DECREF(meta);</span><br><span class="line">            meta = winner;</span><br><span class="line">            Py_INCREF(meta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else: meta is not a class, so we cannot do the metaclass</span></span><br><span class="line"><span class="comment">       calculation, so we will use the explicitly given object as it is */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找__prepare__方法</span></span><br><span class="line">    <span class="keyword">if</span> (_PyObject_LookupAttrId(meta, &amp;PyId___prepare__, &amp;prep) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ns = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个__prepare__方法必须返回一个mapping，如果返回None，那么默认返回一个空字典</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ns = PyDict_New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则将字典返回</span></span><br><span class="line">        PyObject *pargs[<span class="number">2</span>] = &#123;name, bases&#125;;</span><br><span class="line">        <span class="comment">//我们看到这里涉及到了一个函数调用, 这个函数应该有印象吧</span></span><br><span class="line">        ns = _PyObject_FastCallDict(prep, pargs, <span class="number">2</span>, mkw);</span><br><span class="line">        Py_DECREF(prep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(meta);</span><br><span class="line">        Py_XDECREF(mkw);</span><br><span class="line">        Py_DECREF(bases);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyMapping_Check(ns)) &#123;</span><br><span class="line">        <span class="comment">//如果返回的不是一个字典，那么报错，这个错误等信息我们也见过了</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;%.200s.__prepare__() must return a mapping, not %.200s&quot;</span>,</span><br><span class="line">                     isclass ? ((PyTypeObject *)meta)-&gt;tp_name : <span class="string">&quot;&lt;metaclass&gt;&quot;</span>,</span><br><span class="line">                     Py_TYPE(ns)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，一个简单的类定义，Python底层究竟做了多少事情啊，不过显然这还没完。</strong></p>
<p><strong>我们前面说，Python虚拟机获得了关于class的属性表(动态元信息)，比如所有的方法、属性，所以我们可以说，class的动态元信息包含了class的所有属性。但是对于这个class对象的类型是什么，应该如何创建、要分配多少内存，却没有任何的信息。而在<code>builtin___build_class__</code>中，metaclass正是关于class对象的另一部分元信息，我们称之为静态元信息。在静态元信息中，隐藏着所有的类对象应该如何创建的信息，注意：是所有的类对象。</strong></p>
<p><strong>从源码中我们可以看到，如果用户指定了metaclass，那么会选择指定的metaclass，如果没有指定，那么会使用第一个继承的基类的__class__作为该class的metaclass。</strong></p>
<p><strong>对于PyLongObject、PyDictObject这些Python中的实例对象，所有的元信息存储在对应的类对象中(PyLong_Type，PyDict_Type)。但是对于类对象来说，其元信息的静态元信息存储在对应的元类(PyType_Type)中，动态元信息则存储在本身的local名字空间中。但是为什么这么做呢？为什么对于类对象来说，其元信息要游离成两部分呢？都存在metaclass里面不香吗？这是因为，用户在.py文件中可以定义不同的class，这个元信息必须、且只能是动态的，所以它是不适合保存在metaclass中的，因此类对象的创建策略等这些所有class都会共用的元信息，会存储在metaclass里面。</strong></p>
<p><strong>像Python的内建对象都是Python静态提供的，它们都具备相同的接口集合(底层都是PyTypeObject结构体实例)，支持什么操作一开始就定义好了。只不过有的可以用，有的不能用。比如PyLongObject可以使用nb_add，但是PyDictObject不能。而PyDictObject可以使用mp_subscript，但是PyLongObject不可以。尽管如此，但这不影响它们的所有元信息都可以完全存储在类型对象中。但是用户自定义的class对象，接口是动态的，不可能在metaclass中静态指定。</strong></p>
<p><strong>既然创建了元类，那么下面显然就开始调用了。通过函数 *PyObject_Call* 调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_Call</span><span class="params">(PyObject *callable, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用了tp_call，指向type_call</span></span><br><span class="line">        call = callable-&gt;ob_type-&gt;tp_call;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError, <span class="string">&quot;&#x27;%.200s&#x27; object is not callable&quot;</span>,</span><br><span class="line">                         callable-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/typeobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;cannot create &#x27;%.100s&#x27; instances&quot;</span>,</span><br><span class="line">                     type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用tp_new申请内存</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是PyType_Type, 那么执行完__new__之后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span><br><span class="line">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (kwds == <span class="literal">NULL</span> ||</span><br><span class="line">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="number">0</span>)))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还记得我们之前说过, __new__里面一定要返回类的实例对象, 否则是不会执行__init__函数的</span></span><br><span class="line">    <span class="comment">//从这里我们也看到了, 如果obj的类型不是对应的类、或者其子类, 那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//然后获取obj的类型</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//如果存在__init__函数, 那么执行构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行完构造函数之后, 再将实例对象返回</span></span><br><span class="line">    <span class="comment">//注意: 执行了__init__说明obj是实例对象, 如果obj是类对象, 那么是不会走到这里来的</span></span><br><span class="line">    <span class="comment">//执行完元类的__new__之后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tp_new指向type_new，这个type_new是我们创建class对象的第一案发现场。我们看一下type_new的源码，位于 *Objects&#x2F;typeobject.c* 中，这个函数的代码比较长，我们会有删减，像那些检测的代码我们就省略掉了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_new</span><span class="params">(PyTypeObject *metatype, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//都是类的一些动态元信息</span></span><br><span class="line">    PyObject *name, *bases = <span class="literal">NULL</span>, *orig_dict, *dict = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *qualname, *slots = <span class="literal">NULL</span>, *tmp, *newslots, *cell;</span><br><span class="line">    PyTypeObject *type = <span class="literal">NULL</span>, *base, *tmptype, *winner;</span><br><span class="line">    PyHeapTypeObject *et;</span><br><span class="line">    PyMemberDef *mp;</span><br><span class="line">    Py_ssize_t i, nbases, nslots, slotoffset, name_size;</span><br><span class="line">    <span class="type">int</span> j, may_add_dict, may_add_weak, add_dict, add_weak;</span><br><span class="line">    _Py_IDENTIFIER(__qualname__);</span><br><span class="line">    _Py_IDENTIFIER(__slots__);</span><br><span class="line">    _Py_IDENTIFIER(__classcell__);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果metaclass是type的话</span></span><br><span class="line">    <span class="keyword">if</span> (metatype == &amp;PyType_Type) &#123;</span><br><span class="line">        <span class="comment">//获取位置参数和关键字参数个数</span></span><br><span class="line">        <span class="type">const</span> Py_ssize_t nargs = PyTuple_GET_SIZE(args);</span><br><span class="line">        <span class="type">const</span> Py_ssize_t nkwds = kwds == <span class="literal">NULL</span> ? <span class="number">0</span> : PyDict_GET_SIZE(kwds);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//位置参数为1，关键字参数为0，你想到了什么</span></span><br><span class="line">        <span class="comment">//type(xxx)，是不是这个呀</span></span><br><span class="line">        <span class="keyword">if</span> (nargs == <span class="number">1</span> &amp;&amp; nkwds == <span class="number">0</span>) &#123;</span><br><span class="line">            PyObject *x = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">            Py_INCREF(Py_TYPE(x));</span><br><span class="line">            <span class="comment">//这显然是初学Python的时候，就知道的，查看一个变量的类型。</span></span><br><span class="line">            <span class="comment">//获取类型之后直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (PyObject *) Py_TYPE(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上面的if不满足，会走这里，表示现在不再是查看类型了，而是创建类</span></span><br><span class="line">        <span class="comment">//而这里要求位置参数必须是3个，否则报错。</span></span><br><span class="line">        <span class="comment">//我们知道type查看类型，输入一个参数即可，但是创建类需要3个</span></span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">3</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                            <span class="string">&quot;type() takes 1 or 3 arguments&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check arguments: (name, bases, dict) */</span></span><br><span class="line">    <span class="comment">//现在显然是确定参数类型，对于type来说，你传递了三个参数，但是这三个参数是有类型要求的</span></span><br><span class="line">    <span class="comment">//必须是PyUnicodeObject、PyTupleObject、PyDictObject</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;UO!O!:type.__new__&quot;</span>, &amp;name, &amp;PyTuple_Type,</span><br><span class="line">                          &amp;bases, &amp;PyDict_Type, &amp;orig_dict))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type(123, (object, ), &#123;&#125;)  # TypeError: type.__new__() argument 1 must be str, not int</span></span><br><span class="line"><span class="comment">    type(&quot;xx&quot;, [object], &#123;&#125;)  # TypeError: type.__new__() argument 2 must be tuple, not list</span></span><br><span class="line"><span class="comment">    type(&quot;xx&quot;, (object, ), [])  # TypeError: type.__new__() argument 3 must be dict, not list</span></span><br><span class="line"><span class="comment">    */</span>        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理bases为空的情况，另外我们使用class关键字定义类，本质上会转为type定义类的方式</span></span><br><span class="line">    nbases = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">if</span> (nbases == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果发现我们没有继承基类，那么在Python3中会默认继承object</span></span><br><span class="line">        base = &amp;PyBaseObject_Type; <span class="comment">//base设置为object</span></span><br><span class="line">        bases = PyTuple_Pack(<span class="number">1</span>, base); <span class="comment">//bases设置为(object,)</span></span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        nbases = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _Py_IDENTIFIER(__mro_entries__);</span><br><span class="line">        <span class="comment">//如果我们继承了基类</span></span><br><span class="line">        <span class="comment">//那么循环遍历bases</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbases; i++) &#123;</span><br><span class="line">            <span class="comment">//拿到每一个基类</span></span><br><span class="line">            tmp = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">            <span class="comment">//如果是PyType_Type类型，进行下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (PyType_Check(tmp)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_PyObject_LookupAttrId(tmp, &amp;PyId___mro_entries__, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                <span class="string">&quot;type() doesn&#x27;t support MRO entry resolution; &quot;</span></span><br><span class="line">                                <span class="string">&quot;use types.new_class()&quot;</span>);</span><br><span class="line">                Py_DECREF(tmp);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Search the bases for the proper metatype to deal with this: */</span></span><br><span class="line">        <span class="comment">//寻找父类的metaclass, 就是我们之前说的解决元类冲突所采取的策略</span></span><br><span class="line">        winner = _PyType_CalculateMetaclass(metatype, bases);</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (winner != metatype) &#123;</span><br><span class="line">            <span class="keyword">if</span> (winner-&gt;tp_new != type_new) <span class="comment">/* Pass it to the winner */</span></span><br><span class="line">                <span class="keyword">return</span> winner-&gt;tp_new(winner, args, kwds);</span><br><span class="line">            metatype = winner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate best base, and check that all bases are type objects */</span></span><br><span class="line">        <span class="comment">//确定最佳base，存储在PyTypeObject *base中</span></span><br><span class="line">        base = best_base(bases);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Py_INCREF(bases);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use &quot;goto error&quot; from this point on as we now own the reference to &quot;bases&quot;. */</span></span><br><span class="line"></span><br><span class="line">    dict = PyDict_Copy(orig_dict);</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理用户定义了__slots__属性的逻辑，一旦程序猿定义了__slots__, 那么类的实例对象就没有属性字典了</span></span><br><span class="line">    slots = _PyDict_GetItemIdWithError(dict, &amp;PyId___slots__);</span><br><span class="line">    nslots = <span class="number">0</span>;</span><br><span class="line">    add_dict = <span class="number">0</span>;</span><br><span class="line">    add_weak = <span class="number">0</span>;</span><br><span class="line">    may_add_dict = base-&gt;tp_dictoffset == <span class="number">0</span>;</span><br><span class="line">    may_add_weak = base-&gt;tp_weaklistoffset == <span class="number">0</span> &amp;&amp; base-&gt;tp_itemsize == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (slots == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the type object */</span></span><br><span class="line">    <span class="comment">//为class对象申请内存</span></span><br><span class="line">    type = (PyTypeObject *)metatype-&gt;tp_alloc(metatype, nslots);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep name and slots alive in the extended type object */</span></span><br><span class="line">    et = (PyHeapTypeObject *)type;</span><br><span class="line">    Py_INCREF(name);</span><br><span class="line">    et-&gt;ht_name = name;</span><br><span class="line">    et-&gt;ht_slots = slots;</span><br><span class="line">    slots = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化tp_flags */</span></span><br><span class="line">    type-&gt;tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE |</span><br><span class="line">        Py_TPFLAGS_BASETYPE;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tp_flags &amp; Py_TPFLAGS_HAVE_GC)</span><br><span class="line">        type-&gt;tp_flags |= Py_TPFLAGS_HAVE_GC;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置PyTypeObject中的各个域</span></span><br><span class="line">    type-&gt;tp_as_async = &amp;et-&gt;as_async;</span><br><span class="line">    type-&gt;tp_as_number = &amp;et-&gt;as_number;</span><br><span class="line">    type-&gt;tp_as_sequence = &amp;et-&gt;as_sequence;</span><br><span class="line">    type-&gt;tp_as_mapping = &amp;et-&gt;as_mapping;</span><br><span class="line">    type-&gt;tp_as_buffer = &amp;et-&gt;as_buffer;</span><br><span class="line">    type-&gt;tp_name = PyUnicode_AsUTF8AndSize(name, &amp;name_size);</span><br><span class="line">    <span class="keyword">if</span> (!type-&gt;tp_name)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(type-&gt;tp_name) != (<span class="type">size_t</span>)name_size) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError,</span><br><span class="line">                        <span class="string">&quot;type name must not contain null characters&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置基类和基类列表 */</span></span><br><span class="line">    type-&gt;tp_bases = bases;</span><br><span class="line">    bases = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(base);</span><br><span class="line">    type-&gt;tp_base = base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置属性表 */</span></span><br><span class="line">    Py_INCREF(dict);</span><br><span class="line">    type-&gt;tp_dict = dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置__module__</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_GetItemIdWithError(dict, &amp;PyId___module__) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = PyEval_GetGlobals();</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmp = _PyDict_GetItemIdWithError(tmp, &amp;PyId___name__);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___module__,</span><br><span class="line">                                      tmp) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置__qualname__，即&quot;全限定名&quot;</span></span><br><span class="line">    qualname = _PyDict_GetItemIdWithError(dict, &amp;PyId___qualname__);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果自定义的class中重写了__new__方法，将__new__对应的函数改造为static函数</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___new__);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span> &amp;&amp; PyFunction_Check(tmp)) &#123;</span><br><span class="line">        tmp = PyStaticMethod_New(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___new__, tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(tmp);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置__init_subclass__，如果子类继承了父类，那么会触发父类的__init_subclass__方法</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___init_subclass__);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span> &amp;&amp; PyFunction_Check(tmp)) &#123;</span><br><span class="line">        tmp = PyClassMethod_New(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___init_subclass__, tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(tmp);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置__class_getitem__，这个是什么？类似于__getitem__</span></span><br><span class="line">    <span class="comment">//__class_getitem__支持通过 类[&quot;xxx&quot;] 的方式访问</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___class_getitem__);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为class对象对应的instance对象设置内存大小信息 </span></span><br><span class="line">    type-&gt;tp_basicsize = slotoffset;</span><br><span class="line">    type-&gt;tp_itemsize = base-&gt;tp_itemsize;</span><br><span class="line">    type-&gt;tp_members = PyHeapType_GET_MEMBERS(et);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用PyType_Ready对class对象进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Put the proper slots in place */</span></span><br><span class="line">    fixup_slot_dispatchers(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_dictoffset) &#123;</span><br><span class="line">        et-&gt;ht_cached_keys = _PyDict_NewKeysForClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set_names(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_subclass(type, kwds) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(dict);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)type;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    Py_XDECREF(dict);</span><br><span class="line">    Py_XDECREF(bases);</span><br><span class="line">    Py_XDECREF(slots);</span><br><span class="line">    Py_XDECREF(type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机首先会将类名、基类列表和属性表从tuple对象中解析出来，然后会基于基类列表及传入的metaclass(参数metatype)确定最佳的metaclass和base。</strong></p>
<p><strong>随后，python虚拟机会调用<code>metatype-&gt;tp_alloc</code>尝试为要创建的类对象分配内存。这里需要注意的是，在PyType_Type中，我们发现tp_alloc是一个NULL，这显然不正常。但是不要忘记，我们之前提到，在Python进行初始化时，会对所有的内建对象通过PyType_Ready进行初始化，在这个初始化过程中，有一项动作就是从基类继承各种操作。由于type.__bases__中的第一个基类是object，所以type会继承object中的tp_alloc操作，即 *PyType_GenericAlloc* 。对于我们的任意继承自object的class对象来说， *PyType_GenericAlloc* 将申请<code>metatype-&gt;tp_basicsize + metatype-&gt;tp_itemsize</code>大小的内存空间。从PyType_Type的定义中我们看到，这个大小实际就是 *sizeof(PyHeapTypeObject) + sizeof(PyMemerDef)* 。因此在这里应该就明白了PyHeapTypeObject这个老铁到底是干嘛用的了，之前因为偏移量的问题，折腾了不少功夫，甚至让人觉得这有啥用啊，但是现在意识到了，这个老铁是为用户自定义class准备的。</strong></p>
<p><strong>接下来就是设置class对象的各个域，其中包括了在tp_dict上设置属性表，也就是__dict__。另外注意的是，这里还计算了类对象对应的实例对象所需要的内存大小信息，换言之，我们类创建一个实例对象时，需要为这个实例对象申请多大的内存空间呢？对于任意继承object的class对象来说，这个大小为<code>PyBaseObject_Type-&gt;tp_basicsize + 16</code>。其中的16是2 * sizeof(PyObject *)。为什么后面要跟着两个PyObject *的空间，因为这些空间的地址被设置给了 *tp_dictoffset* 和 *tp_weaklistoffset* 了呢？这一点将在下一篇博客中进行解析，它是和实例对象的属性字典密切相关的。</strong></p>
<p><strong>最后，Python虚拟机还会调用PyType_Ready对class定义的类对象<code>(这里简称class对象)</code>进行和内建对象一样的初始化动作，到此class对象才算正式创建完毕。那么内建对象和class对象在内存布局上面有什么区别呢？毕竟都是类对象。</strong></p>
<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005736206-1581059838.png" alt="img"></p>
<p><strong>本质上，无论用户自定义的class对象还是内建对象，在Python虚拟机内部，都可以用一个PyTypeObject来表示。但不同的是，内建对象的PyTypeObject以及与其关联的PyNumberMethods等属性的内存位置都是在编译时确定的，它们在内存中的位置是分离的。而用户自定义的class对象的PyTypeObject和PyNumberMethods等内存位置是连续的，必须在运行时动态分配内存。</strong></p>
<p><strong>现在我们算是对python中可调用(callable)这个概念有一个感性认识了，在python中可调用这个概念是一个相当通用的概念，不拘泥于对象、大小，只要类型对象定义了tp_call操作，就能进行调用操作。我们已经看到，python中的对象class对象是调用metaclass创建。那么显然，调用class对象就能得到实例对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们介绍了自定义的类在底层是如何实现的，但是关于类的知识点还有很多，比如：魔法方法、描述符等等，我们可能还需要两到三篇来进行介绍。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>What the Fork Finding Hidden Code Clones in npm</title>
    <url>/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/</url>
    <content><![CDATA[<h2 id="What-the-Fork-Finding-Hidden-Code-Clones-in-npm"><a href="#What-the-Fork-Finding-Hidden-Code-Clones-in-npm" class="headerlink" title="What the Fork? Finding Hidden Code Clones in npm"></a>What the Fork? Finding Hidden Code Clones in npm</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: What the Fork? Finding Hidden Code Clones in npm<ul>
<li>翻译：发现npm中的隐藏代码克隆</li>
</ul>
</li>
<li>Authors: Elizabeth Wyss, Lorenzo De Carli, and Drew Davidson</li>
<li>Affiliation: Elizabeth Wyss - University of Kansas (美国堪萨斯大学); Lorenzo De Carli - Worcester Polytechnic Institute (美国伍斯特理工学院); Drew Davidson - University of Kansas (美国堪萨斯大学)</li>
<li>Keywords: npm, package ecosystem, shrinkwrapped clones, clone detection, vulnerability, code reuse</li>
<li>URLs: Paper: <a href="https://dl.acm.org/doi/10.1145/3510003.3510168">https://dl.acm.org/doi/10.1145/3510003.3510168</a> , GitHub: <a href="https://osf.io/jfk3n/?view_only=6f930d1de8704a26903540f75982bffb">https://osf.io/jfk3n/?view_only=6f930d1de8704a26903540f75982bffb</a></li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h3><p>文章提出了一种未被充分发现的问题称之为 shrinkwrapped clones</p>
<blockquote>
<p>“npm shrinkwrapped clones” 在论文中指的是那些上传到包仓库的、包含与现有（合法）包相同或几乎相同的代码的包。这里的 “shrinkwrapped” 可能是指这些包保留了原始包的依赖关系，并且通过 npm-shrinkwrap.json 文件锁定了精确的依赖包版本。而 “clones” 则暗示了它们与原始包非常相似，甚至可能是副本。在这种情况下，这些 “npm shrinkwrapped clones” 可能是为了误导用户，让他们错误地安装了这些与原始包非常相似的包。这可能会导致安全隐患，比如植入恶意代码、窃取用户数据等。为了避免这类问题，开发者需要谨慎选择依赖包，并确保所使用的包来自可信赖的来源。</p>
</blockquote>
<p>并描述了两种类型的克隆（clones）：</p>
<ol>
<li>完全相同的克隆（identical clones）：这类克隆包含与现有包完全相同的源代码。也就是说，这些克隆并没有对原始包的代码做任何修改，它们的目的可能是为了利用原始包的知名度来吸引更多的用户。</li>
<li>接近的克隆（close clones）：这类克隆在源代码中进行了潜在的重要的语法&#x2F;语义更改，但这些更改通常仅限于少数文件。尽管这些克隆与原始包非常相似，但它们的代码已经发生了一定程度的改变，这可能是为了引入恶意功能、规避检测或其他目的。</li>
</ol>
<p>并提出了出现这种问题的原因，npm缺乏官方的分叉（forking) 机制</p>
<blockquote>
<p>提到了 npm 生态系统中缺乏官方的分叉（forking）机制。官方的分叉机制指的是一种明确将派生的代码库与其来源代码库关联起来的方法。在其他一些平台（例如 GitHub）上，这种关联关系是非常常见的。</p>
<p>当在 GitHub 上 fork 一个仓库时，新的仓库会明确指出其来源于原始仓库。这种关联关系使得开发者可以更轻松地追踪到源仓库，并确保所用的代码库是经过验证且可信的。此外，fork 机制还方便开发者为原始仓库贡献代码，如提交改进和修复。</p>
<p>然而，在 npm 生态系统中，缺乏这样的官方分叉机制。这意味着当一个 npm 包被复制并上传到包仓库时，它无法明确地与原始包建立关联。这种情况可能导致开发者在选择依赖包时容易误用恶意克隆包，从而产生潜在的安全风险。</p>
<p>总之，“官方的分叉机制”是一种将派生的代码库与其来源代码库关联起来的方法。然而，npm 生态系统中缺乏这种机制，导致了一些潜在的安全隐患。</p>
</blockquote>
<p> “shrinkwrapped clones” 现象对包仓库卫生（hygiene）的挑战，特别是在 npm 包的混淆性（confusability）问题上。挑战在于：</p>
<ol>
<li>大量的包：npm 包含超过 170 万个包，这使得开发者在选择合适的包时面临巨大的挑战。</li>
<li>缺乏选择辅助：尽管 npm 生态系统提供了一个功能强大的搜索接口，但在选择最合适的包以提供所需功能方面，并未提供任何辅助。这可能导致开发者在选择包时感到困惑，无法准确判断哪个包是他们真正需要的。</li>
<li>包混淆：由于 “shrinkwrapped clones” 现象，npm 包可能存在很多相似的包，这些包可能具有相同或相似的名称、功能和代码。这使得开发者更容易误用恶意克隆包，从而产生潜在的安全风险。</li>
<li>类似拼写错误的攻击：之前的研究表明，开发者很容易在安装包时不小心安装了一个与他们预期不同的包。这类攻击，也称为 typosquatting 攻击，是指恶意开发者利用拼写类似的包名来误导开发者，使他们下载并使用恶意包。</li>
</ol>
<p>这篇工作主要研究 “shrinkwrapped clones” 的范围和影响。作者提到了在检测 “shrinkwrapped clones” 时面临的几个挑战，然后提出了一种解决方案。以下是这篇工作的主要内容：</p>
<ol>
<li>确定代码克隆的标准：没有一个公认的标准来确定何种程度的代码重用构成了代码克隆。</li>
<li>面临的挑战：接近的克隆（close clones）在原始包上进行了局部但复杂的语法修改，使它们与许多现有的克隆检测器不兼容。此外，为了确定一个包是否克隆了其他包，必须将该包与整个 npm 进行比较，这对代码分析来说是非常具有挑战性的。</li>
<li>解决方案：提出了一个可参数化的启发式方法，用于成对的包比较。该启发式方法通过一个可调的文件粒度语法距离阈值来定义 “shrinkwrapped clones”。根据这种方法，任何两个距离低于阈值的包被认为是接近的克隆（close clones），或者如果距离等于 1 则被认为是完全相同的克隆（identical clones）。</li>
<li>计算效率：启发式方法仅考虑整个文件的哈希值，避免了标记化和任何形式的词法分析，使其具有较高的计算效率。因此，在几秒钟内，就可以将一个包与整个 npm 进行比较以匹配克隆。</li>
<li>基于启发式方法，作者提出了 “unwrapper”：一种检测一个包是否是另一个更受欢迎包的克隆的机制。</li>
</ol>
<p>总之，这篇工作主要关注 “shrinkwrapped clones” 的范围和影响，提出了一个可参数化的启发式方法来检测克隆包，并实现了一个称为 “unwrapper” 的机制来检测一个包是否是另一个更受欢迎包的克隆。</p>
<p>本文的贡献主要包括以下几点：</p>
<ol>
<li>识别并描述了 npm 包仓库中 “shrinkwrapped clones” 问题的特征。</li>
<li>提出了 “unwrapper” 技术，用于检查一个包是否是其他任何包的 “shrinkwrapped clone”。</li>
<li>对 “unwrapper” 进行了评估，发现它在实际应用中能有效地识别 “shrinkwrapped clones”，且时间和空间开销合理（使用现成的硬件，大多数包可以在 72.85 秒内与现有的 2000 万个包进行比较以找出克隆包）。</li>
<li>根据对 npm 子集的分析报告了研究结果。分析发现，最多有 6,292 个克隆包。其中，最多有 2,159 个依赖于存在漏洞的过时依赖。此外，最多有 207 个克隆包直接集成了无法通过 npm 审计过程发现的漏洞。</li>
</ol>
<p>总之，本文通过识别和描述 “shrinkwrapped clones” 问题，提出了一种有效的检测技术，并对其进行了实际评估。同时，基于对 npm 子集的分析，报告了克隆包数量及其相关安全风险。这些贡献有助于提高开发者对 “shrinkwrapped clones” 问题的认识，并促进 npm 生态系统的安全性。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h3><ul>
<li>a. Research background of this article:<ul>
<li>本文探讨了npm软件包生态系统中存在的“收缩克隆”问题。</li>
</ul>
</li>
<li>b. Past methods, their problems, and motivation:<ul>
<li>过去的方法无法有效检测到收缩克隆所引起的风险，导致了软件包的卫生问题。</li>
</ul>
</li>
<li>c. Research methodology proposed in this paper:<ul>
<li>本研究提出了一种名为“unwrapper”的解决方案来自动检测和匹配收缩克隆。它包括三个模块：软件包爬虫，快速剔除无关的软件包的预过滤器，以及将潜在克隆对的目录树进行比较的克隆探测器。</li>
</ul>
</li>
<li>d. Task and performance achieved by the methods in this paper:<ul>
<li>该方法可以将单个软件包与整个npm生态系统中的其他软件包进行比较，并在72.85秒内发现许多包括“收缩克隆”在内的潜在克隆，包括那些通过标准的npm审计流程无法发现的存在潜在漏洞的软件包。</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h3><ul>
<li>a. Subject and characteristics:<ul>
<li>文章中的主题是软件包管理器和依赖项的相关安全问题，着重讨论了克隆检测工具、源代码作者归属、安全漏洞跟踪、对可执行二进制文件中的程序员的匿名化、攻击软件包管理器等问题。</li>
</ul>
</li>
<li>b. Historical development:<ul>
<li>过去的方法缺乏有效性，不能满足当下的软件包卫生问题。研究中需要探讨更多克隆检测、克隆相似度测量、克隆和拥有的重用分析等方面的问题。</li>
</ul>
</li>
<li>c. Past methods:<ul>
<li>过去的方法无法有效检测到软件包中克隆的存在。</li>
</ul>
</li>
<li>d. Past research shortcomings:<ul>
<li>过去的研究缺乏有效的解决方案，未能探讨软件包管理器和依赖项的相关安全问题。</li>
</ul>
</li>
<li>e. Current issues to address:<ul>
<li>当前，需要解决的问题是软件包卫生问题，提高软件包的合规性和安全性。</li>
</ul>
</li>
</ul>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods:"></a>Methods:</h3><ul>
<li>a. Theoretical basis of the study:<ul>
<li>本研究的主要理论基础是克隆检测和计算机科学。</li>
</ul>
</li>
<li>b. Technical route of the article (step by step):<ul>
<li>本研究提出了一种名为“unwrapper”的解决方案来自动检测和匹配收缩克隆。该方案包括三个模块：软件包爬虫、预过滤器和克隆探测器。软件包爬虫检索npm生态系统中的所有软件包。预过滤器根据早期的结果快速筛选掉不太可能会是原始克隆的软件包。克隆探测器使用树状结构比较软件包之间的差异，通过检测潜在克隆对之间的重合度，定量衡量其相似性。</li>
</ul>
</li>
<li>c. Empirical process of the study:<ul>
<li>通过这个方法，可以在72.85秒内自动检测和匹配收缩克隆，并识别出其中许多存在潜在漏洞的软件包，这些漏洞无法通过标准的npm审计流程发现。</li>
</ul>
</li>
<li>d. Data collection and analysis:<ul>
<li>作者通过构建软件包爬虫，并使用npm依赖图构建了一个包的索引，以发现收缩克隆。</li>
</ul>
</li>
</ul>
<h4 id="3-1-unwrapper-Assumptions-and-Goals"><a href="#3-1-unwrapper-Assumptions-and-Goals" class="headerlink" title="3.1  unwrapper Assumptions and Goals"></a><strong>3.1  unwrapper Assumptions and Goals</strong></h4><p>这段内容概括了 “unwrapper” 的高层目标和挑战。以下是主要观点的总结：</p>
<ol>
<li>识别相似包：在高层次上，研究者们希望建立一种方法来识别与已知包相似的包，并提出实用技术在生态系统范围内识别这些对象。</li>
<li>无代码级别混淆假设：研究者们假设开发者不会试图在代码级别混淆相似性。这一假设基于缺乏这样做的动机，因为大多数 npm 包代码都是在允许重用的许可证下提供的，代码重复没有直接的负面后果。</li>
<li>恢复包代码的来源：”unwrapper” 可用于检测已存在于 npm 中的 shrinkwrapped clones，从而恢复包代码的来源。这样，npm 用户可以检测他们依赖的包是否为 shrinkwrapped clones，并建议可能更适合的原始包。</li>
<li>主动检测新包：”unwrapper” 还可以在发布新包时主动检测它是否为克隆包。</li>
<li>分析挑战：npm 的流行使得分析变得具有挑战性，因为已存在于仓库中的包数量相当大。此外，shrinkwrapped clones 的一个关键问题是它们克隆的是其他包的非当前版本。因此，”unwrapper” 需要将感兴趣的包与整个 npm 生态系统中的所有包（包括所有包的所有版本）进行匹配。</li>
<li>实时处理新包：大约每天有 850 个新包上传到 npm。”unwrapper” 必须能够在不拖慢部署速度的情况下处理所有新包。</li>
</ol>
<h4 id="3-2-Design-Overview"><a href="#3-2-Design-Overview" class="headerlink" title="3.2 Design Overview"></a><strong>3.2 Design Overview</strong></h4><p>基于上述讨论，这段内容概述了 “unwrapper” 的设计，其目标是随着仓库的增长进行扩展，分析相对快速且轻量级，并能在与仓库本身分离的环境中运行。以下是主要观点的总结：</p>
<ol>
<li>设计目标：unwrapper 的设计目标是能够随仓库的增长而扩展，分析相对快速且轻量级，并能在与仓库本身分离的环境中运行。</li>
<li>整体流程：unwrapper 的整体流程如图 1 所示。首先通过 npm 爬虫和监听器获取包（图 1 中的模块 1）。确定一个包是否是另一个包的克隆主要由 Clone Detector 组件（模块 3）完成。</li>
<li>检测方法：shrinkwrapped clone 检测方法利用了识别候选原始-克隆对之间目录树的差异，其中每个文件节点由其名称和校验和标记，不考虑关于文件的其他信息。这种方法不需要进行任何代码分析，除了计算校验和，并符合非对抗性设置的假设。</li>
<li>预过滤步骤：研究者们发现，虽然这种方法效率高，但对新包上传的实时分析时间过长。因此，他们在包数据集和克隆检测器之间增加了预过滤步骤（模块 2）。这个预过滤器可以快速筛选出不太可能是 shrinkwrapped clones 的包。</li>
</ol>
<h4 id="3-3-npm-Interface"><a href="#3-3-npm-Interface" class="headerlink" title="3.3 npm Interface"></a><strong>3.3 npm Interface</strong></h4><p>描述了 unwrapper 的 npm 接口。unwrapper 的前端与 npm 交互，以收集所有可用包的每个版本的信息，并及时分析新包。以下是关键点的总结：</p>
<ol>
<li>收集包：通过实现 npm 爬虫来完成包的收集，下载并将每个包的版本本地存储。这种方法允许快速访问包，而不会给仓库带来分析请求的负担。</li>
<li>数据库更新：包的更改需要作为新版本进行，包数据库对于所有现有包版本保持准确，只需要在新版本添加到仓库时进行更新。</li>
<li>支持更新：实现了一个 npm 监听器，当新包或现有包的新版本添加到仓库时触发。新条目会自动添加到本地包数据库，并排队等待检测是否为 shrinkwrapped clones。</li>
<li>实时更新：监听器使用 npm webhook 系统，自动通知更新，无需轮询。通过这个系统，新包和版本实时添加到分析队列中。</li>
</ol>
<h4 id="3-4-Clone-Detector"><a href="#3-4-Clone-Detector" class="headerlink" title="3.4 Clone Detector"></a><strong>3.4 Clone Detector</strong></h4><p>这段话描述了克隆检测器的设计。克隆检测器接收一对候选的 shrinkwrapped clone 包，并通过计算一个特定领域的成对差异度量（称为 𝑑-score）来评估它们的相似性。关键点如下：</p>
<ul>
<li>​                                                                 𝑑<strong>𝑃,𝑄* &#x3D; <em>𝐼</em> + 2(*𝑈</strong>𝑃* + <em>𝑈**𝑄</em> )</li>
</ul>
<ol>
<li>𝑑-score：定义了两个包 𝑃 和 𝑄 之间的差异度量。它由相同文件名但具有不同校验和的文件数量 𝐼 和仅在一个包中具有唯一文件名的文件数量 𝑈𝑃，𝑈𝑄 组成。较低的差异分数表示包之间更相似，差异分数为 1 的包在语义上相同，仅在保证每个包具有唯一的 package.json 元数据文件方面有所不同。</li>
<li>差异阈值：通过手动构建克隆包的初始数据集来确定合适的差异阈值。分析了 10,000 个最受欢迎的 npm 包中仓库 URL 的重复情况。在对 38 个包进行手动审查之后，选取了𝑑-score 为 11 作为判断两个包是否为 shrinkwrapped clones 的阈值。</li>
<li>调整阈值：在包文件数量较少的情况下，进一步调整 𝑑-score 阈值，以防止小包被错误地报告为其他小包的 shrinkwrapped clones。根据文件树大小，通过经验测量选择了 𝑑-score 阈值。</li>
</ol>
<p>通过这个克隆检测器，可以评估和确定候选包是否是另一个包的 shrinkwrapped clone。</p>
<h4 id="3-5-Clone-Prefilter"><a href="#3-5-Clone-Prefilter" class="headerlink" title="3.5 Clone Prefilter"></a><strong>3.5 Clone Prefilter</strong></h4><p>这段文字描述了克隆预过滤器的设计和实现。预过滤器的目的是加速实时检测 shrinkwrapped clones 的过程，同时考虑到 npm 生态系统的规模和快速增长。关键点如下：</p>
<ol>
<li>预过滤器的设计目标：加速与现有包数据集的匹配，排除在完整克隆检测过程中不太可能被标记为克隆的包。</li>
<li>预计算信息：为了加速预过滤器中的匹配，尽可能预计算有关仓库中已知包的信息，同时确保预计算信息的内存占用与现成硬件兼容。</li>
<li>指纹：预过滤器使用文件夹结构相似性来识别潜在的克隆，但仅基于文件名。通过计算每个包的指纹（𝐹𝑃 &#x3D; {ℎ(𝑝1), …, ℎ(𝑝𝑛)}），然后根据指纹计算包之间的相似度。</li>
<li>阈值：设置阈值 𝑇𝑆 和 𝑇𝑂，用于排除或保留候选克隆。根据 ROC 曲线分析，𝑇𝑆 &#x3D; 2 和 𝑇𝑂 &#x3D; 0.8 可以实现最小化假阴性和假阳性的良好平衡。</li>
</ol>
<p>克隆预过滤器通过这种方式加速了克隆检测过程，同时在保持较高检测效率的同时忽略了文件内容。</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation:"></a>Evaluation:</h3><p>为了评估 shrinkwrapped 克隆检测流水线的实用性和有效性，文章关注回答以下三个研究问题：</p>
<p>• RQ1：pipline在为整个 npm 包仓库生成预过滤器指纹方面的性能是否令人满意？ </p>
<p>• RQ2：pipline是否具有实时性能，能够跟上 npm 的增长速度？</p>
<p>• RQ3：pipline是否能有效区分 shrinkwrapped 克隆和新包？</p>
<p><strong>4.1 Performance</strong></p>
<p>本节讨论了shrinkwrapped克隆检测流水线的在线和离线性能。通过在具有2.1 GHz英特尔至强金牌处理器的CentOS Linux 8服务器上进行的1000次独立试验，作者测量了shrinkwrapped克隆检测器和预过滤器执行操作所需的最小、最大和平均时间，并在表3中呈现了测量到的性能指标。</p>
<p>预过滤器指纹生成：shrinkwrapped克隆检测依赖于npm中每个版本的每个包的文件结构信息。为使流水线正常工作，需要将所有2019万个独特版本的包添加到预过滤器的指纹数据库中。预过滤器将单个包版本添加到其指纹数据库的平均时间为5.24毫秒，因此，生成包含npm中所有独特包版本的指纹数据库需要29.39小时的CPU时间。通过将此过程在多个CPU核心上并行化，可以将所需时间缩短到29.39小时的一小部分。考虑到并行化，作者认为整个npm包仓库的预过滤器指纹生成性能是合理的，因为预过滤器的指纹数据库只需要生成一次。</p>
<p>实时克隆检测：由于npm每天新增包的数量在快速增长，实时shrinkwrapped克隆检测需要具备可随npm增长速度扩展的性能。撰写本文时，npm的增长速度为每天超过850个新包。为了跟上npm上的新包，流水线需要将新包添加到预过滤器并对其进行测试，然后将预过滤器报告的任何阳性结果与克隆检测器进行验证。表3.2详细说明了克隆检测器判断一个包是否是另一个包的克隆所需的时间。典型情况下，候选克隆将与预过滤器中的多个潜在匹配进行比较，我们报告了第一次测试和后续测试的分析时间。后续测试通常更快，因为候选克隆的文件哈希只需计算一次。</p>
<p>根据表3中的性能结果，只要预过滤器报告的平均阳性结果少于122个，shrinkwrapped克隆检测流水线就可以在1&#x2F;850天内仅使用单个CPU核心执行其所需操作。实际上，发现大多数包可以在72.85秒内完成整个shrinkwrapped克隆检测流水线的测试。值得注意的是，shrinkwrapped克隆检测过程具有很高的可并行性，如果npm的增长速度或预过滤器报告</p>
<p><strong>4.2 Effectiveness of Clone Detection</strong></p>
<p>现在我们分析RQ3中描述的检测shrinkwrapped克隆的工具的有效性。</p>
<p>克隆检测器：由于缺乏关于一个包是否是另一个包的克隆的确凿证据，我们依赖随机抽样和人工审核来验证shrinkwrapped克隆检测器的有效性。我们的真阳性验证过程如下：首先收集克隆检测器积极识别为另一个包的（非相同）克隆的包的随机样本。然后，人工检查识别出的原始克隆关系中的两个包的文件树结构和文件内容。最后，如果无法从包文件中明确识别出克隆关系，我们将识别出的克隆包标记为假阳性。在我们的检测器报告的100个克隆包的随机样本中，我们发现了94个真阳性和6个假阳性。</p>
<p>我们发现克隆检测器报告的假阳性具有一组共同特性，这些特性增加了克隆检测的难度。它们都是功能有限的小包，包含很少的文件，并且具有简短且不具描述性的名称，如copy、merge和capitalize。因此，这些包与提供类似功能的独立实现的其他小包类似，而我们的克隆检测器可能会误报它们为克隆。尽管存在这些少量假阳性，但我们认为克隆检测器94%的精确度在准确检测shrinkwrapped克隆方面是令人满意的。</p>
<p>预过滤器：我们使用克隆检测器识别出的克隆包作为评估预过滤器有效性的基础。我们随机抽样1000个已识别的克隆包，用预过滤器对它们进行测试，然后记录预过滤器报告的阳性结果的总数和类型。通过这个实验，我们发现预过滤器的召回率（即正确识别已知克隆关系的百分比）为95.3%。我们在图5中展示了预过滤器识别出的观察到的假阳性的累积分布函数。从这个分布中，我们发现预过滤器报告的假阳性中位数为8，尽管存在少量输入包生成数千个假阳性结果。这与预过滤器的设计目标一致，即以牺牲精确度为代价最大化召回率。</p>
<p><strong>4.3 Analysis of Clone Packages</strong></p>
<p>本段话研究了npm包中存在的克隆包的数量、类型、受欢迎程度、依赖关系、维护情况和潜在漏洞等问题。作者随机选择了6000个npm包作为样本，通过检测发现有626个包是克隆包，占比约为10.4%。作者进一步分析了其中175个克隆包的名称与被克隆包的名称有重叠，认为这些克隆包对npm生态系统的健康更具威胁性。作者还区分了完全相同的克隆包和近似的克隆包，并发现其中有348个完全相同的克隆包和5944个近似的克隆包。作者分析了克隆包的受欢迎程度，发现其中21个完全相同的克隆包和399个近似的克隆包每周下载量超过350次，有可能对真实用户造成影响。作者还分析了克隆包的依赖关系，发现有397个npm包依赖于完全相同的克隆包，而6496个npm包依赖于近似的克隆包。作者还分析了克隆包的维护情况，发现其中209个完全相同的克隆包和2744个近似的克隆包从未接受过更新，这对npm生态系统的健康构成了严重威胁。最后，作者分析了克隆包可能存在的潜在漏洞，发现62个完全相同的克隆包和2304个近似的克隆包存在未在最新版本中修复的漏洞。其中有一些漏洞可能被npm  audit检测出来，但有一些漏洞则难以检测，因此对真实用户造成了风险。作者还研究了克隆包的代码库URL，发现一些克隆包会复制被克隆包的代码库URL，但不是所有克隆包都会这么做，因此URL并不能作为检测克隆包的充分依据。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ul>
<li>a. Significance of the work:<ul>
<li>本研究提出了一种可行的解决方案，自动检测和匹配“收缩克隆”，提高软件包的合规性和安全性。</li>
</ul>
</li>
<li>b. Innovation, performance, and workload:<ul>
<li>该研究的创新在于提出了一种名为“unwrapper”的解决方案来解决“收缩克隆”问题，并通过树状比较等有效的算法，提高了性能。其工作量较大。</li>
</ul>
</li>
<li>c. Research conclusions (list points):<ul>
<li>本文提出了一种可行的解决方案，对于检测和匹配“收缩克隆”问题具有一定的效果。</li>
<li>“unwrapper”工具包括三个模块：软件包爬虫、预过滤器和克隆探测器。</li>
<li>更为有效的树状比较算法以及计算相似度的阈值有利于准确识别软件包的相似性。</li>
<li>“unwrapper”可运用于大规模的软件包卫生检测和监控，并且可以有效提高软件包的合规性和安全性。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Static Type Inference for Foreign Functions of Python</title>
    <url>/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/</url>
    <content><![CDATA[<h2 id="Static-Type-Inference-for-Foreign-Functions-of-Python"><a href="#Static-Type-Inference-for-Foreign-Functions-of-Python" class="headerlink" title="Static Type Inference for Foreign Functions of Python"></a>Static Type Inference for Foreign Functions of Python</h2><p>在这篇论文中，作者针对Python中的外部函数提出了一种静态类型推断方法。外部函数是指那些由其他编程语言实现的函数，它们在Python中被调用。由于这些函数在运行时可能会引发类型错误，因此静态类型推断在提高代码可靠性和安全性方面具有重要意义。</p>
<p>作者提出了一种基于概率的类型推断方法，通过对外部函数接口的分析，自动生成类型注解。这种方法可以自动识别和处理类型信息，有效提高了类型推断的准确性。同时，作者还提出了一种类型错误检测方法，用于识别潜在的类型错误并给出相应的警告。</p>
<p>在论文中，作者通过实验验证了所提方法的有效性。实验数据显示，所提出的类型推断方法在大多数情况下能够准确地推断出外部函数的类型信息，从而有助于提高Python程序的可靠性和安全性。总的来说，这篇论文为Python中外部函数的静态类型推断问题提供了一种有效的解决方案。</p>
<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul>
<li>提出了外部函数接口（FFI）产生的类型误用的问题</li>
<li>总结了Python静态类型推断方法和工具，如基于类型注解的Mypy、Pyright和Pyre。然而，这些方法要求修改源代码，违反了Python的敏捷编码实践。还有一些基于机器学习的方法，产生的结果具有非确定性。其他现有工具（如Pytype和PySonar）不支持外部函数的静态类型推断，它们要么忽略这些函数（导致严重的精度损失），要么使用预设类型桩（需要大量的手工操作）。</li>
<li>FFI是一种机制，允许用一种编程语言编写的程序调用另一种语言编写的函数。对于静态类型语言（如Java和OCaml），外部函数需要声明显式类型。对于动态类型语言（如Python），作者提出可以通过分析调用接口描述中的隐含信息来静态地推断外部函数的约束条件，例如参数的数量和类型。</li>
<li>作者提出了PYCTYPE，一个用于推断Python外部函数类型的静态类型推断系统。PYCTYPE基于一组规则来推断外部函数的类型签名，这些规则可以分为三类：(1) 外部函数声明，说明如何将C实现与Python调用结合；(2) 参数类型转换，说明如何将从Python端传递的参数转换为C类型的对象；(3)  返回类型转换，说明如何为从Python调用的外部函数构建返回值。作者通过在CPython、NumPy和Pillow这三个具有代表性且大量使用Python&#x2F;C多语言的项目上评估PYCTYPE，证明了该系统的有效性。</li>
<li>据我们所知，这是第一项（i）提出一种不基于机器学习和类型注解的Python外部函数静态类型推断系统；（ii）调查不符合调用约定声明的外部函数实现与类型要求不匹配的缺陷的研究。</li>
<li>综上所述，我们做出了以下贡献：</li>
</ul>
<ol>
<li>为Python的外部函数定义了一个静态类型推断系统，该系统由一系列规则构成。该系统包含了Python和C之间接口代码的几种静态分析。基于外部函数接口的方法可以扩展到除Python之外的动态类型宿主语言。</li>
<li>通过原型方法PYCTYPE进行实现。在三个具有代表性的项目上的评估表明，PYCTYPE可以为大多数外部函数推断类型签名。推断结果在设计上是可靠的，通过将更多Python&#x2F;C API纳入系统，完整性可以得到提高。通过将PYCTYPE的结果作为Pytype的补充，证明了它在分析具有外部函数的Python程序中的有效性。</li>
<li>作为类型系统的一部分，用于检查外部函数声明和实现一致性的规则被表示为门控语义谓词和它们的合取范式。该系统在三个常用项目中发现了48个不匹配的错误。这些错误使得将任何类型的参数传递给无参数的外部函数成为合法操作，其中8个错误已经得到了社区的确认和修复。</li>
</ol>
<p><font color="red"><strong>Example</strong></font></p>
<p>当使用FFI时，类型误用问题可能会导致程序崩溃或产生不可预期的行为。这里有一个简单的例子，说明如何在Python中调用C函数时可能发生类型误用问题。</p>
<p>假设我们有一个C语言库，名为<code>example2.c</code>，其中包含一个将两个浮点数相加的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">add_floats</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要编译这个C文件并创建一个共享库。在Linux和macOS上，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared -o example2.so example2.c</span><br></pre></td></tr></table></figure>

<p>在Windows上，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared -o example2.dll example2.c</span><br></pre></td></tr></table></figure>

<p>现在，我们已经有了一个名为<code>example2.so</code>（在Linux和macOS上）或<code>example2.dll</code>（在Windows上）的共享库。接下来，我们需要使用Python的ctypes库来调用这个C语言函数。但是，我们在声明函数参数和返回值类型时犯了一个错误，将<code>c_float</code>误写为<code>c_int</code>。创建一个名为<code>ffi_example2.py</code>的Python文件，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> CDLL, c_float, c_int</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the shared library</span></span><br><span class="line">lib_example2 = CDLL(<span class="string">&#x27;./example2.so&#x27;</span>)  <span class="comment"># On Linux and macOS</span></span><br><span class="line"><span class="comment"># lib_example2 = CDLL(&#x27;./example2.dll&#x27;)  # On Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Incorrectly define the argument types and the return type of the &#x27;add_floats&#x27; function</span></span><br><span class="line">lib_example2.add_floats.argtypes = [c_int, c_int]</span><br><span class="line">lib_example2.add_floats.restype = c_int</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the &#x27;add_floats&#x27; function from the C library with incorrect types</span></span><br><span class="line">result = lib_example2.add_floats(<span class="number">3.5</span>, <span class="number">4.2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum of 3.5 and 4.2 is:&quot;</span>, result)</span><br></pre></td></tr></table></figure>

<p>运行<code>ffi_example2.py</code>文件时，我们可能会得到错误的输出或程序崩溃，因为我们错误地将浮点数类型（<code>c_float</code>）与整数类型（<code>c_int</code>）混淆。这个例子展示了在使用FFI时，类型误用可能会导致问题。为了避免这种问题，我们需要仔细检查我们在Python代码中声明的C函数的参数类型和返回类型，确保它们与C库中的实际类型相匹配。</p>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><font color="red">Python&#x2F;C多语言体系结构</font></p>
<p>这个例子展示了一个简化的C扩展模块与Python结合的情况。在这个例子中，我们有三个代码文件：host.py、interface.c和foreign.c。</p>
<p><strong>host.py (Python主程序)：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> extm</span><br><span class="line">...</span><br><span class="line">size = extm.foo(width, height)</span><br></pre></td></tr></table></figure>

<p>ost.py是Python主程序，它导入了一个名为extm的C扩展模块，并调用了其中的<code>foo</code>函数。<code>width</code>和<code>height</code>是传递给<code>foo</code>函数的参数。</p>
<p><strong>interface.c (接口代码)：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef extMethods[] = &#123;</span><br><span class="line">	&#123;<span class="string">&quot;foo&quot;</span>, (PyCFunction) foo, METH_VARARGS, <span class="string">&quot;docstring&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">extModule</span> =</span> &#123;</span><br><span class="line">	PyModuleDef_HEAD_INIT, <span class="string">&quot;extm&quot;</span>, <span class="string">&quot;docstring&quot;</span>, <span class="number">-1</span>,</span><br><span class="line">		extMethods</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>interface.c是连接Python和C代码的接口。它定义了一个名为<code>extMethods</code>的方法表，其中包含了外部函数<code>foo</code>的信息。<code>foo</code>的C实现指向名为<code>foo</code>的C函数（在foreign.c中定义），并通过<code>METH_VARARGS</code>指定了调用约定。接着，我们定义了一个名为<code>extModule</code>的模块定义结构，将<code>extMethods</code>与模块关联起来。</p>
<p><strong>foreign.c (外部C函数)：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject* <span class="title function_">foo</span><span class="params">(PyObject* self, PyObject* args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;ii&quot;</span>, &amp;x, &amp;y))</span><br><span class="line">	     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> PyLong_FromLong(x * y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreign.c是C扩展模块的实现部分。它包含了一个名为<code>foo</code>的C函数，该函数接收两个<code>PyObject*</code>类型的参数。<code>self</code>是模块对象（如果在<code>PyModuleDef</code>中定义）或者是类对象（如果在<code>PyTypeObject</code>中定义），而<code>args</code>是包含从Python传递过来的所有参数的元组对象。在这个例子中，<code>foo</code>函数通过<code>PyArg_ParseTuple</code>函数解析<code>args</code>中的参数，并将其存储在整数变量<code>x</code>和<code>y</code>中。然后，<code>foo</code>函数计算<code>x</code>和<code>y</code>的乘积并将其作为一个Python长整数对象返回。</p>
<p>通过这个例子，我们可以看到Python主程序如何调用C扩展模块中的外部函数，以及如何在接口代码中定义外部函数及其调用约定。这个例子展示了Python和C语言通过接口代码进行交互的过程。</p>
<p><font color="red">针对单一语言的静态类型推理</font></p>
<p>这段话主要讨论了现有的确定性Python静态类型推断工具在处理动态类型语言（如Python）中的外部函数时面临的挑战。这些工具通常基于单一语言视图进行分析，无法在编译时检查外部函数的参数和返回值类型。就上面那个例子，现有的工具不能推断出host.py中的Width和height的类型。</p>
<p>原因是动态类型语言不能在编译时访问类型信息。</p>
<p>这篇论文通过引用Java <code>native</code>关键字的例子来说明，在静态类型语言中（如Java），外部函数声明（foreign function declaration）通常包含明确的类型信息。这有助于编译时进行类型检查，从而降低类型误用的风险。例如，在Java中，关键字本机声明了一个名为bcopy的外部函数，它的外部函数接受一个字节[]类型的参数并返回void。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bcopy</span><span class="params">(<span class="type">byte</span>[] arr)</span>;</span><br></pre></td></tr></table></figure>

<p>作为一种解决方案，谷歌的Pytype工具采用了来自Python社区的Typeshed作为外部类型注释。Typeshed和Mypy中的类似模块stubgen通过手动编码、文档提取和运行时内省生成类型存根。然而，这些方法难以大规模应用，因此Typeshed仅支持少数第三方库。此外，在现实世界场景中，C扩展模块通常是仅供内部使用的私有库。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><font color="red">问题概述</font></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412171657717.png" alt="image-20230412171657717"></p>
<p>本节提供了一种分析Python与C之间接口代码中隐含类型转换信息的方法。作者通过单语言和多语言类型系统视角对外部函数调用进行比较。</p>
<p>在单语言视角下（蓝色虚线），无法静态地推断外部函数的参数类型和返回类型，因为与Python中实现的本地函数不同，外部函数是使用Python&#x2F;C API在C中实现的。在多语言视角下（红色实线），动态类型语言的接口代码通过Python&#x2F;C API和程序属性提供的隐含信息，描述如何声明外部函数（D）以及如何进行类型转换（P和R）。</p>
<p><font color="red">抽象语法</font></p>
<p>本篇论文的工具PYCTYPE支持CPython 3.3+和C99</p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412211045235.png" alt="image-20230412211045235"></p>
<p><font color="red">类型</font></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412211508790.png" alt="image-20230412211508790"></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412212446620.png" alt="image-20230412212446620"></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412212500008.png" alt="image-20230412212500008"></p>
<p>本节介绍了Python和C的类型集合，分别表示为Tp和Tc。图4定义了每个Python类型的抽象语法形式，即τ,η∈Tp，而图6表示C类型的形式，即α,β∈Tc。</p>
<p>作为一种动态类型语言，Python侧的类型包含程序执行时可以绑定到Python变量的类型值，如str（CPython 3.x中的unicode），int，object，dict等。除了这些内置类型外，product type（pProduct）可用于表示列表、元组和字典等类型，function type（pFunc）可用于表示Python函数（本地或外部）。pUnion用类型集实例化，它也是CPython运行时之外的一种类型。外部函数的参数可以是联合类型，这在C语言中是一种常见的特性。模块和迭代器等类型在此省略，因为它们不能用C的特性表示，且在通过外部函数接口传递时将被视为对象。</p>
<p>同时，调用接口描述实际上不仅可以指示类型转换，还可以指示比内置类型更严格的值约束。例如，格式单位（详见第IV-D2节）“b, B, H, I, k, K”要求传递给外部函数调用的参数必须是非负整数。因此，我们引入pInt nonnegative作为pInt的子类型。给定一个子类型关系&lt;:，如果任何类型为τ的项可以用在期望类型为τ的上下文中，则τ是τ的子类型（τ&lt;:τ）。图5列出了Python侧类型的子类型规则。</p>
<p>C侧的类型包括常见的C类型，如int，用于描述CPython中内置类型的C结构，如Py_UNICODE，以及为支持类型系统中的语言特性而引入的类型，如cProduct。由于Python侧的类型都带有“p”前缀，我们可以像往常一样使用常见的C类型表示法，而不会引起歧义。</p>
<p><font color="cornflowerblue">为什么需要Subtyping rules of types on the Python side呢</font></p>
<p>例如，在将Python对象传递给外部函数（如C函数）时，我们需要确保传递的对象满足特定类型约束。子类型规则可以帮助我们识别哪些类型是兼容的，从而减少类型错误和运行时错误的风险。我觉得要将Python的Int c拆成（unsign int, small int, big int）等等，分别对应C语言的(unsign , int, long)</p>
<p><font color="red">推理规则</font></p>
<p>A、假设判断</p>
<p>本文提出了一种类型系统，用于描述在主机端和外部端之间的变量类型约束和转换规则。该系统主要包括以下几个假设性判断：</p>
<ol>
<li>类型赋值（Type assignment）：表示在给定类型上下文Γ下，构造函数e具有类型τ。类型上下文Γ包括变量x的假设，分为主机端和外部端。</li>
<li>本地函数与外部函数：本地函数是在主机端定义和应用的函数，而外部函数是在主机端调用但在外部端定义的函数。</li>
<li>外部函数声明（Foreign function declaration）：将在主机端调用的外部函数名映射到在外部端实现的函数定义。</li>
<li>参数类型转换（Parameter type conversion）和返回类型转换（Return type conversion）：通过引入表示类型转换协议的属性P，可以推导在两种语言之间的类型约束和转换规则。</li>
<li>在满足某些程序属性P的前提下，判断类型转换是否可行。</li>
</ol>
<p>通过这个类型系统，可以在AST（抽象语法树）和CFG（控制流图）等中间表示中推理不同接口代码单元的静态分析，进而有效地处理Python与C之间的交互。</p>
<p>B、类型推理</p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412221855051.png" alt="image-20230412221855051"></p>
<p>C. 外部函数声明</p>
<p>这段文字描述了C外部函数声明和Python实现之间的关系，特别是调用约定和标志，用于指定如何将Python参数传递到C实现中。该段文字还提到，系统中包括了基于Python&#x2F;C API参考手册和CPython实现的其他调用约定标志。</p>
<p>D. 参数类型转换</p>
<p>1)调用约定分析：</p>
<p>2)参数解析分析：</p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412224943740.png" alt="image-20230412224943740"></p>
<p>E. 返回类型转换</p>
<p><em>1) Value Building Analysis:</em></p>
<p><em>2) Explicit Conversion Analysis:</em></p>
<p><em>3) Type Cast Analysis:</em> </p>
<p><em>4) Reaching Defifinition Analysis:</em></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412225256825.png" alt="image-20230412225256825"></p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>我们在三个具有代表性和广泛使用的Python&#x2F;C项目上进行了实验，即CPython、NumPy和Pillow。</p>
<p><strong>完整性实验</strong></p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412225336529.png" alt="image-20230412225336529"></p>
<p><strong>有效性实验</strong></p>
<p>手动检查</p>
<p>结合Pytype证明有效性</p>
<p><img src="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/image-20230412230248554.png" alt="image-20230412230248554"></p>
<p><strong>不匹配的错误</strong></p>
<p>该系统在三个常用项目中发现了48个不匹配的错误。这些错误使得将任何类型的参数传递给无参数的外部函数成为合法操作，其中8个错误已经得到了社区的确认和修复。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>20-Python类机制的深度解析：实例对象的创建、以及属性访问</title>
    <url>/2023/04/13/20-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="20-Python类机制的深度解析-第四部分-实例对象的创建、以及属性访问"><a href="#20-Python类机制的深度解析-第四部分-实例对象的创建、以及属性访问" class="headerlink" title="20-Python类机制的深度解析(第四部分): 实例对象的创建、以及属性访问"></a>20-Python类机制的深度解析(第四部分): 实例对象的创建、以及属性访问</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>介绍完类对象之后，我们来介绍实例对象。我们之前费了老鼻子劲将类对象剖析了一遍，但这仅仅是万里长征的第一步。因为Python虚拟机执行时，在内存中兴风作浪的是一个个的实例对象，而类对象只是幕后英雄。</strong></p>
<h3 id="通过class类对象创建实例对象"><a href="#通过class类对象创建实例对象" class="headerlink" title="通过class类对象创建实例对象"></a>通过class类对象创建实例对象</h3><p><strong>我们还以之前的代码为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br></pre></td></tr></table></figure>

<p><strong>看一下它的字节码，这里我们只看创建实例对象的字节码，也就是模块的字节码。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">             <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x000002B7A85FABE0</span>, file <span class="string">&quot;instance&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">             <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">            <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>          <span class="number">14</span> LOAD_NAME                <span class="number">0</span> (Girl)</span><br><span class="line">            <span class="number">16</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">18</span> STORE_NAME               <span class="number">1</span> (girl)</span><br><span class="line">            <span class="number">20</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">            <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在类构建完毕之后，14  LOAD_NAME这条指令便将刚刚构建的类Girl取了出来、压入运行时栈，然后通过CALL_FUNCTION将栈里面的类弹出、进行调用，得到实例对象，再将实例对象设置在栈顶。18 STORE_NAME将栈顶的实例对象弹出，让符号girl与之绑定，放在local空间中。</strong></p>
<p><strong>所以我们看到调用类对象的指令居然也是CALL_FUNCTION，因为一开始我们说了，类和函数一样，都是要先将PyCodeObject变成PyFunctionObject。</strong></p>
<p><strong>因此执行完毕之后，模块的local空间就会变成这样：</strong></p>
<p><img src="/2023/04/13/20-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE/1229382-20200902230328951-1929168710.png" alt="img"></p>
<p><strong>在CALL_FUNCTION中，Python同样会执行对应类型的tp_call操作。所以创建实例的时候，显然执行PyType_Type的tp_call，因此最终是在PyType_Type.tp_call中调用Girl.tp_new来创建instance对象的。</strong></p>
<p><strong>需要注意的是，在创建class  Girl这个对象时，Python虚拟机调用PyType_Ready对class  Girl进行了初始化，其中一项动作就是继承基类，所以Girl.tp_new实际上就是object.tp_new，而在PyBaseObject_Type中，这个操作被定义为object_new。创建class对象和创建instance对象的不同之处正是在于tp_new不同。创建class对象，Python虚拟机使用的是tp_new，创建instance对象，Python虚拟机则使用object_new。使用类重写__new__的话，应该很容易明白。</strong></p>
<p><strong>因此，由于我们创建的不是class对象，而是instance对象，type_call会尝试进行初始化的动作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么这个tp_init是哪里来的的，是在使用tp_new创建类对象的时候来的，tp_init在PyType_Ready时会继承PyBaseObject_Type的object_init操作。但正如我们之前说的那样，因为A中的定义重写了__init__，所以在 *fixup_slot_dispatchers* 中，tp_init会指向slotdef中指定的与__init__对应的slot_tp_init。并且还会设置tp_alloc，这与内存分配有关，源码中会有所体现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_new</span><span class="params">(PyTypeObject *metatype, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//tp_alloc被设置为PyType_GenericAlloc, 表示为实例对象分配内存, 因为内存大小的元信息存在对应的类对象中</span></span><br><span class="line">    <span class="comment">//并且在分配内存的同时会将实例对象的ob_type设置为对应的类对象</span></span><br><span class="line">    type-&gt;tp_alloc = PyType_GenericAlloc;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_flags &amp; Py_TPFLAGS_HAVE_GC) &#123;</span><br><span class="line">        type-&gt;tp_free = PyObject_GC_Del;</span><br><span class="line">        type-&gt;tp_traverse = subtype_traverse;</span><br><span class="line">        type-&gt;tp_clear = subtype_clear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        type-&gt;tp_free = PyObject_Del;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置tp_init</span></span><br><span class="line">    fixup_slot_dispatchers(type);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyType_GenericAlloc</span><span class="params">(PyTypeObject *type, Py_ssize_t nitems)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = _PyObject_VAR_SIZE(type, nitems+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_IS_GC(type))</span><br><span class="line">        obj = _PyObject_GC_Malloc(size);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        obj = (PyObject *)PyObject_MALLOC(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(obj, <span class="string">&#x27;\0&#x27;</span>, size);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置实例对象的ob_type</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_itemsize == <span class="number">0</span>)</span><br><span class="line">        (<span class="type">void</span>)PyObject_INIT(obj, type);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        (<span class="type">void</span>) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_IS_GC(type))</span><br><span class="line">        _PyObject_GC_TRACK(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>而在 *slot_tp_init* 中又做了哪些事情呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">slot_tp_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__init__);</span><br><span class="line">    <span class="type">int</span> unbound;</span><br><span class="line">    <span class="comment">//虚拟机会通过lookup_method从class对象及其mro列表中搜索属性__init__对应的操作</span></span><br><span class="line">    PyObject *meth = lookup_method(self, &amp;PyId___init__, &amp;unbound);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    PyObject *res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">if</span> (unbound) &#123;</span><br><span class="line">        res = _PyObject_Call_Prepend(meth, self, args, kwds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyObject_Call(meth, args, kwds);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(meth);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果返回的不是None，那么报错，这个信息熟悉不</span></span><br><span class="line">    <span class="keyword">if</span> (res != Py_None) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;__init__() should return None, not &#x27;%.200s&#x27;&quot;</span>,</span><br><span class="line">                     Py_TYPE(res)-&gt;tp_name);</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果你在定义class时，重写了__init__函数，那么创建实例对象时搜索的结果就是你写的函数，如果没有重写那么执行object的__init__操作，而在object的__init__中，Python虚拟机则什么也不做，而是直接返回。</strong></p>
<p><strong>到了这里可以小结一下，从class对象创建instance对象的两个步骤：</strong></p>
<ul>
<li><code>instance = class.__new__(class, *args, **kwargs)</code></li>
<li><code>class.__init__(instance, *args, **kwargs)</code></li>
</ul>
<p><strong>需要注意的是，这两个步骤同样也适用于从metaclass对象创建class对象，因为从metaclass对象创建class对象的过程其实和class对象创建instance对象是一样的，我们说class具有二象性。</strong></p>
<h3 id="访问instance对象中的属性"><a href="#访问instance对象中的属性" class="headerlink" title="访问instance对象中的属性"></a>访问instance对象中的属性</h3><p><strong>在前面的章节中我们讨论名字空间时就提到，在Python中，形如x.y形式的表达式称之为”属性引用”，其中x为对象，y为对象的某个属性，这个属性可以是很多种，比如：整数、字符串、函数、类、甚至是模块等等。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line">girl.f()</span><br><span class="line">girl.g(<span class="string">&quot;神乐mea&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们加上属性查找逻辑，看看它的字节码如何。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">             <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000019158F5ABE0</span>, file <span class="string">&quot;instance&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">             <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">            <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>          <span class="number">14</span> LOAD_NAME                <span class="number">0</span> (Girl)</span><br><span class="line">            <span class="number">16</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">18</span> STORE_NAME               <span class="number">1</span> (girl)</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>          <span class="number">20</span> LOAD_NAME                <span class="number">1</span> (girl)</span><br><span class="line">            <span class="number">22</span> LOAD_METHOD              <span class="number">2</span> (f)</span><br><span class="line">            <span class="number">24</span> CALL_METHOD              <span class="number">0</span></span><br><span class="line">            <span class="number">26</span> POP_TOP</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>          <span class="number">28</span> LOAD_NAME                <span class="number">1</span> (girl)</span><br><span class="line">            <span class="number">30</span> LOAD_METHOD              <span class="number">3</span> (g)</span><br><span class="line">            <span class="number">32</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;神乐mea&#x27;</span>)</span><br><span class="line">            <span class="number">34</span> CALL_METHOD              <span class="number">1</span></span><br><span class="line">            <span class="number">36</span> POP_TOP</span><br><span class="line">            <span class="number">38</span> LOAD_CONST               <span class="number">3</span> (None)</span><br><span class="line">            <span class="number">40</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>20 LOAD_NAME: 加载变量girl, 因为是girl.f, 所以首先要把girl加载进来, 也就是压入运行时栈;</code></li>
<li><code>22 LOAD_METHOD: 我们看到了一个新的指令, LOAD_METHOD, 显然这是加载一个方法, 关于函数和方法的区别我们后面会详细说;</code></li>
<li><code>24 CALL_METHOD: 调用方法;</code></li>
<li><code>26 POP_TOP: 从栈顶将元素弹出;</code></li>
<li><code>32 LOAD_CONST: 除了加载girl和g之外, 还要加载一个常量字符串;</code></li>
<li><code>34 CALL_METHOD: 调用方法, 这里参数是1个;</code></li>
</ul>
<p><strong>所以关键指令就在于LOAD_METHOD和CALL_METHOD，我们先来看看LOAD_METHOD都做了什么吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_METHOD)</span>: &#123;</span><br><span class="line">    <span class="comment">//从符号表中获取符号, 如果是girl.f的话, 那么这个name就是一个PyUnicodeObject对象&quot;f&quot;</span></span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    <span class="comment">//从栈顶获取(不是弹出, 弹出是POP)obj, 显然这个obj就是实例对象girl</span></span><br><span class="line">    PyObject *obj = TOP();</span><br><span class="line">    <span class="comment">//meth是一个PyObject *指针，显然它要指向一个方法</span></span><br><span class="line">    PyObject *meth = <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//这里是获取obj中和符号name绑定的方法，然后让meth指向它</span></span><br><span class="line">    <span class="comment">//传入二级指针&amp;meth，然后让meth存储的地址变成指向具体方法的地址</span></span><br><span class="line">    <span class="type">int</span> meth_found = _PyObject_GetMethod(obj, name, &amp;meth);</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//如果meth == NULL，raise AttributeError</span></span><br><span class="line">    <span class="keyword">if</span> (meth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Most likely attribute wasn&#x27;t found. */</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//另外还返回了一个meth_found, 要么为1、要么为0</span></span><br><span class="line">    <span class="keyword">if</span> (meth_found) &#123;</span><br><span class="line">        <span class="comment">//如果meth_found为1，说明meth是一个未绑定的方法，obj就是self</span></span><br><span class="line">        <span class="comment">//关于绑定和未绑定我们后面会详细介绍</span></span><br><span class="line">        SET_TOP(meth);</span><br><span class="line">        PUSH(obj);  <span class="comment">// self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则meth不是一个未绑定的方法，而是一个描述符协议返回的一个普通属性、亦或是其他的什么东西</span></span><br><span class="line">        <span class="comment">//那么栈的第二个元素就会设置为NULL</span></span><br><span class="line">        SET_TOP(<span class="literal">NULL</span>);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        PUSH(meth);</span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取方法是LOAD_METHOD，那么获取属性呢？对，其实肯定有人想到了，获取属性是LOAD_ATTR。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_ATTR)</span>: &#123;</span><br><span class="line">    <span class="comment">//可以看到这个和LOAD_METHOD本质上是类似的，并且还要更简单一些</span></span><br><span class="line">    <span class="comment">//name依旧是符号</span></span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    <span class="comment">//owner是所有者，为什么不叫obj，因为方法都是给实例用的，尽管类也能调用，但是方法毕竟是给实例用的</span></span><br><span class="line">    <span class="comment">//但是属性的话，类和实例都可以访问，各自互不干扰，所以是owner</span></span><br><span class="line">    PyObject *owner = TOP();</span><br><span class="line">    <span class="comment">//res显然就是获取属性返回的结果了, 通过PyObject_GetAttr进行获取</span></span><br><span class="line">    PyObject *res = PyObject_GetAttr(owner, name);</span><br><span class="line">    Py_DECREF(owner);</span><br><span class="line">    <span class="comment">//设置到栈顶</span></span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LOAD_ATTR和LOAD_METHOD这两个指令集我们都看到了，但是里面具体实现的方法还没有看，LOAD_ATTR调用了 *PyObject_GetAttr* 函数，LOAD_METHOD调用了 *_PyObject_GetMethod* ，我们来看看这两个方法都长什么样子。首先就从 *PyObject_GetAttr* 开始。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/object.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GetAttr</span><span class="params">(PyObject *v, PyObject *name)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//v: 对象</span></span><br><span class="line">    <span class="comment">//name: 属性名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类型对象</span></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(v);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//name必须是一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;attribute name must be string, not &#x27;%.200s&#x27;&quot;</span>,</span><br><span class="line">                     name-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过类型对象的tp_getattro获取对应的属性, 实例获取属性(包括方法)的时候都是通过类来获取的</span></span><br><span class="line">    <span class="comment">//girl.f()本质上就是Girl.f(girl), 但是后者是不是长得有点丑啊, 所以Python提供了girl.f()</span></span><br><span class="line">    <span class="comment">//并且我们也看到了, 实例调用方法的时候会自动将自身作为参数传进去, 而类默认则不会</span></span><br><span class="line">    <span class="comment">//也正因为如此类获取的话(Girl.f)叫函数, 实例获取(girl.f)的话叫方法, 后面会介绍</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_getattro != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_getattro)(v, name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过tp_getattr获取属性对应的对象, 这里的name是一个char *, 而tp_getattro是一个PyObject *</span></span><br><span class="line">    <span class="comment">//显然tp_getattro还可以处理中文的情况, 只不过我们不会使用中文来命名就是了</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_getattr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name_str = PyUnicode_AsUTF8(name);</span><br><span class="line">        <span class="keyword">if</span> (name_str == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_getattr)(v, (<span class="type">char</span> *)name_str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//属性不存在，抛出异常</span></span><br><span class="line">    PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                 <span class="string">&quot;&#x27;%.50s&#x27; object has no attribute &#x27;%U&#x27;&quot;</span>,</span><br><span class="line">                 tp-&gt;tp_name, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Python的class对象中，定义了两个与属性访问相关的操作：tp_getattro和tp_getattr。其中tp_getattro是优先选择的属性访问动作，而tp_getattr在Python中已不推荐使用。而这两者的区别在 *PyObject_GetAttr*  中已经显示的很清楚了，主要是在属性名的使用上，tp_getattro所使用的属性名必须是一个PyUnicodeObject对象，而tp_getattr所使用的属性名必须是一个char *。因此如果某个类型定义了tp_getattro和tp_getattr，那么 *PyObject_GetAttr* 优先使用tp_getattro，因为这位老铁写在上面。</strong></p>
<p><strong>在Python虚拟机创建class Girl时，会从PyBaseObject_Type中继承其<code>tp_getattro-&gt;PyObject_GenericGetAttr</code>，所以Python虚拟机又会在这里进入 *PyObject_GenericGetAttr* ，并且 *PyObject_GenericGetAttr* 正好涉及到了Python中的描述符，因此也为我们我们后面介绍描述符埋下了一个伏笔。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/object.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GenericGetAttr</span><span class="params">(PyObject *obj, PyObject *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_GenericGetAttrWithDict(obj, name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GenericGetAttrWithDict(PyObject *obj, PyObject *name,</span><br><span class="line">                                 PyObject *dict, <span class="type">int</span> suppress)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到obj的类型，对于我们的例子来说， 显然是class Girl</span></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//一个描述符对象</span></span><br><span class="line">    PyObject *descr = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *res = <span class="literal">NULL</span>;</span><br><span class="line">    descrgetfunc f;</span><br><span class="line">    Py_ssize_t dictoffset;</span><br><span class="line">    PyObject **dictptr;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//name必须是str</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name))&#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;attribute name must be string, not &#x27;%.200s&#x27;&quot;</span>,</span><br><span class="line">                     name-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//字典为空则进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//尝试从mro列表中拿到符号对应的值，等价于descr = Girl.符号 if hasattr(Girl, &#x27;符号&#x27;) else NULL</span></span><br><span class="line">    descr = _PyType_Lookup(tp, name);</span><br><span class="line"></span><br><span class="line">    f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(descr);</span><br><span class="line">        <span class="comment">//f = descr.__class__.__get__ </span></span><br><span class="line">        f = descr-&gt;ob_type-&gt;tp_descr_get;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">NULL</span> &amp;&amp; PyDescr_IsData(descr)) &#123;</span><br><span class="line">            <span class="comment">//f不为NULL，并且descr是数据描述符，那么直接将描述符中__get__方法的结果返回</span></span><br><span class="line">            <span class="comment">//这个f就是描述符里面的__get__方法，而这个descr就是描述符的一个实例对象</span></span><br><span class="line">            res = f(descr, obj, (PyObject *)obj-&gt;ob_type);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span> &amp;&amp; suppress &amp;&amp;</span><br><span class="line">                    PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">                PyErr_Clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//那么显然要从instance对象自身的__dict__中寻找属性</span></span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Inline _PyObject_GetDictPtr */</span></span><br><span class="line">        dictoffset = tp-&gt;tp_dictoffset;</span><br><span class="line">        <span class="comment">//但如果dict为NULL，并且dictoffset不为0, 说明继承自变长对象，那么要调整tp_dictoffset</span></span><br><span class="line">        <span class="keyword">if</span> (dictoffset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictoffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_ssize_t tsize;</span><br><span class="line">                <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">                tsize = ((PyVarObject *)obj)-&gt;ob_size;</span><br><span class="line">                <span class="keyword">if</span> (tsize &lt; <span class="number">0</span>)</span><br><span class="line">                    tsize = -tsize;</span><br><span class="line">                size = _PyObject_VAR_SIZE(tp, tsize);</span><br><span class="line">                _PyObject_ASSERT(obj, size &lt;= PY_SSIZE_T_MAX);</span><br><span class="line"></span><br><span class="line">                dictoffset += (Py_ssize_t)size;</span><br><span class="line">                _PyObject_ASSERT(obj, dictoffset &gt; <span class="number">0</span>);</span><br><span class="line">                _PyObject_ASSERT(obj, dictoffset % SIZEOF_VOID_P == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dictptr = (PyObject **) ((<span class="type">char</span> *)obj + dictoffset);</span><br><span class="line">            dict = *dictptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dict不为NULL，从字典中获取</span></span><br><span class="line">    <span class="keyword">if</span> (dict != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(dict);</span><br><span class="line">        res = PyDict_GetItemWithError(dict, name);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(res);</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (suppress &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">                    PyErr_Clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们看到这里又判断了一次，但是这次少了个条件</span></span><br><span class="line">    <span class="comment">//没错熟悉Python描述符的应该知道，上面的需要满足是数据描述符</span></span><br><span class="line">    <span class="comment">//这个是非数据描述符</span></span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">NULL</span> &amp;&amp; suppress &amp;&amp;</span><br><span class="line">                PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = descr;</span><br><span class="line">        descr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找不到，就报错</span></span><br><span class="line">    <span class="keyword">if</span> (!suppress) &#123;</span><br><span class="line">        PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                     <span class="string">&quot;&#x27;%.50s&#x27; object has no attribute &#x27;%U&#x27;&quot;</span>,</span><br><span class="line">                     tp-&gt;tp_name, name);</span><br><span class="line">    &#125;</span><br><span class="line">  done:</span><br><span class="line">    Py_XDECREF(descr);</span><br><span class="line">    Py_DECREF(name);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>属性访问是从 *PyObject_GetAttr* 开始，那么下面我们来看看 *_PyObject_GetMethod* 生的什么模样，其实不用想也知道，它和 *PyObject_GetAttr* 高度相似。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/object.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)</span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *tp = Py_TYPE(obj);</span><br><span class="line">    PyObject *descr;</span><br><span class="line">    descrgetfunc f = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **dictptr, *dict;</span><br><span class="line">    PyObject *attr;</span><br><span class="line">    <span class="type">int</span> meth_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(*method == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(obj)-&gt;tp_getattro != PyObject_GenericGetAttr</span><br><span class="line">            || !PyUnicode_Check(name)) &#123;</span><br><span class="line">        *method = PyObject_GetAttr(obj, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span> &amp;&amp; PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    descr = _PyType_Lookup(tp, name);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(descr);</span><br><span class="line">        <span class="keyword">if</span> (PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR)) &#123;</span><br><span class="line">            meth_found = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = descr-&gt;ob_type-&gt;tp_descr_get;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">NULL</span> &amp;&amp; PyDescr_IsData(descr)) &#123;</span><br><span class="line">                *method = f(descr, obj, (PyObject *)obj-&gt;ob_type);</span><br><span class="line">                Py_DECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dictptr = _PyObject_GetDictPtr(obj);</span><br><span class="line">    <span class="keyword">if</span> (dictptr != <span class="literal">NULL</span> &amp;&amp; (dict = *dictptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(dict);</span><br><span class="line">        attr = PyDict_GetItemWithError(dict, name);</span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(attr);</span><br><span class="line">            *method = attr;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            Py_XDECREF(descr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                Py_XDECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth_found) &#123;</span><br><span class="line">        *method = descr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *method = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">        Py_DECREF(descr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *method = descr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                 <span class="string">&quot;&#x27;%.50s&#x27; object has no attribute &#x27;%U&#x27;&quot;</span>,</span><br><span class="line">                 tp-&gt;tp_name, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非常类似，这里就不介绍了。</strong></p>
<h4 id="实例对象的属性字典"><a href="#实例对象的属性字典" class="headerlink" title="实例对象的属性字典"></a>实例对象的属性字典</h4><p><strong>在属性访问的时候，我们可以通过girl.__dict__这种形式访问。但是这就奇怪了，在之前的描述中，我们看到从class Girl创建instance girl的时候，Python并没有为instance创建PyDictObject对象啊。</strong></p>
<p><strong>但是在上一篇介绍metaclass的时候，我们说过这样一句话，对于任意继承object的class对象来说，这个大小为<code>PyBaseObject_Type-&gt;tp_basicsize + 16</code>，其中的16是2 * sizeof(PyObject *)。后面跟着的两个PyObject *的空间被设置给了tp_dictoffset和tp_weaklistoffset，那么现在是时候揭开谜底了。</strong></p>
<p><strong>在创建class类对象时我们曾说，Python虚拟机设置了一个名为tp_dictoffset的域，从名字推断，这个可能就是instance对象中__dict__的偏移位置。</strong></p>
<p><img src="/2023/04/13/20-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE/1229382-20200902230338001-2083493292.png" alt="img"></p>
<p><strong>虚线中画出的dict对象就是我们期望中的实例对象的属性字典，这个猜想可以在PyObject_GenericGetAttr中得到证实。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GenericGetAttr</span><span class="params">(PyObject *obj, PyObject *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_GenericGetAttrWithDict(obj, name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GenericGetAttrWithDict(PyObject *obj, PyObject *name,</span><br><span class="line">                                 PyObject *dict, <span class="type">int</span> suppress)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//那么显然要从instance对象自身的__dict__中寻找属性</span></span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Inline _PyObject_GetDictPtr */</span></span><br><span class="line">        dictoffset = tp-&gt;tp_dictoffset;</span><br><span class="line">        <span class="keyword">if</span> (dictoffset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//但如果dict为NULL，并且dictoffset说明继承自变长对象，那么要调整tp_dictoffset</span></span><br><span class="line">            <span class="keyword">if</span> (dictoffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_ssize_t tsize;</span><br><span class="line">                <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">                tsize = ((PyVarObject *)obj)-&gt;ob_size;</span><br><span class="line">                <span class="keyword">if</span> (tsize &lt; <span class="number">0</span>)</span><br><span class="line">                    tsize = -tsize;</span><br><span class="line">                size = _PyObject_VAR_SIZE(tp, tsize);</span><br><span class="line">                assert(size &lt;= PY_SSIZE_T_MAX);</span><br><span class="line"></span><br><span class="line">                dictoffset += (Py_ssize_t)size;</span><br><span class="line">                assert(dictoffset &gt; <span class="number">0</span>);</span><br><span class="line">                assert(dictoffset % SIZEOF_VOID_P == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dictptr = (PyObject **) ((<span class="type">char</span> *)obj + dictoffset);</span><br><span class="line">            dict = *dictptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果dictoffset小于0，意味着Girl是继承自类似str这样的变长对象，Python虚拟机会对dictoffset做一些处理，最终仍然会使dictoffset指向a的内存中额外申请的位置。而PyObject_GenericGetAttr正是根据这个dictoffset获得了一个dict对象。更近一步，我们发现函数g中有设置self.name的代码，这个instance对象的属性设置也会访问属性字典，而这个设置的动作最终会调用 *PyObject_GenericSetAttr* ，也就是<code>girl.__dict__</code>最初被创建的地方。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyObject_GenericSetAttr</span><span class="params">(PyObject *obj, PyObject *name, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_GenericSetAttrWithDict(obj, name, value, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_PyObject_GenericSetAttrWithDict(PyObject *obj, PyObject *name,</span><br><span class="line">                                 PyObject *value, PyObject *dict)</span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *tp = Py_TYPE(obj);</span><br><span class="line">    PyObject *descr;</span><br><span class="line">    descrsetfunc f;</span><br><span class="line">    PyObject **dictptr;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//老规矩，name必须是PyUnicodeObject对象</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name))&#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;attribute name must be string, not &#x27;%.200s&#x27;&quot;</span>,</span><br><span class="line">                     name-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//字典为空、则进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span> &amp;&amp; PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//老规矩，获取属性</span></span><br><span class="line">    descr = _PyType_Lookup(tp, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(descr);</span><br><span class="line">        f = descr-&gt;ob_type-&gt;tp_descr_set;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res = f(descr, obj, value);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//这行代码就是PyObject_GenericGetAttr中根据dictoffset获取dict对象的那段代码</span></span><br><span class="line">        dictptr = _PyObject_GetDictPtr(obj);</span><br><span class="line">        <span class="keyword">if</span> (dictptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (descr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                             <span class="string">&quot;&#x27;%.100s&#x27; object has no attribute &#x27;%U&#x27;&quot;</span>,</span><br><span class="line">                             tp-&gt;tp_name, name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                             <span class="string">&quot;&#x27;%.50s&#x27; object attribute &#x27;%U&#x27; is read-only&quot;</span>,</span><br><span class="line">                             tp-&gt;tp_name, name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        res = _PyObjectDict_SetItem(tp, dictptr, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_INCREF(dict);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            res = PyDict_DelItem(dict, name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = PyDict_SetItem(dict, name, value);</span><br><span class="line">        Py_DECREF(dict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">        PyErr_SetObject(PyExc_AttributeError, name);</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    Py_XDECREF(descr);</span><br><span class="line">    Py_DECREF(name);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再论descriptor"><a href="#再论descriptor" class="headerlink" title="再论descriptor"></a>再论descriptor</h4><p><strong>前面我们看到，在 *PyType_Ready*  中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor(描述符)，那时我们看到的是descriptor这个概念在Python内部是如何实现的。现在我们将要剖析的是descriptor在Python的类机制中究竟会起到怎样的作用。</strong></p>
<p><strong>在Python虚拟机对class对象或instance对象进行属性访问时，descriptor将对属性访问的行为产生重大的影响。一般而言，对于一个对象obj，如果<code>obj.__class__</code>对应的class对象中存在<code>__get__、__set__、__delete__</code>操作<code>(不要求三者同时存在)</code>，那么obj便可以称之为描述符。在slotdefs中，我们会看到这三种魔法方法对应的操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeobject,c</span></span><br><span class="line"></span><br><span class="line">    TPSLOT(<span class="string">&quot;__get__&quot;</span>, tp_descr_get, slot_tp_descr_get, wrap_descr_get,</span><br><span class="line">           <span class="string">&quot;__get__($self, instance, owner, /)\n--\n\nReturn an attribute of instance, which is of type owner.&quot;</span>),</span><br><span class="line">    TPSLOT(<span class="string">&quot;__set__&quot;</span>, tp_descr_set, slot_tp_descr_set, wrap_descr_set,</span><br><span class="line">           <span class="string">&quot;__set__($self, instance, value, /)\n--\n\nSet an attribute of instance to value.&quot;</span>),</span><br><span class="line">    TPSLOT(<span class="string">&quot;__delete__&quot;</span>, tp_descr_set, slot_tp_descr_set,</span><br><span class="line">           wrap_descr_delete,</span><br><span class="line">           <span class="string">&quot;__delete__($self, instance, /)\n--\n\nDelete an attribute of instance.&quot;</span>),</span><br></pre></td></tr></table></figure>

<p><strong>前面我看到了 *PyWrapperDescrObject* 、*PyMethodDescrObject* 等对象，它们对应的类对象中分别为tp_descr_get设置了wrapperdescr_get，method_get等函数，所以它们是当之无愧的descriptor。</strong></p>
<p><strong>另外如果细分，descriptor还可以分为两种。</strong></p>
<blockquote>
<p><strong>关于python中的描述符，我这里有一篇博客写的很详细，对描述符机制不太懂的话可以先去看看，<a href="https://www.cnblogs.com/traditional/p/11714356.html%E3%80%82">https://www.cnblogs.com/traditional/p/11714356.html。</a></strong></p>
</blockquote>
<ul>
<li><strong>data descriptor：数据描述符，对应的__class__中定义了__get__和__set__的descriptor</strong></li>
<li><strong>no data descriptor：非数据描述符，对应的__class__中只定义了__get__方法。</strong></li>
</ul>
<p><strong>在Python虚拟机访问instance对象的属性时，descriptor的一个作用就是影响Python虚拟机对属性的选择。从 *PyObject_GenericGetAttr* 源码中可以看到，Python虚拟机会在instance对象自身的<code>__dict__</code>中寻找属性，也会在instance对象对应的class对象的mro列表中寻找属性，我们将前一种属性称之为instance属性，后一种属性称之为class属性。在属性的选择上，有如下规律：</strong></p>
<ul>
<li><code>Python虚拟机优先按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性</code></li>
<li><code>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</code></li>
</ul>
<p><strong>这两条规则在对属性进行设置时仍然会被严格遵守，换句话说，如果执行<code>girl.value = 1</code>，而在Girl中出现了名为value的数据描述符，那么不好意思，会执行<code>__set__</code>方法，如果是非数据描述符，那么就不再走<code>__set__</code>了，而是设置属性，相当于<code>a.__dict__[&#39;value&#39;] = 1</code>。</strong></p>
<p><strong>所以，获取被描述符代理的属性时，会直接调用__get__方法。设置的话，会调用__set__。当然要考虑优先级的问题，至于优先级的问题是什么，这里就不再解释，强烈建立看我上面发的博客链接，对描述符的解析很详细。</strong></p>
<h4 id="函数变身"><a href="#函数变身" class="headerlink" title="函数变身"></a>函数变身</h4><p><strong>在Girl的成员f对应的def语句中，我们分明一个self参数，那么self在Python中是不是一个真正有效的参数呢？还是它仅仅只是一个语法意义是占位符而已？这一点可以从函数g中看到答案，在g中有这样的语句：<code>self.name = name</code>，这条语句毫无疑问地揭示了self确实是一个实实在在的对象，所以表面上看起来f是一个不需要参数的函数，但实际上是一个货真价值的带参函数，只不过第一个参数自动帮你传递了。根据使用Python的经验，我们都知道，传递给self的就是实例本身。但是现在问题来了，这是怎么实现的呢？我们先再看一遍字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">             <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000019D7B4EABE0</span>, file <span class="string">&quot;instance&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">             <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">            <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>          <span class="number">14</span> LOAD_NAME                <span class="number">0</span> (Girl)</span><br><span class="line">            <span class="number">16</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">18</span> STORE_NAME               <span class="number">1</span> (girl)</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>          <span class="number">20</span> LOAD_NAME                <span class="number">1</span> (girl)</span><br><span class="line">            <span class="number">22</span> LOAD_METHOD              <span class="number">2</span> (f)</span><br><span class="line">            <span class="number">24</span> CALL_METHOD              <span class="number">0</span></span><br><span class="line">            <span class="number">26</span> POP_TOP</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>          <span class="number">28</span> LOAD_NAME                <span class="number">1</span> (girl)</span><br><span class="line">            <span class="number">30</span> LOAD_METHOD              <span class="number">3</span> (g)</span><br><span class="line">            <span class="number">32</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;神乐mea&#x27;</span>)</span><br><span class="line">            <span class="number">34</span> CALL_METHOD              <span class="number">1</span></span><br><span class="line">            <span class="number">36</span> POP_TOP</span><br><span class="line">            <span class="number">38</span> LOAD_CONST               <span class="number">3</span> (None)</span><br><span class="line">            <span class="number">40</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下：24 CALL_METHOD，我们说会将girl.f压入运行时栈，然后就执行CALL_METHOD指令了，注意这里的oparg是0，表示不需要参数<code>(不需要我们传递参数)</code>。注意:这里是CALL_METHOD，不是CALL_FUNCTION。因此我们可以有两条路可走，一条是看看CALL_METHOD是什么，另一条是再研究一下PyFunctionObject。我们先来看看CALL_METHOD这个指令长什么样子吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_METHOD)</span>: &#123;</span><br><span class="line">            <span class="comment">/* Designed to work in tamdem with LOAD_METHOD. */</span></span><br><span class="line">            PyObject **sp, *res, *meth;</span><br><span class="line"></span><br><span class="line">            sp = stack_pointer;</span><br><span class="line"></span><br><span class="line">            meth = PEEK(oparg + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (meth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                res = call_function(tstate, &amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">                stack_pointer = sp;</span><br><span class="line">                (<span class="type">void</span>)POP(); <span class="comment">/* POP the NULL. */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = call_function(tstate, &amp;sp, oparg + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">                stack_pointer = sp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PUSH(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了对比，我们再把CALL_FUNCTION的源码贴出来</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(CALL_FUNCTION)</span>: &#123;</span><br><span class="line">            PREDICTED(CALL_FUNCTION);</span><br><span class="line">            PyObject **sp, *res;</span><br><span class="line">            sp = stack_pointer;</span><br><span class="line">            res = call_function(tstate, &amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">            stack_pointer = sp;</span><br><span class="line">            PUSH(res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过对比，发现端倪，这两个都调用了call_function，但是传递的参数不一样，call_function的第二个参数一个oparg+1<code>(猜测第一个给了self)</code>，一个是oparg，但是这还不足以支持我们找出问题所在。其实在剖析函数的时候，我们放过了PyFunctionObject的<code>ob_type -&gt;PyFunction_Type</code>。在这个PyFunction_Type中，隐藏着一个惊天大秘密。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyFunction_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFunctionObject),</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意注意注意注意注意注意注意，看下面这行</span></span><br><span class="line">    func_descr_get,                             <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    offsetof(PyFunctionObject, func_dict),      <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    func_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现 tp_descr_get 被设置成了func_descr_get，这意味着我们得到的是一个描述符。另外由于 <code>girl.__dict__</code> 中没有f，那么 girl.f 的返回值将会被 descriptor 改变，也就是 <code>func_descr_get(Girl.f, girl, Girl)</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//funcobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果是类获取函数, 那么这里的obj就是NULL, type就是类对象本身</span></span><br><span class="line">    <span class="comment">//如果是实例获取函数, 那么这里的obj就是实例对象, type仍是类对象本身</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果obj为空, 说明是类获取, 那么直接返回func本身, 也就是原来的函数</span></span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是实例对象, 那么通过PyMethod_New将函数和实例绑定在一起, 得到一个PyMethodObject对象</span></span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>func_descr_get将Girl.f对应的PyFunctionObject进行了一番包装，所以通过PyMethod_New，Python虚拟机在PyFunctionObject的基础上创建一个新的对象PyMethodObject，那么这个PyMethodObject是什么呢？到PyMethod_New中一看，这个神秘的对象就现身了：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//classobjet.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyMethod_New</span><span class="params">(PyObject *func, PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyMethodObject *im; <span class="comment">//PyMethodObject对象的指针</span></span><br><span class="line">    <span class="keyword">if</span> (self == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    im = free_list;</span><br><span class="line">    <span class="comment">//使用缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (im != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list = (PyMethodObject *)(im-&gt;im_self);</span><br><span class="line">        (<span class="type">void</span>)PyObject_INIT(im, &amp;PyMethod_Type);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不使用缓冲池，直接创建PyMethodObject对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        im = PyObject_GC_New(PyMethodObject, &amp;PyMethod_Type);</span><br><span class="line">        <span class="keyword">if</span> (im == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    im-&gt;im_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    <span class="comment">//im_func指向PyFunctionObject对象</span></span><br><span class="line">    im-&gt;im_func = func; </span><br><span class="line">    Py_XINCREF(self);</span><br><span class="line">    <span class="comment">//im_self指向实例对象</span></span><br><span class="line">    im-&gt;im_self = self;</span><br><span class="line">    im-&gt;vectorcall = method_vectorcall;</span><br><span class="line">    _PyObject_GC_TRACK(im);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)im;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一切真相大白，原来那个神秘的对象就是PyMethodObject对象，看到free_list这样熟悉的字眼，我们就知道Python内部对PyMethodObject的实现和管理中使用缓冲池的技术。现在再来看看这个PyMethodObject：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//classobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="comment">//可调用的PyFunctionObject对象</span></span><br><span class="line">    PyObject *im_func;  </span><br><span class="line">    <span class="comment">//self参数，instance对象</span></span><br><span class="line">    PyObject *im_self;   </span><br><span class="line">    <span class="comment">//弱引用列表</span></span><br><span class="line">    PyObject *im_weakreflist; <span class="comment">/* List of weak references */</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line">&#125; PyMethodObject;</span><br></pre></td></tr></table></figure>

<p><strong>在PyMethod_New中，分别将im_func，im_self设置了不同的值，分别是：f对应PyFunctionObject对象、实例girl对应的instance对象。因此通过PyMethodObject对象将PyFunctionObject对象和instance对象结合在一起，而这个PyMethodObject对象就是我们说的方法。</strong></p>
<blockquote>
<p><strong>不管是类还是实例，获取成员函数都会走描述符的  func_descr_get，在里面会判断是类获取还是实例获取。如果是类获取，那么直接返回函数本身，如果实例获取则会通过PyMethod_New将func和instance绑定起来得到PyMethodObject对象，再调用函数的时候其实调用的是PyMethodObject。当调用PyMethodObject中会处理自动传参的逻辑，将instance和我们传递的参数组合起来<code>(如果我们没有传参, 那么只有一个self)</code>，然后整体传递给PyFunctionObject，所以为什么实例调用方法的时候会自动传递第一个参数现在是真相大白了。</strong></p>
</blockquote>
<p><strong>这个过程称之为成员函数的绑定，就是将实例和函数绑定起来，使之成为一个整体<code>(方法)</code>。</strong></p>
<p><img src="/2023/04/13/20-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE/1229382-20200902230348348-1015770855.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(Girl.f)  <span class="comment"># &lt;function Girl.f at 0x000001B7805A2820&gt;</span></span><br><span class="line"><span class="built_in">print</span>(girl.f)  <span class="comment"># &lt;bound method Girl.f of &lt;__main__.Girl object at 0x000001B7E92282B0&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Girl.f))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(girl.f))  <span class="comment"># &lt;class &#x27;method&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到通过类来调用成员的函数得到的就是一个普通的函数，如果是实例调用成员函数，那么会将成员函数包装成一个方法，也就是将成员函数和实例绑定在一起，得到结果就是方法，实现方式是通过描述符。</strong></p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p><strong>在LOAD_METHOD指令结束之后，那么便开始了CALL_METHOD，我们知道这个和CALL_FUNCTION之间最大的区别就是，CALL_METHOD调用的是一个PyMethodObject对象，而CALL_FUNCTION调用的一个PyFunctionObject对象。</strong></p>
<blockquote>
<p><strong>CALL_METHOD底层也调用了CALL_FUNCTION，因为方法是将函数和实例绑定在了一起，但最终执行的还是函数。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">Py_LOCAL_INLINE(PyObject *) _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">call_function</span><span class="params">(PyThreadState *tstate, PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;use_tracing) &#123;</span><br><span class="line">        x = trace_call_function(tstate, func, <span class="built_in">stack</span>, nargs, kwnames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">trace_call_function</span><span class="params">(PyThreadState *tstate,</span></span><br><span class="line"><span class="params">                    PyObject *func,</span></span><br><span class="line"><span class="params">                    PyObject **args, Py_ssize_t nargs,</span></span><br><span class="line"><span class="params">                    PyObject *kwnames)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *x; <span class="comment">//返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果func是一个函数, 那么直接通过_PyObject_Vectorcall进行调用, 然后将返回值设置给x</span></span><br><span class="line">    <span class="keyword">if</span> (PyCFunction_Check(func)) &#123;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func, args, nargs, kwnames));</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果func是一个描述符, 注意：此时的 func 不是方法，方法的类型是 PyMethod_Type，这里是描述符</span></span><br><span class="line">    <span class="comment">//那么nargs(func的参数个数)必须大于0, 因为默认会传递一个self</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Py_TYPE(func) == &amp;PyMethodDescr_Type &amp;&amp; nargs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* We need to create a temporary bound method as argument</span></span><br><span class="line"><span class="comment">           for profiling.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           If nargs == 0, then this cannot work because we have no</span></span><br><span class="line"><span class="comment">           &quot;self&quot;. In any case, the call itself would raise</span></span><br><span class="line"><span class="comment">           TypeError (foo needs an argument), so we just skip</span></span><br><span class="line"><span class="comment">           profiling. */</span></span><br><span class="line">        PyObject *self = args[<span class="number">0</span>]; <span class="comment">//self就是args的第一个参数</span></span><br><span class="line">        <span class="comment">//通过调用 PyMethodDescr_Type 的tp_descr_get, 接收三个参数: 函数(显然是通过类获取的)、实例对象、类对象</span></span><br><span class="line">        <span class="comment">//然后调用该描述符的 __get__ 方法，获取返回值</span></span><br><span class="line">        func = Py_TYPE(func)-&gt;tp_descr_get(func, self, (PyObject*)Py_TYPE(self));</span><br><span class="line">        <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        C_TRACE(x, _PyObject_Vectorcall(func, <span class="comment">//调整参数信息变量</span></span><br><span class="line">                                        args+<span class="number">1</span>, nargs<span class="number">-1</span>,</span><br><span class="line">                                        kwnames));</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明是一个方法，还是走同样的逻辑，在里面会自动处理参数逻辑</span></span><br><span class="line">    <span class="keyword">return</span> _PyObject_Vectorcall(func, args, nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以函数调用和方法调用本质上都是类似的，方法里面的成员im_func指向一个函数。调用方法的时候底层还是会调用函数，只不过在调用的时候会自动把方法里面的im_self作为第一个参数传到函数里面去。而我们通过类调用的时候，调用的就是一个普通的函数，所以第一个参数需要我们手动传递。</strong></p>
<p><strong>因此到了这里，我们可以在更高层次俯视一下Python的运行模型了，最核心的模型非常简单，可以简化为两条规则：</strong></p>
<ul>
<li><code>1. 在某个名字空间中寻找符号对应的对象</code></li>
<li><code>2. 对得到的对象进行某些操作</code></li>
</ul>
<p><strong>抛开面向对象这些花里胡哨的外表，其实我们发现class类对象其实就是一个名字空间，实例对象也是一个名字空间，不过这些名字空间通过一些特殊的规则连接在一起，使得符号的搜索过程变得复杂，从而实现了面向对象这种编程模式，それだけ。</strong></p>
<h4 id="bound-method和unbound-method"><a href="#bound-method和unbound-method" class="headerlink" title="bound method和unbound method"></a>bound method和unbound method</h4><p><strong>在Python中，当对作为方法<code>(或者说作为属性的函数)</code>进行引用时，会有两种形式，bound method和unbound method。</strong></p>
<ul>
<li><code>bound method：这种形式是通过实例对象进行属性引用，就像我们之前说的a.f这样</code></li>
<li><code>unbound method：这种形式是通过类对象进行属性引用，比如A.f</code></li>
</ul>
<p><strong>在Python中，bound method和unbound  method的本质区别就在于PyFunctionObject有没有和对象绑定在一起，成为PyMethodObject对象。bound  method完成了绑定动作，而unbound method没有完成绑定动作。</strong></p>
<p><strong>所以无论是类还是实例，在调用成员函数的时候都会经过func_descr_get，但如果是类调用obj为NULL，实例对象调用obj就是实例。而obj如果为NULL，那么就直接返回了，否则通过PyMethod_New变成一个方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//funcobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们通过Python演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descr</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(instance)</span><br><span class="line">        <span class="built_in">print</span>(owner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @Descr</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Girl.f</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">Girl().f</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;__main__.Girl object at 0x000001BDEE7A85E0&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>从Python的层面上我们也可以看到区别。</strong></p>
<p><strong>所以在对unbound method进行调用时，我们必须要显示的传递一个对象<code>(这个对象可以任意，具体什么意思后面会演示)</code>作为成员函数的第一个参数，因为f无论如何都需要一个self参数，所以本质上就是Girl.f(girl)这种形式。而无论是对unbound method进行调用，还是对bound  method进行调用，Python虚拟机的动作本质都是一样的，都是调用带位置参数的一般函数。区别只在于：当调用bound  method时，由于Python虚拟机帮我们完成了PyFunctionObject对象和调用者的绑定，调用者将自动成为self参数；而调用unbound method时，没有这个绑定，我们需要自己传入self参数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line">Girl.f(<span class="number">123</span>)  <span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 我们看到即便传入一个123也是可以的</span></span><br><span class="line"><span class="comment"># 这是我们自己传递的，传递什么就是什么</span></span><br><span class="line"></span><br><span class="line">girl.f()  <span class="comment"># &lt;__main__.A object at 0x000001F0FFE81F10&gt;</span></span><br><span class="line"><span class="comment"># 但是girl.f()就不一样了，首先girl.f()表示先通过girl获取f对应值, 压入运行时栈, 然后再进行调用、完事之后将返回值设置在栈顶</span></span><br><span class="line"><span class="comment"># 而在girl.f的时候就已经通过func_descr_get(Girl.f, girl, Girl)将这个函数和调用者绑定在一起了</span></span><br><span class="line"><span class="comment"># 然后调用的时候自动将调用者作为第一个参数传递进去</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.f)  <span class="comment"># &lt;function A.f at 0x000001F0FFEEFF70&gt;</span></span><br><span class="line"><span class="built_in">print</span>(girl.f)  <span class="comment"># &lt;bound method A.f of &lt;__main__.A object at 0x000001F0FFE81F10&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：我们上面一直说的是调用者<code>(其实说调用者也不是很准确)</code>，而不是实例对象，这是因为函数不仅可以和实例绑定，也可以和类绑定。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.f)  <span class="comment"># &lt;bound method Girl.f of &lt;class &#x27;__main__.Girl&#x27;&gt;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Girl().f)  <span class="comment"># &lt;bound method Girl.f of &lt;class &#x27;__main__.Girl&#x27;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">Girl.f()  <span class="comment"># &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br><span class="line">Girl().f()  <span class="comment"># &lt;class &#x27;__main__.Girl&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到此时通过类去调用得到的不再是一个函数，而是一个方法，这是因为我们加上classmethod装饰器，当然classmethod也是一个描述符。当类在调用的时候，类也和函数绑定起来了，因此也会得到一个方法。不过被classmethod装饰之后，即使是实例调用，第一个参数传递的还是类本身，因为和 PyFunctionObject 绑定的是类、而不是实例。</strong></p>
<p><strong>所以得到的究竟是函数还是方法，就看这个函数有没有和某个对象进行绑定，只要绑定了，那么它就会变成方法。</strong></p>
<h3 id="千变万化的descriptor"><a href="#千变万化的descriptor" class="headerlink" title="千变万化的descriptor"></a>千变万化的descriptor</h3><p><strong>当我们调用instance对象的函数时，最关键的一个动作就是从PyFunctionObject对象向PyMethodObject对象的转变，而这个关键的转变就取决于Python中的descriptor。当我们访问对象中的属性时，由于descriptor的存在，这种转换自然而然的就发生了。事实上，Python中的descriptor很强大，我们可以使用它做很多事情，而在Python的内部，也存在各种各样的descriptor，比如property、staticmethod、classmethod等等，这些descriptor给python的类机制赋予了强大的力量。具体源码就不分析了，我们直接通过Python代码的层面演示一下，这三种描述符的实现。</strong></p>
<p><strong>实现property</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Property</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果instance是None说明是类调用，那么直接返回这个描述符本身</span></span><br><span class="line">            <span class="comment"># 这个和内置property的处理方式是一样</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        res = self.func(instance)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: hanser&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.f)  <span class="comment"># name: hanser</span></span><br><span class="line"><span class="built_in">print</span>(A.f)  <span class="comment"># &lt;__main__.Property object at 0x000001FABFE910A0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：property是为了实例对象准备的，当然property支持的功能远不止我们上面演示的这么简单，它还可以进行set、delete，这些我们在介绍魔法方法的时候再说吧。</strong></p>
<p><strong>实现staticmethod</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMethod</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="comment"># 静态方法的话，类和实例都可以用</span></span><br><span class="line">        <span class="comment"># 类调用不会自动传参，但是实例会自动传递，因此我们需要把实例调用传来的self给扔掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 做法是直接返回self.func即可，注意：self.func是A.func</span></span><br><span class="line">        <span class="comment"># 因此调用的时候，是类去调用的，而类调用是不会自动加上参数的。</span></span><br><span class="line">        <span class="keyword">return</span> self.func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @StaticMethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: hanser&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.f())  <span class="comment"># name: hanser</span></span><br><span class="line"><span class="built_in">print</span>(A.f())  <span class="comment"># name: hanser</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：staticmethod也是为了实例对象准备的，但是类也可以调用。</strong></p>
<p><strong>实现classmethod</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassMethod</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="comment"># 类方法，目的是在类调用的时候，将类本身作为第一个参数传递进去</span></span><br><span class="line">        <span class="comment"># 显然是这里的owner</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回一个闭包，然后当调用的时候，接收参数</span></span><br><span class="line">        <span class="comment"># 不管是谁调用，最终这个self.func都是A.func，然后手动将cls也就是owner传递进去</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">return</span> self.func(owner, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 所以在上面我们看到, 函数被classmethod装饰之后，即使是实例调用，第一个参数传递的还是类本身</span></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;hanser&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @ClassMethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;cls.name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.f())  <span class="comment"># name: hanser</span></span><br><span class="line"><span class="built_in">print</span>(A.f())  <span class="comment"># name: hanser</span></span><br></pre></td></tr></table></figure>



<p><code>property</code> 是 Python 中的一个内置装饰器，用于将类的方法转换为属性。它允许你以属性的形式访问和设置方法的值，而不是作为方法调用。这样可以让类的使用更加直观和简洁。<code>property</code> 可用于创建只读属性，或者在访问和修改属性时自定义行为，如进行验证或计算。</p>
<p>下面是一个使用 <code>property</code> 装饰器的简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative.&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * self._radius ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>Circle</code> 类，包含 <code>_radius</code> 属性。我们使用 <code>@property</code> 装饰器定义了 <code>radius</code> 属性的 getter 和 setter 方法。这允许我们在设置半径时执行验证。同时，我们还定义了 <code>diameter</code> 和 <code>area</code> 属性，它们是基于半径的计算属性。这些属性只有 getter 方法，因此它们是只读的。通过使用 <code>property</code> 装饰器，我们可以像访问普通属性一样访问这些方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c.radius)      <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(c.diameter)    <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(c.area)        <span class="comment"># 78.53975</span></span><br><span class="line"></span><br><span class="line">c.radius = <span class="number">10</span>        <span class="comment"># Updates radius, diameter and area</span></span><br><span class="line"><span class="built_in">print</span>(c.radius)      <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(c.diameter)    <span class="comment"># 20</span></span><br><span class="line"><span class="built_in">print</span>(c.area)        <span class="comment"># 314.159</span></span><br></pre></td></tr></table></figure>



<p><strong>@classmethod</strong></p>
<p><code>@classmethod</code> 将一个普通方法转换为类方法。类方法的第一个参数是类对象本身，通常命名为 <code>cls</code>。这允许类方法访问和修改类级别的属性和方法。类方法可以在类的实例尚未创建时调用。此外，类方法可以被子类覆盖，这样子类就可以提供自己的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">class Example:</span><br><span class="line">    @classmethod</span><br><span class="line">    def class_method(cls):</span><br><span class="line">        print(f&quot;Called class_method of &#123;cls.__name__&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>@staticmethod</strong></p>
<p><code>@staticmethod</code> 将一个普通方法转换为静态方法。静态方法不接受特殊的第一个参数，也就是说它不接受类对象或实例对象。因此，静态方法不能访问类的属性和方法。静态方法只能访问它们所接收的参数和全局变量。静态方法通常用于实现与类和实例无关的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">class Example:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_method(arg):</span><br><span class="line">        print(f&quot;Called static_method with argument &#123;arg&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>区别总结</strong></p>
<ol>
<li>参数：类方法的第一个参数是类对象本身（通常命名为 <code>cls</code>），而静态方法没有特殊的第一个参数。</li>
<li>绑定：类方法绑定到类对象，可以访问和修改类级别的属性和方法。静态方法不绑定到类或实例，因此不能访问类或实例的属性和方法。</li>
<li>子类覆盖：类方法可以被子类覆盖，以提供特定于子类的实现。静态方法在子类中不会自动继承或覆盖。</li>
<li>用途：类方法通常用于创建和操作类及其实例，或实现可以被子类覆盖的工厂方法等功能。静态方法通常用于实现与类和实例无关的功能，类似于模块级别的函数。</li>
</ol>
<p>在选择使用 <code>@classmethod</code> 还是 <code>@staticmethod</code> 时，你需要考虑方法的目的和需求。如果你需要访问或修改类级别的属性和方法，或者希望方法可以被子类覆盖，那么使用 <code>@classmethod</code> 更合适。如果方法只是执行一些独立的功能，并且不依赖于类或实例的属性和方法，那么使用 <code>@staticmethod</code> 更合适。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们介绍了Python中实例对象的创建以及属性访问，下一篇我们介绍魔法方法。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>21-Python类机制的深度解析 全方位介绍Python中的魔法方法，一网打尽</title>
    <url>/2023/04/13/21-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BB%8B%E7%BB%8DPython%E4%B8%AD%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/</url>
    <content><![CDATA[<h2 id="21-Python类机制的深度解析-全方位介绍Python中的魔法方法，一网打尽"><a href="#21-Python类机制的深度解析-全方位介绍Python中的魔法方法，一网打尽" class="headerlink" title="21-Python类机制的深度解析: 全方位介绍Python中的魔法方法，一网打尽"></a>21-Python类机制的深度解析: 全方位介绍Python中的魔法方法，一网打尽</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>下面我们来看一下Python中的魔法方法，我们知道Python将操作符都抽象成了一个魔法方法(magic method)，实例对象进行操作时，实际上会调用魔法方法。也正因为如此，numpy才得以很好的实现。</strong></p>
<p><strong>那么Python中常见的魔法方法都有哪些呢？我们按照特征分成了几类，下面就来看看魔法方法都有哪些，然后再举例说明它们的用法。</strong></p>
<h3 id="魔法方法概览"><a href="#魔法方法概览" class="headerlink" title="魔法方法概览"></a>魔法方法概览</h3><p><strong>我们根据不同的特征分为了以下几类：</strong></p>
<blockquote>
<p><strong>注意：有的方法是Python2中的，但是在Python3中依然存在，但是不推荐使用了。比如：__cmp__、__coerce__等等，我们就没有画在图中。</strong></p>
</blockquote>
<p><img src="/2023/04/13/21-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BB%8B%E7%BB%8DPython%E4%B8%AD%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/1229382-20200904233034263-1037438318.png" alt="img"></p>
<p><strong>下面我们就来介绍一下上面的那些魔法方法的实际用途。</strong></p>
<h3 id="魔法方法介绍"><a href="#魔法方法介绍" class="headerlink" title="魔法方法介绍"></a>魔法方法介绍</h3><h4 id="构建以及初始化"><a href="#构建以及初始化" class="headerlink" title="构建以及初始化"></a>构建以及初始化</h4><p><strong>__new__和__init__我们之前已经见识过了，还有一个__del__是做什么 呢？我们一起来看一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__del__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;################&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">################</span></span><br><span class="line"><span class="string">__del__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>__del__被称为析构函数，当一个实例对象被销毁之后会调用该函数。如果没有销毁，那么程序结束时也会调用。</strong></p>
<h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><p><strong>Python的比较操作符也抽象成了魔法方法，a &#x3D;&#x3D; b，等价于a.<strong>eq</strong>(b)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;!=&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;=&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&gt;=&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&gt;&quot;</span>, self.name, other.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl1 = Girl(<span class="string">&quot;girl1&quot;</span>)</span><br><span class="line">girl2 = Girl(<span class="string">&quot;girl2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(girl1 == girl2)  <span class="comment"># (&#x27;==&#x27;, &#x27;girl1&#x27;, &#x27;girl2&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(girl1 != girl2)  <span class="comment"># (&#x27;!=&#x27;, &#x27;girl1&#x27;, &#x27;girl2&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(girl1 &lt; girl2)  <span class="comment"># (&#x27;&lt;&#x27;, &#x27;girl1&#x27;, &#x27;girl2&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(girl2 &lt;= girl1)  <span class="comment"># (&#x27;&lt;=&#x27;, &#x27;girl2&#x27;, &#x27;girl1&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(girl2 &gt; girl1)  <span class="comment"># (&#x27;&gt;&#x27;, &#x27;girl2&#x27;, &#x27;girl1&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(girl2 &gt;= girl1)  <span class="comment"># (&#x27;&gt;=&#x27;, &#x27;girl2&#x27;, &#x27;girl1&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到如果是a &gt; b，那么会调用a的__gt__方法，self就是a、other就是b；如果是b &gt; a，那么调用b的__gt__方法，self就是b、other就是a；也就是说谁在前面，就调用谁的魔法方法。</strong></p>
<p><strong>但如果a &gt; b，并且type(a)内部没有定义__gt__呢？那么会尝试调用type(b)内部的__gt__，如果都没有定义，那么就会调用object的__gt__，显然这个时候就会报错了。</strong></p>
<blockquote>
<p><strong>注意：如果操作符两边有一个是内置对象、或者内置对象的实例对象，那么会直接调用我们创建的实例对象的魔法方法<code>(前提是定义了)</code>。比如：123 !&#x3D; girl1，那么直接调用girl1的__ne__，尽管整数对象也有__ne__。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name, other</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl(<span class="string">&quot;matsuri&quot;</span>)</span><br><span class="line"><span class="comment"># 如果其中一方为内置，那么直接调用girl的__eq__</span></span><br><span class="line"><span class="comment"># 如果girl在左边就更不用说了</span></span><br><span class="line"><span class="built_in">print</span>(girl == <span class="number">123</span>)  <span class="comment"># (&#x27;matsuri&#x27;, 123)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span> == girl)  <span class="comment"># (&#x27;matsuri&#x27;, 123)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span> == girl)  <span class="comment"># (&#x27;matsuri&#x27;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="built_in">print</span>(girl == <span class="built_in">object</span>)  <span class="comment"># (&#x27;matsuri&#x27;, &lt;class &#x27;object&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<h4 id="单目运算"><a href="#单目运算" class="headerlink" title="单目运算"></a>单目运算</h4><p><strong>下面再来看看单目运算，估计很多人都不一定能百分百说出对应魔法方法的作用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># +self 的时候调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pos__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__pos__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -self 的时候调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__neg__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__neg__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># abs(self) 的时候会调用, 也可以是np.abs(self), 但不推荐numpy调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__abs__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ~self 的时候调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__invert__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__invert__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># round(self, n) 的时候调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__round__</span>(<span class="params">self, n=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;__round__, <span class="subst">&#123;n&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># math.floor(self)的时候调用, 也可以是np.floor(self), 但不推荐numpy调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__floor__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__floor__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># math.ceil(self)的时候调用, 也可以是np.ceil(self), 但不推荐numpy调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ceil__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__ceil__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># math.trunc(self)的时候调用, 也可以是np.trunc(self), 或者int(self)</span></span><br><span class="line">    <span class="comment"># 但不推荐numpy调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__trunc__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__trunc__&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. +girl触发__pos__</span></span><br><span class="line"><span class="built_in">print</span>(+girl)  <span class="comment"># __pos__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. -girl触发__pos__</span></span><br><span class="line"><span class="built_in">print</span>(-girl)  <span class="comment"># __neg__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意: 不可以写成 0 + girl 和 0 - girl, 尽管我们知道在数学上这与 girl和-girl是等价的</span></span><br><span class="line"><span class="string">但是在Python中不行, 因为这样会调用girl的__radd__和__rsub__, 我们后面会说</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. abs(girl)或者np.abs(girl)触发__abs__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(girl))  <span class="comment"># __abs__</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">abs</span>(girl))  <span class="comment"># __abs__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. ~girl触发__invert__</span></span><br><span class="line"><span class="built_in">print</span>(~girl)  <span class="comment"># __invert__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. round(girl)触发__round__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(girl))  <span class="comment"># __round__, None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(girl, <span class="number">2</span>))  <span class="comment"># __round__, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. math.floor(girl), np.floor(girl)触发__round__</span></span><br><span class="line"><span class="built_in">print</span>(math.floor(girl))  <span class="comment"># __floor__</span></span><br><span class="line"><span class="built_in">print</span>(np.floor(girl))  <span class="comment"># __floor__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. math.ceil(girl), np.ceil(girl)触发__round__</span></span><br><span class="line"><span class="built_in">print</span>(math.ceil(girl))  <span class="comment"># __ceil__</span></span><br><span class="line"><span class="built_in">print</span>(np.ceil(girl))  <span class="comment"># __ceil__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. math.trunc(girl), np.trunc(girl)触发__trunc__</span></span><br><span class="line"><span class="built_in">print</span>(math.trunc(girl))  <span class="comment"># __trunc__</span></span><br><span class="line"><span class="built_in">print</span>(np.trunc(girl))  <span class="comment"># __trunc__</span></span><br><span class="line"><span class="comment"># __trunc__表示截断, 只保留整数位, 所以int(girl)也是可以触发的</span></span><br><span class="line"><span class="comment"># 但如果是int(girl)这种方式, 它要求__trunc__必须返回一个整数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>(girl)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># __trunc__ returned non-Integral (type str)</span></span><br><span class="line">Girl.__trunc__ = <span class="keyword">lambda</span> self: <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(Girl()))  <span class="comment"># 666</span></span><br></pre></td></tr></table></figure>

<p><strong>以上便是单目运算的一些魔法方法，但是说实话个人觉得只有__pos__、__neg__、__invert__会用上，因为我们可能希望一些操作的调用方式尽可能简单，所以会通过重些+、-、~ 操作符对应的魔法方法，来赋予实例对象一些特殊的含义。</strong></p>
<p><strong>至于其它的简单了解一下即可，不过注意的是，有些方法numpy也是可以是使用的，但是并不推荐。</strong></p>
<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p><strong>算术运算是比较常用的了，我们来看看算数运算对应的魔法方法。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a + b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__add__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a - b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__sub__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a * b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__mul__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a // b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__floordiv__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__floordiv__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a / b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="comment"># 还有一个__div__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__truediv__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__truediv__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a + b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mod__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__mod__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># divmod(a, b) 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__divmod__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__divmod__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a ** b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, power, modulo=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__pow__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a &lt;&lt; b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lshift__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__lshift__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a &gt;&gt; b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rshift__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__rshift__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a &amp; b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__and__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__and__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a | b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__or__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__or__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a ^ b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__xor__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__xor__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a @ b 的时候调用, self就是a、other就是b</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__matmul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 这个方法是用在矩阵运算的, Python在3.5版本的时候将@抽象成了这个方法</span></span><br><span class="line">        <span class="comment"># 比如numpy的两个数组如果想进行矩阵之间的相乘</span></span><br><span class="line">        <span class="comment"># 除了np.dot(arr1, arr2)之外, 还可以直接arr1 @ arr2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__matmul__&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl1 = Girl()</span><br><span class="line">girl2 = Girl()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(girl1 + girl2)  <span class="comment"># __add__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 - girl2)  <span class="comment"># __sub__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 * girl2)  <span class="comment"># __mul__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 // girl2)  <span class="comment"># __floordiv__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 / girl2)  <span class="comment"># __truediv__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 % girl2)  <span class="comment"># __mod__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">divmod</span>(girl1, girl2))  <span class="comment"># __divmod__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 ** girl2)  <span class="comment"># __pow__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 &lt;&lt; girl2)  <span class="comment"># __lshift__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 &gt;&gt; girl2)  <span class="comment"># __rshift__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 &amp; girl2)  <span class="comment"># __and__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 | girl2)  <span class="comment"># __or__</span></span><br><span class="line"><span class="built_in">print</span>(girl1 ^ girl2)  <span class="comment"># __xor__</span></span><br></pre></td></tr></table></figure>

<p><strong>常见的算术运算大概就是上面这些，还是很简单的。</strong></p>
<h4 id="反射算术运算"><a href="#反射算术运算" class="headerlink" title="反射算术运算"></a>反射算术运算</h4><p><strong>反射算术运算指的是什么呢？比如: a + b，我们知道会调用a的__add__，但如果type(a)中没有定义__add__，那么会尝试寻找b的__radd__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;class A:&quot;</span>, <span class="built_in">type</span>(self).__name__, <span class="built_in">type</span>(other).__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;class B:&quot;</span>, <span class="built_in">type</span>(self).__name__, <span class="built_in">type</span>(other).__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"><span class="comment"># type(a)中定义了__add__, 那么优先调用</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># (&#x27;class A:&#x27;, &#x27;A&#x27;, &#x27;B&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果type(a)中没有定义__add__, 那么会去看type(b)中有没有定义__radd__</span></span><br><span class="line"><span class="keyword">del</span> A.__add__</span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># (&#x27;class B:&#x27;, &#x27;B&#x27;, &#x27;A&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果a + b, 其中一个是内置对象, 那么做法和比较操作是类似的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果是一方为内置对象, 比如:</span></span><br><span class="line"><span class="string">a + 123: 直接调用a的__add__</span></span><br><span class="line"><span class="string">123 + a: 直接调用a的__radd__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span> + b)  <span class="comment"># (&#x27;class B:&#x27;, &#x27;B&#x27;, &#x27;int&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">123</span> + a</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 显然a没有__radd__, 因此会选择object的__add__, 显然这个时候报错了</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但a是有__add__的, 所以直接走a的__add__</span></span><br><span class="line">A.__add__ = <span class="keyword">lambda</span> self, other: (self, other)</span><br><span class="line"><span class="built_in">print</span>(a + <span class="string">&quot;xxx&quot;</span>)  <span class="comment"># (&lt;__main__.A object at 0x0000020FB72A82B0&gt;, &#x27;xxx&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>其它操作符也是类似的，<code>a 操作符 b</code>会调用a的<code>__xxx__</code>，但如果a没有，会尝试搜寻b的<code>__rxxx__</code>。</strong></p>
<h4 id="赋值算术运算"><a href="#赋值算术运算" class="headerlink" title="赋值算术运算"></a>赋值算术运算</h4><p><strong>赋值算术运算适用于类似于+&#x3D;这种形式，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self).__name__ + other</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 会调用__iadd__, 参数self就是a, other就是&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line">a += <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># A&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>比较简单，其它的也与此类似。</strong></p>
<h4 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h4><p><strong>下面我们看看序列操作。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以len(a)本质上会调用type(a).__len__(a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 是type(a).__len__(a), 不是a.__len__()</span></span><br><span class="line">a.__len__ = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.__len__)  <span class="comment"># xxx</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: __len__必须返回一个整型, 否则报错</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，__len__还有充当布尔值的作用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认返回的是True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(A()))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">A.__len__ = <span class="keyword">lambda</span> self: <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(A()))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __len__返回的是0, 为假, 所以结果为False</span></span><br><span class="line"><span class="comment"># 当然真正起到决定性作用的是__bool__方法, 如果定义了__bool__, 那么以__bool__的返回值为准,必须返回布尔类型的值</span></span><br><span class="line"><span class="comment"># 没有__bool__, 那么解释器会退化, 寻找__len__</span></span><br><span class="line">A.__bool__ = <span class="keyword">lambda</span> self: <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(A()))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>所以解释器具有退化功能，会优先寻找某个方法，但如果没有，那么会退化寻找替代方法。在后面，我们还会看到类似的实现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面三个可以让我像操作字典一样, 操作实例对象</span></span><br><span class="line">a = A()</span><br><span class="line">a[<span class="string">&quot;xxx&quot;</span>]  <span class="comment"># xxx</span></span><br><span class="line">a[<span class="string">&quot;xxx&quot;</span>] = <span class="string">&quot;yyy&quot;</span>  <span class="comment"># xxx yyy</span></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&quot;aaa&quot;</span>]  <span class="comment"># aaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不仅如此, 它们还可以作用于切片</span></span><br><span class="line">a[<span class="number">3</span>: <span class="number">4</span>]  <span class="comment"># slice(3, 4, None)</span></span><br><span class="line">a[<span class="string">&quot;你好&quot;</span>: <span class="string">&quot;我很可爱&quot;</span>: <span class="string">&quot;请亏我全&quot;</span>]  <span class="comment"># slice(&#x27;你好&#x27;, &#x27;我很可爱&#x27;, &#x27;请亏我全&#x27;)</span></span><br><span class="line">a[<span class="string">&quot;你好&quot;</span>: <span class="string">&quot;我很可爱&quot;</span>: <span class="string">&quot;请亏我全&quot;</span>] = <span class="string">&quot;屑女仆&quot;</span>  <span class="comment"># slice(&#x27;你好&#x27;, &#x27;我很可爱&#x27;, &#x27;请亏我全&#x27;) 屑女仆</span></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&quot;神乐mea&quot;</span>: <span class="string">&quot;迷迭迷迭帕里桑&quot;</span>]  <span class="comment"># slice(&#x27;神乐mea&#x27;, &#x27;迷迭迷迭帕里桑&#x27;, None)</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我们再着重说一下__getitem__，我们说Python的for循环本质上会调用内部的__iter__，但如果内部没有定义，那么解释器会退化寻找__getitem__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> A():</span><br><span class="line">    <span class="keyword">if</span> idx &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    lst.append(idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到遍历A()的时候, 在没有__iter__的时候会去找__getitem__</span></span><br><span class="line"><span class="comment"># 并且默认传递0 1 2 3......, 所以循环遍历的话默认是无休止的</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.lst = [<span class="string">&quot;古明地觉&quot;</span>, <span class="string">&quot;芙兰朵露&quot;</span>, <span class="string">&quot;雾雨魔理沙&quot;</span>, <span class="string">&quot;八意永琳&quot;</span>, <span class="string">&quot;琪露诺&quot;</span>]</span><br><span class="line">        self.__<span class="built_in">len</span> = <span class="built_in">len</span>(self.lst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">if</span> item == self.__<span class="built_in">len</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.lst[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(B()))  <span class="comment"># [&#x27;古明地觉&#x27;, &#x27;芙兰朵露&#x27;, &#x27;雾雨魔理沙&#x27;, &#x27;八意永琳&#x27;, &#x27;琪露诺&#x27;]</span></span><br><span class="line">(lst := []).extend(B())</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;古明地觉&#x27;, &#x27;芙兰朵露&#x27;, &#x27;雾雨魔理沙&#x27;, &#x27;八意永琳&#x27;, &#x27;琪露诺&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很神奇呢？当然for循环肯定是优先寻找__iter__，没有的话会进行退化。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__reversed__&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">reversed</span>(A()))  <span class="comment"># __reversed__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a in b等价于 b.__contains__(a), 但是会自动将返回值变成bool值</span></span><br><span class="line"><span class="comment"># 也就是说我们上面的return item其实等价于return bool(item)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xx&quot;</span> <span class="keyword">in</span> A())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span> <span class="keyword">in</span> A())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>([] <span class="keyword">in</span> A())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>最后一个__missing__比较特殊，它是针对于字典的，我们来看一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key).upper()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;age&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;Name&quot;</span>])  <span class="comment"># NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们使用获取元素时, 首先调用__getitem__</span></span><br><span class="line"><span class="comment"># 由于我们没有重写, 显然调用父类的__getitem__, 如果获取到结果, 那么直接返回</span></span><br><span class="line"><span class="comment"># 获取不到, 那么会调用__missing__, 如果没有重写则报错, 重写的话则是__missing__的返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们可以这么做</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getitem__(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;key!r&#125;</span>不存在&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = MyDict(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;age&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;age&quot;</span>])  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;AGE&quot;</span>])  <span class="comment"># &#x27;AGE&#x27;不存在</span></span><br><span class="line"><span class="comment"># 首先会执行我们重写的__getitem__, 但是我们通过super().__getitem__(item), 通过父类来获取对应的value</span></span><br><span class="line"><span class="comment"># 父类发现在获取不到的时候, 会去找__missing__, 如果我们定义了就走我们重写的__missing__</span></span><br><span class="line"><span class="comment"># 没有重写, 对于父类而言则报错, 因为dict没有__missing__</span></span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>很简单的内容了，我们直接来看一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__index__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面两个作用类似, 在执行int(self)时候所调用</span></span><br><span class="line"><span class="comment"># 但是存在一个优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是__int__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(A()))  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有__init__, 执行__index__</span></span><br><span class="line"><span class="keyword">del</span> A.__int__</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(A()))  <span class="comment"># 789</span></span><br><span class="line"><span class="comment"># __init__和__index__要求必须返回整型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 必须返回浮点型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.</span>  <span class="comment"># 3.是可以的, 但是3不行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(B()))  <span class="comment"># 3.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="comment"># 针对复数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__complex__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">3j</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(C()))  <span class="comment"># (1+3j)</span></span><br></pre></td></tr></table></figure>

<h4 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h4><p><strong>这部分不说了，可以看我的这一篇博客：<code>https://www.cnblogs.com/traditional/p/11487979.html</code>，通过源码分析contextlib标准库介绍with语句。</strong></p>
<h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p><strong>__getattr__、__setattr__、__delattr__和我们之前说的__getitem__、__setitem__、__delitem__类似，只不过这里是通过<code>.</code>的方式来访问的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.name  <span class="comment"># name</span></span><br><span class="line">a.name = <span class="string">&quot;夏色祭&quot;</span>  <span class="comment"># name 夏色祭</span></span><br><span class="line"><span class="keyword">del</span> a.age  <span class="comment"># age</span></span><br></pre></td></tr></table></figure>

<p><strong>getattr、setattr、delattr这几个内置函数本质上也是调用这几个魔法方法，只不过它额外做了一些其它的工作。以getattr为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">        self.age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(A(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;不存在的属性&quot;</span>))  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(A(), <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;不存在的属性&quot;</span>))  <span class="comment"># 不存在的属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了不存在的属性, 会返回默认值, 注意: getattr必须指定三个参数</span></span><br><span class="line"><span class="comment"># 否则属性不存在会报错, 而不是我们认为的None</span></span><br><span class="line"><span class="comment"># 可能有人觉得第三个参数不传就是None, 其实不是的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">        self.age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__dict__[item]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(B(), <span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;不存在的属性&quot;</span>))  <span class="comment"># 不存在的属性</span></span><br><span class="line"><span class="comment"># 我们重写了__getattr__, 那么会调用我们重写的__getattr__</span></span><br><span class="line"><span class="comment"># 然后通过字典返回, 但是注意: 在__getattr__里面可千万不能通过.来访问一个不存在的属性</span></span><br><span class="line"><span class="comment"># 那样会陷入无限递归</span></span><br><span class="line"><span class="comment"># 如果存在的话, 直接返回; 但如果不存在, 一定要raise AttributeError, 这样的话才会返回getattr的第三个参数, 即默认值</span></span><br><span class="line"><span class="comment"># 如果是其它错误, getattr是无法捕获的; 正如自定义迭代器要raise StopIteration一样, 只有这样for循环才会捕捉到并终止迭代</span></span><br></pre></td></tr></table></figure>

<h4 id="对象调用"><a href="#对象调用" class="headerlink" title="对象调用"></a>对象调用</h4><p><strong>这一点我们好像很早之前就说过了，一个对象能否被调用，取决于它的类对象中是否定义了__call__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deco</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deco</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">start</span></span><br><span class="line"><span class="string">夏色祭 -1</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>剩下的内容比较简单，当然描述符我们之前就说过了。最主要的是魔法方法的话，可以自己试一下就知道它们是干什么的了，没太大难度，这里就不说了。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>22-Python中的生成器对象</title>
    <url>/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="22-Python中的生成器对象"><a href="#22-Python中的生成器对象" class="headerlink" title="22-Python中的生成器对象"></a>22-Python中的生成器对象</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>下面我们来聊一聊Python中的生成器，它是我们理解后面协程的基础，生成器的话，估计大部分人在写程序的时候都想不到用。但是一旦用好了，确实能给程序带来性能上的提升，那么我们就来看一看吧。</strong></p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><strong>我们知道，一个函数如果它的内部出现了yield关键字，那么它就不再是普通的函数了，而是一个生成器函数。当我们调用的时候，就会创建一个生成器对象。</strong></p>
<blockquote>
<p><strong>生成器对象一般用于处理循环结构，应用得当的话可以极大优化内存使用率。比如：我们读取一个大文件。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(file, encoding=<span class="string">&quot;utf-8&quot;</span>).readlines()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(read_file(<span class="string">&quot;假装是大文件.txt&quot;</span>))</span><br><span class="line"><span class="comment"># [&#x27;人生は一体何だろう\n&#x27;, &#x27;たぶん 輝いている同時に\n&#x27;, &#x27;人を苦しくさせるものだろう&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>这个版本的函数，直接将里面的内容全部读取出来了，返回了一个列表。如果文件非常大，那么内存的开销可想而知。</strong></p>
<p><strong>于是我们可以通过yield关键字，将函数变成一个生成器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = read_file(<span class="string">&quot;假装是大文件.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># &lt;generator object read_file at 0x0000019B4FA8BAC0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里返回了一个生成器对象, 我们需要使用for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">    <span class="comment"># 文件每一行自带换行符, 所以这里print就不用换行符了</span></span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">人生は一体何だろう</span></span><br><span class="line"><span class="string">たぶん 輝いている同時に</span></span><br><span class="line"><span class="string">人を苦しくさせるものだろう</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="观察生成器的运行行为"><a href="#观察生成器的运行行为" class="headerlink" title="观察生成器的运行行为"></a>观察生成器的运行行为</h4><p><strong>那么生成器是怎么做到的呢？我们继续考察一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = read_file(<span class="string">&quot;假装是大文件.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># &lt;generator object read_file at 0x0000019B4FA8BAC0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用初始化函数(生成器函数)时, 会创建一个生成器</span></span><br><span class="line"><span class="comment"># 此时生成器就已经被创建了</span></span><br><span class="line"><span class="comment"># 当我们调用__next__的时候, 生成器会执行</span></span><br><span class="line"><span class="comment"># 一旦执行到yield的时候就会将生成器暂停, 并将yield后面的值返回</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(data), end=<span class="string">&quot;&quot;</span>)  <span class="comment"># 人生は一体何だろう</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时生成器处于暂停状态, 如果我们不驱使它的话, 它是不会前进的</span></span><br><span class="line"><span class="comment"># 当我们再次执行__next__的时候, 生成器恢复执行, 继续处理并在下一个yield处暂停</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(data), end=<span class="string">&quot;&quot;</span>)  <span class="comment"># たぶん 輝いている同時に</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器会记住自己的执行进度, 每次调用next函数, 它总是处理并生产下一个数据, 完全不需要我们担心</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(data))  <span class="comment"># 人を苦しくさせるものだろう</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦next的时候, 就会找下一个yield, 但我们知道此时循环已经结束了</span></span><br><span class="line"><span class="comment"># 所以没有下一个yield了, 因此程序就会报错了</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(data))</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成器执行完毕&quot;</span>)  <span class="comment"># 生成器执行完毕</span></span><br></pre></td></tr></table></figure>

<p><strong>因此生成器和之前我们说的迭代器是类似的，毕竟生成器就是一个特殊的迭代器。</strong></p>
<blockquote>
<p><strong>原谅我写到这里有点懈怠了，有点累了。所以这里后面只对生成器的底层实现进行剖析，至于一些Python层面的东西就不说了。</strong></p>
</blockquote>
<h4 id="任务上下文"><a href="#任务上下文" class="headerlink" title="任务上下文"></a>任务上下文</h4><p><strong>在经典的线程模型中，每个线程都有一个独立的执行流，只能执行一个任务。如果一个程序需要同时处理多个任务，可以借助多线程或者多进程技术。假设一个站点需要同时服务于多个客户端连接，可以为每个连接创建一个独立的线程进行处理。</strong></p>
<p><strong>但不管是线程还是进程，切换时都会带来巨大的性能开销：用户态和内核态的切换、执行上下文保存和恢复、CPU刷新缓存等等。因此，使用进程或者线程来驱动多个小任务的执行，显然不是一个理想的选择。</strong></p>
<p><strong>那么，除了进程和线程，还有其它的解决方案吗？显然是有的，答案就是协程。不过在讨论之前，我们先来总结多任务执行体系的关键之处。</strong></p>
<p><strong>一个程序想要同时处理多个任务，必须提供一种能够记录任务执行进度的机制。在经典线程模型中，这个机制由CPU提供：</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005404319-765933567.png" alt="img"></p>
<p><strong>如上图，程序内存空间分为代码、数据、堆以及栈等多个段，*CPU* 中的 *CS* 寄存器指向代码段，*SS* 寄存器指向栈段。当程序任务(线程)执行时，*IP* 寄存器指向代码段中当前正被执行的指令，*BP* 寄存器指向当前栈帧，*SP* 寄存器则指向栈顶。</strong></p>
<p><strong>有了 *IP* 寄存器，*CPU* 可以取出需要执行的下一条指令；有了 *BP* 寄存器，当函数调用结束时，*CPU* 可以回到调用者继续执行。因此，*CPU* 寄存器与内存地址空间一起构成了任务执行上下文，记录着任务执行进度。当任务切换时，操作系统先将 *CPU* 当前寄存器保存到内存，然后恢复待执行任务的寄存器。</strong></p>
<p><strong>至此，我们已经受到一些启发：生成器不是可以记住自己的执行进度吗？那么，是不是可以用生成器来实现任务执行流？由于生成器在用户态运行，切换成本比线程或进程小很多，是组织微型任务的理想手段。</strong></p>
<p><strong>现在，我们用生成器来写一个玩具协程，以此体会协程的运行机制：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">f&quot;生产者生产第<span class="subst">&#123;i&#125;</span>包子&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">f&quot;消费者消费第<span class="subst">&#123;i&#125;</span>包子&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = producer(<span class="number">3</span>)</span><br><span class="line">c = consumer(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们创建一个生产包子的生产者，和一个消费包子的消费者，然后进行初始化。当我们调用next函数的时候，就可以驱动它们执行了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(p))  <span class="comment"># 生产者生产第1包子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(c))  <span class="comment"># 消费者消费第1包子</span></span><br></pre></td></tr></table></figure>

<p><strong>当遇到第一个yield语句时，让出执行权，并将yield后面的值返回。但是在实例项目中，一般在遇到网络I&#x2F;O时，才会让出执行权。</strong></p>
<p><strong>而且我们看到，我们还扮演着调度器的角色。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(p))  <span class="comment"># 生产者生产第2包子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(c))  <span class="comment"># 消费者消费第2包子</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再次通过next驱动生成器执行，然后遇到yield之后继续暂停，将yield后面的值返回，并将执行权交给我们。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(p))  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    print(next(p))  # 生产者生产第2包子</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>再次驱动生成器执行，但是发现已经找不到下一个yield了，所以抛出StopIteration异常告诉我们生成器已经将全部的值都生成了。</strong></p>
<p><strong>以上通过一个小例子，感受一下生成器的运行原理，它可以帮我们更好地理解后面的协程。因为协程的思想和生成器本质是一样的，而且在早期Python还没有提供原生协程的时候，就是通过生成器来模拟的协程。</strong></p>
<h3 id="字节码解密生成器"><a href="#字节码解密生成器" class="headerlink" title="字节码解密生成器"></a>字节码解密生成器</h3><p><strong>上面我们简单的考察了一下生成器的运行时行为，发现了它神秘的一面。生成器可以通过yield关键字暂停，并且还可以通过next函数重新恢复执行<code>(从上一次暂停的位置)</code>，这个特性可以用来实现协程。</strong></p>
<h4 id="生成器的创建"><a href="#生成器的创建" class="headerlink" title="生成器的创建"></a>生成器的创建</h4><p><strong>而理解协程，首先要理解生成器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成器开始执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量name&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> name </span><br><span class="line"></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量age&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> age </span><br><span class="line">    </span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量gender&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> gender</span><br></pre></td></tr></table></figure>

<p><strong>我们创建一个简单的生成器函数，当我们调用的时候就会得到一个生成器对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成器开始执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量name&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> name</span><br><span class="line"></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量age&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> age</span><br><span class="line"></span><br><span class="line">    gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建了一个局部变量gender&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然是生成器函数, 但它也是一个函数</span></span><br><span class="line"><span class="built_in">print</span>(gen)  <span class="comment"># &lt;function gen at 0x000001DABAD951F0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是调用生成器函数并不会立刻执行, 而是会返回一个生成器对象</span></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># &lt;generator object gen at 0x000001D89E9D7270&gt;</span></span><br><span class="line"><span class="built_in">print</span>(g.__class__)  <span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于普通函数和生成器函数，有一个非常生动的栗子。普通函数可以想象成一匹马，只要调用了，那么不把里面的代码执行完毕誓不罢休；而生成器函数则好比一头驴，调用的时候并没有动，只是返回一个生成器对象，然后需要每次拿鞭子抽一下<code>(调用一次next)</code>才往前走一步。</strong></p>
<p><strong>另外我们可以把生成器看成是可以暂停的函数，其中的yield就类似于return，只不过可以有多个yield。当执行到一个yield时，将值返回、同时暂停在此处，然后当使用next函数驱动时，从暂停的地方继续执行，直到找到下一个yield。如果找不到下一个yield，就会抛出StopIteration异常。</strong></p>
</blockquote>
<p><strong>那么老规矩，肯定要看一下字节码。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object gen at <span class="number">0x00000188E73D1450</span>, file <span class="string">&quot;generator&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;gen&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (gen)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object gen at <span class="number">0x00000188E73D1450</span>, file <span class="string">&quot;generator&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;生成器开始执行了&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> STORE_FAST               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">12</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;创建了一个局部变量name&#x27;</span>)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">20</span> LOAD_FAST                <span class="number">0</span> (name)</span><br><span class="line">             <span class="number">22</span> YIELD_VALUE</span><br><span class="line">             <span class="number">24</span> POP_TOP</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">26</span> LOAD_CONST               <span class="number">4</span> (<span class="number">-1</span>)</span><br><span class="line">             <span class="number">28</span> STORE_FAST               <span class="number">1</span> (age)</span><br><span class="line"></span><br><span class="line">  <span class="number">9</span>          <span class="number">30</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">             <span class="number">32</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;创建了一个局部变量age&#x27;</span>)</span><br><span class="line">             <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">36</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>          <span class="number">38</span> LOAD_FAST                <span class="number">1</span> (age)</span><br><span class="line">             <span class="number">40</span> YIELD_VALUE</span><br><span class="line">             <span class="number">42</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">12</span>          <span class="number">44</span> LOAD_CONST               <span class="number">6</span> (<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">             <span class="number">46</span> STORE_FAST               <span class="number">2</span> (gender)</span><br><span class="line"></span><br><span class="line"> <span class="number">13</span>          <span class="number">48</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">             <span class="number">50</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;创建了一个局部变量gender&#x27;</span>)</span><br><span class="line">             <span class="number">52</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">54</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">14</span>          <span class="number">56</span> LOAD_FAST                <span class="number">2</span> (gender)</span><br><span class="line">             <span class="number">58</span> YIELD_VALUE</span><br><span class="line">             <span class="number">60</span> POP_TOP</span><br><span class="line">             <span class="number">62</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">64</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码指令依旧是分为两部分，我们先来看看模块的。很简单，就是创建一个生成器对象，而且我们发现字节码和调用一个普通函数的字节码是一样的。那么Python是如何知道这是一个生成器函数呢？显然秘密就在CALL_FUNCTION里面。</strong></p>
<p><strong>由于我们已经分析过函数了，所以CALL_FUNCTION下一步会调用什么就不多说了，直接用我们之前的一张图：</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200828230612755-992873571.png" alt="2"></p>
<p><strong>CALL_FUNCTION中，它会调用Objects&#x2F;call.c中的call_function函数。call_function函数可以根据被调用对象的类型进行区别处理，可分为：类方法、函数对象、普通可调用对象等等。</strong></p>
<p><strong>在这个例子中，被调用的是函数对象。因此call_function内部会调用位于Objects&#x2F;call.c中的 *_PyFunction_FastCallDict* 函数，而它则进一步调用位于 *Python&#x2F;ceval.c* 中的 *_PyEval_EvalCodeWithName* 函数，该函数会为PyFunctionObject创建一个栈帧，然后检查co_flags。如果带有 *CO_GENERATOR* 、*CO_COROUTINE* 或 *CO_ASYNC_GENERATOR*，那么便创建生成器返回。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) &#123;</span><br><span class="line">        PyObject *gen;</span><br><span class="line">        <span class="type">int</span> is_coro = co-&gt;co_flags &amp; CO_COROUTINE;</span><br><span class="line">        Py_CLEAR(f-&gt;f_back);</span><br><span class="line">        <span class="keyword">if</span> (is_coro) &#123;</span><br><span class="line">            gen = PyCoro_New(f, name, qualname);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_ASYNC_GENERATOR) &#123;</span><br><span class="line">            gen = PyAsyncGen_New(f, name, qualname);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gen = PyGen_NewWithQualName(f, name, qualname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gen == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//直接返回一个生成器</span></span><br><span class="line">        <span class="keyword">return</span> gen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中的 *co_flags* 是PyCodeObject中的一个域，显然它是在编译时由语法规则确定的。我们之前说它是用来判断参数特征的，但其实它还可以用来判断函数特征。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/code.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_OPTIMIZED    0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NEWLOCALS    0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARARGS      0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_VARKEYWORDS  0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_NESTED       0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CO_GENERATOR    0x0020</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 *CO_GENERATOR* 的值为0x0020。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(gen.__code__.co_flags &amp; <span class="number">0x0020</span>)  <span class="comment"># 32</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不是生成器函数，那么结果为0；现在结果不为0，说明是生成器函数。</strong></p>
<p><strong>下面我们可以看看生成器的底层定义了，位于 *Include&#x2F;genobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _PyGenObject_HEAD(prefix)                                           \</span></span><br><span class="line"><span class="meta">    PyObject_HEAD                                                           \</span></span><br><span class="line"><span class="meta">    struct _frame *prefix##_frame;                                          \</span></span><br><span class="line"><span class="meta">    char prefix##_running;                                                  \</span></span><br><span class="line"><span class="meta">    PyObject *prefix##_code;                                                \</span></span><br><span class="line"><span class="meta">    PyObject *prefix##_weakreflist;                                         \</span></span><br><span class="line"><span class="meta">    PyObject *prefix##_name;                                                \</span></span><br><span class="line"><span class="meta">    PyObject *prefix##_qualname;                                            \</span></span><br><span class="line"><span class="meta">    _PyErr_StackItem prefix##_exc_state;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    _PyGenObject_HEAD(gi)</span><br><span class="line">&#125; PyGenObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果整理一下, 那么等价于这样</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">gi_frame</span>;</span> <span class="comment">//生成器执行时对应的栈帧对象, 用于保存执行上下文信息</span></span><br><span class="line">    <span class="type">char</span> gi_running;  <span class="comment">//标识生成器是否运行中</span></span><br><span class="line">    PyObject *gi_code; <span class="comment">//PyCodeObject对象</span></span><br><span class="line">    PyObject *gi_weakreflist; <span class="comment">//弱引用相关，不深入讨论</span></span><br><span class="line">    PyObject *gi_name; <span class="comment">//生成器名</span></span><br><span class="line">    PyObject *gi_qualname; <span class="comment">//全限定名</span></span><br><span class="line">    _PyErr_StackItem *gi_exc_state; <span class="comment">//生成器执行状态</span></span><br><span class="line">&#125; PyGenObject;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们可以画出一张模型图：</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005412543-756656835.png" alt="img"></p>
<p><strong>至此生成器对象的创建过程已经浮出水面，与普通函数对象一样，当生成器函数gen被调用时，Python将为其创建栈帧对象，用于维护函数执行上下文。PyCodeObject对象、全局名字空间、局部名字空间、以及运行时栈都在里面。</strong></p>
<p><strong>但和普通函数不同的是，gen函数的PyCodeObject对象带有生成器标识，在调用的时候，Python不会立刻执行PyCodeObject对象里面的字节码，栈帧对象也不会被接入到调用链中，所以f_back字段此时是空的。相反，Python创建了一个生成器对象，并将其作为函数结果返回。</strong></p>
<p><strong>我们可以使用Python来验证在我们得到的结论。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = gen()</span><br><span class="line"><span class="comment"># 此时刚创建生成器对象, 还没有开始运行</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_running)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈帧对象</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame)  <span class="comment"># &lt;frame at 0x0000021B6B0969F0,....</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PyCodeObject对象</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_code)  <span class="comment"># &lt;code object gen...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们还可以通过如下方式获取</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_code <span class="keyword">is</span> g.gi_code <span class="keyword">is</span> gen.__code__)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器的执行"><a href="#生成器的执行" class="headerlink" title="生成器的执行"></a>生成器的执行</h4><p><strong>当执行g &#x3D; gen()之后，返回生成器对象并交给变量g指向，这个时候还没有开始执行。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>

<p><strong>栈帧对象 *f_lasti* 字段记录当前字节码执行进度，*-1* 表示尚未开始执行。</strong></p>
<p><strong>在使用Python时我们知道，借助 *next* 内建函数或者 *send* 方法可以启动生成器，并驱动它不断执行。这意味着，生成器执行的秘密可以通过这两个函数找到。</strong></p>
<p><strong>我们先从 *next* 函数入手，作为内建函数，它定义于 *Python&#x2F;bltinmodule.c* 源文件，*C* 语言函数 *builtin_next* 是也。*builtin_next* 函数逻辑非常简单，除了类型检查等一些样板式代码，最关键的是这一行：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">res = (*it-&gt;ob_type-&gt;tp_iternext)(it);</span><br></pre></td></tr></table></figure>

<p><strong>这行代码表明，*next* 函数实际上调用了生成器类型对象的 *tp_iternext* 函数完成工作。</strong></p>
<blockquote>
<p><strong>next(g)等价于g.<strong>next</strong>()、等价于g.<strong>class</strong>.<strong>next</strong>(g)。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g.__next__())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">生成器开始执行了</span></span><br><span class="line"><span class="string">创建了一个局部变量name</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 其中g.__next__()的返回值就是yield后面的name</span></span><br></pre></td></tr></table></figure>

<p><strong>那么底层调用了哪个函数呢？我们说类型对象决定实例对象的行为，实例对象相关操作函数的指针都保存在类型对象中。生成器作为 *Python* 对象中的一员，当然也遵守这一法则。顺着生成器的类型对象 *PyGen_Type* ( *Objects&#x2F;genobject.c* )，很快就可以找到 *gen_iternext* 函数。</strong></p>
<p><strong>另一方面， *g.send* 也可以启动并驱动生成器的执行，根据 *Objects&#x2F;genobject.c* 中的方法定义，它底层调用 *_PyGen_Send* 函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef coro_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;send&quot;</span>,(PyCFunction)_PyGen_Send, METH_O, coro_send_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;throw&quot;</span>,(PyCFunction)gen_throw, METH_VARARGS, coro_throw_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;close&quot;</span>,(PyCFunction)gen_close, METH_NOARGS, coro_close_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;        <span class="comment">/* Sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不管 *gen_iternext* 函数还是 *_PyGen_Send* 函数，都是直接调用 *gen_send_ex* 函数完成工作的：</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005419630-869370138.png" alt="img"></p>
<p><strong>因为不管是哪一种方式驱动，最终都由 *gen_send_ex* 函数处理，*next* 和 *send* 的等价性也源于此。经过千辛万苦，我们终于找到了理解生成器运行机制的关键所在。不过这两者虽然是等价的，但是稍稍还有一点不同。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    name = <span class="keyword">yield</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;name = <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = test()</span><br><span class="line">t.__next__()</span><br><span class="line">t.__next__()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">t = test()</span><br><span class="line">t.__next__()</span><br><span class="line">t.send(<span class="string">&quot;夏色祭&quot;</span>)  <span class="comment"># name = 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>这里简单提一下，具体细节可以自己去了解，比较简单。</strong></p>
<p><strong>此外，*gen_send_ex* 函数同样位于 *Objects&#x2F;genobject.c* 源文件，函数挺长，但最关键的代码只有两行：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f-&gt;f_back = tstate-&gt;frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">result = PyEval_EvalFrameEx(f, exc);</span><br></pre></td></tr></table></figure>

<p><strong>首先，第一行代码将生成器栈帧挂到当前调用链(或者说栈帧链)上；然后，第二行代码调用 *PyEval_EvalFrameEx* 开始在生成器栈帧对象中执行字节码；生成器栈帧对象保存着生成器执行上下文，其中 *f_lasti* 字段跟踪生成器代码对象的执行进度。</strong></p>
<p><strong>剩下的逻辑我们显然之前就知道了，*PyEval_EvalFrameEx* 函数最终调用 *_PyEval_EvalFrameDefault* 函数执行 *frame* 对象中 *f_code* 内部的字节码。这个函数我们在虚拟机部分学习过，对它并不陌生。虽然它体量巨大，超过 *3* 千行代码，但逻辑却非常直白——内部由无限 *for* 循环逐条遍历字节码，然后交给内部的一个巨型switch case语句，根据不同的指令执行不同的case分支，每执行完一条字节码就自增 *f_lasti* 字段，直到字节码全部执行完毕、或者中间出现异常时结束循环。</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005428253-249060011.png" alt="img"></p>
<h4 id="生成器的暂停"><a href="#生成器的暂停" class="headerlink" title="生成器的暂停"></a>生成器的暂停</h4><p><strong>我们知道，生成器可以利用 *yield* 语句，将执行权归还给调用者。因此，生成器暂停执行的秘密就隐藏在 *yield* 语句中。我们先来看看 *yield* 语句编译后，生成什么字节码。这里我们就直接分析上面生成器函数内部的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">             <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;生成器开始执行了&#x27;</span>)</span><br><span class="line">             <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">6</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">4</span>           <span class="number">8</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> STORE_FAST               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line"> <span class="number">5</span>          <span class="number">12</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">            <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;创建了一个局部变量name&#x27;</span>)</span><br><span class="line">            <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">            <span class="number">18</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">6</span>          <span class="number">20</span> LOAD_FAST                <span class="number">0</span> (name)</span><br><span class="line">            <span class="number">22</span> YIELD_VALUE</span><br><span class="line">            <span class="number">24</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">8</span>          <span class="number">26</span> LOAD_CONST               <span class="number">4</span> (<span class="number">-1</span>)</span><br><span class="line">            <span class="number">28</span> STORE_FAST               <span class="number">1</span> (age)</span><br><span class="line"></span><br><span class="line"> <span class="number">9</span>          <span class="number">30</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">            <span class="number">32</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;创建了一个局部变量age&#x27;</span>)</span><br><span class="line">            <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">            <span class="number">36</span> POP_TOP</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>          <span class="number">38</span> LOAD_FAST                <span class="number">1</span> (age)</span><br><span class="line">            <span class="number">40</span> YIELD_VALUE</span><br><span class="line">            <span class="number">42</span> POP_TOP</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>          <span class="number">44</span> LOAD_CONST               <span class="number">6</span> (<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">            <span class="number">46</span> STORE_FAST               <span class="number">2</span> (gender)</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>          <span class="number">48</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">            <span class="number">50</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;创建了一个局部变量gender&#x27;</span>)</span><br><span class="line">            <span class="number">52</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">            <span class="number">54</span> POP_TOP</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>          <span class="number">56</span> LOAD_FAST                <span class="number">2</span> (gender)</span><br><span class="line">            <span class="number">58</span> YIELD_VALUE</span><br><span class="line">            <span class="number">60</span> POP_TOP</span><br><span class="line">            <span class="number">62</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">            <span class="number">64</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到每个 *yield* 语句编译后，都得到这样 *3* 条字节码指令：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOAD_FAST   </span><br><span class="line">YIELD_VALUE</span><br><span class="line">POP_TOP</span><br></pre></td></tr></table></figure>

<p><strong>这里是LOAD_FAST，也可以是LOAD_CONST、LOAD_NAME等等，首先这里的LOAD_FAST是将变量指向的值压入运行时栈，设置在栈顶。另外这里变量就是yield右边的值，然后执行 *YIELD_VALUE* 指令，显然关键就在此处。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(YIELD_VALUE)</span>: &#123;</span><br><span class="line">    retval = POP(); <span class="comment">//弹出返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_ASYNC_GENERATOR) &#123;</span><br><span class="line">        PyObject *w = _PyAsyncGenValueWrapperNew(retval);</span><br><span class="line">        Py_DECREF(retval);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            retval = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        retval = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f-&gt;f_stacktop = stack_pointer;</span><br><span class="line">    <span class="comment">//直接通过goto语句跳出for循环</span></span><br><span class="line">    <span class="keyword">goto</span> exit_yielding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>紧接着，*_PyEval_EvalFrameDefault* 函数将当前栈帧(也就是生成器的栈帧)从栈帧链中解开。注意到，*yield* 值被 *_PyEval_EvalFrameDefault* 函数返回，并最终被 *send* 方法或 *next* 函数返回给调用者。</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005437906-1976463887.png" alt="img"></p>
<h4 id="生成器的恢复"><a href="#生成器的恢复" class="headerlink" title="生成器的恢复"></a>生成器的恢复</h4><p><strong>当我们再次调用 *next* 函数或者 *send* 方法时，生成器将恢复执行：</strong></p>
<p><strong>另外通过 *send* 方法，可以传入一个值，赋给yield所在语句的等号左边的变量，那么这是如何做到的呢？</strong></p>
<p><strong>首先我们知道，*send* 方法被调用后，*Python* 先把生成器栈帧对象挂到栈帧链中，并最终调用 *PyEval_EvalFrameEx* 函数逐条执行字节码。在这个过程中，*send* 发送的数据会被放在生成器栈顶：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g.__next__())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">生成器开始执行了</span></span><br><span class="line"><span class="string">创建了一个局部变量name</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># 22</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="string">&quot;matsuri&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建了一个局部变量age</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># 40</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我们 *send* 一个字符串”matsuri”，当然我们的 *yield*  语句中没有出现赋值，所以这里的值没有变量接收。因此在YIELD_VALUE指令后面就是POP_TOP了，将栈顶的值直接弹出、丢弃。尽管我们没有尝试，但如果假设我们使用变量接收了会怎么样呢？不用想，显然YIELD_VALUE指令后面的POP_TOP会变成STORE_FAST，从栈顶取出 *send* 发来的值，并保存在局部变量中。</strong></p>
<p><strong>所以当出现 *next* 函数或者 *send* 方法时，这里会再次将生成器对象的栈帧插入到栈帧链中。</strong></p>
<p><img src="/2023/04/13/22-Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1/1229382-20200906005448401-885632238.png" alt="img"></p>
<p><strong>而且我们看到 *f_lasti* ，它负责保存执行进度，这个进度显然是指字节码指令的便宜量。一开始是 *-1* 表示生成器没有执行，后面的 *22* 、*40* 则对应各自的YIELD_VALUE。此外，我们看到随着生成器的执行，f_locals也在不断变化。</strong></p>
<p><strong>再接着生成器按照逻辑有条不紊的执行，每次遇到 *yield* 就将后面的值返回，并将生成器所在栈帧从栈帧链中移除，同时将f_back设置为空；当使用next函数或者send方法时，再将生成器所在栈帧插入到栈帧链中，然后f_back指向next(g)或者g.send(value)对应的栈帧。然后next(g)或者g.send(value)继续执行，在找到下一个yield之后，继续返回，然后再将生成器所在栈帧的f_back设置为空、并从栈帧链中移除，至于next(g)或者g.send(value)，由于它们已经执行完毕，所在栈帧就被销毁了。然后代码继续执行，如果再遇到next(g)或者g.send(value)，那么再重复相同的动作，周而复始，直到生成器执行完毕。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g.__next__())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">生成器开始执行了</span></span><br><span class="line"><span class="string">创建了一个局部变量name</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># 22</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 我们说next函数或者send方法执行完毕时, 生成器所在栈帧就会从栈帧链中移除, 同时f_back设置为空</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_back)  <span class="comment"># None</span></span><br><span class="line"><span class="comment"># 如果是函数, 那么它的栈帧的f_back属性显然是模块对应的栈帧, 但是对于生成器而言则是None</span></span><br><span class="line"><span class="comment"># 只有在执行时才会被插入到栈帧链中, 并且f_back就是next函数或者send方法调用时所在的栈帧</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="string">&quot;matsuri&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建了一个局部变量age</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># 40</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建了一个局部变量gender</span></span><br><span class="line"><span class="string">-female</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_lasti)  <span class="comment"># 58</span></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame.f_locals)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成器执行完毕&quot;</span>)  <span class="comment"># 生成器执行完毕</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：一旦当生成器执行完毕之后，它的 *gi_frame* 会被设置为None。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(g.gi_frame)  <span class="comment"># &lt;frame at 0x000002353BB469F0...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成器执行完毕&quot;</span>)  <span class="comment"># 生成器执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g.gi_frame)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器小结"><a href="#生成器小结" class="headerlink" title="生成器小结"></a>生成器小结</h4><p><strong>至此，生成器执行、暂停、恢复的全部秘密皆已揭开。流程如下：</strong></p>
<ul>
<li><code>生成器函数编译后代码对象带有 CO_GENERATOR 标识</code></li>
<li><code>如果函数代码对象带 CO_GENERATOR 标识，被调用时 Python 将创建生成器对象</code></li>
<li><code>生成器创建的同时，Python 还创建一个栈帧对象，用于维护代码对象执行上下文</code></li>
<li><code>调用 next函数或者send方法 驱动生成器执行，然后Python 将生成器栈帧对象插入栈帧链，f_back设置为调用的next函数或者send方法对应的栈帧, 开始执行字节码, 注意: 此时是在next函数或者send方法对应的栈帧中执行</code></li>
<li><code>执行到yield语句时，说明next函数或者send方法执行完毕了; 那么将yield右边的值压入运行时栈栈顶, 并终止字节码执行, 退回到上一级栈帧; 并且还会将生成器所在栈帧的f_back设置为空, 以及设置f_lasti等成员</code></li>
<li><code>yield值最终作为next函数或者send方法的返回值，被调用者取得</code></li>
<li><code>当再次调用next函数或者send方法时，Python会将生成器栈帧重新插入到栈帧链中，f_back设置为调用的next函数或者send方法对应的栈帧，然后继续执行生成器内部的字节码。从什么地方开始执行呢？显然是上一次中断的位置，那么上一次中断的位置Python如何得知？没错，显然是通过f_lasti(字节码偏移量)，直接从f_lasti处开始执行</code></li>
<li><code>执行时，会从f_lasti、即上一次YIELD_VALUE处开始执行，并且会获得调用者通过send发来的值，然后继续往下执行</code></li>
<li><code>代码执行权就这样在调用者和生成器间来回切换，然后一直周而复始，直至生成器执行完毕。执行完毕之后，gi_frame就被设置为None了。</code></li>
</ul>
<h3 id="yield和yield-from"><a href="#yield和yield-from" class="headerlink" title="yield和yield from"></a>yield和yield from</h3><p><strong>除了yield还有一个yield from，估计有人理解不清它们的作用，这里我们简单的提一句。由于我们现在是分析解释器，所以这些Python层面的语法知识，就简单说一下。另外之所以会提到yield from，主要是为了后面的协程做铺垫。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = f1()</span><br><span class="line">f2 = f2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__next__())  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 夏</span></span><br></pre></td></tr></table></figure>

<p><strong>yield后面可以跟可迭代对象和不可迭代对象，而yield from后面必须跟可迭代对象。当执行时，会将yield后面的值作为一个整体迭代出来，而yield from则是迭代”可迭代对象里面的一个值”。我们再举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">f1 = foo1()</span><br><span class="line">f2 = foo2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__next__())  <span class="comment"># [1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">所以我们发现了:</span></span><br><span class="line"><span class="string">    yield from [1, 2, 3]</span></span><br><span class="line"><span class="string">    等价于</span></span><br><span class="line"><span class="string">    for item in [1, 2, 3]</span></span><br><span class="line"><span class="string">        yield item</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果要是但看上面的吗？会发现yield from貌似没什么特殊的地方，但是yield from它还可以作为委托生成器。</strong></p>
<blockquote>
<p><strong>委托生成器：负责在调用方和子生成器之间建立一个双向通道。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;白上吹雪&quot;</span>]:</span><br><span class="line">        <span class="keyword">yield</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;yagoo的偶像梦破灭了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    res = <span class="keyword">yield</span> <span class="keyword">from</span> foo1()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f2 = foo2()</span><br><span class="line"><span class="comment"># 此时不经过foo2, 我们说调用方和子生成器之间建立了一个双向通道</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 神乐mea</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 白上吹雪</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f2.__next__()</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;迭代结束了&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">yagoo的偶像梦破灭了</span></span><br><span class="line"><span class="string">迭代结束了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里在执行f2.<strong>next</strong>()的时候并没有经过foo2，因为它建立了一个双向通道，我们是直接找到foo1，同理foo1中yield后面的值也会直接返回给调用方。</strong></p>
<p><strong>一旦foo1中的代码执行完毕，理论上肯定会抛出StopIteration异常，但是有委托生成器。所以会将返回值交给委托生成器中的res，然后在委托生成器中继续寻找yield或者yield from。但是显然res &#x3D; yield from foo1()这行代码下面已经没有yield或者yield  from了，所以异常会由委托生成器抛出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;白上吹雪&quot;</span>]:</span><br><span class="line">        <span class="keyword">yield</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;yagoo的偶像梦破灭了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    <span class="keyword">yield</span> (<span class="keyword">yield</span> <span class="keyword">from</span> foo1())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f2 = foo2()</span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 神乐mea</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># 白上吹雪</span></span><br><span class="line"><span class="built_in">print</span>(f2.__next__())  <span class="comment"># yagoo的偶像梦破灭了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然这是最标准的写法</span></span><br><span class="line"><span class="comment"># 当foo1结束之后, 那么yield from foo1()就是foo1的返回值</span></span><br><span class="line"><span class="comment"># 因此等价于yield &quot;yagoo的偶像梦破灭了&quot;, 在寻找下一个yield的时候, 正好将返回值迭代出来</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们介绍了生成器，分析了它的执行原理，相信你对生成器会有一个更深的认识。另外在项目中，可以多尝试使用生成器。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>Where to Start Studying Type Annotation Practices in Python</title>
    <url>/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/</url>
    <content><![CDATA[<h2 id="Where-to-Start-Studying-Type-Annotation-Practices-in-Python"><a href="#Where-to-Start-Studying-Type-Annotation-Practices-in-Python" class="headerlink" title="Where to Start: Studying Type Annotation Practices in Python"></a>Where to Start: Studying Type Annotation Practices in Python</h2><h3 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h3><p>主要研究这三个问题：</p>
<p>RQ1. What are the patterns that non-trivial type-annotation practices follow?</p>
<p>非平凡的类型注解实践遵循哪些模式？</p>
<p>这个问题旨在探讨在实际项目中，类型注解的使用是否遵循某种特定的模式或规律。例如，开发者可能会倾向于在某些场景下使用类型注解，或者某些特定类型的函数和变量更常见于类型注解。</p>
<p>RQ2. Do type-annotated files present different dependency structure?</p>
<p>使用类型注解的文件是否呈现出不同的依赖结构？ </p>
<p>这个问题旨在了解类型注解是否对项目的依赖结构产生影响。例如，使用类型注解的文件是否更可能依赖其他类型注解文件，或者这些文件在项目中的依赖关系是否更紧密。</p>
<p>RQ3. Do type-annotated files incur different maintenance cost?</p>
<p>使用类型注解的文件是否带来不同的维护成本？</p>
<p>这个问题关注类型注解是否对项目的维护成本产生影响。例如，使用类型注解的文件是否更容易出现错误，是否需要更多的修改，或者这些文件的维护难度是否更高。</p>
<h3 id="研究方法-METHODOLOGY"><a href="#研究方法-METHODOLOGY" class="headerlink" title="研究方法 METHODOLOGY"></a>研究方法 METHODOLOGY</h3><h4 id="A-Concepts"><a href="#A-Concepts" class="headerlink" title="A.Concepts"></a><strong>A.Concepts</strong></h4><p>Optional Type Annotation:</p>
<p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413103136596.png" alt="image-20230413103136596"></p>
<p>Type Annotation Implementation</p>
<p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413103339736.png" alt="image-20230413103339736"></p>
<p>一种是直接写在函数体上的，一种是另存在Stub file里的</p>
<p>Trivial and Non-trivial Type Practices</p>
<p>Trivial Type Practices（简单类型实践）：这种类型注解实践非常简单，只需要按照 <code>: type</code> 的语法为代码实体分配类型。在这种情况下，类型注解前后的源代码是一致的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>Non-trivial Type Practices（复杂类型实践）：这种类型注解实践相对复杂，需要引入额外的定义，如变量、函数和类。这种实践会导致代码和类型注解代码之间的不一致。</p>
<p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413104015800.png" alt="image-20230413104015800"></p>
<h4 id="B-THProfifiler"><a href="#B-THProfifiler" class="headerlink" title="B.THProfifiler"></a><strong>B.THProfifiler</strong></h4><p>(1) Typing Practice Identification（类型实践识别）</p>
<p>：该部分检测源代码中带有类型注解的实体和类型使用情况。</p>
<ul>
<li>Typing Coverage Detection（类型覆盖检测）：使用 Python 的 <code>ast</code> 库，此模块首先识别所有代码实体和类型注解实体，然后计算各个级别的类型覆盖率。类型覆盖率定义为带有类型提示的实体（如函数、文件、变量）所占的比例。</li>
<li>Diverse Type Extraction（多样性类型提取）：通过遍历源文件和存根文件（如果有）的抽象语法树（AST）结构，此模块检测分配给实体的所有类型。</li>
<li>Complex Typing Usage Detection（复杂类型使用检测）：此模块检测协议和函数重载的使用情况。重载函数使用 <code>@overload</code> 装饰器声明，该装饰器从 <code>typing</code> 模块导入。</li>
</ul>
<p>函数重载：允许在同一个模块或类中定义多个具有相同名称但参数类型不同的函数。可以使用来自 <code>typing</code> 模块的 <code>@overload</code> 装饰器来声明重载函数。这使得在静态类型检查时，根据传递的参数类型选择合适的函数实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> overload, <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>], b: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> add(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world!&quot;</span>) == <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>协议（Protocols）：协议是一种支持结构化类型检查的类，它来自 <code>typing</code> 模块。协议允许在静态类型检查时进行隐式的基类检查，而无需显式地继承。实际上，只要一个类具有协议所定义的成员，它就可以被视为协议的子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SupportsLength</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_length</span>(<span class="params">obj: SupportsLength</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> get_length(MyClass()) == <span class="number">42</span></span><br><span class="line"><span class="keyword">assert</span> get_length([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>(2)依赖结构表征。</p>
<p>该部分根据设计规则理论（Design Rule Theory）提取和分析源代码的依赖结构。系统包括以下几个模块：</p>
<p><font color="red">Dependency Extraction（依赖关系提取）</font>：该模块考虑源代码中的显式依赖关系和可能的依赖关系。显式依赖关系是源代码中显式引用的语法依赖关系，而可能的依赖关系是由于鸭子类型（duck typing）而产生的不可见和非确定性依赖关系。该模块使用 SCITool Understand 和 ENRE 分别提取显式依赖关系和可能的依赖关系。在实际编程过程中，鸭子类型允许函数或方法接受任何类型的参数，只要这些参数支持预期的行为（如方法或属性）。这意味着不需要显式地检查对象的类型，而是通过对象的行为来推断其类型。</p>
<p>在这个例子中，我们将展示 Dependency Extraction（依赖关系提取）中的显式依赖关系（explicit dependencies）和可能的依赖关系（possible dependencies）。</p>
<p>考虑以下 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file_a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Quack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># file_b.py</span></span><br><span class="line"><span class="keyword">from</span> file_a <span class="keyword">import</span> Duck</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.speak()</span><br><span class="line"></span><br><span class="line">d = Duck()</span><br><span class="line">make_sound(d)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>file_b.py</code> 显式地依赖于 <code>file_a.py</code>，因为它从 <code>file_a</code> 导入了 <code>Duck</code> 类。这是一个显式依赖关系，因为它在源代码中明确指定。</p>
<p>然而，在这段代码中还存在一个可能的依赖关系。函数 <code>make_sound</code> 接受一个参数 <code>animal</code>，并调用其 <code>speak</code> 方法。由于 Python 使用鸭子类型，<code>animal</code> 参数可以是任何具有 <code>speak</code> 方法的对象。这意味着，尽管 <code>make_sound</code> 函数在这里使用了 <code>Duck</code> 类的实例，但它也可以接受其他具有 <code>speak</code> 方法的类的实例，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file_c.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># file_d.py</span></span><br><span class="line"><span class="keyword">from</span> file_c <span class="keyword">import</span> Dog</span><br><span class="line"><span class="keyword">from</span> file_b <span class="keyword">import</span> make_sound</span><br><span class="line"></span><br><span class="line">d = Dog()</span><br><span class="line">make_sound(d)</span><br></pre></td></tr></table></figure>

<p>在这个情况下，<code>file_d.py</code> 的 <code>make_sound</code> 函数依赖于 <code>file_c.py</code> 中的 <code>Dog</code> 类。尽管这种依赖关系并非在源代码中明确指定，但由于鸭子类型的使用，<code>Dog</code> 类可以作为 <code>animal</code> 参数传递给 <code>make_sound</code> 函数。因此，这是一个可能的依赖关系。</p>
<p>总之，在依赖关系提取中，显式依赖关系是源代码中明确指定的依赖关系，而可能的依赖关系是由于动态类型语言（如 Python）的特性（如鸭子类型）而存在的不可见和非确定性依赖关系。</p>
<p><font color="red">Graph Construction（图构建）</font>：该模块根据显式依赖关系和可能的依赖关系构建属性依赖图（ADG）。在 ADG 中，每个节点表示一个源文件，每个有向边表示两个文件之间的依赖关系。节点属性指定节点是否具有类型提示（表示为类型化）。属性信息来自 THProfiler 的类型实践识别。</p>
<p>我们将使用以下 Python 代码构建属性依赖图（Attributed Dependency Graph, ADG）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># animal.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># duck.py</span></span><br><span class="line"><span class="keyword">from</span> animal <span class="keyword">import</span> Animal</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Quack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dog.py</span></span><br><span class="line"><span class="keyword">from</span> animal <span class="keyword">import</span> Animal</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> duck <span class="keyword">import</span> Duck</span><br><span class="line"><span class="keyword">from</span> dog <span class="keyword">import</span> Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.speak()</span><br><span class="line"></span><br><span class="line">d = Duck()</span><br><span class="line">g = Dog()</span><br><span class="line">make_sound(d)</span><br><span class="line">make_sound(g)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们有四个 Python 文件：<code>animal.py</code>、<code>duck.py</code>、<code>dog.py</code> 和 <code>main.py</code>。我们可以从这些文件的依赖关系构建一个属性依赖图。为了简化，我们假设所有文件都有类型提示。</p>
<p>ADG 的节点表示源文件，有向边表示文件之间的依赖关系。节点的属性指定文件是否有类型提示。在这个例子中，图如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal.py -&gt; [typed]</span><br><span class="line">duck.py   -&gt; [typed] -&gt; animal.py</span><br><span class="line">dog.py    -&gt; [typed] -&gt; animal.py</span><br><span class="line">main.py   -&gt; [typed] -&gt; duck.py, dog.py</span><br></pre></td></tr></table></figure>

<p>图中的箭头表示依赖关系。例如，<code>duck.py</code> 依赖于 <code>animal.py</code>，因为它从 <code>animal.py</code> 导入了 <code>Animal</code> 类。同样，<code>main.py</code> 依赖于 <code>duck.py</code> 和 <code>dog.py</code>，因为它从这两个文件导入了 <code>Duck</code> 和 <code>Dog</code> 类。</p>
<p>在这个 ADG 中，每个节点都有一个 <code>[typed]</code> 属性，表示文件具有类型提示。实际情况下，属性依赖图会根据文件是否使用类型提示（如类型注解）来设置节点属性。</p>
<p><font color="red">Design Rule Hierarchy (DRH)（设计规则层次结构）</font>：基于 ADG，该模块使用 DRH 算法识别软件系统中的设计规则和独立模块。根据设计规则理论，DRH 将源文件聚类为分层结构，其中上层的文件表示设计规则，下层的文件被组织成由这些设计规则解耦的独立模块。下层的模块依赖于上层的模块，反之则不然。同一层的模块相互独立。</p>
<p>在上述例子中，我们有一个属性依赖图（ADG）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal.py -&gt; [typed]</span><br><span class="line">duck.py   -&gt; [typed] -&gt; animal.py</span><br><span class="line">dog.py    -&gt; [typed] -&gt; animal.py</span><br><span class="line">main.py   -&gt; [typed] -&gt; duck.py, dog.py</span><br></pre></td></tr></table></figure>

<p>现在我们将应用设计规则层次结构（Design Rule Hierarchy，DRH）来识别设计规则和独立模块。DRH 将源文件聚类为分层结构，其中上层文件表示设计规则，下层文件表示通过这些设计规则解耦的独立模块。</p>
<p>在这个例子中，DRH 可以生成以下层次结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L0: animal.py</span><br><span class="line">L1: duck.py, dog.py</span><br><span class="line">L2: main.py</span><br></pre></td></tr></table></figure>

<ul>
<li>层 L0（最高层）包含 <code>animal.py</code>，它定义了一个通用的 <code>Animal</code> 基类。这个基类是这个系统的设计规则，因为其他类（<code>Duck</code> 和 <code>Dog</code>）继承自它。</li>
<li>层 L1 包含 <code>duck.py</code> 和 <code>dog.py</code>，它们都依赖于 L0 中的 <code>animal.py</code>。这一层包含了通过 <code>Animal</code> 基类解耦的独立模块。这些模块实现了特定的动物（<code>Duck</code> 和 <code>Dog</code>）。</li>
<li>层 L2 包含 <code>main.py</code>，它依赖于 L1 中的 <code>duck.py</code> 和 <code>dog.py</code>。这一层的模块使用了 L1 中的模块，但不直接依赖于设计规则（在本例中为 <code>Animal</code> 类）。</li>
</ul>
<p>通过这种分层结构，DRH 揭示了代码中的设计规则和独立模块。在这个例子中，设计规则是 <code>Animal</code> 基类，它允许将 <code>Duck</code> 和 <code>Dog</code> 类组织为独立模块。<code>main.py</code> 作为客户端代码，使用这些模块实现特定功能，如调用 <code>make_sound</code> 函数。</p>
<p><font color="red">Maintenance Measurement:(维护注解成本度量)</font></p>
<p>第三部分关注于度量带有类型注解和不带类型注解文件的维护成本。这部分基于版本控制系统（如 Git）管理的修订历史来计算维护成本。</p>
<ol>
<li>修订历史预处理：这个模块从代码仓库中导出提交日志。每个提交记录包括提交 ID、进行此次提交的作者、修改的文件列表、此次提交修复的问题 ID，以及添加和删除的代码行数（LoC）。</li>
<li>维护成本度量：基于提交记录，这个模块量化维护源文件所需的工作量。参照其他研究（如 [10] 和 [24]），计算了六个度量值，包括：<ul>
<li>提交次数（#commit）：对文件进行的提交次数；</li>
<li>修改代码行数（#changeLoc）：修改文件时的总代码行数；</li>
<li>开发人员数量（#author）：维护文件的开发人员数量；</li>
<li>涉及问题数量（#issue）：文件涉及的问题数量；</li>
<li>问题修复提交次数（#issueCmt）：文件修复问题的提交次数；</li>
<li>问题修复代码行数（#issueLoc）：为修复问题而修改的文件的总代码行数。</li>
</ul>
</li>
</ol>
<p>这些度量值越大，表示投入到文件维护的成本越高。通过比较带有类型注解和不带类型注解文件的维护成本，可以了解类型注解是否对代码维护产生影响。</p>
<h3 id="实证研究"><a href="#实证研究" class="headerlink" title="实证研究"></a>实证研究</h3><h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h4><p>文章的作者们手动选择了 Python 项目作为研究对象。基本的选择标准包括：</p>
<ol>
<li>项目部分使用了类型提示（type-hinted）；</li>
<li>项目被广泛使用，经常被标星（starred）或下载；</li>
<li>项目具有良好管理的修订历史，包括提交和问题；</li>
<li>项目遵循 Python 3.5 或更高版本支持的类型注解语法；</li>
<li>项目使用非 Any 类型，因为 Any 类型与所有类型兼容且没有语义。</li>
</ol>
<p>根据这些要求，文章的三位贡献者首先从最近一项研究 [10] 中研究的 105 个公共项目中选择项目，然后选择在 Github 上频繁被标星的 Python 项目。选择过程需要手动检查项目、源代码和社区讨论，以确定类型相关信息，例如他们采用的类型提示方式以及管理类型实现的仓库。</p>
<p>为了减轻研究偏见，从三位贡献者收集的项目中，最终选择了具有各种多样性的项目：</p>
<ol>
<li>多样化的类型提示方式：选择了仅采用内联类型注解、仅采用存根类型文件或同时采用内联和存根的项目。</li>
<li>不同领域：项目涵盖了不同领域，如 Web 框架、科学计算和类型检查。</li>
<li>不同规模：项目可以是小规模（少于 1 万行代码）、中等规模（至少 1 万行代码）或大规模（至少 10 万行代码）。</li>
</ol>
<p>最终，作者们收集了 19 个项目，如表 I 所示。</p>
<p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413112642078.png" alt="image-20230413112642078"></p>
<h4 id="覆盖率统计"><a href="#覆盖率统计" class="headerlink" title="覆盖率统计"></a>覆盖率统计</h4><p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413112733674.png" alt="image-20230413112733674"></p>
<p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413112740091.png" alt="image-20230413112740091"></p>
<h4 id="不同类型使用情况的统计数据"><a href="#不同类型使用情况的统计数据" class="headerlink" title="不同类型使用情况的统计数据"></a>不同类型使用情况的统计数据</h4><p><img src="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/image-20230413112844216.png" alt="image-20230413112844216"></p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>动机：在使用 THProfiler 的 Typing Coverage Detection 时，作者们在带有存根文件的研究对象中发现了一个有趣的现象：除了为符号添加一个类型之外，开发人员有时还定义了在源文件中不存在的新实体。</p>
<h4 id="RQ1"><a href="#RQ1" class="headerlink" title="RQ1:"></a>RQ1:</h4><p>Patterns of Non-trivial Type-annotation Practices</p>
<p>类别1（类型兼容性）：随着 typing 模块的发展，类型注解不可避免地会提供以前版本中不可用的新类型。在较旧版本中实现类型注解时，需要为版本兼容性自定义这些新类型。</p>
<p>类别2（API可见性）：一个模块定义了一个API，而其相应的类型注解API在依赖此API的另一个模块的存根文件中声明。</p>
<p>类别3（基类呈现）：基类，无论是从typing.Protocol1扩展还是没有扩展，都被引入到类型实现中，使原本不可见的接口变得显式。</p>
<p>类别4（函数重载）：源代码中的函数可能在其类型实现中重载。过载的函数具有相同的名称，但使用不同类型的参数或返回进行声明</p>
<p>类别5（函数赋值变量）：对于被赋予函数对象的变量，类型实现可能会明确地将它们声明为函数。这种做法将在存根文件中生成新的函数定义。这意味着，尽管在源代码中变量被赋予了函数对象，但在存根文件中，它们将作为单独的函数进行类型注解。这样可以让类型实现更加清晰和明确，以便于其他开发者理解和使用。</p>
<p>类别6（类型扩展）：某些存根文件对应于扩展文件，如 <em>.pxd。</em>.pxd 的作用类似于 C 语言的头文件，由 Cython  提供，用于支持为 Python 语言编写 C  扩展。在这种情况下，存根文件中的类型注解用于描述这些扩展文件中的接口和数据结构。这有助于提高类型安全性，并为使用这些扩展的开发人员提供更清晰的接口说明。</p>
<h4 id="RQ2"><a href="#RQ2" class="headerlink" title="RQ2:"></a>RQ2:</h4><p><em>Characterizing Dependency Structure</em></p>
<p>我们的结果表明，有类型注释的文件在软件结构中呈现出不同的特征。具体地说，它们具有较高的度中心性值，并且它们位于层次结构的最上层，因此表现为软件系统的设计规则。</p>
<h4 id="RQ3："><a href="#RQ3：" class="headerlink" title="RQ3："></a>RQ3：</h4><p><em>Characterizing Maintenance Cost</em></p>
<p>结果表明，类型注释文件与其他文件的维护成本存在差异。这一观察结果表明，难以维护的文件可能是有希望优先进行类型注释的候选文件。</p>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>TYPET5 SEQ2SEQ TYPE INFERENCEUSING STATIC ANALYSIS</title>
    <url>/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/</url>
    <content><![CDATA[<h2 id="TYPET5-SEQ2SEQ-TYPE-INFERENCE-USING-STATIC-ANALYSIS"><a href="#TYPET5-SEQ2SEQ-TYPE-INFERENCE-USING-STATIC-ANALYSIS" class="headerlink" title="TYPET5: SEQ2SEQ TYPE INFERENCE USING STATIC ANALYSIS"></a>TYPET5: SEQ2SEQ TYPE INFERENCE USING STATIC ANALYSIS</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: TypeT5: Seq2Seq Type Inference Using Static Analysis(利用静态分析的Seq2Seq类型推断)</li>
<li>Authors: Jiayi Wei, Greg Durrett, Isil Dillig</li>
<li>Affiliation: Department of Computer Science, University of Texas at Austin(得克萨斯大学奥斯汀分校计算机科学系)</li>
<li>Keywords: type inference, static analysis, seq2seq, CodeT5</li>
<li>URLs: arXiv:2303.09564v1 [cs.SE], GitHub: None</li>
</ul>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h3><ul>
<li>a. 本文的研究背景：<ul>
<li>本文提出了TypeT5模型，用于在Python代码中推断类型注释。TypeT5是基于CodeT5模型的改进版本，使用静态分析构建使用图进行语境增强。</li>
</ul>
</li>
<li>b. 过去的方法，它们的问题和动机：<ul>
<li>目前已有的方法在预测常见类型方面表现良好，但对于罕见或复杂类型的预测往往存在困难。</li>
</ul>
</li>
<li>c. 本文提出的研究方法：<ul>
<li>作者将类型预测作为代码填充任务，使用CodeT5进行训练，使用静态分析构建动态上下文，应用迭代解码方案从相关代码元素中收集信息进行类型预测。</li>
</ul>
</li>
<li>d. 方法在任务和性能方面所实现的：<ul>
<li>TypeT5模型比基线方法（包括不使用静态分析的CodeT5模型）具有更高的准确性，产生更多的连贯结果，类型错误更少。TypeT5方法还可以方便地进行用户干预，使其成为注释完全无类型项目的有用工具。</li>
</ul>
</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><ul>
<li>a. 主题和特点：<ul>
<li>本文研究类型推断问题，针对Python编程语言中的不稳定类型，提高代码的分析和维护过程。</li>
</ul>
</li>
<li>b. 历史发展：<ul>
<li>目前Python等语言中的类型推断通常基于程序执行的动态特性。传统方法的准确性受到功能需求的限制，难以在复杂情况下确定类型注释。</li>
</ul>
</li>
<li>c. 过去的方法：<ul>
<li>学者们在对于不稳定类型的Python代码类型推断任务上，采用了基于语义的技术来解决编程过程中的困难。这些方法的准确性在复杂情况下受到一定的限制，因此需要进行改进。</li>
</ul>
</li>
<li>d. 过去研究的不足之处:<ul>
<li>针对罕见或复杂类型的预测往往存在困难，因此需要提出更有针对性的预测方法。</li>
</ul>
</li>
<li>e. 当前需要解决的问题:<ul>
<li>如何提高类型预测的准确性和效率，并通过静态分析对动态上下文情境增强以实现更好的类型预测。</li>
</ul>
</li>
</ul>
<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a>Intro:</h3><p>首先指明了类型注释的重要性，随着大规模预训练和Transformer架构的爆炸式发展，序列到序列（seq2seq）模型已被证明对编程任务非常有效，例如生成代码注释、补全和合成。然而，与代码补全任务相比，有效的类型推断通常需要非局部信息，这些信息可能属于完全不同的文件。</p>
<p>随着大规模预训练和Transformer架构的兴起，Seq2Seq模型在编程任务（如代码注释生成、代码补全和代码合成）方面已经被证明非常有效。然而，与可以仅依赖周围代码环境的代码补全任务不同，有效的类型推断通常需要非局部信息，这些信息可能属于完全不同的文件。为解决这一挑战，TypeT5方法通过使用静态分析来确定对每个预测有用的代码部分。具体而言，构建了一个所谓的使用图（usage  graph），其中节点对应于代码元素（即我们想要预测类型的函数或变量），边表示它们之间的潜在用户-使用者关系。给定这样一个图，我们将给定代码元素的用户和使用者以类似于正常代码的形式进行编码，并将它们作为额外的上下文输入到Transformer模型中。为充分利用Seq2Seq范式，我们还提出了一种迭代解码方案，该方案利用上下文传递先前的类型预测，允许信息在整个代码库的远程代码元素之间传播。TypeT5基于流行的CodeT5模型实现，并用于为无类型Python代码合成类型注解。评估将TypeT5与三种最先进的类型推断工具（Allamanis等人，2020; Mir等人，2022; Peng等人，2022）和不利用静态分析的CodeT5 Baseline进行比较。</p>
<p>综上所述，本文的贡献如下：</p>
<ul>
<li>我们应用CodeT5来推断Python类型的注释，并显示出比以前的方法有显著的改进。据我们所知，这是第一个能够同时预测参数化类型和用户定义类型的基于ml的技术。</li>
<li>我们通过应用静态分析技术来改进普通的CodeT5模型，以帮助模型推理除局部上下文之外的信息，从而进一步提高其性能。</li>
<li>我们提出了一个迭代解码方案，特别有助于处理一致性，通过类型检查器报告的类型错误的数量来衡量。此外，我们还提出了一种结合了seq2seq解码方案和用户干预的新设置。</li>
</ul>
<h3 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h3><p><img src="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/image-20230418144904538.png" alt="image-20230418144904538"></p>
<p><strong>Type inference as code infifilling</strong>  在这项工作中，作者提倡将类型推断视为代码填充（code infilling）的一种新方法。因为类型注解可以被视为缺失的代码片段，所以作者使用了一种先进的代码填充模型（即CodeT5）作为起点进行微调。由于CodeT5使用字节对编码（Byte Pair Encoding）生成子词（subword）令牌序列，因此它原则上可以预测任意代码片段来填充被屏蔽的空白，包括具有复杂参数类型和用户定义类的类型注解。</p>
<p>**Incorporating context through static analysis ** 通过静态分析整合上下文：通过使用周围的代码作为预测上下文，微调后的CodeT5可以相对容易地预测某些变量的正确类型注解。例如，根据n_seqs（model.py，第7行）或window_size（eval.py，第4行）的名称和默认值，CodeT5可以判断出这些参数的正确类型。然而，对于eval.py第2行的model等其他参数，周围的上下文没有足够的信息来做出合理的预测。造成这种情况的原因是，ModelWrapper是在另一个文件中定义的新类，因此（1）在训练期间从未见过它，（2）它的定义不作为上下文的一部分提供。同样，预测eval_on_dataset的返回类型也非常困难，因为它直接返回model.predict的结果，而model.predict的定义对模型来说也是不可用的。解决这个问题的关键是如何构造上下文。</p>
<p><img src="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/image-20230418145818609.png" alt="image-20230418145818609"></p>
<p><strong>TypeT5 architecture</strong></p>
<p>为什么不把所有的信息都传递给CodeT5进行代码填充呢，因为模型可接受的上下文有限。为了解决这个问题，TypeT5采用了一种迭代解码方案，允许根据先前的类型预测进行条件化。具体来说，我们的解码方案首先对用户-使用者图进行拓扑排序，然后进行两个顺序的预测传递，首先从使用者到用户，然后反向进行，如图3所示。要理解为什么这两个方向都有用，请注意eval_on_dataset的返回类型取决于predict，而predict又取决于predict_on_batch。因此，将信息从被调用者传播到调用者显然是有用的。相反，考虑预测predict的第一个参数data的类型。由于chunk_srcs的返回值作为predict的第一个参数传递，因此反向传播信息也可能是有帮助的。</p>
<p><img src="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/image-20230418151229179.png" alt="image-20230418151229179"></p>
<p>user-usee图（简单来说就是调用关系，和callgraph没区别吧）</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 研究的理论基础：<ul>
<li>序列到序列的模型用于在Python代码中进行类型预测，作者在此基础上提出了TypeT5模型，并使用代码中的上下文信息进行语境增强，以弥补现有研究方法的不足。</li>
</ul>
</li>
<li>b. 文章的技术路线：<ul>
<li>TypeT5模型将类型推断视为代码填充任务。模型采用Transformers模型将分布放置在原始代码序列及其周围上下文中给定的类型序列上。TypeT5通过使用使用图来构造模型输入，并通过迭代解码方案利用推断时间中上下文中包含的类型信息，最大化预测的地面真相的对数似然性。文章还对TypeT5和其他三个最先进的用于Python的类型推断系统进行了评估，并展示了消融研究以评估提高模型性能的不同因素。</li>
</ul>
</li>
<li>c. 方法的细节：<ul>
<li>该方法将Python代码类型推断作为序列到序列的任务，将TypeT5分为四个部分：前面部分、Usees部分、主体代码部分和Users部分，并通过充分利用使用关系等其他信息，提高了推断精度。</li>
</ul>
</li>
</ul>
<p><strong>使用CodeT5进行类型预测</strong></p>
<p>我们将类型预测形式化为一个序列到序列（seq2seq）任务。设u &#x3D; (u1, …, un)表示代码令牌的序列，其中每个令牌都是一个未类型化的代码元素e（函数或变量）。我们在需要预测类型的每个位置插入带索引的标记令牌（<extra id i>），并让模型预测t &#x3D; (t1, …, tm)，即表示u中标记位置类型的令牌序列。注意，t只包含类型，不包含其他代码令牌，格式为&lt;extra id 1&gt; [type 1 tokens] &lt;extra id 2&gt; [type 2 tokens]等。我们使用与CodeT5相同的分词器，它允许将任何Python表达式编码为（通常较短的）子词令牌序列。</extra></p>
<p>我们的基线CodeT5模型是一个Transformer seq2seq模型P(t | u, ¯u)，在原始代码序列u及其周围代码¯u的条件下，对类型序列t建立分布。这个过程如图2所示，为了清晰起见，省略了¯u。</p>
<p>我们的改进模型TypeT5用静态分析构建的上下文s替换周围的代码¯u。因此，我们可以将模型表示为P(t | u, s)。注意，在这两个模型中，我们在预处理步骤中删除所有注释和Python文档字符串，如之前的工作所做的那样。现在我们将展示如何从静态分析中构建s。</p>
<p><strong>构建使用图</strong></p>
<p>为了克服仅使用周围代码作为上下文的局限性，我们的方法依赖于静态分析来提取代码库相关的全局信息。特别是，我们的分析构建了一个使用图，其节点对应于代码元素，边表示直接使用。例如，如果x和y都是函数，从x到y的边表示x调用y。类似地，对于变量，从x到y的边表示x的值取决于y。</p>
<p>我们之前示例的使用图如图4所示。我们展示了两种使用类型：确切的使用（用实线箭头表示）和潜在的使用（用虚线箭头表示）。确切的使用是可以在不知道涉及变量的类型的情况下静态确定的使用。例如，全局函数chunk srcs直接被eval on dataset使用，我们还知道predict on batch是由predict调用的（第12行的self方法调用）。对于其他情况，如非self属性访问或方法调用，目标取决于接收者的类型，因此我们首先收集当前项目中具有匹配名称的所有属性和方法，然后为每个属性和方法生成一个潜在的使用。我们在附录A.1中详细介绍了使用图的构建。</p>
<p><strong>构建模型输入</strong></p>
<p>定义代码元素e为以下四个部分：</p>
<p>Preamble：spre的主要目的是帮助模型将每个局部名称映射到它所引用的定义，因此前导包括所有导入语句。此外，为了帮助模型了解当前作用域中可用的类型，前导还包括当前文件中的所有类定义的头部以及所有类型变量声明。<font color="red">简单说就是import语句和变量的定义。</font></p>
<p>Main Code：我们使用其定义构造u。如果e是一个函数，u就是其源代码；如果e是一个变量，u包括所有顶级赋值语句，其中e作为左侧。另外，如果e是类C的方法或属性，我们还缩进u并用C的头部将其前置。</p>
<p>Users：根据使用图G，我们通过包括来自users(G,  e)的所有元素的源令牌来构造suser。由于这些元素可能来自不同的源文件，我们还在每个元素前添加一个特殊注释，表示它来自的Python模块。注意，这些元素可以选择包含我们TypeT5模型预测的类型，如后续3.4小节所述。</p>
<p>Usee：susee不仅包含e的直接用户，还包含用户上下文中使用的任何东西。由于这通常比suser包含更多的元素，所以我们只使用元素的（类型或非类型）签名来构造susee。</p>
<p>我们将总输入大小限制在最多4096个子词令牌内，并从左右两侧截断超出的令牌，以主代码为中心。涉及确定用法的上下文元素被安排在离中心更近的位置，以便它们始终优先于潜在用法。</p>
<p><strong>迭代解码推理</strong></p>
<p>CodeT5解码：给定训练好的模型P(t | u,  ¯u)，我们可以使用束搜索为u（带有周围上下文¯u）推断出最可能的一组类型t。我们的实现对单个代码块u的输出类型进行联合预测，因为块中较后的类型取决于先前类型的预测。然而，请注意，u和¯u始终是完全无类型的代码：尽管我们在预测时考虑先前的类型，但这些类型不会插入到下一个元素的预测上下文中。</p>
<p>TypeT5迭代解码：将上下文s包括在内的部分动机是在推理时利用其类型信息。关键的是，这需要s是有类型的。然而，从原始代码库中获取的上下文是无类型的，因此TypeT5使用自己的预测迭代地向这些上下文添加类型签名。</p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p><strong>数据集</strong></p>
<p><img src="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/image-20230418154821134.png" alt="image-20230418154821134"></p>
<p>主要数据集BetterTypes4Py是通过从ManyTypes4Py数据集（Mir等人，2021年）中选择高质量子集构建的，该数据集用于训练Type4Py。附录A.2中描述了选择标准。由于我们的模型是从CodeT5模型（可能已经在上述数据集中的一些测试仓库上进行了预训练）进行微调的，我们另外构建了InferTypes4Py，这是一个测试集，派生自Typilus、Type4Py和我们自己的工具的源代码，它们都没有被用作CodeT5的（预）训练数据。我们在附录中进一步讨论了潜在的代码重复问题（附录A.3）和标签质量问题（附录A.4）。</p>
<p><strong>评估指标</strong></p>
<p>准确度</p>
<p>Type error count</p>
<p><strong>评估结果</strong></p>
<p>准确度</p>
<p><img src="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/image-20230418154804401.png" alt="image-20230418154804401"></p>
<p>不同的组件如何影响模型的性能？(Preamble,MainCode等等）（1）所有组件都提高了总体准确性，其中preamble的影响最大；（2）虽然迭代解码方案只略微提高了总体准确性，但它显着提高了模型的连贯性，导致类型错误减少了12%。</p>
<p>不同的解码策略如何比较？除了第3.4小节介绍的两遍迭代解码策略外，我们还测试了另外四种解码策略：（1）Independent，它独立地为每个元素预测类型签名，不受模型自身预测的影响（与Nonincremental模型相同，只是没有重新训练）；（2）Random，按照随机顺序依次访问每个元素；（3）UserToUsee，先访问用户再访问被使用者；（4）UseeToUser，先访问被使用者再访问用户。结果显示在表5中（在表8中显示了其他准确性指标）。我们可以看到，我们提出的两遍解码策略相对于Independent有最大的准确性和类型错误改进；而UserToUsee表现比Independent还差，这表明不良的解码顺序可能对模型的性能产生不利影响。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h3><ul>
<li>a. 研究的重要性:<ul>
<li>该文提出了一种新的、高效的类型推断方法TypeT5，在Python代码中应用静态分析构建代码的动态上下文，准确地预测复杂类型，并提供用户干预功能，适用于注释完全无类型项目。</li>
</ul>
</li>
<li>b. 创新，性能和工作负载：<ul>
<li>TypeT5模型相对于目前基线方法和其他类型推断模型具有优异的性能和精度。Article还提出了一种更加有效的序列到序列类型推断方法，充分利用上下文信息进行语境增强，以提高其推断的准确性。</li>
</ul>
</li>
<li>c. 研究结论（列清单）：<ul>
<li>TypeT5在Python等编程语言中具有更高的准确性，能够准确地预测复杂类型，具有更强的连贯性和更少的类型错误，在Python代码的类型推断任务中具有更高的应用前景。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>24-Python运行时的环境初始化</title>
    <url>/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="24-Python运行时的环境初始化"><a href="#24-Python运行时的环境初始化" class="headerlink" title="24-Python运行时的环境初始化"></a>24-Python运行时的环境初始化</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>我们之前分析了Python的核心–字节码、以及虚拟机的剖析工作，但这仅仅只是一部分，而其余的部分则被遮在了幕后。记得我们在分析虚拟机的时候，曾这么说过：</strong></p>
<blockquote>
<p><strong>当Python启动后，首先会进行 “运行时环境” 的初始化，而关于  “运行时环境” 的初始化是一个非常复杂的过程。并且 “运行时环境” 和 “执行环境” 是不同的， “运行时环境” 是一个全局的概念，而  “执行环境”  是一个栈帧。关于”运行时环境”我们后面将用单独的一章进行剖析，这里就假设初始化动作已经完成，我们已经站在了Python虚拟机的门槛外面，只需要轻轻推动一下第一张骨牌，整个执行过程就像多米诺骨牌一样，一环扣一环地展开。</strong></p>
</blockquote>
<p><strong>所以这次，我们将回到时间的起点，从Python的应用程序被执行开始，一步一步紧紧跟随Python的轨迹，完整地展示Python在启动之初的所有动作。当我们根据Python完成所有的初始化动作之后，也就能对Python执行引擎执行字节码指令时的整个运行环境了如执掌了。</strong></p>
<h3 id="线程环境初始化"><a href="#线程环境初始化" class="headerlink" title="线程环境初始化"></a>线程环境初始化</h3><p><strong>我们知道线程是操作系统调度的最小单元，那么Python中的线程又是怎么样的呢？</strong></p>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><p><strong>我们之前介绍栈帧的时候说过，通过Python启动一个线程，那么底层会通过C来启动一个线程，然后启动操作系统的一个原生线程(OS线程)。所以Python中的线程实际上是对OS线程的一个封装，因此Python中的线程是货真价实的。</strong></p>
<p><strong>然后Python还提供了一个PyThreadState(线程状态)对象，维护OS线程执行的状态信息，相当于是OS线程的一个抽象描述。虽然真正用来执行的线程及其状态肯定是由操作系统进行维护的，但是Python虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。而PyThreadState对象正是Python为OS线程准备的、在虚拟机层面保存其状态信息的对象，也就是线程状态对象。而在Python中，当前活动的OS线程对应的PyThreadState对象可以通过PyThreadState_GET获得，有了线程状态对象之后，就可以设置一些额外信息了。具体内容，我们后面会说。</strong></p>
<p><strong>当然除了线程状态对象之外，还有进程状态对象，我们来看看两者在Python底层的定义是什么？它们位于 *Include&#x2F;pystate.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> <span class="title">PyInterpreterState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> <span class="title">PyThreadState</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>里面的 *PyInterpreterState* 表示进程状态对象， *PyThreadState* 表示线程状态对象。但是我们看到它们都是typedef起得一个别名，而定义的结构体 *struct _is* 位于 *Include&#x2F;cpython&#x2F;pystate.h* 中， *struct _ts* 位于 *Include&#x2F;internal&#x2F;pycore_pystate.h*中。</strong></p>
<p><strong>线程状态对象：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">prev</span>;</span>  <span class="comment">//多个线程状态对象也像链表一样串起来, 因为一个进程里面是可以包含多个线程的, prev指向上一个线程状态对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个线程状态对象</span></span><br><span class="line">    PyInterpreterState *interp;  <span class="comment">//进程状态对象, 标识对应的线程是属于哪一个进程的</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">frame</span>;</span> <span class="comment">//栈帧对象, 模拟线程中函数的调用堆栈</span></span><br><span class="line">    <span class="type">int</span> recursion_depth;  <span class="comment">//递归深度</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="type">uint64_t</span> id; <span class="comment">//线程id</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>进程状态对象：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">is</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> *<span class="title">next</span>;</span> <span class="comment">//当前进程的下一个进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">tstate_head</span>;</span> <span class="comment">//进程环境中的线程状态对象的集合, 我们说线程状态对象会形成一个链表, 这里就是链表的头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> id; <span class="comment">//线程id</span></span><br><span class="line"> 	<span class="comment">//....</span></span><br><span class="line">    PyObject *audit_hooks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们说 *PyInterpreterState* 对象是对进程的模拟， *PyThreadState* 是对线程的模拟。我们之前分析虚拟机的时候说过其执行环境，如果再将运行时环境加进去的话。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213714167-397884335.png" alt="img"></p>
<h4 id="线程环境的初始化"><a href="#线程环境的初始化" class="headerlink" title="线程环境的初始化"></a>线程环境的初始化</h4><p><strong>在Python启动之后，初始化的动作是从 *Py_NewInterpreter* 函数开始的，然后这个函数调用了 *new_interpreter* 函数完成初始化，我们分析会先从 *new_interpreter* 函数开始，当然 *Py_NewInterpreter* 里面也做了一些工作，具体的后面会说。</strong></p>
<p><strong>我们知道在Windows平台上，当执行一个可执行文件时，操作系统首先创建一个进程内核。同理在Python中亦是如此，会在 *new_interpreter* 中调用 *PyInterpreterState_New* 创建一个崭新的 *PyInterpreterState*对象。该函数位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyInterpreterState *</span><br><span class="line"><span class="title function_">PyInterpreterState_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请进程状态对象所需要的内存</span></span><br><span class="line">    PyInterpreterState *interp = PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyInterpreterState));</span><br><span class="line">    <span class="keyword">if</span> (interp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> interp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于进程状态对象我们不做过多解释，只需要知道Python解释器在启动时，会创建一个、或者多个 *PyInterpreterState* 对象，然后通过内部的next指针将多个 *PyInterpreterState* 串成一个链表结构。</strong></p>
<p><strong>在调用 *PyInterpreterState_New* 成功创建 *PyInterpreterState*之后，会再接再厉，调用 *PyThreadState_New* 创建一个全新的线程状态对象，相关函数定义同样位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_New</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//我们注意到这个函数接收一个PyInterpreterState</span></span><br><span class="line">    <span class="comment">//这些说明了线程是依赖于进程的，因为需要进程分配资源，而且这个函数又调用了new_threadstate</span></span><br><span class="line">    <span class="comment">//除了传递PyInterpreterState之外，还传了一个1，想也不用想肯定是创建的线程数量</span></span><br><span class="line">    <span class="comment">//这里创建1个，也就是主线程(main thread)</span></span><br><span class="line">    <span class="keyword">return</span> new_threadstate(interp, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyThreadState *</span><br><span class="line"><span class="title function_">new_threadstate</span><span class="params">(PyInterpreterState *interp, <span class="type">int</span> init)</span></span><br><span class="line">&#123;	</span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//为线程状态对象申请内存</span></span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyThreadState));</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置从线程中获取函数调用栈的操作</span></span><br><span class="line">    <span class="keyword">if</span> (_PyThreadState_GetFrame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置该线程所在的进程</span></span><br><span class="line">    tstate-&gt;interp = interp;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面就是设置内部的成员属性</span></span><br><span class="line">    tstate-&gt;frame = <span class="literal">NULL</span>;  <span class="comment">//栈帧</span></span><br><span class="line">    tstate-&gt;recursion_depth = <span class="number">0</span>; <span class="comment">//递归深度</span></span><br><span class="line">    tstate-&gt;id = ++interp-&gt;tstate_next_unique_id;<span class="comment">//线程id</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    tstate-&gt;prev = <span class="literal">NULL</span>; <span class="comment">//上一个线程状态对象</span></span><br><span class="line">    tstate-&gt;next = interp-&gt;tstate_head;<span class="comment">//当前线程状态对象的next, 我们看到指向了线程状态对象链表的头结点, 说明是头插法</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;next)</span><br><span class="line">        <span class="comment">//因为每个线程状态对象的prev指针都要指向它的上一个线程状态对象, 如果是头结点的话, 那么prev就指向NULL</span></span><br><span class="line">        <span class="comment">//但由于新的线程状态对象在插入之后显然就变成了链表的头结点, 因此还需要将插入之间的头结点的prev指向新插入的线程状态对象</span></span><br><span class="line">        tstate-&gt;next-&gt;prev = tstate;</span><br><span class="line">    <span class="comment">//将tstate_head设置为新的线程状态对象(链表的头结点)</span></span><br><span class="line">    interp-&gt;tstate_head = tstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线程状态对象</span></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和 *PyInterpreterState_New* 相同， *PyThreadState_New* 申请内存，创建 *PyThreadState* 对象，并且对其中每个成员进行初始化。而且其中的prev指针和next指针分别指向了上一个线程状态对象和下一个线程状态对象。而且也肯定会存在某一时刻，存在多个 *PyThreadState* 对象形成一个链表，那么什么时刻会发生这种情况呢？显然用鼻子想也知道这是在Python启动多线程(下一章分析)的时候。</strong></p>
<blockquote>
<p><strong>此外我们看到Python在插入线程状态对象的时候采用的是头插法。</strong></p>
</blockquote>
<p><strong>我们说Python设置了从线程中获取函数调用栈的操作，所谓函数调用栈就是我们前面章节说的PyFrameObject对象链表。而且在源码中，我们看到了 *PyThreadState* 关联了 *PyInterpreterState* ， *PyInterpreterState* 也关联了 *PyInterpreterState* 。到目前为止，仅有的两个对象建立起了联系。对应到Windows，或者说操作系统，我们说进程和线程建立了联系</strong></p>
<p><strong>在 *PyInterpreterState* 和 *PyThreadState* 建立了联系之后，那么就很容易在 *PyInterpreterState* 和*PyThreadState* 之间穿梭。并且在Python运行时环境中，会有一个变量<code>(先买个关子)</code>一直维护着当前活动的线程，更准确的说是当前活动线程(OS线程)对应的 *PyThreadState* 对象。初始时，该变量为NULL。在Python启动之后创建了第一个 *PyThreadState* 之后，会用该 *PyThreadState* 对象调用 *PyThreadState_Swap* 函数来设置这个变量，函数位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_Swap</span><span class="params">(PyThreadState *newts)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了_PyThreadState_Swap, 里面传入了两个参数, 第一个我们后面说, 显然从名字上看我们知道这是个GIL相关的</span></span><br><span class="line">    <span class="comment">//第二个参数就是创建的线程状态对象</span></span><br><span class="line">    <span class="keyword">return</span> _PyThreadState_Swap(&amp;_PyRuntime.gilstate, newts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyThreadState *</span><br><span class="line">_PyThreadState_Swap(<span class="keyword">struct</span> _gilstate_runtime_state *gilstate, PyThreadState *newts)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这里是获取当前的线程状态对象, 并且保证线程的安全性</span></span><br><span class="line">    PyThreadState *oldts = _PyRuntimeGILState_GetThreadState(gilstate);</span><br><span class="line">    <span class="comment">//将GIL交给newts</span></span><br><span class="line">    _PyRuntimeGILState_SetThreadState(gilstate, newts);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> oldts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过&amp;(gilstate)-&gt;tstate_current获取当前线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyRuntimeGILState_GetThreadState(gilstate) \</span></span><br><span class="line"><span class="meta">    ((PyThreadState*)_Py_atomic_load_relaxed(&amp;(gilstate)-&gt;tstate_current))</span></span><br><span class="line"><span class="comment">//将newts设置为当前线程, 可以理解为发生了线程的切换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyRuntimeGILState_SetThreadState(gilstate, value) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_store_relaxed(&amp;(gilstate)-&gt;tstate_current, \</span></span><br><span class="line"><span class="meta">                             (uintptr_t)(value))</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到这两个宏里面出现了 *_Py_atomic_load_relaxed* 、 *_Py_atomic_store_relaxed* 和 *&amp;(gilstate)-&gt;tstate_current* ，这些又是什么呢？还有到底哪个变量在维护这当前的活动线程对应的状态对象呢？其实那两个宏已经告诉你了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/internal/pycore_pystate.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gilstate_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//宏里面出现的gilstate就是该结构体实例, tstate_current指的就是当前活动的OS线程对应的状态对象</span></span><br><span class="line">    <span class="comment">//同时也是获取到GIL的Python线程</span></span><br><span class="line">    _Py_atomic_address tstate_current;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/internal/pycore_atomic.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_load_relaxed(ATOMIC_VAL) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_load_explicit((ATOMIC_VAL), _Py_memory_order_relaxed)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_store_relaxed(ATOMIC_VAL, NEW_VAL) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_store_explicit((ATOMIC_VAL), (NEW_VAL), _Py_memory_order_relaxed)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_load_explicit(ATOMIC_VAL, ORDER) \</span></span><br><span class="line"><span class="meta">    atomic_load_explicit(&amp;((ATOMIC_VAL)-&gt;_value), ORDER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_store_explicit(ATOMIC_VAL, NEW_VAL, ORDER) \</span></span><br><span class="line"><span class="meta">    atomic_store_explicit(&amp;((ATOMIC_VAL)-&gt;_value), NEW_VAL, ORDER)</span></span><br><span class="line"><span class="comment">//_Py_atomic_load_relaxed用到了_Py_atomic_load_explicit, _Py_atomic_load_explicit用到了atomic_load_explicit</span></span><br><span class="line"><span class="comment">//_Py_atomic_store_relaxed用到了_Py_atomic_store_explicit, _Py_atomic_store_explicit用到了atomic_store_explicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而atomic_load_explicit和atomic_store_explicit是系统头文件stdatomic.h中定义的api，这是在系统的api中修改的，所以说是线程安全的</span></span><br></pre></td></tr></table></figure>

<p><strong>介绍完中间部分的内容，那么我们可以从头开始分析Python运行时的初始化了，我们说它是在 *new_interpreter* 函数中调用 *_PyRuntime_Initialize* 函数时开始的，函数位于 *Python&#x2F;pylifecycle.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">Py_NewInterpreter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//传入线程对象, 调用new_interpreter</span></span><br><span class="line">    PyStatus status = new_interpreter(&amp;tstate);</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">        Py_ExitStatusException(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回线程状态对象, 显然不会返回一个NULL, 这就说明在new_interpreter中线程状态对象就已经被设置了</span></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外里面出现了一个 *PyStatus*， 表示程序执行的状态， 会检测是否发生了异常，该结构体定义在 *Include&#x2F;cpython&#x2F;initconfig.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        _PyStatus_TYPE_OK=<span class="number">0</span>,</span><br><span class="line">        _PyStatus_TYPE_ERROR=<span class="number">1</span>,</span><br><span class="line">        _PyStatus_TYPE_EXIT=<span class="number">2</span></span><br><span class="line">    &#125; _type;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *func;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *err_msg;</span><br><span class="line">    <span class="type">int</span> exitcode;</span><br><span class="line">&#125; PyStatus;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们的重点是 *new_interpreter*函数，我们进程状态对象的创建就是在这个函数里面发生的，该函数位于*Python&#x2F;pylifecycle.c*中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyStatus status; <span class="comment">//状态对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//运行时初始化, 如果出现异常直接返回</span></span><br><span class="line">    status = _PyRuntime_Initialize();</span><br><span class="line">    <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 创建一个进程状态对象</span></span><br><span class="line">    PyInterpreterState *interp = PyInterpreterState_New();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//根据进程状态对象创建一个线程状态对象, 维护对应OS线程的状态</span></span><br><span class="line">    PyThreadState *tstate = PyThreadState_New(interp);</span><br><span class="line">    <span class="comment">//将GIL的控制权交给创建的线程</span></span><br><span class="line">    PyThreadState *save_tstate = PyThreadState_Swap(tstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在初始化运行时环境时，肯定也要对类型系统进行初始化等等，整体是一个非常庞大的过程。有兴趣的话，可以追根溯源对着源码阅读以下。</strong></p>
<p><strong>到这里，我们对 *new_interpreter* 算是有了一个阶段性的成功，我们创建了代表进程和线程概念的 *PyInterpreterState* 和 *PyThreadState* 对象，并且在它们之间建立的联系。下面， *new_interpreter* 将进行入另一个环节，设置系统module。</strong></p>
<h4 id="创建-builtins"><a href="#创建-builtins" class="headerlink" title="创建__builtins__"></a>创建__builtins__</h4><p><strong>在 *new_interpreter* 中当Python解释器创建了 *PyInterpreterState* 和 *PyThreadState* 对象之后，就会开始设置系统的__builtins__了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//申请一个PyDictObject对象, 用于存储所有的module对象</span></span><br><span class="line">    <span class="comment">//而我们说Python中的module对象都是存在sys.modules中的, 所以这里的modules指的就是Python中的sys.modules</span></span><br><span class="line">    PyObject *modules = PyDict_New();</span><br><span class="line">    <span class="keyword">if</span> (modules == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t make modules dictionary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后让interp -&gt; modules维护modules</span></span><br><span class="line">    <span class="comment">//我们翻看到这个interp表示的时进程实例对象, 这说明什么? 显然是该进程内的多个线程共享同一个内置名字空间</span></span><br><span class="line">    interp-&gt;modules = modules;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//加载sys模块, 我们说所有的module对象都在sys.modules中</span></span><br><span class="line">    PyObject *sysmod = _PyImport_FindBuiltin(<span class="string">&quot;sys&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (sysmod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;sysdict = PyModule_GetDict(sysmod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;sysdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(interp-&gt;sysdict);</span><br><span class="line">        PyDict_SetItemString(interp-&gt;sysdict, <span class="string">&quot;modules&quot;</span>, modules);</span><br><span class="line">        <span class="keyword">if</span> (_PySys_InitMain(runtime, interp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t finish initializing sys&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//加载内置模块, builtins是内置模块, 可以import builtins, 并且builtins.list等价于list</span></span><br><span class="line">    PyObject *bimod = _PyImport_FindBuiltin(<span class="string">&quot;builtins&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (bimod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;builtins = PyModule_GetDict(bimod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;builtins == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        Py_INCREF(interp-&gt;builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整体还是比较清晰和直观的，另外我们说内置名字空间是由进程来维护的，因为进程就是用来为线程提供资源的。但是我们也能看出，这意味着一个进程内的多个线程共享同一个内置作用域，显然这是非常合理的，不可能每开启一个线程，就为其创建一个__builtins__。我们来从Python的角度证明这一点：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    builtins.<span class="built_in">list</span>, builtins.<span class="built_in">tuple</span> = builtins.<span class="built_in">tuple</span>, builtins.<span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;猜猜下面代码会输出什么：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list:&quot;</span>, <span class="built_in">list</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple:&quot;</span>, <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = threading.Thread(target=foo1)</span><br><span class="line">f1.start()</span><br><span class="line">f1.join()</span><br><span class="line">threading.Thread(target=foo2).start()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">猜猜下面代码会输出什么：</span></span><br><span class="line"><span class="string">list: (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="string">tuple: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们说所有的内建对象和内置函数都在内置名字空间里面，我们可以通过  import  builtins获取、也可以直接通过__builtins__这个变量来获取。我们在foo1中把list和tuple互换了，而这个结果显然也影响到了foo2函数。这也说明了__builtins__是属于进程级别的，它是被多个线程共享的。所以是<code>interp -&gt; modules = modules</code>，当然这个modules是sys.modules，因为不止内置名字空间，所有的module对象都是被多个线程共享的。</strong></p>
<p><strong>而对__builts__的初始化时在 *_PyBuiltin_Init* 函数中进行的，它位于 *Python&#x2F;bltinmodule.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyBuiltin_Init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *mod, *dict, *debug;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> PyConfig *config = &amp;_PyInterpreterState_GET_UNSAFE()-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;PyFilter_Type) &lt; <span class="number">0</span> ||</span><br><span class="line">        PyType_Ready(&amp;PyMap_Type) &lt; <span class="number">0</span> ||</span><br><span class="line">        PyType_Ready(&amp;PyZip_Type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建并设置__builtins__ module</span></span><br><span class="line">    mod = _PyModule_CreateInitialized(&amp;builtinsmodule, PYTHON_API_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将所有python内建对象加入到__builtins__ module中</span></span><br><span class="line">    dict = PyModule_GetDict(mod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//老铁们，下面这些东西应该不陌生吧   </span></span><br><span class="line">    SETBUILTIN(<span class="string">&quot;None&quot;</span>,                  Py_None);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;Ellipsis&quot;</span>,              Py_Ellipsis);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;NotImplemented&quot;</span>,        Py_NotImplemented);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;False&quot;</span>,                 Py_False);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;True&quot;</span>,                  Py_True);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bool&quot;</span>,                  &amp;PyBool_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;memoryview&quot;</span>,        &amp;PyMemoryView_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bytearray&quot;</span>,             &amp;PyByteArray_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bytes&quot;</span>,                 &amp;PyBytes_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;classmethod&quot;</span>,           &amp;PyClassMethod_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;complex&quot;</span>,               &amp;PyComplex_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;dict&quot;</span>,                  &amp;PyDict_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;enumerate&quot;</span>,             &amp;PyEnum_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;filter&quot;</span>,                &amp;PyFilter_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;float&quot;</span>,                 &amp;PyFloat_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;frozenset&quot;</span>,             &amp;PyFrozenSet_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;property&quot;</span>,              &amp;PyProperty_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;int&quot;</span>,                   &amp;PyLong_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;list&quot;</span>,                  &amp;PyList_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;map&quot;</span>,                   &amp;PyMap_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;object&quot;</span>,                &amp;PyBaseObject_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;range&quot;</span>,                 &amp;PyRange_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;reversed&quot;</span>,              &amp;PyReversed_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;set&quot;</span>,                   &amp;PySet_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;slice&quot;</span>,                 &amp;PySlice_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;staticmethod&quot;</span>,          &amp;PyStaticMethod_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;str&quot;</span>,                   &amp;PyUnicode_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;super&quot;</span>,                 &amp;PySuper_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;tuple&quot;</span>,                 &amp;PyTuple_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;type&quot;</span>,                  &amp;PyType_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;zip&quot;</span>,                   &amp;PyZip_Type);</span><br><span class="line">    debug = PyBool_FromLong(config-&gt;optimization_level == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItemString(dict, <span class="string">&quot;__debug__&quot;</span>, debug) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(debug);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(debug);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ADD_TO_ALL</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SETBUILTIN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整个 *<em>PyBuiltin__Init* 函数的功能就是设置好__builtins</em>_ module，而这个过程是分为两步的。</strong></p>
<ul>
<li><code>通过_PyModule_CreateInitialized函数创建PyModuleObject对象，我们知道这是Python中模块对象的底层实现;</code></li>
<li><code>设置module，将python中所有的内建对象都塞到__builtins__中</code></li>
</ul>
<p><strong>但是我们看到设置的东西似乎少了不少，比如dir、hasattr、setattr等等，这些明显也是内置的，但是它们到哪里去了。别急，我们刚才说创建__builtins__分为两步，第一步是创建PyModuleObject，而使用的函数就是 *_PyModule_CreateInitialized* ，而在这个函数里面就已经完成了大部分设置__builtins__的工作。该函数位于 *Object&#x2F;moduleobject.c* 。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyModule_CreateInitialized(<span class="keyword">struct</span> PyModuleDef* module, <span class="type">int</span> module_api_version)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!PyModuleDef_Init(module))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拿到module的name，对于当前来说，这里显然是__builtins__</span></span><br><span class="line">    name = module-&gt;m_name;</span><br><span class="line">    <span class="comment">//这里比较有意思，这是检测模块版本的，针对的是需要导入的py文件。</span></span><br><span class="line">    <span class="comment">//我们说编译成PyCodeObject对象之后，会直接从当前目录的__pycache__里面导入</span></span><br><span class="line">    <span class="comment">//而那里面都是pyc文件，介绍字节码的时候我们说，pyc文件的文件名是有Python解释器的版本号的</span></span><br><span class="line">    <span class="comment">//这里就是比较版本是否一致，不一致则不导入pyc文件，而是会重新编译py文件    </span></span><br><span class="line">    <span class="keyword">if</span> (!check_api_version(name, module_api_version)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_slots) &#123;</span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;module %s: PyModule_Create is incompatible with m_slots&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个PyModuleObject </span></span><br><span class="line">    <span class="keyword">if</span> ((m = (PyModuleObject*)PyModule_New(name)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_methods != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历methods中指定的module对象中应包含的操作集合</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_AddFunctions((PyObject *) m, module-&gt;m_methods) != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_doc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//设置docstring</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_SetDocString((PyObject *) m, module-&gt;m_doc) != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;md_def = module;</span><br><span class="line">    <span class="keyword">return</span> (PyObject*)m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据上面的代码我们可以得出如下信息：</strong></p>
<ul>
<li><code>1. name：module对象的名称，在这里就是__builtins__</code></li>
<li><code>2. module_api_version：python内部使用的version值，用于比较</code></li>
<li><code>3. PyModule_New：用于创建一个PyModuleObject对象</code></li>
<li><code>4. methods：该module中所包含的函数的集合，在这里是builtin_methods</code></li>
<li><code>5. PyModule_AddFunctions：设置methods中的函数操作</code></li>
<li><code>6. PyModule_SetDocString：设置docstring</code></li>
</ul>
<h5 id="创建module对象"><a href="#创建module对象" class="headerlink" title="创建module对象"></a>创建module对象</h5><p><strong>我们说Python中的module对象在底层cpython中对应的结构体是PyModuleObject对象，我们来看看它长什么样子吧，定义在 *Objects&#x2F;moduleobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD  <span class="comment">//头部信息</span></span><br><span class="line">    PyObject *md_dict;  <span class="comment">//属性字典, 所有的属性和值都在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> *<span class="title">md_def</span>;</span>  <span class="comment">//module对象包含的操作集合, 里面是一些结构体, 每个结构体包含一个函数的相关信息</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PyObject *md_name;  <span class="comment">//模块名</span></span><br><span class="line">&#125; PyModuleObject;</span><br></pre></td></tr></table></figure>

<p><strong>而这个对象我们知道是通过PyModule_New创建的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_New</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//module对象的name、PyModuleObject</span></span><br><span class="line">    PyObject *nameobj, *module;</span><br><span class="line">    nameobj = PyUnicode_FromString(name);</span><br><span class="line">    <span class="keyword">if</span> (nameobj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//根据创建PyModuleObject</span></span><br><span class="line">    module = PyModule_NewObject(nameobj);</span><br><span class="line">    Py_DECREF(nameobj);</span><br><span class="line">    <span class="keyword">return</span> module;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_NewObject</span><span class="params">(PyObject *name)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个module对象</span></span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    m = PyObject_GC_New(PyModuleObject, &amp;PyModule_Type);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//设置相应属性, 初始化为NULL</span></span><br><span class="line">    m-&gt;md_def = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_state = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_weaklist = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//属性字典</span></span><br><span class="line">    m-&gt;md_dict = PyDict_New();</span><br><span class="line">    <span class="comment">//调用module_init_dict</span></span><br><span class="line">    <span class="keyword">if</span> (module_init_dict(m, m-&gt;md_dict, name, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    PyObject_GC_Track(m);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)m;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">    Py_DECREF(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">module_init_dict</span><span class="params">(PyModuleObject *mod, PyObject *md_dict,</span></span><br><span class="line"><span class="params">                 PyObject *name, PyObject *doc)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__name__);</span><br><span class="line">    _Py_IDENTIFIER(__doc__);</span><br><span class="line">    _Py_IDENTIFIER(__package__);</span><br><span class="line">    _Py_IDENTIFIER(__loader__);</span><br><span class="line">    _Py_IDENTIFIER(__spec__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (md_dict == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>)</span><br><span class="line">        doc = Py_None;</span><br><span class="line">	<span class="comment">//模块的一些属性、__name__、__doc__等等</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___name__, name) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___doc__, doc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___package__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___loader__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___spec__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(name)) &#123;</span><br><span class="line">        Py_INCREF(name);</span><br><span class="line">        Py_XSETREF(mod-&gt;md_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里虽然创建了一个module对象，但是这仅仅是一个空的module对象，却并没有包含相应的操作和数据。我们看到只设置了name和doc等属性。</strong></p>
<h5 id="设置module对象"><a href="#设置module对象" class="headerlink" title="设置module对象"></a>设置module对象</h5><p><strong>在PyModule_New结束之后，程序继续执行 *_PyModule_CreateInitialized* 下面的代码，然后我们知道通过 *PyModule_AddFunctions* 完成了对__builtins__几乎全部属性的设置。这个设置的属性依赖于第二个参数methods，在这里为builtin_methods。然后会遍历builtin_methods，并处理每一项元素，我们还是来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/bltinmodule.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef builtin_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__build_class__&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___build_class__,</span><br><span class="line">     METH_FASTCALL | METH_KEYWORDS, build_class_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__import__&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc&#125;,</span><br><span class="line">    BUILTIN_ABS_METHODDEF</span><br><span class="line">    BUILTIN_ALL_METHODDEF</span><br><span class="line">    BUILTIN_ANY_METHODDEF</span><br><span class="line">    BUILTIN_ASCII_METHODDEF</span><br><span class="line">    BUILTIN_BIN_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;breakpoint&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_breakpoint, METH_FASTCALL | METH_KEYWORDS, breakpoint_doc&#125;,</span><br><span class="line">    BUILTIN_CALLABLE_METHODDEF</span><br><span class="line">    BUILTIN_CHR_METHODDEF</span><br><span class="line">    BUILTIN_COMPILE_METHODDEF</span><br><span class="line">    BUILTIN_DELATTR_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;dir&quot;</span>,             builtin_dir,        METH_VARARGS, dir_doc&#125;,</span><br><span class="line">    BUILTIN_DIVMOD_METHODDEF</span><br><span class="line">    BUILTIN_EVAL_METHODDEF</span><br><span class="line">    BUILTIN_EXEC_METHODDEF</span><br><span class="line">    BUILTIN_FORMAT_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;getattr&quot;</span>,         (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_getattr, METH_FASTCALL, getattr_doc&#125;,</span><br><span class="line">    BUILTIN_GLOBALS_METHODDEF</span><br><span class="line">    BUILTIN_HASATTR_METHODDEF</span><br><span class="line">    BUILTIN_HASH_METHODDEF</span><br><span class="line">    BUILTIN_HEX_METHODDEF</span><br><span class="line">    BUILTIN_ID_METHODDEF</span><br><span class="line">    BUILTIN_INPUT_METHODDEF</span><br><span class="line">    BUILTIN_ISINSTANCE_METHODDEF</span><br><span class="line">    BUILTIN_ISSUBCLASS_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;iter&quot;</span>,            (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_iter,       METH_FASTCALL, iter_doc&#125;,</span><br><span class="line">    BUILTIN_LEN_METHODDEF</span><br><span class="line">    BUILTIN_LOCALS_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;max&quot;</span>,             (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;min&quot;</span>,             (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;next&quot;</span>,            (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_next,       METH_FASTCALL, next_doc&#125;,</span><br><span class="line">    BUILTIN_OCT_METHODDEF</span><br><span class="line">    BUILTIN_ORD_METHODDEF</span><br><span class="line">    BUILTIN_POW_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;print&quot;</span>,           (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_print,      METH_FASTCALL | METH_KEYWORDS, print_doc&#125;,</span><br><span class="line">    BUILTIN_REPR_METHODDEF</span><br><span class="line">    BUILTIN_ROUND_METHODDEF</span><br><span class="line">    BUILTIN_SETATTR_METHODDEF</span><br><span class="line">    BUILTIN_SORTED_METHODDEF</span><br><span class="line">    BUILTIN_SUM_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;vars&quot;</span>,            builtin_vars,       METH_VARARGS, vars_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,              <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是看到了玄机。</strong></p>
<p><strong>总结一下就是：在 *Py_NewInterpreter* 中调用 *new_interpreter* 函数，然后在 *new_interpreter* 这个函数里面，通过 *PyInterpreterState_New* 创建 *PyInterpreterState* ，然后传递 *PyInterpreterState* 调用 *PyThreadState_New* 得到 *PyThreadState* 对象。</strong></p>
<p><strong>接着就是执行各种初始化动作，然后在 *new_interpreter* 中调用 *_PyBuiltin_Init* 设置内建属性，在代码的最后会设置大量的内置属性<code>(函数、对象)</code>。但是有几个却不在里面，比如：dir、getattr等等。所以中间调用的 *_PyModule_CreateInitialized* 不仅仅是初始化一个module对象，还会在初始化之后将我们没有看到的一些属性设置进去，在 *_PyModule_CreateInitialized* 里面，先是使用 *PyModule_New* 创建一个PyModuleObject，在里面设置了name和doc等属性之后，再通过 *PyModule_AddFunctions* 设置methods，在这里面我们看到了dir、getattr等内置属性。当这些属性设置完之后，退回到 *_PyBuiltin_Init* 函数中，再设置剩余的大量属性。之后，__builtins__就完成了。</strong></p>
<p><strong>另外 builtin_methods 是一个 PyMethodDef 类型的数组，里面是一个个的 PyMethodDef 结构体，而这个结构体定义在 *Include&#x2F;methodobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 内置的函数或者方法名 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_name;   </span><br><span class="line">    <span class="comment">/* 实现对应逻辑的C函数，但是需要转成PyCFunction类型，主要是为了更好的处理关键字参数 */</span></span><br><span class="line">    PyCFunction ml_meth;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 参数类型 </span></span><br><span class="line"><span class="comment">    #define METH_VARARGS  0x0001  扩展位置参数</span></span><br><span class="line"><span class="comment">    #define METH_KEYWORDS 0x0002  扩展关键字参数</span></span><br><span class="line"><span class="comment">    #define METH_NOARGS   0x0004  不需要参数</span></span><br><span class="line"><span class="comment">    #define METH_O        0x0008  需要一个参数</span></span><br><span class="line"><span class="comment">    #define METH_CLASS    0x0010  被classmethod装饰</span></span><br><span class="line"><span class="comment">    #define METH_STATIC   0x0020  被staticmethod装饰   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>         ml_flags;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的__dic__</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_doc; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于这里面每一个 *PyMethodDef* ，*_PyModule_CreateInitialized* 都会基于它创建一个 *PyCFunctionObject* 对象， 这个对象Python对函数指针的包装， 当然里面好包含了其它信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD  <span class="comment">//头部信息</span></span><br><span class="line">    PyMethodDef *m_ml;  <span class="comment">//PyMethodDef</span></span><br><span class="line">    PyObject    *m_self;  <span class="comment">//self参数</span></span><br><span class="line">    PyObject    *m_module;  <span class="comment">//__module__属性</span></span><br><span class="line">    PyObject    *m_weakreflist;  <span class="comment">//弱引用列表, 不讨论</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line">&#125; PyCFunctionObject;</span><br></pre></td></tr></table></figure>

<p><strong>而 *PyCFunctionObject* 对象则是通过 *PyCFunction_New* 完成的，该函数位于 *Objects&#x2F;methodobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCFunction_New</span><span class="params">(PyMethodDef *ml, PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyCFunction_NewEx(ml, self, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCFunction_NewEx</span><span class="params">(PyMethodDef *ml, PyObject *self, PyObject *module)</span></span><br><span class="line">&#123;</span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line">    <span class="comment">//判断参数类型</span></span><br><span class="line">    <span class="keyword">switch</span> (ml-&gt;ml_flags &amp; (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> METH_VARARGS:</span><br><span class="line">        <span class="keyword">case</span> METH_VARARGS | METH_KEYWORDS:</span><br><span class="line">            vectorcall = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_FASTCALL:</span><br><span class="line">            vectorcall = cfunction_vectorcall_FASTCALL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_FASTCALL | METH_KEYWORDS:</span><br><span class="line">            vectorcall = cfunction_vectorcall_FASTCALL_KEYWORDS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_NOARGS:</span><br><span class="line">            vectorcall = cfunction_vectorcall_NOARGS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_O:</span><br><span class="line">            vectorcall = cfunction_vectorcall_O;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            PyErr_Format(PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;%s() method: bad call flags&quot;</span>, ml-&gt;ml_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyCFunctionObject *op;</span><br><span class="line">    <span class="comment">//我们看到这里也采用了缓存池的策略</span></span><br><span class="line">    op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list = (PyCFunctionObject *)(op-&gt;m_self);</span><br><span class="line">        (<span class="type">void</span>)PyObject_INIT(op, &amp;PyCFunction_Type);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则重新申请</span></span><br><span class="line">        op = PyObject_GC_New(PyCFunctionObject, &amp;PyCFunction_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    op-&gt;m_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;m_ml = ml;</span><br><span class="line">    Py_XINCREF(self);</span><br><span class="line">    op-&gt;m_self = self;</span><br><span class="line">    Py_XINCREF(module);</span><br><span class="line">    op-&gt;m_module = module;</span><br><span class="line">    op-&gt;vectorcall = vectorcall;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 *_PyBuiltin__Init* 之后，Python会把PyModuleObject对象中维护的那个PyDictObject对象抽取出来，将其赋值给 *interp -&gt; builtins* 。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//moduleobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_GetDict</span><span class="params">(PyObject *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *d;</span><br><span class="line">    <span class="keyword">if</span> (!PyModule_Check(m)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = ((PyModuleObject *)m) -&gt; md_dict;</span><br><span class="line">    assert(d != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    PyObject *bimod = _PyImport_FindBuiltin(<span class="string">&quot;builtins&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (bimod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//通过PyModule_GetDict获取属性字典, 赋值给builtins</span></span><br><span class="line">        interp-&gt;builtins = PyModule_GetDict(bimod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;builtins == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        Py_INCREF(interp-&gt;builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> handle_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以后Python在需要访问__builtins__时，直接访问 *interp-&gt;builtins* 就可以了，不需要再到 *interp-&gt;modules* 里面去找了。因为对于内置函数、属性的使用在Python中会比较频繁，所以这种加速机制是很有效的。</strong></p>
<h4 id="创建sys-module"><a href="#创建sys-module" class="headerlink" title="创建sys module"></a>创建sys module</h4><p><strong>Python在创建并设置了__builtins__之后，会照猫画虎，用同样的流程来设置sys module，并像设置 *interp-&gt;builtins* 一样设置 *interp-&gt;sysdict* 。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/pylifecycle.c</span></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    PyObject *sysmod = _PyImport_FindBuiltin(<span class="string">&quot;sys&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (sysmod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;sysdict = PyModule_GetDict(sysmod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;sysdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(interp-&gt;sysdict);</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        PyDict_SetItemString(interp-&gt;sysdict, <span class="string">&quot;modules&quot;</span>, modules);</span><br><span class="line">        <span class="keyword">if</span> (_PySys_InitMain(runtime, interp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t finish initializing sys&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在创建了sys module之后，会在此module中设置一个Python搜索module时的默认路径集合。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/pylifecycle.c</span></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    status = add_main_module(interp);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">add_main_module</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *loader, *ann_dict;</span><br><span class="line">    <span class="comment">//将__main__添加进sys.modules中</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t create __main__ module&quot;</span>);</span><br><span class="line"></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    ann_dict = PyDict_New();</span><br><span class="line">    <span class="keyword">if</span> ((ann_dict == <span class="literal">NULL</span>) ||</span><br><span class="line">        (PyDict_SetItemString(d, <span class="string">&quot;__annotations__&quot;</span>, ann_dict) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__annotations__&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(ann_dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__builtins__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *bimod = PyImport_ImportModule(<span class="string">&quot;builtins&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bimod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve builtins module&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__builtins__&quot;</span>, bimod) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__builtins__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(bimod);</span><br><span class="line">    &#125;</span><br><span class="line">    loader = PyDict_GetItemString(d, <span class="string">&quot;__loader__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">NULL</span> || loader == Py_None) &#123;</span><br><span class="line">        PyObject *loader = PyObject_GetAttrString(interp-&gt;importlib,</span><br><span class="line">                                                  <span class="string">&quot;BuiltinImporter&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve BuiltinImporter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__loader__&quot;</span>, loader) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__loader__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(loader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyStatus_OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据我们使用Python的经验，我们知道最终Python肯定会创建一个PyListObject对象，也就是Python中的sys.path，里面包含了一组PyUnicodeObject，每一个PyUnicodeObject的内容就代表了一个搜索路径。但是这一步不是在这里完成的，至于是在哪里完成的，我们后面会说。</strong></p>
<p><strong>另外，我们需要注意的是：在上面的逻辑中，解释器将__main__这个模块添加进去了，这个__main__估计不用我多说了。之前在 *PyModule_New* 中，创建一个PyModuleObject对象之后，会在其属性字典<code>(md_dict获取)</code>中插入一个名为”<strong>name</strong>“的key，value就是 “<strong>main</strong>“。但是对于当然模块来说，这个模块也可以叫做__main__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;神楽七奈&quot;</span></span><br><span class="line"><span class="keyword">import</span> __main__</span><br><span class="line"><span class="built_in">print</span>(__main__.name)  <span class="comment"># 神楽七奈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;__main__&quot;</span>] <span class="keyword">is</span> __main__)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现这样也是可以导入的，因为这个__main__就是这个模块本身。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">add_main_module</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *loader, *ann_dict;</span><br><span class="line">    <span class="comment">//创建__main__ module，并将其插入到interp-&gt;modules中</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t create __main__ module&quot;</span>);</span><br><span class="line">    <span class="comment">//获取__main__的属性字典</span></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取interp-&gt;modules中的__builtins__ module</span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__builtins__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *bimod = PyImport_ImportModule(<span class="string">&quot;builtins&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bimod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve builtins module&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将(&quot;__builtins__&quot;, __builtins__)插入到__main__ module的dict中</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__builtins__&quot;</span>, bimod) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__builtins__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(bimod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们算是知道了，为什么python  xxx.py执行的时候，__name__是__main__了，因为我们这里设置了。而Python沿着名字空间寻找的时候，最终会在__main__的local空间中发现__name__，且值为字符串”<strong>main</strong>“。但如果是以import的方式加载的，那么__name__则不是”<strong>main</strong>“，而是模块名,后面我们会继续说。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20191226190436915-1589229349.png" alt="2.png"></p>
<p><strong>其实这个__main__我们是再熟悉不过的了，当输入dir()的时候，就会显示__main__的内容。dir是可以不加参数的，如果不加参数，那么默认访问当前的py文件，也就是__main__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__name__</span><br><span class="line"><span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__name__</span><br><span class="line"><span class="string">&#x27;builtins&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.__name__</span><br><span class="line"><span class="string">&#x27;numpy&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以说，访问模块就类似访问变量一样。modules里面存放了所有的(module name,  PyModuleObject)，当我们调用np的时候，是会找到name为”numpy”的值，然后这个值里面也维护了一个字典，其中就有一个key为__name__的entry。</strong></p>
<h4 id="设置site-specific的module的搜索路径"><a href="#设置site-specific的module的搜索路径" class="headerlink" title="设置site-specific的module的搜索路径"></a>设置site-specific的module的搜索路径</h4><p><strong>Python是一个非常开放的体系，它的强大来源于丰富的第三方库，这些库由外部的py文件来提供，当使用这些第三方库的时候，只需要简单的进行import即可。一般来说，这些第三方库都放在<code>/lib/site-packages</code>中，如果程序想使用这些库，直接把库放在这里面即可。</strong></p>
<p><strong>但是到目前为止，我们好像也没看到python将site-packages路径设置到搜索路径里面去啊。其实在完成了__main__的创建之后，Python才腾出手来，收拾这个site-package。这个关键的动作在于Python的一个标准库：site.py。</strong></p>
<p><strong>我们先来将Lib目录下的site.py删掉，然后导入一个第三方模块，看看会有什么后果。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213801726-2007195328.png" alt="img"></p>
<p><strong>因此我们发现，Python在初始化的过程中确实导入了site.py，所以才有了如下的输出。而这个site.py也正是Python能正确加载位于site-packages目录下第三方包的关键所在。我们可以猜测，应该就是这个site.py将site-packages目录加入到了前面的sys.path中，而这个动作是由 *init_import_size* 完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (config-&gt;site_import) &#123;</span><br><span class="line">            status = init_import_size();</span><br><span class="line">            <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">init_import_size</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m;</span><br><span class="line">    m = PyImport_ImportModule(<span class="string">&quot;site&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的报错信息是不是和上图中显示的一样呢？</span></span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to import the site module&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(m);</span><br><span class="line">    <span class="keyword">return</span> _PyStatus_OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 *init_import_size* 中，只调用了 *PyImport_ImportModule* 函数，这个函数是Python中import机制的核心所在。PyImport_ImportModule(“numpy”)等价于python中的 import numpy 即可。</strong></p>
<h3 id="激活python虚拟机"><a href="#激活python虚拟机" class="headerlink" title="激活python虚拟机"></a>激活python虚拟机</h3><p><strong>Python运行方式有两种，一种是在命令行中运行的交互式环境；另一种则是以python xxx.py方式运行脚本文件。尽管方式不同，但是却殊途同归，进入同一个字节码虚拟机。</strong></p>
<p><strong>Python在 *Py_Initialize* 完成之后，最终会通过 *pymain_run_file* 调用 *PyRun_AnyFileExFlags*。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pymain_run_file</span><span class="params">(PyConfig *config, PyCompilerFlags *cf)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//那么获取文件名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> *filename = config-&gt;run_filename;</span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">&quot;cpython.run_file&quot;</span>, <span class="string">&quot;u&quot;</span>, filename) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pymain_exit_err_print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    FILE *fp = _Py_wfopen(filename, <span class="string">L&quot;rb&quot;</span>);</span><br><span class="line">    <span class="comment">//如果fp为NULL, 证明文件打开失败</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *cfilename_buffer;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *cfilename;</span><br><span class="line">        <span class="type">int</span> err = errno;</span><br><span class="line">        cfilename_buffer = _Py_EncodeLocaleRaw(filename, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (cfilename_buffer != <span class="literal">NULL</span>)</span><br><span class="line">            cfilename = cfilename_buffer;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cfilename = <span class="string">&quot;&lt;unprintable file name&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%ls: can&#x27;t open file &#x27;%s&#x27;: [Errno %d] %s\n&quot;</span>,</span><br><span class="line">                config-&gt;program_name, cfilename, err, strerror(err));</span><br><span class="line">        PyMem_RawFree(cfilename_buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用PyRun_AnyFileExFlags</span></span><br><span class="line">    <span class="type">int</span> run = PyRun_AnyFileExFlags(fp, filename_str, <span class="number">1</span>, cf);</span><br><span class="line">    Py_XDECREF(bytes);</span><br><span class="line">    <span class="keyword">return</span> (run != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_AnyFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                     PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="literal">NULL</span>)</span><br><span class="line">        filename = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    <span class="comment">//根据fp是否代表交互环境，对程序进行流程控制</span></span><br><span class="line">    <span class="keyword">if</span> (Py_FdIsInteractive(fp, filename)) &#123;</span><br><span class="line">        <span class="comment">//如果是交互环境，那么调用PyRun_InteractiveLoopFlags</span></span><br><span class="line">        <span class="type">int</span> err = PyRun_InteractiveLoopFlags(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (closeit)</span><br><span class="line">            fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则说明是一个普通的python脚本，执行PyRun_SimpleFileExFlags</span></span><br><span class="line">        <span class="keyword">return</span> PyRun_SimpleFileExFlags(fp, filename, closeit, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到交互式和py脚本式走的两条不同的路径，但是别着急，最终你会看到它们又会分久必合、走向同一条路径。</strong></p>
<h4 id="交互式运行"><a href="#交互式运行" class="headerlink" title="交互式运行"></a>交互式运行</h4><p><strong>先来看看交互式运行时候的情形，不过在此之前先来看一下提示符。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&quot;matsuri:&quot;</span></span><br><span class="line">matsuri:a = <span class="number">1</span></span><br><span class="line">matsuri:a</span><br><span class="line"><span class="number">1</span></span><br><span class="line">matsuri:</span><br><span class="line">matsuri:sys.ps2 = <span class="string">&quot;fubuki:&quot;</span></span><br><span class="line">matsuri:<span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">fubuki:    <span class="keyword">pass</span></span><br><span class="line">fubuki:</span><br><span class="line">matsuri:</span><br></pre></td></tr></table></figure>

<p><strong>我们每输入一行，开头都是<code>&gt;&gt;&gt; </code>，这个是sys.ps1，而输入语句块的时候，没输入完的时候，那么显示<code>...</code>，这个是sys.ps2。如果修改了，那么就是我们自己定义的了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_InteractiveLoopFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//创建交互式提示符 </span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps1, v = PyUnicode_FromString(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>));</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理这个也是一样</span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps2, v = PyUnicode_FromString(<span class="string">&quot;... &quot;</span>));</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//这里就进入了交互式环境，我们看到每次都调用了PyRun_InteractiveOneObjectEx</span></span><br><span class="line">        <span class="comment">//直到下面的ret != E_EOF不成立 停止循环，一般情况就是我们输入exit()图此处了</span></span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_MemoryError)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++nomem_count &gt; <span class="number">16</span>) &#123;</span><br><span class="line">                    PyErr_Clear();</span><br><span class="line">                    err = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nomem_count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PyErr_Print();</span><br><span class="line">            flush_io();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nomem_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    Py_DECREF(filename);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_InteractiveOneObjectEx</span><span class="params">(FILE *fp, PyObject *filename,</span></span><br><span class="line"><span class="params">                             PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v, *w, *oenc = <span class="literal">NULL</span>, *mod_name;</span><br><span class="line">    mod_ty mod;</span><br><span class="line">    PyArena *arena;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ps1 = <span class="string">&quot;&quot;</span>, *ps2 = <span class="string">&quot;&quot;</span>, *enc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> errcode = <span class="number">0</span>;</span><br><span class="line">    _Py_IDENTIFIER(encoding);</span><br><span class="line">    _Py_IDENTIFIER(__main__);</span><br><span class="line"></span><br><span class="line">    mod_name = _PyUnicode_FromId(&amp;PyId___main__); <span class="comment">/* borrowed */</span></span><br><span class="line">    <span class="keyword">if</span> (mod_name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="built_in">stdin</span>) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    w = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译用户在交互式环境下输入的python语句</span></span><br><span class="line">    arena = PyArena_New();</span><br><span class="line">    <span class="keyword">if</span> (arena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">        Py_XDECREF(w);</span><br><span class="line">        Py_XDECREF(oenc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成抽象语法树</span></span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, enc,</span><br><span class="line">                                     Py_single_input, ps1, ps2,</span><br><span class="line">                                     flags, &amp;errcode, arena);</span><br><span class="line">    Py_XDECREF(v);</span><br><span class="line">    Py_XDECREF(w);</span><br><span class="line">    Py_XDECREF(oenc);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">        <span class="keyword">if</span> (errcode == E_EOF) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">            <span class="keyword">return</span> E_EOF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取&lt;module __main__&gt;中维护的dict</span></span><br><span class="line">    m = PyImport_AddModuleObject(mod_name);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    <span class="comment">//执行用户输入的python语句</span></span><br><span class="line">    v = run_mod(mod, filename, d, d, flags, arena);</span><br><span class="line">    PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    flush_io();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现在run_mod之前，python会将<code>__main__</code>中维护的PyDictObject对象取出，作为参数传递给run_mod，这个参数关系极为重要，实际上这里的参数d就将作为Python虚拟机开始执行时当前活动的frame对象的local名字空间和global名字空间。</strong></p>
<h4 id="脚本文件运行方式"><a href="#脚本文件运行方式" class="headerlink" title="脚本文件运行方式"></a>脚本文件运行方式</h4><p><strong>接下来，我们看一看直接运行脚本文件的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.include/compile.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_file_input 257</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_SimpleFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                        PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ext;</span><br><span class="line">    <span class="type">int</span> set_file_name = <span class="number">0</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">//__main__就是当前文件</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Py_INCREF(m);</span><br><span class="line">    <span class="comment">//还记得这个d吗?当前活动的frame对象的local和global名字空间</span></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    <span class="comment">//在__main__中设置__file__属性</span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__file__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *f;</span><br><span class="line">        f = PyUnicode_DecodeFSDefault(filename);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__file__&quot;</span>, f) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__cached__&quot;</span>, Py_None) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        set_file_name = <span class="number">1</span>;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(filename);</span><br><span class="line">    ext = filename + len - (len &gt; <span class="number">4</span> ? <span class="number">4</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果是pyc</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123;</span><br><span class="line">        FILE *pyc_fp;</span><br><span class="line">        <span class="comment">//二进制模式打开</span></span><br><span class="line">        <span class="keyword">if</span> (closeit)</span><br><span class="line">            fclose(fp);</span><br><span class="line">        <span class="keyword">if</span> ((pyc_fp = _Py_fopen(filename, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: Can&#x27;t reopen .pyc file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (set_main_loader(d, filename, <span class="string">&quot;SourcelessFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            fclose(pyc_fp);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        v = run_pyc_file(pyc_fp, filename, d, d, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, <span class="string">&quot;&lt;stdin&gt;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            set_main_loader(d, filename, <span class="string">&quot;SourceFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行脚本文件</span></span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyRun_FileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, <span class="type">int</span> start, PyObject *globals,</span></span><br><span class="line"><span class="params">                  PyObject *locals, <span class="type">int</span> closeit, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//编译</span></span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, <span class="literal">NULL</span>, start, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                     flags, <span class="literal">NULL</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (closeit)</span><br><span class="line">        fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行, 依旧是调用了runmod</span></span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    Py_XDECREF(filename);</span><br><span class="line">    <span class="keyword">if</span> (arena != <span class="literal">NULL</span>)</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>很显然，脚本文件和交互式之间的执行流程是不同的，但是最终都进入了run_mod，而且同样也将与<code>__main__</code>中维护的PyDictObject对象作为local名字空间和global名字空间传入了run_mod。</strong></p>
<h4 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h4><p><strong>是的你没有看错，下面才是启动虚拟机，之前做了那么工作都是前戏。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="comment">//基于ast编译字节码指令序列，创建PyCodeObject对象</span></span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">&quot;exec&quot;</span>, <span class="string">&quot;O&quot;</span>, co) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(co);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建PyFrameObject，执行PyCodeObject对象中的字节码指令序列</span></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>run_mod接手传来的ast，然后传到 *PyAST_CompileObject*  中，创建了一个我们已经非常熟悉的PyCodeObject对象。关于这个完整的编译过程，就又是另一个话题了，总之先是scanner进行词法分析、将源代码切分成一个个的token，然后parser在词法分析之后的结果之上进行语法分析、通过切分好的token生成抽象语法树(AST，abstract syntax  tree)，然后将AST编译PyCodeObject对象，最后再由虚拟机执行。知道这么一个大致的流程即可，至于到底是怎么分词、怎么建立语法树的，这就又是一个难点了，个人觉得甚至比研究Python虚拟机还难。有兴趣的话可以去看Python源码中Parser目录，如果能把Python的分词、语法树的建立给了解清楚，那我觉得你完全可以手写一个正则表达式的引擎、以及各种模板语言。</strong></p>
<p><strong>而接下来，Python已经做好一切工作，开始通过 *run_eval_code_obj* 着手唤醒字节码虚拟机。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_eval_code_obj</span><span class="params">(PyCodeObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (!v &amp;&amp; PyErr_Occurred() == PyExc_KeyboardInterrupt) &#123;</span><br><span class="line">        _Py_UnhandledKeyboardInterrupt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数中调用了 *PyEval_EvalCode*，根据前面介绍函数的时候，我们知道最终一定会走到 *PyEval_EvalFrameEx*。</strong></p>
<p><strong>从操作系统创建进程，进程创建线程，线程设置builtins(包括设置<code>__name__</code>、内建对象、内置函数方法等等)、设置缓存池，然后各种初始化，设置搜索路径。最后分词、编译、激活虚拟机执行。而执行的这个过程就是曾经与我们朝夕相处的 *PyEval_EvalFrameEx* ，掌控Python世界中无数对象的生生灭灭。参数f就是PyFrameObject对象，我们曾经探索了很久，现在一下子就回到了当初。有种梦回<code>栈帧对象</code>的感觉。目前的话，Python的骨架我们已经看清了，虽然还有很多细节隐藏在幕后。至少神秘的面纱已经被撤掉了。</strong></p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p><strong>现在我们来看一下有趣的东西，看看在激活字节码虚拟机、创建 *PyFrameObject* 对象时，所设置的3个名字空间：local、global、builtin。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/frameobject.c</span></span><br><span class="line">PyFrameObject*</span><br><span class="line"><span class="title function_">PyFrame_New</span><span class="params">(PyThreadState *tstate, PyCodeObject *code,</span></span><br><span class="line"><span class="params">            PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *f = _PyFrame_New_NoTrack(tstate, code, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置builtin名字空间</span></span><br><span class="line">    <span class="keyword">if</span> (back == <span class="literal">NULL</span> || back-&gt;f_globals != globals) &#123;</span><br><span class="line">        <span class="comment">//但是我们发现设置builtins，居然是从globals里面获取的</span></span><br><span class="line">        <span class="comment">//带着这个疑问，看看下面更大的疑问        </span></span><br><span class="line">        builtins = _PyDict_GetItemIdWithError(globals, &amp;PyId___builtins__);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we share the globals, we share the builtins.</span></span><br><span class="line"><span class="comment">           Save a lookup and a call. */</span></span><br><span class="line">        builtins = back-&gt;f_builtins;</span><br><span class="line">        assert(builtins != <span class="literal">NULL</span>);</span><br><span class="line">        Py_INCREF(builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//设置builtins</span></span><br><span class="line">    f-&gt;f_builtins = builtins;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//设置globals</span></span><br><span class="line">    f-&gt;f_globals = globals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==</span><br><span class="line">        (CO_NEWLOCALS | CO_OPTIMIZED))</span><br><span class="line">        ; <span class="comment">/* f_locals = NULL; will be set by PyFrame_FastToLocals() */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code-&gt;co_flags &amp; CO_NEWLOCALS) &#123;</span><br><span class="line">        locals = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//如果locals为NULL，那么等同于globals，显然这是针对模块来的</span></span><br><span class="line">            locals = globals;</span><br><span class="line">        Py_INCREF(locals);</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说内置名字空间是从global名字空间里面获取的，我们用Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代表了globals()里面存放了builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说builtins里面包含了所有的内置对象、函数等等，显然调用int是可以的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>))  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是,我居然能从builtins里面拿到globals</span></span><br><span class="line"><span class="comment"># 不过也很好理解，因为globals是一个内置函数，肯定是在builtins里面</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>)  <span class="comment"># &lt;built-in function globals&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 于是拿到了globals，继续调用，然后获取__builtins__，又拿到了builtins，而且我们是可以调用list的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">list</span>(<span class="string">&quot;abcd&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>所以不管套娃多少次，都是可以的，因为它们都是指针。</strong></p>
<p><strong>可以看到builtin和global空间里面都存储一个能够获取对方空间的一个函数指针， 所以这两者是并不冲突的。当然除此之外，还有一个<code>__name__</code>，注意我们之前说设置<code>__name__</code>只是builtins的<code>__name__</code>，并不是当前模块的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们看到，builtins里面获取的__name__居然不是__main__，而是builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].__name__)  <span class="comment"># builtins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先按照local  global builtin的顺序查找是没问题的</span></span><br><span class="line"><span class="comment"># 而对于模块来说，我们知道local空间为NULL的话，然后直接把global空间交给local空间了</span></span><br><span class="line"><span class="comment"># 而local里面有__name__，就是__main__，所以__name__和builtins.__name__不是一个东西</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__name__&quot;</span>])  <span class="comment"># __main__</span></span><br><span class="line"><span class="comment"># 初始化builtins的时候，那个__name__指的是builtins这个PyModuleObject的__name__</span></span><br><span class="line"><span class="comment"># 而对于我们py文件这个模块来说，__name__是设置在global名字空间里面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将global空间或者local空间里面的__name__删掉，那么按照顺序就会寻找builtin里面的__name__，此时就会打印builtins了。</span></span><br><span class="line"><span class="built_in">globals</span>().pop(<span class="string">&quot;__name__&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># builtins</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213825050-2076588242.png" alt="img"></p>
<p><strong>所以我们看到__name__这个属性是在启动之后动态设置的，如果执行的文件和该文件是同一个文件，那么__name__就会是__main__；如果不是同一个文件，证明这个文件是作为模块被导入进来的，那么此时它的__name__就是文件名。</strong></p>
<p><strong>更多细节可以前往源码中查看，Python运行环境初始化还是比较复杂的。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们说了Python运行环境的初始化，或者说当Python启动的时候都做了哪些事情。可以看到，做的事情不是一般的多，真的准备了大量的工作。因为Python是动态语言，这就意味很多操作都要发生在运行时。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>23-剖析Python中的模块导入机制、Python是如何加载模块的</title>
    <url>/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/</url>
    <content><![CDATA[<h2 id="23-剖析Python中的模块导入机制、Python是如何加载模块的"><a href="#23-剖析Python中的模块导入机制、Python是如何加载模块的" class="headerlink" title="23-剖析Python中的模块导入机制、Python是如何加载模块的"></a>23-剖析Python中的模块导入机制、Python是如何加载模块的</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>上一篇我们介绍了生成器，本来这里应该介绍协程的，但是大致阅读了一下，感觉如果从源码的角度来介绍协程的话，工作量太大。而且个人精力有限，所以推荐我写的这一篇博客：<code>https://www.cnblogs.com/traditional/p/11828780.html</code>，是用来介绍asyncio的，当然也从Python的角度介绍了Python中的协程。</strong></p>
<p><strong>这一次我们说一下Python模块的加载机制，我们之前所考察的所有内容都具有一个相同的特征，那就是它们都局限在一个py文件中。然而现实中不可能只有一个py文件，而是存在多个，而多个py文件之间存在引用和交互，这些也是程序的一个重要组成部分。那么这里我们就来分析，Python中模块的导入机制。</strong></p>
<p><strong>在这里我们必须强调一点，Python中一个单独的py文件、或者pyd文件，我们称之为一个 *模块* ；而多个模块组合起来放在一个目录中，这个目录我们称之为 *包* 。</strong></p>
<p><strong>但是不管是模块，还是包，它们在Python的底层都是PyModuleObject结构体实例，类型为PyModule_Type，而在Python中则都是一个<code>&lt;class &#39;module&#39;&gt;</code>对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/moduleobject.c</span></span><br><span class="line">PyTypeObject PyModule_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;module&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyModuleObject),                     <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python中的&lt;class &#x27;module&#x27;&gt;对应底层的PyModule_Type</span></span><br><span class="line"><span class="comment">//而导入进来的模块对象 则对应底层的 PyModuleObject</span></span><br></pre></td></tr></table></figure>

<p><strong>所以模块和包导入进来之后也是一个对象，下面我们通过Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pandas)  <span class="comment"># &lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(os))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(pandas))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此不管是模块还是包，在Python中都是一样的，我们后面会详细说。总之它们都是一个PyModuleObject，只不过为了区分，我们把单独的py文件、pyd文件叫做模块，一个目录叫做包，但是在Python的底层则并没有区分那么明显，它们都是一样的。</strong></p>
<p><strong>所以为了不产生歧义，我们这里做一个约定，从现在开始本系列中出现的”模块”：指的就是单独的可导入文件；出现的”包”：指的就是目录；而”模块”和”包”组合起来，我们称之为module对象，因为这两者本来就是<code>&lt;class &#39;module&#39;&gt;</code>的实例对象。</strong></p>
<h3 id="import前奏曲"><a href="#import前奏曲" class="headerlink" title="import前奏曲"></a>import前奏曲</h3><p><strong>我们以一个简单的import为序幕，看看相应的字节码；</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">4</span> IMPORT_NAME              <span class="number">0</span> (sys)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (sys)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们发现对应的字节码真的是简单无比。先不管开头的两个LOAD_CONST，我们在第三行看到了IMPORT_NAME，这个可以类比之前的LOAD_NAME。表示将sys这个module对象加载进来，然后通过STORE_NAME存储在当前的local名字空间中，然后当我们调用sys.path的时候，虚拟机就能很轻松地通过sys来获取path这个属性所对应的值了。因此就像我们之前说的那样，创建函数、类、导入模块等等，它们本质上和通过赋值语句创建一个变量是没有什么区别的，关键就是这个IMPORT_NAME，我们看看它的实现，知道从哪里看吗？我们说Python中所有指令集的实现都在 *ceval.c* 的那个无限for循环的巨型switch中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(IMPORT_NAME)</span>: &#123;</span><br><span class="line">    <span class="comment">//PyUnicodeObject对象，比如import pandas，那么这个name就是字符串pandas</span></span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    <span class="comment">//我们看到这里有一个fromlist和level，显然需要从运行时栈中获取对应的值，那么显然要先将值压入运行时栈</span></span><br><span class="line">    <span class="comment">//我们再看一下刚才的字节码，我们发现在IMPORT_NAME之前有两个LOAD_CONST，将0和None压入了运行时栈</span></span><br><span class="line">    <span class="comment">//因此这里会从运行时栈中获取到None和0，然后分别赋值给fromlist和level，至于这两个是干啥的，我们后面说</span></span><br><span class="line">    PyObject *fromlist = POP();</span><br><span class="line">    PyObject *level = TOP();</span><br><span class="line">    PyObject *res; <span class="comment">//一个PyModuleObject *，也就是模块对象</span></span><br><span class="line">    <span class="comment">//调用import_name, 将该函数的返回值赋值给res</span></span><br><span class="line">    res = import_name(tstate, f, name, fromlist, level);</span><br><span class="line">    Py_DECREF(level);</span><br><span class="line">    Py_DECREF(fromlist);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此重点在import_name这个函数中，但是在此之前我们需要重点关注一下这个fromlist和level，而这一点我们可以从Python的层面来介绍。我们知道在python中，我们导入一个模块直接通过import关键字即可，  但是除了import，我们还可以使用__import__函数来进行导入，这个__import__是解释器使用的一个函数，不推荐我们直接使用，但是我想说的是import os就等价于os &#x3D; <strong>import</strong>(“os”)。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os = <span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>)</span><br><span class="line">SYS = <span class="built_in">__import__</span>(<span class="string">&quot;sys&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(SYS.prefix)  <span class="comment"># C:\python38</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1 = <span class="built_in">__import__</span>(<span class="string">&quot;os.path&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m1)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 我们惊奇地发现，居然还是os模块，按理说应该是os.path(windows系统对应ntpath)啊</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">__import__</span>(<span class="string">&quot;os.path&quot;</span>, fromlist=[<span class="string">&quot;&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(m2)  <span class="comment"># &lt;module &#x27;ntpath&#x27; from &#x27;C:\\python38\\lib\\ntpath.py&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 你看到了什么，fromlist，没错，我们加上一个fromlist，就能导入子模块</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会这样呢？我们来看看<code>__import__</code>这个函数的解释，这个是pycharm给抽象出来的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__import__</span>(<span class="params">name, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, fromlist=(<span class="params"></span>), level=<span class="number">0</span></span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Import a module. Because this function is meant for use by the Python</span></span><br><span class="line"><span class="string">    interpreter and not for general use, it is better to use</span></span><br><span class="line"><span class="string">    importlib.import_module() to programmatically import a module.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The globals argument is only used to determine the context;</span></span><br><span class="line"><span class="string">    they are not modified.  The locals argument is unused.  The fromlist</span></span><br><span class="line"><span class="string">    should be a list of names to emulate ``from name import ...&#x27;&#x27;, or an</span></span><br><span class="line"><span class="string">    empty list to emulate ``import name&#x27;&#x27;.</span></span><br><span class="line"><span class="string">    When importing a module from a package, note that __import__(&#x27;A.B&#x27;, ...)</span></span><br><span class="line"><span class="string">    returns package A when fromlist is empty, but its submodule B when</span></span><br><span class="line"><span class="string">    fromlist is not empty.  The level argument is used to determine whether to</span></span><br><span class="line"><span class="string">    perform absolute or relative imports: 0 is absolute, while a positive number</span></span><br><span class="line"><span class="string">    is the number of parent directories to search relative to the current module.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>大意就是，此函数会由import语句调用，当我们import的时候，解释器底层就会调用__import__。比如import  os表示将”os”这个字符串传入__import__中，从指定目录加载os.py(也可能是os.pyd、或者一个名为os的目录也可以)得到一个module对象，并将返回值再次赋值给符号os，也就是os &#x3D;  <strong>import</strong>(“os”)。虽然我们可以通过这种方式来导入模块，但是Python不建议我们这么做。而globals参数则是确定import语句包的上下文，一般直接传globals()即可，但是locals参数我们基本不用，不过一般情况下globals和locals我们都不用管。</strong></p>
<p><strong>fromlist我们刚才已经说了，<strong>import</strong>(“os.path”)，如果是这种情况的话，那么导入的不是os.path，还是os这个外层模块。如果想导入os.path，那么只需要给fromlist传入一个非空列表即可，其实不仅仅是非空列表，只要是一个非空的可迭代对象就行。而level如果是0，那么表示仅执行绝对导入，如果是一个正整数，表示要搜索的父目录的数量。一般这个值也不需要传递。</strong></p>
<p><strong>那这个方法有什么作用呢？假设如果我们有一个字符串a，其值为”pandas”，我想导入这个模块，该怎么做呢？显然就可以使用这种方式，但是这种方式导入的话，python官方不推荐使用__import__，而是希望我们使用一个叫做importlib的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;pandas&quot;</span></span><br><span class="line">pd = importlib.import_module(a)</span><br><span class="line"><span class="comment"># 很方便的就导入了, 字节通过字符串的方式导入一个module对象</span></span><br><span class="line"><span class="built_in">print</span>(pd)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想导入一个&quot;模块中导入的另一个模块&quot;, 比如: 模块a中导入了模块b, 我们希望导入a.b</span></span><br><span class="line"><span class="comment"># 或者导入一个包下面的子模块等等, 比如: pandas.core.frame</span></span><br><span class="line">sub_mod = importlib.import_module(<span class="string">&quot;pandas.core.frame&quot;</span>)</span><br><span class="line"><span class="comment"># 我们看到可以自动导入pandas.core.frame</span></span><br><span class="line"><span class="built_in">print</span>(sub_mod)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas.core.frame&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\core\\frame.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但如果是__import__, 默认的话是不行的, 导入的依旧是最外层pandas</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">__import__</span>(<span class="string">&quot;pandas.core.frame&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过给fromlist指定一个非空列表来实现</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">__import__</span>(<span class="string">&quot;pandas.core.frame&quot;</span>, fromlist=[<span class="string">&quot;&quot;</span>]))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas.core.frame&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\core\\frame.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>扯了这么多，我们来看看之前源码中说的import_name。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(IMPORT_NAME)</span>: &#123;</span><br><span class="line">            <span class="comment">// 这个函数接收了五个参数，tstate：线程状态对象、f：栈帧、name：模块名、fromlist：一个None、level：0</span></span><br><span class="line">            res = import_name(tstate, f, name, fromlist, level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">import_name</span><span class="params">(PyThreadState *tstate, PyFrameObject *f,</span></span><br><span class="line"><span class="params">            PyObject *name, PyObject *fromlist, PyObject *level)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__import__);</span><br><span class="line">    PyObject *import_func, *res;</span><br><span class="line">    PyObject* <span class="built_in">stack</span>[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取内建函数__import__</span></span><br><span class="line">    import_func = _PyDict_GetItemIdWithError(f-&gt;f_builtins, &amp;PyId___import__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为NULL获取失败, 显然这些都是Python底层做的检测, 在Python使用上不会出现</span></span><br><span class="line">    <span class="comment">//如果出现, 只能说明解释器出问题了</span></span><br><span class="line">    <span class="keyword">if</span> (import_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_ImportError, <span class="string">&quot;__import__ not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断__import__是否被重载了</span></span><br><span class="line">    <span class="keyword">if</span> (import_func == tstate-&gt;interp-&gt;import_func) &#123;</span><br><span class="line">        <span class="type">int</span> ilevel = _PyLong_AsInt(level);</span><br><span class="line">        <span class="keyword">if</span> (ilevel == <span class="number">-1</span> &amp;&amp; _PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未重载的话，调用PyImport_ImportModuleLevelObject</span></span><br><span class="line">        res = PyImport_ImportModuleLevelObject(</span><br><span class="line">                        name,</span><br><span class="line">                        f-&gt;f_globals,</span><br><span class="line">                        f-&gt;f_locals == <span class="literal">NULL</span> ? Py_None : f-&gt;f_locals,</span><br><span class="line">                        fromlist,</span><br><span class="line">                        ilevel);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(import_func);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">0</span>] = name;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">1</span>] = f-&gt;f_globals;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">2</span>] = f-&gt;f_locals == <span class="literal">NULL</span> ? Py_None : f-&gt;f_locals;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">3</span>] = fromlist;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">4</span>] = level;</span><br><span class="line">    res = _PyObject_FastCall(import_func, <span class="built_in">stack</span>, <span class="number">5</span>);</span><br><span class="line">    Py_DECREF(import_func);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到底层又调用了 *PyImport_ImportModuleLevelObject* ，我们来看一下它的实现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/import.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyImport_ImportModuleLevelObject</span><span class="params">(PyObject *name, PyObject *globals,</span></span><br><span class="line"><span class="params">                                 PyObject *locals, PyObject *fromlist,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(_handle_fromlist);</span><br><span class="line">    PyObject *abs_name = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *final_mod = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *mod = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *package = <span class="literal">NULL</span>;</span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET_UNSAFE();</span><br><span class="line">    <span class="type">int</span> has_from;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//名字不可以为空</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;Empty module name&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字必须是PyUnicodeObject</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError, <span class="string">&quot;module name must be a string&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//level不可以小于0</span></span><br><span class="line">    <span class="keyword">if</span> (level &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;level must be &gt;= 0&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//level大于0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在相应的父目录寻找，得到abs_name</span></span><br><span class="line">        abs_name = resolve_name(name, globals, level);</span><br><span class="line">        <span class="keyword">if</span> (abs_name == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//否则的话，说明level==0，因为level要求是一个大于等于0的整数</span></span><br><span class="line">        <span class="keyword">if</span> (PyUnicode_GET_LENGTH(name) == <span class="number">0</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_ValueError, <span class="string">&quot;Empty module name&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时直接将name赋值给abs_name</span></span><br><span class="line">        <span class="comment">//因为此时是绝对导入</span></span><br><span class="line">        abs_name = name;</span><br><span class="line">        Py_INCREF(abs_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用PyImport_GetModule获取module对象</span></span><br><span class="line">    <span class="comment">//注意：这个module对象会从sys.modules里面获取，并不会重新加载</span></span><br><span class="line">    <span class="comment">//我们说在Python中，导入一个module对象的时候会从sys.modules里面查找</span></span><br><span class="line">    <span class="comment">//如果没有，那么才从硬盘上加载。一旦加载，那么会直接设置在sys.modules里面</span></span><br><span class="line">    <span class="comment">//在下一次导入的时候，直接从sys.modules中获取，具体细节后面聊</span></span><br><span class="line">    mod = PyImport_GetModule(abs_name);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用函数，导入模块</span></span><br><span class="line">        final_mod = _PyObject_CallMethodIdObjArgs(interp-&gt;importlib,</span><br><span class="line">                                                  &amp;PyId__handle_fromlist, mod,</span><br><span class="line">                                                  fromlist, interp-&gt;import_func,</span><br><span class="line">                                                  <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">    Py_XDECREF(abs_name);</span><br><span class="line">    Py_XDECREF(mod);</span><br><span class="line">    Py_XDECREF(package);</span><br><span class="line">    <span class="keyword">if</span> (final_mod == <span class="literal">NULL</span>)</span><br><span class="line">        remove_importlib_frames();</span><br><span class="line">    <span class="keyword">return</span> final_mod;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外关于module对象的导入方式，Python也提供了非常丰富的写法，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.random <span class="keyword">as</span> _random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random <span class="keyword">as</span> _random</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p><strong>从import的目标来说，可以是”包”，也可以是模块。而模块可以通过py文件作为载体，也可以通过dll<code>(pyd)</code>或者so等二进制文件作为载体，下面我们就来一一介绍。</strong></p>
<h3 id="import机制的黑盒探测"><a href="#import机制的黑盒探测" class="headerlink" title="import机制的黑盒探测"></a>import机制的黑盒探测</h3><p><strong>同C++的namespace，Python通过模块和包来实现对系统复杂度的分解，以及保护名字空间不受污染。通过模块和包，我们可以将某个功能、某种抽象进行独立的实现和维护，在module对象的基础之上构建软件，这样不仅使得软件的架构清晰，而且也能很好的实现代码复用。</strong></p>
<h4 id="标准import"><a href="#标准import" class="headerlink" title="标准import"></a>标准import</h4><h5 id="Python内建module"><a href="#Python内建module" class="headerlink" title="Python内建module"></a>Python内建module</h5><p><strong>sys这个模块恐怕是使用最频繁的module对象之一了，我们就从这位老铁入手。Python中有一个内置函数dir，这个小工具是我们探测import的杀手锏。如果你在交互式环境下输入dir()，那么会打印当前local名字空间的所有符号，如果有参数，则将参数视为对象，输出该对象的所有属性。我们先来看看import动作对当前名字空间的影响：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到当我们进行了import动作之后，当前的local名字空间增加了一个sys符号。而且通过type操作，我们看到这个sys符号指向一个module对象，我们说在底层它是一个PyModuleObject。当然虽然写着类型是<code>&lt;class &#39;module&#39;&gt;</code>，但是我们在Python中是无法直接使用module这个类的。不过它既然是一个class，那么就一定继承object，并且元类为type。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.__class__.__base__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这与我们的分析是一致的。言归正传，我们看到import机制影响了当前local名字空间，使得加载的module对象在local空间成为可见的。实际上，这和我们创建一个变量的时候，也会影响local名字空间。引用该module的方法正是通过module的名字，即这里的sys。</strong></p>
<p><strong>不过这里还有一个问题，我们来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys</span><br><span class="line">&lt;module <span class="string">&#x27;sys&#x27;</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到sys是内置的，说明模块除了真实存在文件之外，还可以内嵌在解释器里面。但既然如此，那为什么我们不能直接使用，还需要导入呢？其实不光是sys，在Python初始化的时候，就已经将一大批的module对象加载到了内存中。但是为了使得当前local名字空间能够达到最干净的效果，Python并没有将这些符号暴露在local名字空间中，而是需要用户显式的使用import机制来将这个符号引入到local名字空间中，才能让程序使用这个符号背后的对象。</strong></p>
<p><strong>我们知道，凡是加载进内存的module对象都保存在sys.modules里面，尽管当前的local空间里面没有，但是sys.modules里面是跑不掉的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 这个modules是一个字典，里面分别为 module对象的名字 和 对应的PyModuleObject</span></span><br><span class="line"><span class="comment"># 里面有很多模块，我就不打印了，另外感到意味的是，居然把numpy也加载进来了</span></span><br><span class="line">modules = sys.modules</span><br><span class="line"></span><br><span class="line">np = modules[<span class="string">&quot;numpy&quot;</span>]</span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(arr))  <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">os_ = modules[<span class="string">&quot;os&quot;</span>]</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(os) == <span class="built_in">id</span>(os_))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>一开始这些module对象是不在local空间里面的，除非我们显式导入，但是即便我们导入，这些module对象也不会被二次加载，因为已经在初始化的时候就被加载到内存里面了。因此对于已经在sys.modules里面的module对象来说，导入的时候只是加到local空间里面去，所以代码中的os和os_的id是一样的。如果我们在Python启动之后，导入一个sys.modules中不存在的module对象，那么才会进行加载、然后同时进入local空间和sys.modules。</strong></p>
<h5 id="用户自定义module"><a href="#用户自定义module" class="headerlink" title="用户自定义module"></a>用户自定义module</h5><p><strong>我们知道，对于那些内嵌在解释器里面的module对象，如果import，只是将该module对象暴露在了local名字空间中。下面我们看看对于那些没有在初始化的时候加载到内存的module对象进行import的时候，会出现什么样动作。这里就以模块为例，当然正如我们之前说的，一个模块的载体可以是py文件或者二进制文件，py文件可以是自己编写的、也可以是标准库中的、或者第三方库中的。不过我们目前不区分那么多，通过自己编写的py文件作为例子，探探路。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># False</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())  </span><br><span class="line"><span class="comment"># [&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;a&#x27;, &#x27;sys&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 2653299804976</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(sys.modules[<span class="string">&quot;a&quot;</span>]))  <span class="comment"># 2653299804976</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>调用type的结果显示，import机制确实创建了一个新的module对象。而且也确实如我们之前所说，Python对a这个module对象或者模块，不仅将其引入进当前的local名字空间中，而且这个被动态加载的模块也在sys.module中拥有了一席之地，而且它们背后隐藏的是同一个PyModuleObject对象。然后我们再来看看这个module对象：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(a))  <span class="comment"># [&#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__.keys())</span><br><span class="line"><span class="comment"># dict_keys([&#x27;__name__&#x27;, &#x27;__doc__&#x27;, &#x27;__package__&#x27;, &#x27;__loader__&#x27;, &#x27;__spec__&#x27;, &#x27;__file__&#x27;, &#x27;__cached__&#x27;, &#x27;__builtins__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__name__)  <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(a.__file__)  <span class="comment"># D:\satori\a.py</span></span><br></pre></td></tr></table></figure>

<p><strong>这里可以看到，module对象内部实际上是通过一个dict在维护所有的module对象<code>&#123;名字: 属性值&#125;</code>，里面有module的元信息<code>(名字、文件路径)</code>、以及module对象里面的内容。对，说白了，同class一样，module也是一个名字空间。</strong></p>
<p><strong>另外如果此时你查看a.py所在目录的<code>__pycache__</code>目录，你会发现里面有一个a.pyc，说明Python在导入的时候先生成了pyc，然后导入了pyc。并且我们通过dir(a)查看的时候，发现里面有一个<code>__builtins__</code>符号，那么这个<code>__builtins__</code>和我们之前说的那个<code>__builtins__</code>是一样的吗？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们之前说获取builtins可以通过import builtins的方式导入，但其实也可以通过__builtins__获取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(__builtins__), <span class="built_in">type</span>(__builtins__))  <span class="comment"># 1745602347792 &lt;class &#x27;module&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]), <span class="built_in">type</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]))  <span class="comment"># 1745602345408 &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>尽管它们都叫<code>__builtins__</code>，但一个是module对象，一个是字典。我们通过<code>__builtins__</code>获取的是一个module对象，里面存放了int、str、globals等内建对象和内建函数等等，我们直接输入int、str、globals和通过<code>__builtins__.int</code>，<code>__builtins__.str</code>，<code>__builtins__.globals</code>的效果是一样的，我们输入<code>__builtins__</code>可以拿到这个内置模块，通过这个内置模块去获取里面的内容，当然也可以直接获取里面的内容，因为这些已经是全局的了。</strong></p>
<p><strong>但是<code>a.__dict__[&quot;__builtins__&quot;]</code>是一个字典，这就说明两个从性质上就是不同的东西，但即便如此，就真的一点关系也没有吗？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(__builtins__.__dict__))  <span class="comment"># 2791398177216</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]))  <span class="comment"># 2791398177216</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到还是有一点关系的，和类、类的实例对象一样，每一个module对象也有自己的属性字典<code>__dict__</code>，记录了自身的元信息、里面存放的内容等等。对于<code>a.__dict__[&quot;__builtins__&quot;]</code>来说，拿到的就是<code>__builtins__.__dict__</code>，所以说<code>__builtins__</code>是一个模块，但是这个模块有一个<code>__dict__</code>属性字典，而这个字典是可以通过<code>module对象.__dict__[&quot;__builtins__&quot;]</code>来获取的，因为任何一个模块都可以使用<code>__builtins__</code>里面的内容，并且所有模块对应的<code>__builtins__</code>都是一样的。所以当你直接打印<code>a.__dict__</code>的时候会输出一大堆内容，因为输出的内容里面不仅有当前模块的内容，还有<code>__builtins__.__dict__</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&quot;list&quot;</span>](<span class="string">&quot;abcd&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.__dict__[&quot;__builtins__&quot;]就是__builtins__.__dict__这个属性字典</span></span><br><span class="line"><span class="comment"># __builtins__.list就等价于__builtins__.__dict__[&quot;list&quot;]</span></span><br><span class="line"><span class="comment"># 说白了，就是我们直接输入的list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&quot;list&quot;</span>] <span class="keyword">is</span> <span class="built_in">list</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回顾之前的内容</span></span><br><span class="line"><span class="comment"># 我们说，模块名是在模块的属性字典里面</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__name__&quot;</span>] == a.__name__ == <span class="string">&quot;a&quot;</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __builtins__里面的__name__就是builtins</span></span><br><span class="line"><span class="built_in">print</span>(__builtins__.__dict__[<span class="string">&quot;__name__&quot;</span>])  <span class="comment"># builtins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还记得如何获取当前文件的文件名吗</span></span><br><span class="line"><span class="built_in">print</span>(__name__)   <span class="comment"># __main__</span></span><br><span class="line"><span class="comment"># 咦，可能有人说，这不是从__builtins__里面获取的吗？</span></span><br><span class="line"><span class="comment"># 我们之前说了，__name__已经被设置到local名字空间了</span></span><br><span class="line"><span class="comment"># 所以这个__name__是从local里面拿的，尽管我们没有设置，但是它确确实实在里面</span></span><br><span class="line"><span class="comment"># 而且local里面有的话，就不会再去找__builtins__</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以可以把模块的属性字典，看成是local空间、内置空间的组合。</strong></p>
</blockquote>
<h4 id="嵌套import"><a href="#嵌套import" class="headerlink" title="嵌套import"></a>嵌套import</h4><p><strong>我们下面来看一下import的嵌套，所谓import的嵌套就是指，假设我import a，但是在a中又import b，我们来看看这个时候会发生什么有趣的动作。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (a)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               0 (a)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>在a.py中导入sys，在另一个模块导入a，打印字节码指令，我们只看到了<code>IMPORT_NAME 0 (a)</code>，似乎并没有看到a模块中的动作。我们说了，使用dis模块查看的字节码是分层级的，只能看到import a这个动作，a里面做了什么是看不到的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.sys <span class="keyword">is</span> sys <span class="keyword">is</span> sys.modules[<span class="string">&quot;sys&quot;</span>] <span class="keyword">is</span> a.__dict__[<span class="string">&quot;sys&quot;</span>] <span class="keyword">is</span> a.sys)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>首先我们import  a，那么a模块就在当前模块的属性字典里面了，我们通过a这个符号是可以直接拿到其对应的模块的。但是在a中我们又import  sys，那么这个sys模块就已经在a模块对应的属性字典里面了，也就是说，我们这里通过a.sys是可以直接拿到sys模块的。但是，我们第二次导入sys的时候，会怎么样呢？首先我们在a中已经导入了sys，那么sys这个模块就已经在sys.modules里面了。那么当我们再导入sys的时候，就直接从sys.modules里面去找了，因此不会二次加载。为了更直观的验证，我们再举一个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># c.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>以上是三个文件，每个文件只有一行代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"><span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>当导入一个不在sys.modules的模块时，会先从硬盘中加载相应的文件，然后逐行解释执行里面的内容，构建PyModuleObject对象，加入到sys.modules里面。当第二次导入的时候，直接将符号暴露在当前的local空间中，就不会再执行里面的内容了。</strong></p>
<p><strong>所以我们可以把sys.modules看成是一个大仓库，任何导入了的模块都在这里面。如果再导入的话，在sys.modules里面找到了，就直接返回即可，这样可以避免重复加载。</strong></p>
<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><p><strong>我们写的多个逻辑或者功能上相关的函数、类可以放在一个模块里面，那么多个模块是不是也可以组成一个包呢？如果说模块是管理class、函数、一些变量的机制，那么包就是管理模块的机制，当然啦，多个小的包又可以聚合成一个较大的包。</strong></p>
<p><strong>因此在Python中，模块是由一个单独的文件来实现的，可以是py文件、或者二进制文件。而对于包来说，则是一个目录，里面容纳了模块对应的文件，这种方式就是把多个模块聚合成一个包的具体实现。</strong></p>
<p><strong>现在我有一个名为test_import的模块，里面有一个a.py：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062927709-338402810.png" alt="img"></p>
<p><strong>a.py内容如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>现在我们来导入它</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; (namespace)&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python2中，这样是没办法导入的，因为如果一个目录要成为Python中的包，那么里面必须要有一个<code>__init__</code>文件，但是在Python3中没有此要求。而且我们发现print之后，显示的也是一个module对象，因此Python对于模块和包的底层定义其实是很灵活的，并没有那么僵硬。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">AttributeError: module &#x27;test_import&#x27; has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>然而此时神奇的地方出现了，我们调用test_import.a的时候，告诉我们没有a这个属性。很奇怪，我们的test_import里面不是有a.py吗？首先python导入一个包，会先执行这个包的<code>__init__</code>文件，只有在<code>__init___</code>文件中导入了，我们才可以通过包名来调用。如果这个包里面没有<code>__init__</code>文件，那么你导入这个包，是什么属性也用不了的。光说可能比较难理解，我们来演示一下。我们先来创建<code>__init__</code>文件，但是里面什么也不写。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时我们又看到了神奇的地方，我们在test_import目录里面创建了<code>__init__</code>文件之后，再打印test_import，得到结果又变了，告诉我们这个包来自于该包里面的<code>__init__</code>文件。所以就像我们之前说的，Python对于包和模块的概念区分的不是很明显，我们把包就当做该包下面的<code>__init__</code>文件即可，这个<code>__init__</code>中定义了什么，那么这个包里面就有什么。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line">name = <span class="string">&quot;satori&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>from . import a</code>这句话表示导入test_import这个下面的a.py，但是直接像import sys那样import a不行吗？答案是不行的，至于为什么我们后面说。我们在<code>__init__.py</code>中导入了sys模块、a模块，定义了name属性，那么就等于将sys、a、name加入到了test_import这个包的local空间里面去了。因为我们说过，对于Python中的包，那么其等价于里面的<code>__init__</code>文件，这个文件有什么，那么这个包就有什么。既然我们在<code>__init__.py</code>中导入了sys、a模块，定义了name，那么这个文件的属性字典里面、或者也可以说local空间里面就有了<code>&quot;sys&quot;: sys, &quot;a&quot;: a, &quot;name&quot;: &quot;satori&quot;</code>这三个entry，而我们又说了<code>__init__.py</code>里面有什么，那么通过包名就能够调用什么。所以：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a)</span><br><span class="line"><span class="built_in">print</span>(test_import.a.a)</span><br><span class="line"><span class="built_in">print</span>(test_import.sys)</span><br><span class="line"><span class="built_in">print</span>(test_import.name)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&lt;module &#x27;sys&#x27; (built-in)&gt;</span></span><br><span class="line"><span class="string">satori</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 首先在a里面有一个print(&quot;&gt;&gt;&gt;&quot;)</span></span><br><span class="line"><span class="comment"># 而我们说初次导入一个模块，就相当于把这个模块里面的内容拿过来执行一遍；初次导入一个包则是把这个包里面的__init__.py拿过来执行一遍</span></span><br><span class="line"><span class="comment"># 那么在__init__里面导入a的时候，就会打印这个print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外此时如果我再单独导入test_import里面的a模块的话，会怎么样呢？</span></span><br><span class="line"><span class="comment"># 下面这两种导入方式后面会介绍</span></span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"><span class="comment"># 我们看到a里面的print没有被打印，证明确实模块、包不管以怎样的方式被导入，只要被导入一次，那么对应的文件只会被加载一遍</span></span><br><span class="line"><span class="comment"># 第二次导入只是将符号加入到了当前的名字空间中</span></span><br></pre></td></tr></table></figure>

<h5 id="相对导入与绝对导入"><a href="#相对导入与绝对导入" class="headerlink" title="相对导入与绝对导入"></a>相对导入与绝对导入</h5><p><strong>我们刚才使用了一个<code>from . import a</code>的方式，这个<code>.</code>表示当前文件所在的目录，这行代码就表示，我要导入a这个模块，不是从别的地方导入，而是从该文件所在的目录里面导入。如果是<code>..</code>就表示该目录的上一层目录，三个<code>.</code>、四个<code>.</code>依次类推。我们知道a模块里面还有一个a这个变量，那如果我想在<code>__init__.py</code>中导入这个变量该怎么办呢？直接<code>from .a import a</code>即可，表示导入当前目录里面的a模块里面的a变量。如果我们导入的时候没有<code>.</code>的话，那么表示绝对导入，Python虚拟机就会按照sys.path定义的路径去找。假设我们在<code>__init__.py</code>当中写的是不是<code>from . import a</code>，而是<code>import a</code>，那么会发生什么后果呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    import a</span></span><br><span class="line"><span class="string">ModuleNotFoundError: No module named &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现报错了，告诉我们没有a这个模块，可是我们明明在module包里面定义了呀。还记得之前说的导入一个模块、导入一个包会做哪些事情吗？导入一个模块，会将该模块里面”拿过来”执行一遍，导入包会将该包里面的<code>__init__.py</code>文件”拿过来”执行一遍。注意：我们把”拿过来”三个字加上了引号。</strong></p>
<p><strong>我们在test_import同级目录的py文件中导入了test_import，那么就相当于把里面的__init__拿过来执行一遍<code>(当然只有第一次导入的时候才会这么做)</code>，然后它们具有单独的空间，是被隔离的，调用需要使用符号test_import来调用。但是正如我们之前所说，是”拿过来”执行，所以这个<code>__init__.py</code>里面的内容是”拿过来”，在当前的py文件<code>(在哪里导入的就是哪里)</code>中执行的。所以由于import a这行代码表示绝对导入，就相当于在当前模块里面导入，会从sys.path里面搜索，但是a是在test_import包里面，那么此时还能找到这个a吗？显然是不能的。那<code>from . import a</code>为什么就好使呢？因为这种导入表示相对导入，就表示要在<code>__init__.py</code>所在目录里面找，那么不管在什么地方导入这个包，由于这个<code>__init__.py</code>的位置是不变的，所以<code>from . import a</code>这种相对导入的方式总能找到对应的a。至于标准库、第三方模块、第三方包，因为它是在sys.path里面的，在哪儿都能找得到，所以可以绝对导入，貌似也只能绝对导入。并且我们知道每一个模块都有一个<code>__file__</code>属性<code>(除了内嵌在解释器里面的模块)</code>，当然包也是。如果你在一个模块里面<code>print(__file__)</code>，那么不管你在哪里导入这个模块，打印的永远是这个模块的路径；包的话，则是指向内部的<code>__init__.py</code>文件。</strong></p>
<p><strong>另外关于相对导入，一个很重要的一点，一旦一个模块出现了相对导入，那么这个模块就不能被执行了，它只可以被导入。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line">name = <span class="string">&quot;satori&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    from . import a</span></span><br><span class="line"><span class="string">ImportError: attempted relative import with no known parent package</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时如果我试图执行<code>__init__.py</code>，那么就会给我报出这个错误。另外即便导入一个内部具有”相对导入”的模块，那么此模块和导入的模块也不能在同一个包内，我们要执行的当前模块至少要在导入模块的上一级，否则执行的当前模块也会报出这种错误。为什么会有这种情况，很简单。想想为什么会有相对导入，就是希望这些模块在被其它地方导入的时候能够准确记住要导入的包的位置。那么这些模块肯定要在一个共同的包里面，然后我们在包外面使用。所以我们导入一个具有相对导入的模块时候，那么我们当前模块和要导入的模块绝对不能在同一个包里面。</strong></p>
<h5 id="import的另一种方式"><a href="#import的另一种方式" class="headerlink" title="import的另一种方式"></a>import的另一种方式</h5><p><strong>我们要导入test_import包里面的a模块，除了可以import test_import<code>(_init__.py里面导入了a)</code>，还可以通过<code>import test_import.a</code>的方式，另外如果是这种导入方式，那么module里面可以没有<code>__init__.py</code>文件，因为我们导入test_import包的时候，是通过test_import来获取a，所以必须要有<code>__init__.py</code>文件、并且里面导入a。但是在导入test_import.a的时候，就是找test_import.a，所以此时是可以没有<code>__init__.py</code>文件的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line">__version__ = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>此时test_import包里面的<code>__init__.py</code>只定义了一个变量，下面我们来通过test_import.a的形式导入。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a.name) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当import test_import.a的时候，会执行里面的print</span></span><br><span class="line"><span class="comment"># 然后可以通过test_import.a获取a.py里面的属性，这很好理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，没错，我要说但是了</span></span><br><span class="line"><span class="built_in">print</span>(test_import.__version__)  <span class="comment"># 1.0</span></span><br></pre></td></tr></table></figure>

<p><strong>惊了，我们在导入test_import.a的时候，也把test_import导入进来了，为了更直观的看到现象，我们在<code>__init__.py</code>里面打印一句话。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line">__version__ = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的__init__&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一个有趣的现象就产生了，我们是导入test_import.a，但是把test_import也导入进来了。而且通过打印的顺序，我们看到是先导入了test_import，然后再导入test_import下面的a。如果我们在<code>__init__.py</code>中也导入了a会怎么样？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的__init__&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的a&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">我是test_import下面的a</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们看到a.py里面的内容只被打印了一次，说明没有进行二次加载</span></span><br><span class="line"><span class="comment"># 在__init__.py中将a导进来之后，就加入到sys.modules里面了</span></span><br></pre></td></tr></table></figure>

<p><strong>所以通过<code>test_import.a</code>的方式来导入，即使没有<code>__init__.py</code>文件依旧是可以访问的，因为这是我在import的时候指定的。我们可以看一下sys.modules</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;test_import&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;test_import.a&quot;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">我是test_import下面的a</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>不过问题来了，为什么在导入test_import.a的时候，会将test_import也导入了进来呢？并且还可以直接使用test_import，毕竟这不是我们期望的结果，因为导入test_import.a的话，那么我们只是想使用test_import.a，不打算使用test_import，那么Python为什么要这么做呢？</strong></p>
<blockquote>
<p><strong>事实上，这对Python而言是必须的，根据我们对Python虚拟机的执行原理的了解，Python要想执行test_import.a，那么肯定要先从local空间找到test_import，然后才能找到a，如果不找到test_import的话，那么对a的查找也就无从谈起。可问题是sys.modules里面是<code>test_import.a</code>啊，这是一个整体啊。事实上尽管是一个整体，但并不是说有一个模块，这个模块就叫做test_import.a。准确的说import  test_import.a表示先导入test_import，然后再将test_import下面的a加入到test_import的属性字典里面。我们说当module这个包里面没有<code>__init__.py</code>的时候，那个这个包是无法使用的，因为属性字典里面没有相关属性，但是当我们import test_import.a的时候，Python会先导入test_import这个包，然后自动帮我们把a这个模块加入到module这个包的属性字典里面。</strong></p>
<p><strong>但之所以会有”test_import.a”这个key，显然也是为了解决重复导入的问题。</strong></p>
</blockquote>
<p><strong>假设test_import这个包里面有a和b两个py文件，那么我们执行<code>import test_import.a</code>和<code>import test_import.b</code>会进行什么样的动作应该就了如指掌了吧。执行<code>import test_import.a</code>，那么会先导入test_import，然后把a加到test_import的属性字典里面，执行<code>import test_import.b</code>，还是会先导入包test_import，但是包test_import在上一步已经被导入了，所以此时直接会从sys.modules里面获取，然后再把b加入到test_import的属性字典里面。所以如果<code>__init__.py</code>里面有一个print的话，那么两次导入显然只会print一次，这种现象是由Python对包中的模块的动态加载机制决定的。还是那句话，一个包你就看成是里面的<code>__init__.py</code>文件即可，Python对于包和模块的区分不是特别明显。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import目录下有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__file__)  <span class="comment"># D:\satori\test_import\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import目录下没有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__file__)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; (namespace)&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到如果包里面有<code>__init__.py</code>文件，那么这个包的<code>__file__</code>属性就是其内部的<code>__init__.py</code>文件，打印这个包，显示的也是其内部的<code>__init__.py</code>模块。如果没有<code>__init__.py</code>文件，那么这个包的<code>__file__</code>就是一个None，打印这个包，显示其是一个名字空间。另外，我们知道任何一个模块<code>(即使里面什么也不写)</code>的属性字典里面都是有<code>__builtins__</code>属性的，因为可以直接使用内置的对象、函数等等。而<code>__init__.py</code>也是属于一个模块，所以它也有<code>__builtins__</code>属性的，由于一个包指向了内部的<code>__init__.py</code>，所以这个包的属性字典也是有<code>__builtins__</code>属性的。但如果这个包没有<code>__init__.py</code>文件，那么这个包是没有<code>__builtins__</code>属性的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__dict__.get(<span class="string">&quot;__builtins__&quot;</span>))  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__dict__.get(<span class="string">&quot;__builtins__&quot;</span>)[<span class="string">&quot;int&quot;</span>])  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="路径搜索树"><a href="#路径搜索树" class="headerlink" title="路径搜索树"></a>路径搜索树</h5><p><strong>假设我有这样的一个目录结构：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062935691-954690708.png" alt="img"></p>
<p><strong>那么Python会将这个结构进行分解，得到一个类似于树状的节点集合：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062939957-3975499.png" alt="img"></p>
<p><strong>然后从左到右依次去sys.modules中查找每一个符号所对应的module对象是否已经被加载，如果一个包被加载了，比如说包test_import被加载了，那么在包test_import对应的PyModuleObject中会维护一个元信息<code>__path__</code>，表示这个包的路径。比如我搜索A.a，当加载进来A的时候，那么a只会在<code>A.__path__</code>中进行，而不会在Python的所有搜索路径中执行了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__path__)  <span class="comment"># [&#x27;D:\\satori\\test_import&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入sys模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> test_import.sys</span><br><span class="line"><span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># No module named &#x27;test_import.sys&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然这样是错的，因为导入test_import.sys，那么就将搜索范围只限定在test_import的__path__下面了</span></span><br></pre></td></tr></table></figure>

<h4 id="from与import"><a href="#from与import" class="headerlink" title="from与import"></a>from与import</h4><p><strong>在Python的import中，有一种精确控制所加载的对象的方法，通过from和import的结合，可以只将我们期望的module对象、甚至是module对象中的某个符号，动态地加载到内存中。这种机制使得Python虚拟机在当前名字空间中引入的符号可以尽可能地少，从而更好地避免名字空间遭到污染。</strong></p>
<p><strong>按照我们之前所说，导入test_import下面的a模块，我们可以使用<code>import test_import.a</code>的方式，但是此时a是在test_import的名字空间中，不是在我们当前模块的名字空间中。也就是说我们希望能直接通过符号a来调用，而不是test_import.a，此时通过<code>from ... import ...</code>联手就能完美解决。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;test_import&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;test_import.a&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;a&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到，确确实实将a这个符号加载到当前的名字空间里面了，但是在sys.modules里面却没有a。还是之前说的，a这个模块是在test_import这个包里面的，你不可能不通过包就直接拿到包里面的模块，因此在sys.modules里面的形式其实还是test_import.a这样形式，只不过在当前模块的名字空间中是a，a被映射到sys.modules[“test_import.a”]，另外我们看到除了test_import.a，test_import也导入进来了，这个原因我们之前也说过了，不再赘述。所以我们发现即便我们是<code>from ... import ...</code>，还是会触发整个包的导入。只不过我们导入谁<code>(假设从a导入b)</code>，就把谁加入到了当前模块的名字空间里面<code>(但是在sys.modules里面是没有b的，而是a.b)</code>，并映射到sys.modules[“a.b”]。</strong></p>
<p><strong>所以我们见识到了，即便是我们通过from test_import import a，还是会导入test_import这个包的，只不过test_import这个包是在sys.modules里面，并没有暴露到local空间中。</strong></p>
<p><strong>此外我们<code>from test_import import a</code>，导入的这个a是一个模块，但是模块a里面还有一个变量a，我们不加from，只通过import的话，那么最深也只能import到一个模块，不可能说直接import模块里面的某个变量、方法什么的。但是<code>from ... import ...</code>的话，却是可以的，比如我们<code>from test_import.a import a</code>，这句就表示我要导入test_import.a模块里面变量a。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">modules = sys.modules</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import.a&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们导入的a是一个变量，并不是模块，所以sys.modules里面不会出现test_import.a.a这样的东西存在，但是这个a毕竟是从test_import.a里面导入的，所以test_import.a是会在sys.modules里面的，同理test_import.a表示从test_import的属性字典里面找a，所以test_import也是会进入sys.modules里面的。</strong></p>
<blockquote>
<p><strong>最后还可以使用from test_import.a import  *，这样的机制把一个模块里面所有的内容全部导入进来，本质和导入一个变量是一致的。但是在Python中有一个特殊的机制，比如我们from  test_import.a import *，如果a里面定义了__all__，那么只会导入__all__里面指定的属性。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="number">456</span></span><br><span class="line">c = <span class="number">789</span></span><br><span class="line">__all__ = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到在<code>__all__</code>里面只指定了a和b，那么后续通过<code>from test_import.a import \*</code>的时候，只会导入a和b，而不会导入c。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> <span class="string">&quot;b&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们注意到：通过<code>from ... import \*</code>导入的时候，是无法导入c的，因为c没有在<code>__all__</code>中。但是即便如此，我们也可以通过单独导入，把c导入进来。只是不推荐这么做，像pycharm这种智能编辑器也会提示：<code>&#39;c&#39; is not declared in __all__</code>。因为既然没有在<code>__all__</code>里面，就证明这个变量是不希望被导入的，但是一般导入了也没关系。</strong></p>
<h4 id="符号重命名"><a href="#符号重命名" class="headerlink" title="符号重命名"></a>符号重命名</h4><p><strong>我们导入的时候一般为了解决符号冲突，往往会起别名，或者说符号重命名。比如包a和包b下面都有一个模块叫做m，如果是<code>from a import m</code>和<code>from b import m</code>的话，那么两者就冲突了，后面的m会把上面的m覆盖掉，不然Python怎么知道要找哪一个m。所以这个时候我们会起别名，比如<code>from a import m as m1</code>、<code>from b import m as m2</code>，但是<code>from a import \*</code>是不支持as的。所以直接Python都是将module对象内部所以符号都暴露给了local名字空间，而符号重命名则是Python可以通过as关键字控制包、模块、变量暴露给local名字空间的方式。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># &lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import.a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>到结论我相信就应该心里有数了，不管我们有没有as，既然<code>import test_import.a</code>，那么sys.modules里面就一定有test_import.a，和test_import。其实理论上有包test_import就够了，但是我们说a是一个模块，为了避免多次导入所以也要加到sys.modules里面，而且a又是test_import包里面，所以是test_import.a。而我们这里<code>as a</code>，那么a这个符号就暴露在了当前模块的local空间里面，而且这个a就跟之前的test_import.a一样，指向了test_import包下面的a模块，无非是名字不同罢了。当然这不是重点，我们之前通过<code>import test_import.a</code>的时候，会自动把test_import也加入到当前模块的local空间里面，也就是说通过<code>import test_import.a</code>是可以直接使用test_import的，但是当我们加上了as之后，发现test_import包已经不能访问了。尽管都在sys.modules里面，但是对于加了as来说，此时的test_import这个包已经不在local名字空间里面了。一个as关键字，导致了两者的不同，这是什么原因呢？我们后面分解。</strong></p>
<h4 id="符号的销毁与重载"><a href="#符号的销毁与重载" class="headerlink" title="符号的销毁与重载"></a>符号的销毁与重载</h4><p><strong>为了使用一个模块，无论是内置的还是自己写的，都需要import动态加载到内存，使用之后，我们也可能会删除，删除的原因一般是释放内存啊等等。在python中，删除一个对象可以使用del关键字，遇事不决del。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># [2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(A))  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">del</span> A.foo</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(A))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>不光是列表、字典，好多东西del都能删除，甚至是删除某一个位置的值、或者方法。我们看到类的一个方法居然也能使用del删除，但是对于module对象来说，del能做到吗？显然是可以做到的，或者更准确的说法是<code>符号的销毁</code>和<code>符号关联的对象的销毁</code>是一个概念吗？Python已经向我们隐藏了太多的动作，也采取了太多的缓存策略，当然对于Python的使用者来说是好事情，因为把复杂的特性隐藏起来了，但是当我们想彻底的了解Python的行为时，则必须要把这些隐藏的东西挖掘出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于模块来说，dir()和locals()、globals()的keys是一致的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(sys.modules[<span class="string">&quot;test_import.a&quot;</span>]))  <span class="comment"># 1576944838432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> 我不叫a了</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(我不叫a了))  <span class="comment"># 1576944838432</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到在del之后，a这个符号确实从local空间消失了，或者说dir已经看不到了。但是后面我们发现，消失的仅仅是a这个符号，至于test_import.a指向的PyModuleObject依旧在sys.modules里面岿然不动。然而，尽管它还存在于Python系统中，但是我们的程序再也无法感知到，但它就在那里不离不弃。所以此时Python就成功地向我们隐藏了这一切，我们的程序认为：test_import.a已经不存在了。</strong></p>
<p><strong>不过为什么Python要采用这种看上去类似<code>模块池</code>的缓存机制呢？因为组成一个完整系统的多个py文件可能都要对某个module对象进行import动作。所以要是从sys.modules里面删除了，那么就意味着需要重新从文件里面读取，如果不删除，那么只需要从sys.modules里面暴露给当前的local名字空间即可。所以import实际上并不等同我们所说的动态加载，它的真实含义是希望某个模块被感知，也就是”将这个模块以某个符号的形式引入到某个名字空间”。这些都是同一个模块，如果import等同于动态加载，那么Python对同一个模块执行多次动态加载，并且内存中保存一个模块的多个镜像，这显然是非常愚蠢的。</strong></p>
<p><strong>所以Python引入了全局的module对象集合–sys.modules，这个集合作为<code>模块池</code>，保存了模块的唯一值。当某个模块通过import声明希望感知到某个module对象时，Python将在这个池子里面查找，如果被导入的模块已经存在于池子中，那么就引入一个符号到当前模块的名字空间中，并将其关联到导入的模块，使得被导入的模块可以透过这个符号被当前模块感知到。而如果被导入的模块不在池子里，Python这才执行动态加载的动作。</strong></p>
<p><strong>如果这样的话，难道一个模块在被加载之后，就不能改变了。假如在加载了模块a的时候，如果我们修改了模块a，难道Python程序只能先暂停再重启吗？显然不是这样的，python的动态特性不止于此，它提供了一种重新加载的机制，使用importlib模块，通过importlib.reload(module),可以实现重新加载并且这个函数是有返回值的，返回加载之后的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">r&quot;D:\satori&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name  <span class="comment"># 不存在name属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: module <span class="string">&#x27;test_import.a&#x27;</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = importlib.reload(a)  <span class="comment"># 增加一个赋值语句 name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">&#x27;夏色祭&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = importlib.reload(a)  <span class="comment"># 将 name = &quot;夏色祭&quot; 语句删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">&#x27;夏色祭&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们的a模块里面啥也没有，但是我们在a.py里面增加了name变量，然后重新加载模块，所以a.name正确打印。然后我们在a.py再删除name属性，然后重新加载，但是我们看到name变量还在里面，还可以被调用。</strong></p>
<p><strong>那么根据这个现象我们是不是可以大胆猜测，python在reload一个模块的时候，只是将模块里面新的符号加载进来，而删除的则不管了，那么这个猜测到底正不正确呢，别急我们下面就来揭晓，并通过源码来剖析import的实现机制。</strong></p>
<h3 id="import机制的实现"><a href="#import机制的实现" class="headerlink" title="import机制的实现"></a>import机制的实现</h3><p><strong>从前面的黑盒探测我们已经对import机制有了一个非常清晰的认识，python的import机制基本上可以切分为三个不同的功能。</strong></p>
<ul>
<li><code>python运行时的全局模块池的维护和搜索</code></li>
<li><code>解析与搜索模块路径的树状结构</code></li>
<li><code>对不同文件格式的模块的动态加载机制</code></li>
</ul>
<p><strong>尽管import的表现形式千变万化，但是都可以归结为：<code>import x.y.z</code>的形式。因为<code>import sys</code>也可以看成是<code>x.y.z</code>的一种特殊形式。而诸如from、as与import的结合，实际上同样会进行<code>import x.y.z</code>的动作，只是最后在当前名字空间中引入符号时各有不同。所以我们就以<code>import x.y.z</code>的形式来进行分析。</strong></p>
<p><strong>我们说导入模块，是调用<code>__import__</code>，那么我们就来看看这个函数长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin___import__</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *kwlist[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;globals&quot;</span>, <span class="string">&quot;locals&quot;</span>, <span class="string">&quot;fromlist&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;level&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化globals、fromlist都为NULL</span></span><br><span class="line">    PyObject *name, *globals = <span class="literal">NULL</span>, *locals = <span class="literal">NULL</span>, *fromlist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;<span class="comment">//表示默认绝对导入</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从PyTupleObject中解析出需要的信息</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwds, <span class="string">&quot;U|OOOi:__import__&quot;</span>,</span><br><span class="line">                    kwlist, &amp;name, &amp;globals, &amp;locals, &amp;fromlist, &amp;level))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//导入模块</span></span><br><span class="line">    <span class="keyword">return</span> PyImport_ImportModuleLevelObject(name, globals, locals,</span><br><span class="line">                                            fromlist, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，PyArg_ParseTupleAndKeywords这个函数在python中是一个被广泛使用的函数，原型如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/getargs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PyArg_ParseTupleAndKeywords</span><span class="params">(PyObject *, PyObject *,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数的目的是将args和kwds中所包含的所有对象按format中指定的格式解析成各种目标对象，可以是Python中的对象<code>(PyListObject、PyLongObject等等)</code>，也可以是C的原生对象。</strong></p>
<p><strong>我们知道这个args实际上是一个PyTupleObject对象，包含了<code>__import__</code>函数运行所需要的参数和信息，它是Python虚拟机在执行IMPORT_NAME的时候打包而产生的，然而在这里，Python虚拟机进行了一个逆动作，将打包后的这个PyTupleObject拆开，重新获得当初的参数。Python在自身的实现中大量的使用了这样打包、拆包的策略，使得可变数量的对象能够很容易地在函数之间传递。</strong></p>
<p><strong>在解析参数的过程中，指定解析格式的format中可用的格式字符有很多，这里只看一下<code>__import__</code>用到的格式字符。其中s代表目标对象是一个char *，通常用来将元组中的PyUnicodeObject对象解析成char *，i则用来将元组中的PyLongObject解析成int，而O则代表解析的目标对象依然是一个Python中的合法对象，通常这表示 *PyArg_ParseTupleAndKeywords* 不进行任何的解析和转换，因为在PyTupleObject对象中存放的肯定是一个python的合法对象。至于<code>|</code>和<code>:</code>，它们不是非格式字符，而是指示字符，<code>|</code>指示其后所带的格式字符是可选的。也就是说，如果args中只有一个对象，那么<code>__import__</code>对 *PyArg_ParseTupleAndKeywords* 的调用也不会失败。其中，args中的那个对象会按照<code>s</code>的指示被解析为char *，而剩下的globals、locals、fromlist则会按照<code>O</code>的指示被初始化为Py_None，level是0。而<code>:</code>则指示”格式字符”到此结束了，其后所带字符串用于在解析过程中出错时，定位错误的位置所使用的。</strong></p>
<p><strong>在完成了对参数的拆包动作之后，然后进入了 *PyImport_ImportModuleLevelObject* ，这个我们在import_name中已经看到了，而且它也是先获取<code>__builtin__</code>里面的<code>__import__</code>函数指针。</strong></p>
<p><strong>另外每一个包和模块都有一个<code>__name__</code>和<code>__path__</code>属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.core</span><br><span class="line"><span class="keyword">import</span> six</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.__name__, np.__path__)  <span class="comment"># numpy [&#x27;C:\\python38\\lib\\site-packages\\numpy&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(np.core.__name__, np.core.__path__)  <span class="comment"># numpy.core [&#x27;C:\\python38\\lib\\site-packages\\numpy\\core&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(six.__name__, six.__path__)  <span class="comment"># six []</span></span><br></pre></td></tr></table></figure>

<p><strong><code>__name__</code>就是模块或者包名，如果包下面的包或者模块，那么就是<code>包名.包名</code>或者<code>包名.模块名</code>，至于<code>__path__</code>则是包所在的路径。但是这个和<code>__file__</code>又是不一样的，如果是<code>__file__</code>则是指向内部的<code>__init__.py</code>文件，没有则为None。但是对于模块来说，则没有<code>__path__</code>。</strong></p>
<p><strong>精力有限，具体的不再深入。我们下面从python的角度来理解一下吧</strong></p>
<h3 id="Python中的import操作"><a href="#Python中的import操作" class="headerlink" title="Python中的import操作"></a>Python中的import操作</h3><h4 id="import-模块"><a href="#import-模块" class="headerlink" title="import 模块"></a>import 模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sys)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               0 (sys)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是我们一开始考察的例子，现在我们已经很清楚地了解了<code>IMPORT_NAME</code>的行为，在<code>IMPORT_NAME</code>指令的最后，python虚拟机会将<code>PyModuleObject</code>对象压入到运行时栈内，随后会将<code>(sys, PyModuleObject)</code>存放到当前的local名字空间中。</strong></p>
<h4 id="import-包"><a href="#import-包" class="headerlink" title="import 包"></a>import 包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.linear_model.ridge</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model.ridge)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               1 (sklearn)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是我们一开始考察的例子，现在我们已经很清楚地了解了<code>IMPORT_NAME</code>的行为，在<code>IMPORT_NAME</code>指令的最后，python虚拟机会将<code>PyModuleObject</code>对象压入到运行时栈内，随后会将<code>(sys, PyModuleObject)</code>存放到当前的local名字空间中。</strong></p>
<p><strong>如果涉及的是对包的import动作，那么IMPORT_NAME的指令参数则是关于包的完整路径信息，IMPORT_NAME指令的内部将解析这个路径，并为sklearn、sklearn.linear_model，sklearn.linear_model.ridge都创建一个PyModuleObject对象，这三者都存在于sys.modules里面。但是我们看到STORE_NAME是sklearn，表示只有sklearn对应的PyModuleObject放在了当前模块的local空间里面，可为什么是sklearn呢？难道不应该是sklearn.linear_model.ridge吗？其实经过我们之前的分析这一点已经不再是问题了，因为<code>import sklearn.linear_model.ridge</code>并不是说导入一个模块或包叫做sklearn.linear_model.ridge，而是先导入sklearn，然后把linear_model放在sklearn的属性字典里面，把ridge放在linear_model的属性字典里面。同理sklearn.linear_model.ridge代表的是先从local空间里面找到sklearn，再从sklearn的属性字典中找到linear_model，然后在linear_model的属性字典里面找到ridge。而我们说，linear_model和ridge已经在对应的包的属性字典里面的了，我们通过sklearn一级一级往下找是可以找到的，因此只需要把skearn返回即可，或者说返回sklearn.linear_model.ridge本身就是不合理的，因为这表示导入一个名字就叫做sklearn.linear_model.ridge的模块或者包，但显然不存在，即便我们创建了，但是由于python的语法解析规范依旧不会得到想要的结果。不然的话，假设<code>import test_import.a</code>，那Python是导入名为<code>test_import.a</code>的模块或包呢？还是导入test_import下的a呢？</strong></p>
<p><strong>也正如我们之前分析的<code>test_import.a</code>，我们<code>import test_import.a</code>的时候，会把test_import加载进来，然后把a加到test_import的属性字典里面，然后只需要把test_import返回即可，因为我们通过test_import是可以找到a，而且也不存在我们期望的<code>test_import.a</code>，因为这个<code>test_import.a</code>代表的含义是<code>从test_import的属性字典里面获取a</code>，所以<code>import test_import.a</code>是必须要返回test_import的，而且只返回了test_import。至于sys.modules<code>(一个字典)</code>里面是存在字符串名为<code>test_import.a</code>的key的，这是为了避免重复加载所采取的策略，但它依旧表示从test_import里面获取a。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas.core</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pandas.DataFrame(&#123;<span class="string">&quot;a&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   a</span></span><br><span class="line"><span class="string">0  1</span></span><br><span class="line"><span class="string">1  2</span></span><br><span class="line"><span class="string">2  3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 导入pandas.core会先执行pandas的__init__文件</span></span><br><span class="line"><span class="comment"># 所以通过pandas.DataFrame是可以调用的</span></span><br></pre></td></tr></table></figure>

<h4 id="from-amp-import"><a href="#from-amp-import" class="headerlink" title="from &amp; import"></a>from &amp; import</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ridge</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 ((&#x27;ridge&#x27;,))</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model)</span></span><br><span class="line"><span class="string">              6 IMPORT_FROM              1 (ridge)</span></span><br><span class="line"><span class="string">              8 STORE_NAME               1 (ridge)</span></span><br><span class="line"><span class="string">             10 POP_TOP</span></span><br><span class="line"><span class="string">             12 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="string">             14 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意此时的<code>LOAD_CONST 1</code>不再是None了，而是一个元组。此时Python是将ridge放到了当前模块的local空间中，并且sklearn、sklearn.linear_model都被导入了，并且存在于sys.modules里面，但是sklearn却并不在当前local空间中，尽管这个对象被创建了，但是它被Python隐藏了。IMPORT_NAME是sklearn.linear_model，也表示导入sklearn，然后把sklearn下面的linear_model加入到sklearn的属性字典里面。其实sklearn没在local空间里面，还可以这样理解。只有import的时候，那么我们必须从头开始一级一级向下调用，所以顶层的包必须加入到local空间里面，但是<code>from sklearn.linear_model import ridge</code>是把ridge导出，此时ridge已经指向了<code>sklearn</code>下面的<code>linear_model</code>下面的<code>ridge</code>，那么此时就不需要sklearn了，或者说sklearn就没必要暴露在local空间里面了。并且sys.modules里面也不存在<code>ridge</code>这个key，存在的是<code>sklearn.linear_model.ridge</code>，暴露给当前模块的local空间里面的符号是<code>ridge</code></strong></p>
<h4 id="import-amp-as"><a href="#import-amp-as" class="headerlink" title="import &amp; as"></a>import &amp; as</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.linear_model.ridge <span class="keyword">as</span> xxx</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model.ridge)</span></span><br><span class="line"><span class="string">              6 IMPORT_FROM              1 (linear_model)</span></span><br><span class="line"><span class="string">              8 ROT_TWO</span></span><br><span class="line"><span class="string">             10 POP_TOP</span></span><br><span class="line"><span class="string">             12 IMPORT_FROM              2 (ridge)</span></span><br><span class="line"><span class="string">             14 STORE_NAME               3 (xxx)</span></span><br><span class="line"><span class="string">             16 POP_TOP</span></span><br><span class="line"><span class="string">             18 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             20 RETURN_VALUE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这个和带有from的import类似，<code>sklearn</code>，<code>sklearn.linear_model</code>，<code>sklearn.linear_model.ridge</code>都在sys.modules里面，但是我们加上了as xxx，那么这个xxx就直接指向了<code>sklearn</code>下面的<code>linear_model</code>下面的<code>ridge</code>，就不需要sklearn了。这个和上面的from &amp; import类似，只有xxx暴露在了当前模块的local空间里面，sklearn虽然在sys.modules里面，但是在当前模块就无法访问了。</strong></p>
<h4 id="from-amp-import-amp-as"><a href="#from-amp-import-amp-as" class="headerlink" title="from &amp; import &amp; as"></a>from &amp; import &amp; as</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ridge <span class="keyword">as</span> xxx</span><br></pre></td></tr></table></figure>

<p><strong>这个我想连字节码都不需要贴了，和之前from &amp; import一样，只是最后暴露给当前模块的local空间的ridge变成了我们自己指定的xxx。</strong></p>
<h3 id="与module对象有关的名字空间问题"><a href="#与module对象有关的名字空间问题" class="headerlink" title="与module对象有关的名字空间问题"></a>与module对象有关的名字空间问题</h3><p><strong>同函数、类一样，每个PyModuleObject也是有自己的名字空间的。一个模块不能直接访问另一个模块的内容，尽管模块内部的作用域比较复杂，比如：遵循LEGB规则，但是模块与模块之间的划分则是很明显的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>():</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, print_name</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line"><span class="built_in">print</span>(print_name())  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>执行test2.py之后，发现打印的依旧是”夏色祭”。我们说Python是根据LEGB规则，而print_name里面没有name，那么去外层找，test2.py里面的name是”神乐mea”，但是找到的依旧是test1.py里面的”夏色祭”。为什么？</strong></p>
<p><strong>还是那句话，模块与模块之间的作用域划分的非常明显，print_name是test1.py里面的函数，所以在返回name的时候，只会从test1.py中搜索，无论如何都是不会跳过test1.py、跑到test2.py里面的。</strong></p>
<p><strong>再来看个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">nicknames = [<span class="string">&quot;夏哥&quot;</span>, <span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">test1.name = <span class="string">&quot;❤夏色祭❤&quot;</span></span><br><span class="line">test1.nicknames = [<span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># ❤夏色祭❤</span></span><br><span class="line"><span class="built_in">print</span>(nicknames)  <span class="comment"># [&#x27;祭妹&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>很简单，直接把test1里面的变量修改了。因为这种方式，相当于直接修改test1内部的属性字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">nicknames = [<span class="string">&quot;夏哥&quot;</span>, <span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line">name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">nicknames.remove(<span class="string">&quot;夏哥&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(nicknames)  <span class="comment"># [&quot;祭妹&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>如果是<code>from test1 import name, nicknames</code>，那么相当于在当前的local空间中创建一个变量name和nicknames指向对应的对象。name &#x3D; “神乐mea”相当于重新赋值了，而nicknames.remove则是在本地进行修改。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>总的来说，Python中module对象的导入还是很简单的，所以我们也没有涉及太多关于源码的知识。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制</title>
    <url>/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制"><a href="#25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制" class="headerlink" title="25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制"></a>25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这次我们来说一下Python中的多线程，在上篇博客中我们说了Python的线程，我们说Python中的线程是对OS线程进行了一个封装，并提供了一个线程状态(PyThreadState)对象，来记录OS线程的一些状态信息。</strong></p>
<p><strong>那什么是多线程呢？首先线程是操作系统调度cpu工作的最小单元，同理进程则是操作系统资源分配的最小单元，线程是需要依赖于进程的，并且每一个进程只少有一个线程，这个线程我们称之为主线程。而主线程则可以创建子线程，一个进程中如果有多个线程去工作，我们就称之为多线程。</strong></p>
<p><strong>开发一个多线程应用程序是很常见的事情，很多语言都支持多线程，有的是原生支持，有的是通过库的支持。而Python毫无疑问也支持多线程，并且它是通过threading这个库的方式实现的。另外提到Python的多线程，会让人想到GIL<code>(global interpreter lock)</code>这个万恶之源，我们后面会详细介绍。目前我们知道Python中的多线程是不能利用多核的，因为Python虚拟机使用一个全局解释器锁<code>(GIL)</code>来控制线程对程序的执行，这个结果就使得无论你的cpu有多少核，但是同时被线程调度的cpu只有一个。不过底层是怎么做的呢？我们下面就来分析一下。</strong></p>
<h3 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h3><p><strong>首先我们来分析一下为什么会有GIL这个东西存在？看两行代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis.dis(<span class="string">&quot;del name&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 DELETE_NAME              0 (name)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">              4 RETURN_VALUE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>当我们使用del删除一个变量的时候，对应的指令是DELETE_NAME，这个指令对应的源码中可以自己去查看。总之这条指令做的事情就是通过宏 *Py_DECREF* 减少一个对象的引用计数，并且判断减少之后其引用计数是否为0，如果为0就进行回收。伪代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--obj-&gt;ob_refcnt</span><br><span class="line"><span class="title function_">if</span> <span class="params">(obj -&gt; ob_refcnt == <span class="number">0</span>)</span>&#123;</span><br><span class="line">	销毁obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以总共是两步：第一步先将对象的引用计数减1；第二步判断引用计数是否为0，为0则进行销毁。那么问题来了，假设有两个线程A和B，内部都引用了全局变量obj，此时obj指向的对象的引用计数为2，然后让两个线程都执行del obj这行代码。</strong></p>
<p><strong>其中A线程先执行，如果A线程在执行完<code>--obj-&gt;ob_refcnt</code>之后，会将对象的引用计数减一，但不幸的是这个时候调度机制将A挂起了，唤醒了B。而B也执行del obj，但是它比较幸运，将两步都一块执行完了。而由于之前A已经将引用计数减1，所以再减1之后会发现对象的引用计数为0，从而执行了对象的销毁动作，内存被释放。</strong></p>
<p><strong>然后A又被唤醒了，此时开始执行第二个步骤，但由于<code>obj-&gt;ob_refcnt</code>已经被减少到0，所以条件满足，那么A依旧会对obj指向的对象进行释放，但是这个对象所占内存已经被释放了，所以obj此时就成了悬空指针。如果再对obj指向的对象进行释放，最终会引发什么结果，只有天知道。</strong></p>
<p><strong>关键来了，所以Python引入了GIL，GIL是解释器层面上的一把超级大锁，它是字节码级别的互斥锁，作用就是：在同时一刻，只让一个线程执行字节码，并且保证每一条字节码在执行的时候都不会被打断。</strong></p>
<p><strong>所以由于GIL的存在，会使得线程只有把当前的某条字节码指令执行完毕之后才有可能会发生调度。因此无论是A还是B，线程调度时，要么发生在DELETE_NAME这条指令执行之前，要么发生在DELETE_NAME这条指令执行完毕之后，但是不存在指令<code>(不仅是DELETE_NAME, 而是所有指令)</code>执行到一半的时候发生调度。</strong></p>
<p><strong>因此GIL才被称之为是字节码级别的互斥锁，它是保护字节码指令只有在执行完毕之后才会发生线程调度。所以回到上面那个del  obj这个例子中来，由于引入了GIL，所以就不存在我们之前说的：在A将引用计数减一之后，挂起A、唤醒B这一过程。因为A已经开始了DELETE_NAME这条指令的执行，所以在没执行完之前是不会发生线程调度的，至于为什么我们后面通过源码分析就知道了，总之此时就不会发生悬空指针的问题了。</strong></p>
<blockquote>
<p><strong>事实上，GIL在单核时代，其最初的目的就是为了解决引用计数的安全性问题，只不过Python的作者龟叔没想到多核会发展的这么快。</strong></p>
</blockquote>
<p><strong>那么，GIL是否会被移除呢？因为对于现在的多核cpu来说，Python的GIL无疑是进行了限制。</strong></p>
<blockquote>
<p><strong>关于能否移除GIL，从个人的角度来说不太可能，这都几十年了，能移除早就移除了。</strong></p>
<p><strong>而且事实上，在Python诞生没多久，就有人发现了这一诡异之处，因为当时的程序猿发现使用多线程在计算上居然没有任何性能上的提升，反而还比单线程慢了一点。当时Python的官方人员直接回复：不要使用多线程，而是使用多进程。</strong></p>
<p><strong>此时站在上帝视角的我们知道，因为GIL的存在使得同一时刻只有一个核被使用，所以对于纯计算的代码来说，理论上多线程和单线程是没有区别的。但是由于多线程涉及上下文的切换，会额外有一些开销，所以反而还慢一些。</strong></p>
<p><strong>因此在得知GIL的存在之后，有两位勇士站了出来表示要移除GIL，当时Python处于1.5的版本，非常的古老了。当它们在去掉GIL的时候，发现多线程的效率相比之前确实提升了，但是单线程的效率只有原来的一半，这显然是不能接受的。因为把GIL去掉了，就意味着需要更细粒度的锁，这就会导致大量的加锁、解锁，而加锁、解锁对于操作系统来说是一个比较重量级的操作，所以GIL的移除是极其困难的。</strong></p>
<p><strong>另外还有一个关键，就是当GIL被移除之后，会使得扩展模块的编写难度大大增加。像很多现有的C扩展，在很大程度上依赖GIL提供的解决方案，如果要移除GIL，就需要重新解决这些库的线程安全性问题。比如：我们熟知的numpy，numpy的速度之所以这么快，就是因为底层是C写的，外面套上了一层Python的接口。而其它的库，像pandas、scipy、sklearn都是基于numpy之上的，如果把GIL移除了，那么这些库就都不能用了。还有深度学习，深度学习对应的库：tensorflow、pytorch等框架所使用的底层算法也都不是Python编写的，而是C和C++，Python只是起到了一个包装器的作用。Python在深度学习领域很火，主要是它可以和C无缝结合，如果GIL被移除，那么这些框架也没法用了。</strong></p>
<p><strong>还有Cython，Cython代码本质上也是翻译成C的代码，再编译成扩展模块给Python调用，本质上也是写扩展模块。所以我们可以看到，如果GIL被移除了，那么很多Python第三方库(包括上面提到的)可能就要重新洗牌了。</strong></p>
<p><strong>因此在2020年的今天，生态如此成熟的Python，几乎是不可能摆脱GIL了。</strong></p>
</blockquote>
<p><strong>小插曲：我们说去GIL的老铁有两位，分别是<code>Greg Stein</code>和<code>Mark Hammond</code>，这个<code>Mark Hammond</code>估计很多人都见过，如果没见过，说明你Windows安装Python的时候不怎么关注。</strong></p>
<p><img src="/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/1229382-20200911012946105-410645391.png" alt="img"></p>
<p><strong>特别感谢 Mark Hammond，没有它这些年无偿分享的Windows专业技术，那么Python如今仍会运行在DOS上。</strong></p>
<p><strong>图解GIL</strong></p>
<p><strong>我们说Python启动一个线程，底层会启动一个C线程，最终启动一个操作系统的线程。所以还是那句话，Python中的线程实际上是封装了C的线程，进而封装了OS线程，一个Python线程对应一个OS线程。实际执行的肯定是OS线程，而OS线程Python解释器是没有权限控制的，它能控制的只是Python的线程。假设有4个Python线程，那么肯定对应4个OS线程，但是Python解释器每次只让一个Python线程去调用OS线程的执行，其它的线程只能干等着，只有当前的Python线程将GIL释放了，其它的某个线程在拿到GIL时，才可以调用相应的OS线程去执行。</strong></p>
<p><img src="/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/1229382-20200911095341427-509369386.png" alt="img"></p>
<p><strong>所以Python线程是调用C的线程、进而调用操作系统的OS线程，而每个线程在执行过程中Python解释器是控制不了的，因为Python的控制范围只有在解释器这一层，Python无权干预C的线程、更无权干预OS线程。</strong></p>
<p><strong>但是注意：GIL并不是Python语言的特性，它是CPython解释器开发人员为了方便才加上去的，只不过我们大部分用的都是CPython解释器，所以很多人认为CPython和Python是等价的，但其实不是的。Python是一门语言，而CPython是对使用Python语言编写的源代码进行解释执行的一个解释器。而解释器不止CPython一种，还有JPython，JPython解释器就没有GIL。因此Python语言本身是和GIL无关的，只不过我们平时在说Python的GIL的时候，指的都是CPython解释器里面的GIL，这一点要注意。</strong></p>
<p><img src="/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/1229382-20200911013000410-924037153.png" alt="img"></p>
<p><strong>所以就类似于上图的结果，一个线程执行一会儿，另一个线程执行一会儿，至于线程怎么切换、什么时候切换，我们后面会说。</strong></p>
<p><strong>因此我们知道，对于Python而言，解释执行字节码是Python的核心所在，所以Python通过GIL来互斥不同线程调用解释器执行字节码。如果一个线程想要执行，就必须拿到GIL，而一旦拿到GIL，其他线程就无法执行了，如果想执行，那么只能等GIL释放、被自己获取之后才可以执行。然而实际上，GIL保护的不仅仅是Python的解释器，同样还有python的C API，在C&#x2F;C++和Python混合开发时，在涉及到原生线程和python线程相互合作时，也需要通过GIL进行互斥。</strong></p>
<p><strong>有了GIL，在编写多线程代码的时候是不是就意味着不需要加锁了呢？</strong></p>
<blockquote>
<p><strong>答案显然不是的，因为GIL保护的是每条字节码不会被打断，而一行代码一般是对应多条字节码的，所以每行代码是可以被打断的。比如：a &#x3D; a + 1这样一条语句，它是对应4条字节码：LOAD_NAME、LOAD_CONST、BINARY_ADD、STORE_NAME。</strong></p>
<p><strong>假设此时a &#x3D; 8，两个线程同时执行 a &#x3D; a +  1，线程A执行的时候已经将a和1压入运行时栈，栈里面的a 显然是  8。但是还没有执行BINARY_ADD的时候，就被线程B执行了，此时B得到a显然还是8，因为线程A还没有对变量a做加法操作，然后B将这4条字节码全部执行完了，所以a应该是9。但是当线程A在执行的时候，会执行BINARY_ADD，不过注意：此时栈里面的a还是8，所以加完之后还是9。</strong></p>
<p><strong>所以本来a应该是10，但是却是9，就是因为在执行的时候发生的线程调度。所以我们在编写多线程代码的时候还是需要加锁的，GIL只是保证每条字节码执行的时候不会被打断，但是一行代码往往对应多条字节码，所以我们会通过threading.Lock()再加上一把锁。这样即便发生了线程调度，但由于我们在Python的层面上又加了一把锁，所以别的线程依旧无法执行。</strong></p>
</blockquote>
<p><strong>Python会在什么情况下释放锁？</strong></p>
<p><strong>关于GIL的释放Python有一个自己的调度机制：</strong></p>
<ul>
<li><strong>1. 当遇见io阻塞的时候会把锁释放，因为io阻塞是不耗费cpu的，所以此时虚拟机会把该线程的锁释放。</strong></li>
<li><strong>2. 即便是耗费cpu的运算等等，也不会一直执行，会在执行一小段时间之后释放锁，为了保证其他线程都有机会执行，就类似于cpu的时间片轮转的方式。</strong></li>
</ul>
<p><strong>调度机制虽然简单，但是这背后还隐藏这两个问题：</strong></p>
<ul>
<li><code>在何时挂起线程，选择处于等待状态的下一个线程？</code></li>
<li><code>在众多的处于等待状态的候选线程中，选择激活哪一个线程？</code></li>
</ul>
<p><strong>在Python的多线程机制中，这两个问题是分别由不同的层次解决的。对于何时进行线程调度问题，是由Python自身决定的。考虑一下操作系统是如何进行进程切换的，当一个进程运行了一段时间之后，发生了时钟中断，操作系统响应时钟，并开始进行进程的调度。同样，Python中也是模拟了这样的时钟中断，来激活线程的调度。我们知道Python解释字节码的原理就是按照指令的顺序一条一条执行，而Python内部维护着一个数值，这个数值就是Python内部的时钟。在Python2中如果一个线程执行的字节码指令数达到了这个值，那么会进行线程切换，并且这个值在Python3中仍然存在。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 我们看到默认是执行100条字节码启动线程调度机制，进行切换</span></span><br><span class="line"><span class="comment"># 这个方法python2、3中都存在</span></span><br><span class="line"><span class="built_in">print</span>(sys.getcheckinterval())  <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在python3中，我们更应该使用这个函数，表示线程切换的时间间隔。</span></span><br><span class="line"><span class="comment"># 表示一个线程在执行0.005s之后进行切换</span></span><br><span class="line"><span class="built_in">print</span>(sys.getswitchinterval())  <span class="comment"># 0.005</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的方法我们都可以手动设置</span></span><br><span class="line"><span class="comment"># 通过sys.setcheckinterval(N)和sys.setswitchinterval(N)设置即可</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在Python3.8的时候，使用sys.getcheckinterval和sys.setcheckinterval会被警告，表示这两个方法已经废弃了。</strong></p>
<p><strong>除了执行时间之外，还有就是我们之前说的遇见IO阻塞的时候会进行切换，所以多线程在IO密集型还是很有用处的，说实话如果IO都不会自动切换的话，那么我觉得Python的多线程才是真的没有用，至于为什么IO会切换我们后面说，总是现在我们知道Python会在什么时候进行线程切换了。那么下面的问题就是，Python在切换的时候会从等待的线程中选择哪一个呢？对于这个问题，Python则是借用了底层操作系统所提供的调度机制来决定下一个进入Python解释器的线程究竟是谁。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们说了一下Python中的GIL和线程调度，我们后面会介绍线程的创建以及GIL的源码分析。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</title>
    <url>/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"><a href="#26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理" class="headerlink" title="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"></a>26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</h2><h3 id="初见Python的-thread模块"><a href="#初见Python的-thread模块" class="headerlink" title="初见Python的_thread模块"></a>初见Python的_thread模块</h3><p><strong>下面我们来说一下Python中线程的创建，我们知道在创建多线程的时候会使用threading这个标准库，这个库是以一个py文件存在的形式存在的，不过这个模块依赖于_thread模块，我们来看看它长什么样子。</strong></p>
<p><img src="/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200912035621242-1036825105.png" alt="img"></p>
<p><strong>_thread是真正用来创建线程的模块，这个模块是由C编写，内嵌在解释器里面。我们可以import调用，但是在Python安装目录里面则是看不到的。像这种底层由C编写、内嵌在解释器里面的模块，以及那些无法使用文本打开的pyd文件，pycharm都会给你做一个抽象，并且把注释给你写好。</strong></p>
<p><strong>记得我们之前说过Python源码中的Modules目录，这个目录里面存放了大量使用C编写的模块，我们在编译完Python之后就，这些模块就内嵌在解释器里面了。而这些模块都是针对那些性能要求比较高的，而要求不高的则由Python编写，存放在Lib目录下。像我们平时调用random、collections、threading，其实它们背后会调用_random、_collections、_thread。再比如我们使用的re模块，真正用来做正则匹配的逻辑实际上位于 *Modules&#x2F;_sre.c* 里面。</strong></p>
<p><strong>说了这么多，只是为引出_thread是在Modules里面。玛德，前戏真长啊。Python中 _thread 的底层实现是在 _threadmodule.c中，我们来看看它都提供了哪些接口。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef thread_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start_new_thread&quot;</span>,        (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;start_new&quot;</span>,               (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allocate_lock&quot;</span>,           thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allocate&quot;</span>,                thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;exit_thread&quot;</span>,             thread_PyThread_exit_thread,</span><br><span class="line">     METH_NOARGS, exit_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;exit&quot;</span>,                    thread_PyThread_exit_thread,</span><br><span class="line">     METH_NOARGS, exit_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt_main&quot;</span>,          thread_PyThread_interrupt_main,</span><br><span class="line">     METH_NOARGS, interrupt_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get_ident&quot;</span>,               thread_get_ident,</span><br><span class="line">     METH_NOARGS, get_ident_doc&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_HAVE_THREAD_NATIVE_ID</span></span><br><span class="line">    &#123;<span class="string">&quot;get_native_id&quot;</span>,           thread_get_native_id,</span><br><span class="line">     METH_NOARGS, get_native_id_doc&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;<span class="string">&quot;_count&quot;</span>,                  thread__count,</span><br><span class="line">     METH_NOARGS, _count_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stack_size&quot;</span>,              (PyCFunction)thread_stack_size,</span><br><span class="line">     METH_VARARGS, stack_size_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_set_sentinel&quot;</span>,           thread__set_sentinel,</span><br><span class="line">     METH_NOARGS, _set_sentinel_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_excepthook&quot;</span>,              thread_excepthook,</span><br><span class="line">     METH_O, excepthook_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,                      <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到第一个 *start_new_thread* 和第二个 *start_new* ，发现它们都对应 *thread_PyThread_start_new_thread* 这个函数，这些接口和_thread.py中对应的是一致的。</strong></p>
<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><p><strong>当我们使用threading模块创建一个线程的时候，threading会调用_thread模块来创建，而在_thread中显然是通过里面 *start_new_thread* 对应的 *thread_PyThread_start_new_thread* 来创建，下面我们就来看看这个函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">thread_PyThread_start_new_thread</span><span class="params">(PyObject *self, PyObject *fargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ident;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面都是参数检测逻辑, thread.Thread()里面我们一般传递target、args、kwargs</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">&quot;start_new_thread&quot;</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                           &amp;func, &amp;args, &amp;keyw))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//target必须可调用</span></span><br><span class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;first arg must be callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//args是个元组</span></span><br><span class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;2nd arg must be a tuple&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kwargs是个字典</span></span><br><span class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;optional 3rd arg must be a dictionary&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建bootstate结构体实例</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct bootstate &#123;</span></span><br><span class="line"><span class="comment">        PyInterpreterState *interp;</span></span><br><span class="line"><span class="comment">        PyObject *func;</span></span><br><span class="line"><span class="comment">        PyObject *args;</span></span><br><span class="line"><span class="comment">        PyObject *keyw;</span></span><br><span class="line"><span class="comment">        PyThreadState *tstate;</span></span><br><span class="line"><span class="comment">    &#125;;    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    boot = PyMem_NEW(<span class="keyword">struct</span> bootstate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//获取进程状态对象、函数、args、kwargs</span></span><br><span class="line">    boot-&gt;interp = _PyInterpreterState_Get();</span><br><span class="line">    boot-&gt;func = func;</span><br><span class="line">    boot-&gt;args = args;</span><br><span class="line">    boot-&gt;keyw = keyw;</span><br><span class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</span><br><span class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    Py_INCREF(args);</span><br><span class="line">    Py_XINCREF(keyw);</span><br><span class="line">    <span class="comment">//初始化多线程环境，记住这一步</span></span><br><span class="line">    PyEval_InitThreads(); <span class="comment">/* Start the interpreter&#x27;s thread-awareness */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程, 返回id</span></span><br><span class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="type">void</span>*) boot);</span><br><span class="line">    <span class="keyword">if</span> (ident == PYTHREAD_INVALID_THREAD_ID) &#123;</span><br><span class="line">        PyErr_SetString(ThreadError, <span class="string">&quot;can&#x27;t start new thread&quot;</span>);</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        Py_DECREF(args);</span><br><span class="line">        Py_XDECREF(keyw);</span><br><span class="line">        PyThreadState_Clear(boot-&gt;tstate);</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromUnsignedLong(ident);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在这个函数中，我们看到Python虚拟机通过三个主要的动作完成一个线程的创建。</strong></p>
<ul>
<li><code>1. 创建并初始化bootstate结构体实例对象boot，在boot中，会保存一些相关信息</code></li>
<li><code>2. 初始化Python的多线程环境</code></li>
<li><code>3. 以boot为参数，创建子线程，子线程也会对应操作系统的原生线程</code></li>
</ul>
<p><strong>另外我们看到了这一步：<code>boot-&gt;interp = _PyInterpreterState_Get();</code>，说明boost保存了Python的 *PyInterpreterState* 对象，这个对象中携带了Python的<code>模块对象池(module pool)</code>这样的全局信息，Python中所有的thread都会保存这些全局信息。</strong></p>
<p><strong>我们在下面还看到了多线程环境的初始化动作，这一点需要注意，Python在启动的时候是不支持多线程的。换言之，Python中支持多线程的数据结构、以及GIL都是没有被创建的。因为对多线程的支持是需要代价的，如果上来就激活了多线程，但是程序却只有一个主线程，那么Python仍然会执行所谓的线程调度机制，只不过调度完了还是它自己，所以这无异于在做无用功。因此Python将开启多线程的权利交给了程序员，自己在启动的时候是单线程的，既然是单线程，自然就不存在线程调度了、当然也没有GIL。一旦用户调用了<code>threading.Thread(...).start() =&gt; _thread.start_new_thread()</code>，则代表明确地指示虚拟机要创建新的线程了，这个时候Python虚拟机就知道自己该创建与多线程相关的东西了，比如：数据结构、环境、以及那个至关重要的GIL。</strong></p>
<h4 id="建立多线程环境"><a href="#建立多线程环境" class="headerlink" title="建立多线程环境"></a>建立多线程环境</h4><p><strong>多线程环境的建立，说的直白一点，主要就是创建GIL。我们已经知道了GIL对于Python的多线程机制的重要意义，那么这个GIL是如何实现的呢？这是一个比较有趣的问题，下面我们就来看看GIL长什么样子吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/internal/pycore_pystate.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ceval_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 递归限制, 可以通过sys.getrecursionlimit()查看 */</span></span><br><span class="line">    <span class="type">int</span> recursion_limit;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	记录是否对任意线程启用跟踪，同时计算 tstate-&gt;c_tracefunc 为空的线程数。</span></span><br><span class="line"><span class="comment">   	如果该值为0，那么将不会检查该线程的 c_tracefunc</span></span><br><span class="line"><span class="comment">   	这会加快 PyEval_EvalFrameEx() 中 fast_next_opcode 后的if语句</span></span><br><span class="line"><span class="comment">   	</span></span><br><span class="line"><span class="comment">   	这里我们不做深入讨论</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> tracing_possible;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//eval循环中所有跳出快速通道的请求, 不深入讨论</span></span><br><span class="line">    _Py_atomic_int eval_breaker;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放弃GIL的请求</span></span><br><span class="line">    _Py_atomic_int gil_drop_request;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程调度相关, 比如: 加锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pending_calls</span> <span class="title">pending</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//信号检测相关</span></span><br><span class="line">    _Py_atomic_int signals_pending;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, GIL, 我们看到GIL是一个struct _gil_runtime_state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> <span class="title">gil</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>所以GIL在Python的底层是一个结构体，这个结构体藏身于 *include&#x2F;internal&#x2F;pycore_gil* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/ceval_gil.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_INTERVAL 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//include/internal/pycore_gil</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 一个线程拥有gil的间隔，默认是5000微妙，也就是我们上面用sys.getswitchinterval()得到的0.005 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> interval;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*最后一个持有GIL的PyThreadState(线程)，</span></span><br><span class="line"><span class="comment">    这有助于我们知道在丢弃GIL后是否还有其他线程被调度    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    _Py_atomic_address last_holder;</span><br><span class="line">    <span class="comment">/* GIL是否被获取，这个是原子性的，因为在ceval.c中不需要任何锁就能够读取它 */</span></span><br><span class="line">    _Py_atomic_int locked;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从GIL创建之后，总共切换的次数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> switch_number;</span><br><span class="line">    <span class="comment">/* cond允许一个或多个线程等待，直到GIL被释放 */</span></span><br><span class="line">    PyCOND_T cond;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* mutex则是负责保护上面的变量 */</span></span><br><span class="line">    PyMUTEX_T mutex;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    <span class="comment">/* &quot;GIL等待线程&quot;在被调度获取GIL之前, &quot;GIL释放线程&quot;一致处于等待状态 */</span></span><br><span class="line">    PyCOND_T switch_cond;</span><br><span class="line">    PyMUTEX_T switch_mutex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以我们看到gil是*struct _gil_runtime_state* 类型，然后内嵌在结构体 *struct _ceval_runtime_state* 里面。</strong></p>
<p><strong>gil是一个结构体实例，根据里面的gil.locked判断这个gil有没有人获取，而这个locked可以看成是一个布尔变量，其访问受到gil.mutex保护，是否改变则取决于gil.cond。在持有gil的线程中，主循环(PyEval_EvalFrameEx)必须能通过另一个线程来按需释放gil。</strong></p>
</blockquote>
<p><strong>并且我们知道在创建多线程的时候，首先是需要调用 *PyEval_InitThreads* 进行初始化的。我们就来看看这个函数，位于 *Python&#x2F;ceval.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyEval_InitThreads</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取运行时状态对象</span></span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//拿到ceval, struct _ceval_runtime_state类型, gil就在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ceval_runtime_state</span> *<span class="title">ceval</span> =</span> &amp;runtime-&gt;ceval;</span><br><span class="line">    <span class="comment">//获取gil</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> *<span class="title">gil</span> =</span> &amp;ceval-&gt;gil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果gil已经创建，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (gil_created(gil)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//线程的初始化</span></span><br><span class="line">    PyThread_init_thread();</span><br><span class="line">    <span class="comment">//创建gil</span></span><br><span class="line">    create_gil(gil);</span><br><span class="line">    <span class="comment">//获取线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = _PyRuntimeState_GetThreadState(runtime);</span><br><span class="line">    <span class="comment">//gil创建了，那么就要拿到这个gil</span></span><br><span class="line">    take_gil(ceval, tstate);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们说这个是和线程调度相关的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pending_calls</span> *<span class="title">pending</span> =</span> &amp;ceval-&gt;pending;</span><br><span class="line">    <span class="comment">//如果拿到gil了，其它线程就不能获取了，那么不好意思这个时候要加锁</span></span><br><span class="line">    pending-&gt;lock = PyThread_allocate_lock();</span><br><span class="line">    <span class="keyword">if</span> (pending-&gt;lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_FatalError(<span class="string">&quot;Can&#x27;t initialize threads for pending calls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看 *gil_created* 、 *create_gil* 、 *take_gil*  这三个函数，我们说它是用来检测 gil是否被创建、创建gil、和获取gil，定义在 *Python&#x2F;ceval_gil.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gil_created</span><span class="params">(<span class="keyword">struct</span> _gil_runtime_state *gil)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到这个gil_created就是用来检测gil有没有被创建的</span></span><br><span class="line">    <span class="keyword">return</span> (_Py_atomic_load_explicit(&amp;gil-&gt;locked, _Py_memory_order_acquire) &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_gil</span><span class="params">(<span class="keyword">struct</span> _gil_runtime_state *gil)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里是创建gil</span></span><br><span class="line">    <span class="comment">//我们看到这里负责初始化gil里面的成员</span></span><br><span class="line">    MUTEX_INIT(gil-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    MUTEX_INIT(gil-&gt;switch_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    COND_INIT(gil-&gt;cond);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    COND_INIT(gil-&gt;switch_cond);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil-&gt;last_holder, <span class="number">0</span>);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_CREATE(&amp;gil-&gt;locked);</span><br><span class="line">    _Py_atomic_store_explicit(&amp;gil-&gt;locked, <span class="number">0</span>, _Py_memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">take_gil</span><span class="params">(<span class="keyword">struct</span> _ceval_runtime_state *ceval, PyThreadState *tstate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_FatalError(<span class="string">&quot;take_gil: NULL tstate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> *<span class="title">gil</span> =</span> &amp;ceval-&gt;gil;</span><br><span class="line">    <span class="type">int</span> err = errno;</span><br><span class="line">    MUTEX_LOCK(gil-&gt;mutex);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断gil是否被释放, 如果被释放, 那么直接跳转到_ready</span></span><br><span class="line">    <span class="keyword">if</span> (!_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> _ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="type">int</span> timed_out = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> saved_switchnum;</span><br><span class="line">        <span class="comment">//如果没有释放，代表gil被人使用了，会一直循环请求获取gil</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">_ready:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/* 获取到gil的时候，那么会通过_Py_atomic_store_relaxed对其再次上锁 */</span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil-&gt;locked, <span class="number">1</span>);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_ACQUIRED(&amp;gil-&gt;locked, <span class="comment">/*is_write=*/</span><span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事实上，Python的多线程机制和平台有关系，需要进行统一的封装。比如：线程的销毁，Windows系统下就位于 *Python&#x2F;thread_nt.h* 中，可以自己看一看。</strong></p>
<p><strong>总之Python的线程在获取gil的时候，会检查当前gil是否可用。而其中的locked域就是指示当前gil是否可用，如果这个值为0，那么代表可用，那么就必须要将gil的locked设置为1，表示当前gil已被占用。一旦当该线程释放gil的时候，就一定要将该值减去1，这样gil的值才会从1变成0，才能被其他线程使用，所以官方把gil的locked说成是布尔类型也不是没道理的。</strong></p>
<p><strong>最终在一个线程释放gil时，会通知所有在等待gil的线程，这些线程会被操作系统唤醒。但是这个时候会选择哪一个线程执行呢？之前说了，这个时候Python会直接借用操作系统的调度机制随机选择一个。</strong></p>
<h4 id="线程状态保护机制"><a href="#线程状态保护机制" class="headerlink" title="线程状态保护机制"></a>线程状态保护机制</h4><p><strong>要剖析线程状态的保护机制，我们首先需要回顾一下线程状态对象。在Python中肯定要有对象负责记录对应线程的状态信息，这个对象就是PyThreadState对象。</strong></p>
<p><strong>每一个PyThreadState对象中都保存着当前的线程的PyFrameObject、线程id这样的信息，因为这些信息是需要被线程访问的。假设线程A访问线程对象，但是线程对象里面存储的却是B的id，这样的话就完蛋了。因此Python内部必须有一套机制，这套机制与操作系统管理进程的机制非常类似。在线程切换的时候，会保存当前线程的上下文，并且还能够进行恢复。在Python内部，维护这一个全局变量，当前活动线程所对应的线程状态对象就保存在该变量里。当Python调度线程时，会将被激活的线程所对应的线程状态对象赋给这个全局变量，让其始终保存活动线程的状态对象。</strong></p>
<p><strong>但是这样就引入了一个问题：Python如何在调度线程时，获得被激活线程对应的状态对象呢？其实Python内部会通过一个单项链表来管理所有的Python线程状态对象，当需要寻找一个线程对应的状态对象时，就遍历这个链表，搜索其对应的状态对象。</strong></p>
<p><strong>而对这个状态对象链表的访问，则不必在gil的保护下进行。因为对于这个状态对象链表，python会专门创建一个独立的锁，专职对这个链表进行保护，而且这个锁的创建是在python初始化的时候完成的。</strong></p>
<p><img src="/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200912035628568-1560244594.png" alt="img"></p>
<h4 id="从gil到字节码解释器"><a href="#从gil到字节码解释器" class="headerlink" title="从gil到字节码解释器"></a>从gil到字节码解释器</h4><p><strong>我们知道创建线程对象是通过 *PyThreadState_New* 函数创建的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python/pystate.c</span></span><br><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_New</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> new_threadstate(interp, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyThreadState *</span><br><span class="line"><span class="title function_">new_threadstate</span><span class="params">(PyInterpreterState *interp, <span class="type">int</span> init)</span></span><br><span class="line">&#123;	</span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyThreadState));</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//用于获取当前线程的frame</span></span><br><span class="line">    <span class="keyword">if</span> (_PyThreadState_GetFrame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面是线程的相关属性</span></span><br><span class="line">    tstate-&gt;interp = interp;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;frame = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;recursion_depth = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;overflowed = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;recursion_critical = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;stackcheck_counter = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;tracing = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;use_tracing = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;gilstate_counter = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;async_exc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;thread_id = PyThread_get_thread_ident();</span><br><span class="line"></span><br><span class="line">    tstate-&gt;dict = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;curexc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_traceback = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;exc_state.exc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.exc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.exc_traceback = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.previous_item = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_info = &amp;tstate-&gt;exc_state;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;c_profilefunc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_tracefunc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_profileobj = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_traceobj = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;trash_delete_nesting = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;trash_delete_later = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;on_delete = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;on_delete_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;coroutine_origin_tracking_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;async_gen_firstiter = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;async_gen_finalizer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;context = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;context_ver = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;id = ++interp-&gt;tstate_next_unique_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">//其它的都是设置属性，我们在前面章节已经见过了</span></span><br><span class="line">        <span class="comment">//之所以又拿出来，是因为关键的这一步</span></span><br><span class="line">        _PyThreadState_Init(runtime, tstate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HEAD_LOCK(runtime);</span><br><span class="line">    tstate-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;next = interp-&gt;tstate_head;</span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;next)</span><br><span class="line">        tstate-&gt;next-&gt;prev = tstate;</span><br><span class="line">    interp-&gt;tstate_head = tstate;</span><br><span class="line">    HEAD_UNLOCK(runtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步_PyThreadState_Init就表示将线程对应的线程对象放入到我们刚才说的那个&quot;线程状态对象链表&quot;当中</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyThreadState_Init(_PyRuntimeState *runtime, PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    _PyGILState_NoteThreadState(&amp;runtime-&gt;gilstate, tstate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有一个特别需要注意的地方，就是当前活动的Python线程不一定获得了gil。比如主线程获得了gil，但是子线程还没有申请gil，那么操作系统也不会将其挂起。由于主线程和子线程都对应操作系统的原生线程，所以操作系统系统是可能在主线程和子线程之间切换的，因为操作系统级别的线程调度和Python级别的线程调度是不同的。当所有的线程都完成了初始化动作之后，操作系统的线程调度和Python的线程调度才会统一。那时python的线程调度会迫使当前活动线程释放gil，而这一操作会触发操作系统内核的用于管理线程调度的对象，进而触发操作系统对线程的调度。所以我们说，Python对线程的调度是交给操作系统的<code>(使用的是操作系统内核调度线程的调度机制)</code>，当操作系统随机选择一个线程的时候，Python就会根据这个线程去<code>线程状态对象链表</code>当中找到对应的线程状态对象，并赋值给那个保存当前线程活动状态对象的全局变量。从而开始获取gil，执行字节码，执行一段时间，再次被强迫释放gil，然后操作系统再次调度，选择一个线程，再获取对应的线程状态对象，然后该线程获取gil，执行一段时间字节码，再次被强迫释放gil，然后操作系统再次随机选择，依次往复。。。。。。</strong></p>
<p><strong>显然，当子线程还没有获取gil的时候，相安无事。然而一旦 *PyThreadState_New* 之后，多线程机制初始化完成，那么子线程就开始互相争夺话语权了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">t_bootstrap</span><span class="params">(<span class="type">void</span> *boot_raw)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//线程信息都在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span> =</span> (<span class="keyword">struct</span> bootstate *) boot_raw;</span><br><span class="line">    <span class="comment">//线程状态对象</span></span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">//获取线程状态对象</span></span><br><span class="line">    tstate = boot-&gt;tstate;</span><br><span class="line">    <span class="comment">//拿到线程id</span></span><br><span class="line">    tstate-&gt;thread_id = PyThread_get_thread_ident();</span><br><span class="line">    _PyThreadState_Init(&amp;_PyRuntime, tstate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面说</span></span><br><span class="line">    PyEval_AcquireThread(tstate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进程内部的线程数量+1</span></span><br><span class="line">    tstate-&gt;interp-&gt;num_threads++;</span><br><span class="line">    <span class="comment">//执行字节码</span></span><br><span class="line">    res = PyObject_Call(boot-&gt;func, boot-&gt;args, boot-&gt;keyw);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_SystemExit))</span><br><span class="line">            <span class="comment">/* SystemExit is ignored silently */</span></span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _PyErr_WriteUnraisableMsg(<span class="string">&quot;in thread started by&quot;</span>, boot-&gt;func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(boot-&gt;func);</span><br><span class="line">    Py_DECREF(boot-&gt;args);</span><br><span class="line">    Py_XDECREF(boot-&gt;keyw);</span><br><span class="line">    PyMem_DEL(boot_raw);</span><br><span class="line">    tstate-&gt;interp-&gt;num_threads--;</span><br><span class="line">    PyThreadState_Clear(tstate);</span><br><span class="line">    PyThreadState_DeleteCurrent();</span><br><span class="line">    PyThread_exit_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里面有一个 *PyEval_AcquireThread* ，之前我们没有说，但如果我要说它是做什么的你就知道了。在 *PyEval_AcquireThread* 中，子线程进行了最后的冲刺，于是在里面它通过 *PyThread_acquire_lock*  争取gil。到了这一步，子线程将自己挂起了，操作系统没办法靠自己的力量将其唤醒，只能等待Python的线程调度机制强迫主线程放弃gil后，触发操作系统内核的线程调度，子线程才会被唤醒。然而当子线程被唤醒之后，主线程却又陷入了苦苦的等待当中，同样苦苦地等待这Python强迫子线程放弃gil的那一刻。<code>(假设我们这里只有一个主线程和一个子线程)</code></strong></p>
<p><strong>当子线程被Python的线程调度机制唤醒之后，它所做的第一件事就是通过 *PyThreadState_Swap* 将Python维护的当前线程状态对象设置为其自身的状态对象，就如同操作系统进程的上下文环境恢复一样。这个 *PyThreadState_Swap* 我们也没有详细展开说，因为有些东西我们只需要知道是干什么的就行。</strong></p>
<p><strong>子线程获取了gil之后，还不算成功，因为它还没有进入字节码解释器<code>(想象成大大的for循环，里面有一个巨大的switch)</code>。当Python线程唤醒子线程之后，子线程将回到<code>t_bootstrap</code>，并进入 *PyObject_Call* ，从这里一路往前，最终调用 *PyEval_EvalFrameEx* ，才算是成功。因为 *PyEval_EvalFrameEx* 执行的是字节码指令，而Python最终执行的也是一个字节码，所以此时才算是真正的执行，之前的都只能说是初始化。当进入 *PyEval_EvalFrameEx* 的那一刻，子线程就和主线程一样，完全受Python线程度调度机制控制了。</strong></p>
<h3 id="Python的线程调度"><a href="#Python的线程调度" class="headerlink" title="Python的线程调度"></a>Python的线程调度</h3><h4 id="标准调度"><a href="#标准调度" class="headerlink" title="标准调度"></a>标准调度</h4><p><strong>当主线程和子线程都进入了Python解释器后，Python的线程之间的切换就完全由Python的线程调度机制掌控了。Python的线程调度机制肯定是在Python解释器核心 *PyEval_EvalFrameEx* 里面的，因为线程是在执行字节码的时候切换的，那么肯定是在 *PyEval_EvalFrameEx* 里面。而在分析字节码的时候，我们看到过 *PyEval_EvalFrameEx* ，尽管说它是字节码执行的核心，但是它实际上调用了其它的函数，但毕竟是从它开始的，所以我们还是说字节码核心是 *PyEval_EvalFrameEx* 。总之，在分析字节码的时候，我们并没有看线程的调度机制，那么下面我们就来分析一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* Give another thread a chance */</span></span><br><span class="line">        <span class="keyword">if</span> (_PyThreadState_Swap(&amp;runtime-&gt;gilstate, <span class="literal">NULL</span>) != tstate) &#123;</span><br><span class="line">            Py_FatalError(<span class="string">&quot;ceval: tstate mix-up&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放gil，给其他线程一个机会</span></span><br><span class="line">        drop_gil(ceval, tstate);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Other threads may run now */</span></span><br><span class="line">        <span class="comment">//你一旦释放了，那么就必须要再次申请，才能等待下一次被调度。</span></span><br><span class="line">        take_gil(tstate);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主线程获得了gil执行字节码，但是我们知道在Python2中是通过执行字节码数量<code>(_Py_Ticker)</code>判断的，每执行一条字节码这个<code>_Py_Ticker</code>将减少1，初始为100。而在Python3中，则是通过执行时间来判断的，默认是0.005秒。一旦达到了执行时间，那么主线程就会将维护当前线程状态对象的全局变量设置为NULL并释放掉gil，这时候由于等待gil而被挂起的子线程被操作系统的线程调度机制重新唤醒，从而进入 *PyEval_EvalFrameEx* 。而对于主线程，虽然它失去了gil，但是由于它没有被挂起，所以对于操作系统的线程调度机制，它是可以再次被切换为活动线程的。</strong></p>
<p><strong>当操作系统的调度机制将主线程切换为活动线程的时候，主线程将主动申请gil，但由于gil被子线程占有，主线程将自身挂起。从这时开始，操作系统就不能再将主线程切换为活动线程了。所以我们发现，线程释放gil并不是马上就被挂起的，而是在释放完之后重新申请gil的时候才被挂起的。然后子线程执行0.005s之后，又会释放gil，申请gil，将自身挂起。而释放gil，会触发操作系统线程调度机制，唤醒主线程，如果是多个子线程的话，那么会从挂起的主线程和其它子线程中随机选择一个恢复。当主线程执行一段时间之后，又给子线程，如此反复，从而实现对Python多线程的支持。</strong></p>
<h4 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h4><p><strong>标准调度就是Python的调度机制掌控的，每个线程都是相当公平的。但是如果仅仅只有标准调度的话，那么可以说Python的多线程没有任何意义，但为什么可以很多场合使用多线程呢？就是因为调度除了标准调度之外，还存在阻塞调度。</strong></p>
<p><strong>阻塞调度是指，当某个线程遇到io阻塞的时候，会主动释放gil，让其它线程执行，因为io是不耗费cpu的。假设time.sleep，或者从网络上请求数据等等，这些都是处于io阻塞，那么会发生线程调度，当阻塞的线程可以执行了<code>(如：sleep结束，请求的数据成功返回)</code>，那么再切换回来。除了这一种情况之外，还有一种情况，也会导致线程不得不挂起，那就是input函数等待用户输入，这个时候也不得不释放gil。</strong></p>
<h3 id="Python子线程的销毁"><a href="#Python子线程的销毁" class="headerlink" title="Python子线程的销毁"></a>Python子线程的销毁</h3><p><strong>我们创建一个子线程的时候，往往是执行一个函数，或者重写一个类继承自threading.Thread，当然Python的threading模块我们后面会介绍。当一个子线程执行结束之后，Python肯定是要把对应的子线程销毁的，当然销毁主线程和销毁子线程是不同的，销毁主线程必须要销毁Python的运行时环境，而子线程的销毁则不需要这些动作，因此我们只看子线程的销毁。</strong></p>
<p><strong>通过前面的分析我们知道，线程的主体框架是在t_bootstrap中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">t_bootstrap</span><span class="params">(<span class="type">void</span> *boot_raw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span> =</span> (<span class="keyword">struct</span> bootstate *) boot_raw;</span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    Py_DECREF(boot-&gt;func);</span><br><span class="line">    Py_DECREF(boot-&gt;args);</span><br><span class="line">    Py_XDECREF(boot-&gt;keyw);</span><br><span class="line">    PyMem_DEL(boot_raw);</span><br><span class="line">    tstate-&gt;interp-&gt;num_threads--;</span><br><span class="line">    PyThreadState_Clear(tstate);</span><br><span class="line">    PyThreadState_DeleteCurrent();</span><br><span class="line">    PyThread_exit_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python首先会将进程内部的线程数量自减1，然后通过 *PyThreadState_Clear* 清理当前线程所对应的线程状态对象。所谓清理实际上比较简单，就是改变引用计数。随后，Python通过 *PyThreadState_DeleteCurrent* 函数释放gil。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/pystate.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyThreadState_DeleteCurrent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyThreadState_DeleteCurrent(&amp;_PyRuntime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_PyThreadState_DeleteCurrent(_PyRuntimeState *runtime)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gilstate_runtime_state</span> *<span class="title">gilstate</span> =</span> &amp;runtime-&gt;gilstate;</span><br><span class="line">    PyThreadState *tstate = _PyRuntimeGILState_GetThreadState(gilstate);</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>)</span><br><span class="line">        Py_FatalError(</span><br><span class="line">            <span class="string">&quot;PyThreadState_DeleteCurrent: no current tstate&quot;</span>);</span><br><span class="line">    tstate_delete_common(runtime, tstate);</span><br><span class="line">    <span class="keyword">if</span> (gilstate-&gt;autoInterpreterState &amp;&amp;</span><br><span class="line">        PyThread_tss_get(&amp;gilstate-&gt;autoTSSkey) == tstate)</span><br><span class="line">    &#123;</span><br><span class="line">        PyThread_tss_set(&amp;gilstate-&gt;autoTSSkey, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _PyRuntimeGILState_SetThreadState(gilstate, <span class="literal">NULL</span>);</span><br><span class="line">    PyEval_ReleaseLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后首先会删除当前的线程状态对象，然后通过 *PyEval_ReleaseLock* 释放gil。当然这只是完成了绝大部分的销毁工作，至于剩下的收尾工作就依赖于对应的操作系统了，当然这跟我们也就没关系了。</strong></p>
<h3 id="Python线程的用户级互斥与同步"><a href="#Python线程的用户级互斥与同步" class="headerlink" title="Python线程的用户级互斥与同步"></a>Python线程的用户级互斥与同步</h3><p><strong>我们知道，Python的线程在gil的控制之下，线程之间对Python提供的c  api访问都是互斥的，并且每次在字节码执行的过程中不会被打断，这可以看做是Python的内核级的用户互斥。但是这种互斥不是我们能够控制的，内核级通过gil的互斥保护了内核共享资源，比如<code>del obj</code>，它对应的指令是DELETE_NAME，这个是不会被打断的。但是像<code>n += 1</code>这种一行代码对应多条字节码，即便是有gil，但由于在执行到一半的时候，碰巧gil释放了，那么也会出岔子。所以我们还需要一种互斥，也就是用户级互斥。</strong></p>
<p><strong>实现用户级互斥的一种方法就是加锁，我们来看看Python提供的锁。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef lock_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;acquire_lock&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;acquire&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;release_lock&quot;</span>, (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_NOARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;release&quot;</span>,      (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_NOARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;locked_lock&quot;</span>,  (PyCFunction)lock_locked_lock,</span><br><span class="line">     METH_NOARGS, locked_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;locked&quot;</span>,       (PyCFunction)lock_locked_lock,</span><br><span class="line">     METH_NOARGS, locked_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__enter__&quot;</span>,    (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__exit__&quot;</span>,    (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_VARARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,           <span class="literal">NULL</span>&#125;              <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这些方法我们肯定都见过，acquire表示上锁、release就是释放。假设有两个线程A和B，A线程执行了lock.acquire()，然后执行下面的代码。这个时候依旧会进行线程调度，线程B执行的时候，也遇到了lock.acquire()，那么不好意思B线程就只能在这里等着了。没错，是轮到B线程执行了，但是由于我们在用户级层面上设置了一把锁lock，而这把锁已经被A线程获取了，那么即使后面切换到B线程，但是在A还没有lock.release()的时候，B也只能卡在lock.acquire()上面。因为A先拿到了锁，那么只要A不释放，B就拿不到锁，从而一直卡在lock.acquire()上面。</strong></p>
<blockquote>
<p><strong>用户级互斥：即便你拿到了GIL，你也无法执行。</strong></p>
</blockquote>
<h3 id="Python的threading模块"><a href="#Python的threading模块" class="headerlink" title="Python的threading模块"></a>Python的threading模块</h3><p><strong>上面说了这么多，那么我们来看看Python中的threading模块，下面就是从Python层面上介绍这个模块的使用方法、api。</strong></p>
<h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">target：执行的函数</span></span><br><span class="line"><span class="string">args：位置参数</span></span><br><span class="line"><span class="string">kwargs：关键字参数</span></span><br><span class="line"><span class="string">name：线程名字</span></span><br><span class="line"><span class="string">daemon：布尔类型。表示是否设置为守护线程。设置为守护线程，那么当主线程执行结束会立即自杀</span></span><br><span class="line"><span class="string">        默认不是守护线程，表示主线程执行完毕但不会退出，而是等待子线程执行结束才会退出。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们调用threading.Thread会创建一个线程</span></span><br><span class="line"><span class="comment"># 介绍几个简单的属性吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.拿到线程名字,等价于t.getName()</span></span><br><span class="line"><span class="built_in">print</span>(t.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看是否是守护线程，等价于t.isDaemon()</span></span><br><span class="line"><span class="built_in">print</span>(t.daemon)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.线程创建之后，还可以重新设置名字、或者守护线程</span></span><br><span class="line">t.setName(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">t.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t.getName())  <span class="comment"># 线程2</span></span><br><span class="line"><span class="built_in">print</span>(t.isDaemon())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    l.append(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程创建好了，但是我们如何启动呢？</span></span><br><span class="line"><span class="comment"># 直接调用t.start()即可。</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到启动一个子线程之后，主线程是不会等待子线程的，而是会继续往下走。因此在子线程进行append之前，主线程就已经打印了。那么如何等待子线程执行完毕之后，再让主线程往下走呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    l.append(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就表示必须等t这个线程执行完毕，主线程才能向下走。</span></span><br><span class="line"><span class="comment"># 当然这里面是可以传递一个超时时间的，如果执行完毕那么主线程往下走</span></span><br><span class="line"><span class="comment"># 但是执行完毕之前，时间到了，主线程也会向下走</span></span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">[123]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 由于多个线程操作系统调度，所以无法决定谁先打印。</span></span><br><span class="line"><span class="comment"># 但是我们看到确实是等待子线程结束之后才向下走的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们没有写t.jojn()</span></span><br><span class="line"><span class="comment"># 那么主线程执行完毕之后，会在最后默认执行一个join，不然它就直接结束了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是守护线程的话，那么就不用等了，直接结束</span></span><br><span class="line"><span class="comment"># 如果是多个子线程，同样的逻辑</span></span><br></pre></td></tr></table></figure>

<p><strong>突然发现这个模块的api实在简单，没啥可介绍的。可以直接网上搜索。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们算是将Python的多线程分析完毕了，很多人都说Python的多线程比较”鸡肋”，主要就是因为GIL导致Python无法利用多核。但是GIL也是有它的优点的，所以关于GIL也是仁者见仁智者见智吧。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制</title>
    <url>/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="28-Python内存管理与垃圾回收-第二部分-：源码解密Python中的垃圾回收机制"><a href="#28-Python内存管理与垃圾回收-第二部分-：源码解密Python中的垃圾回收机制" class="headerlink" title="28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制"></a>28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制</h3><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>现在绝大部分的语言都实现了垃圾回收机制，这其中也包括Python，而不同的语言采用的垃圾回收算法也各不相同。那么，常见的垃圾回收算法都有哪些呢？</strong></p>
<ul>
<li><code>引用计数法(reference count): 记录对象的被引用次数, 引用计数降为0时回收</code></li>
<li><code>标记-清除法(mark-sweep): 从根集合触发, 遍历所有能访问到的对象并对其进行标记, 然后将未被标记的对象清除</code></li>
<li><code>停止-复制法(stop-copy): 将内存划分为大小相同的内存块, 一块用完后启用另一块、并将存活的对象拷贝过去, 原来那块则整体被回收</code></li>
<li><code>分代回收法(generational-collection): 根据对象的存活时间将对象分为若干代, 并按照不同代的特征采用最合适的回收策略</code></li>
</ul>
<p><strong>那么我们下面来看看Python中的垃圾回收。</strong></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong>对于Python而言，其对象的生命周期是通过对象的引用计数来管理的，这一点在开始的章节我们就说了，对于Python中实现对象的基石PyObject，有两个属性，一个是该对象的类型，还有一个就是引用计数(ob_refcnt)。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235209572-1489713358.png" alt="img"></p>
<p><strong>ob_refcnt始终维护这对象的引用计数，所以从广义上将，引用计数也算是一种垃圾回收机制，而且它是一种最简单最直观的垃圾回收技术。尽管需要一个值来维护引用计数，但是引用计数有一个最大的优点：实时性。任何内存，一旦没有指向它的引用，那么就会被回收。而其他的垃圾回收技术必须在某种特定条件下<code>(比如内存分配失败)</code>才能进行无效内存的回收。</strong></p>
<p><strong>那么在Python中引用计数什么时候会增加，什么时候会减少呢？</strong></p>
<p><strong>引用计数加1</strong></p>
<ul>
<li><code>对象被创建：a=1</code></li>
<li><code>对象被引用：b=a</code></li>
<li><code>对象被作为参数传到一个函数中，func(a)</code></li>
<li><code>对象作为列表、元组等其他容器里面的元素</code></li>
</ul>
<p><strong>引用计数减1</strong></p>
<ul>
<li><code>指向对象的变量(符号)被显式的销毁：del a</code></li>
<li><code>对象的引用指向了其他的对象：a=2</code></li>
<li><code>对象的引用离开了它的作用域，比如函数的局部变量，在函数执行完毕的时候，也会被销毁(如果没有获取栈帧的话)，而全局变量则不会</code></li>
<li><code>对象的引用所在的容器被销毁，或者从容器中删除等等</code></li>
</ul>
<p><strong>查看引用计数</strong></p>
<p><strong>查看一个对象的引用计数，可以通过sys.getrefcount(obj)，但是由于作为getrefcount这个函数的参数，所以引用计数会多1。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235224081-339809316.png" alt="img"></p>
<p><strong>我们之前说Python中的变量只是一个和对象绑定的符号，在底层都是PyObject *泛型指针，b &#x3D;  a在底层中则表示把指针变量a存储的地址拷贝给了指针变量b，所以此时b也指向了a指向的对象。因此字符串对象”mashiro”的引用计数就会加1，此时变为2。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235228142-2049550450.png" alt="img"></p>
<p><strong>而每当减少一个引用，引用计数就会减少1。尽管我们用<code>sys.getrefcount</code>得到的结果是2，但是当这个函数执行完，由于局部变量的销毁，其实结果已经变成了1。因此引用计数很方便，就是当一片空间没有人引用了，那么就直接销毁。</strong></p>
<p><strong>所以我们看到ob_refcnt这个成员是维护引用计数的，一个对象是否要被销毁完全取决于它的引用计数是否为0，不为0、则存活，为0、则销毁。</strong></p>
<p><strong>所以引用计数机制是需要一些额外操作的，因为需要有成员时刻维护引用计数，并且与Python运行中所进行的内存分配、释放、引用赋值的次数是成正比的。这一点，相对于主流的垃圾回收技术，比如标记–清除<code>(mark--sweep)</code>、停止–复制<code>(stop--copy)</code>等方法相比是一个弱点，因为它们带来额外操作只和内存数量有关，至于多少人引用了这块内存则不关心。因此为了与引用计数搭配、在内存的分配和释放上获得最高的效率，Python设计了大量的内存池机制，比如小整数对象池、字符串的intern机制，列表的freelist缓冲池等等，这些大量使用的面向特定对象的内存池机制正是为了弥补引用计数的软肋。</strong></p>
<p><strong>其实对于现在的cpu和内存来说，上面的问题都不是什么问题，而且引用计数真的很方便、并且直观。但是引用计数还存在一个致命的缺陷，这一缺陷几乎将引用计数在垃圾回收机制中判了”死刑”，这一缺陷就是”循环引用”。而且也正是因为”循环引用”这个致命伤，导致在狭义上并不把引用计数看成是垃圾回收机制的一种。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = []</span><br><span class="line">lst2 = []</span><br><span class="line"></span><br><span class="line">lst1.append(lst2)</span><br><span class="line">lst2.append(lst1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> lst1, lst2</span><br></pre></td></tr></table></figure>

<p><strong>初始的时候，lst1和lst2指向的内存的引用计数都为1，但是<code>lst1.append(lst2)</code>，那么lst2指向内存的引用计数变成了2，同理<code>lst2.append(lst1)</code>导致lst1指向内存的引用计数也变成了2。因此当我们<code>del lst1, lst2</code>的时候，引用计数会从2变成1，因此lst1和lst2都不会被回收，但我们是希望回收lst1和lst2的。因此此时我们就说lst1和lst2指向的对象之间发生了循环引用，所以如果只是引用计数的话，那么显然这两者是回收不了的。</strong></p>
<p><strong>因此程序一直运行的话，是有可能发生内存泄露的。所以Python为了解决这个问题，又在引用计数之上引入了新的主流垃圾回收技术：标记–清除和分代回收技术来弥补这个最致命的漏洞。</strong></p>
<h3 id="三色标记模型之标记–清除"><a href="#三色标记模型之标记–清除" class="headerlink" title="三色标记模型之标记–清除"></a>三色标记模型之标记–清除</h3><p><strong>无论何种垃圾回收机制，一般都分为两个阶段：垃圾检测和垃圾回收。垃圾检测是从所有的已经分配的内存中区别出”可回收”和”不可回收”的内存，而垃圾回收则是使操作系统重新掌握垃圾检测阶段所标识出来的”可回收”内存块。所以垃圾回收，并不是说直接把这块内存的数据清空了，而是将使用权从新交给了操作系统，不会自己霸占了。</strong></p>
<p><strong>而我们说Python解决循环引用所采用的方法是标记–清除，那么我们看看这个方法是如何实现的，并未其建立一个三色标记模型，标记–清除正是基于这个模型实现的。</strong></p>
<p><strong>从具体的实现上来讲，标记–清除方法同样遵循垃圾回收的两个阶段，其简要过程如下：</strong></p>
<ul>
<li><code>寻找根对象(root object)的集合，所谓的root object就是一些全局引用和函数栈的引用。这些引用所用的对象是不可被删除的，而这个root object集合也是垃圾检测动作的起点</code></li>
<li><code>从root object集合出发，沿着root object集合中的每一个引用进行探索，如果能到达某个对象A，则称A是可达的(reachable)，可达的对象也不可被删除。这个阶段就是垃圾检测阶段</code></li>
<li><code>当垃圾检测阶段结束后，所有的对象分为了可达的(reachable)和不可达的(unreachable)。而所有可达对象都必须予以保留，而不可达对象所占用的内存将被回收</code></li>
</ul>
<p><strong>我们通过几张图来简单描述一下：</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235236491-1181272167.png" alt="img"></p>
<p><strong>图中的圈圈表示对象，其中黑色部分表示需要回收、但是由于循环引用而无法回收的垃圾对象，换句话说就是不可达的对象，这里我们假设除了根对象之外都是不可达的。而白色部分表示被程序引用而不能回收的活跃对象。</strong></p>
<p><strong>然后我们开始遍历了，显然从根对象开始遍历，首先根对象本身是可达的，不可以删除；被根对象引用的对象也是可达的，同样不能删除。当我们从根对象出发，沿着引用关系遍历，能够遍历到的对象都是可达的，我们将其标记为灰色。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235240699-1516371777.png" alt="img"></p>
<p><strong>我们看到被根对象直接引用的对象我们标记成了灰色，那么为什么不直接标记成白色呢？因为被根对象直接引用的对象，还有可能引用其它对象，我们需要一层一层遍历。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235244783-2045048359.png" alt="img"></p>
<p><strong>我们看到当灰色直接引用的对象检测完毕时，灰色就被标记成了白色，然后下面的黑色则变成了新的灰色。所以下面该谁了呢？显然从新的被标记成灰色的对象开始继续往下找，就是一层一层遍历嘛。</strong></p>
<blockquote>
<p><strong>可达对象标记成灰色，当其直接引用的对象被检查完毕时，就会被标记成白色，然后其直接引用的对象就会变成灰色。</strong></p>
</blockquote>
<p><strong>如果从根集合开始，按照广度优先的策略进行搜索的话，那么不难想象，灰色节点集合就如同波纹一样不断向外扩散。凡是被灰色波纹触碰到的就会变成白色，没有被触碰到的则还是原来的黑色。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235248250-1560490414.png" alt="img"></p>
<p><strong>如果是黑色，说明是不可达的，会被回收；白色，这说明是可达的，不会被回收。</strong></p>
<p><strong>以上就是垃圾回收中的标记–清除法，思想其实很简单。Python内部也是采用这个办法来识别、回收垃圾对象。由于Python中的对象都是分配在堆上的，根对象集合其实不太直观，Python是先通过一个算法找出根对象，然后再从根对象出发找到可达的活跃对象。此外，为提升垃圾回收效率，Python还引入了分代回收技术。</strong></p>
<h3 id="Python中的垃圾回收"><a href="#Python中的垃圾回收" class="headerlink" title="Python中的垃圾回收"></a>Python中的垃圾回收</h3><p><strong>如之前所说，Python中主要的内存管理手段是引用计数，而标记–清除和分代收集只是为了打破循环引用而引入的补充技术。这一事实意味着Python中的垃圾回收只关注可能会产生循环引用的对象，而像PyLongObject、PyUnicodeObject这些对象是绝对不可能产生循环引用的，因为它们内部不可能持有对其他对象的引用，所以这些直接通过引用计数机制就可以实现，而且后面我们说的垃圾回收也专指那些可能产生循环引用的对象。Python中的循环引用只会总是发生在container对象之间，所谓container对象就是<code>内部可持有对其他对象的引用</code>的对象，比如PyListObject、PyDictObject、自定义类对象、自定义类对象的实例对象等等。</strong></p>
<p><strong>当Python的垃圾回收机制开始运行时，只需要检查这些container对象，而对于PyLongObject、PyUnicodeObject等对象则不需要理会，这使得垃圾回收带来的开销只依赖于container对象的数量，而非所有对象的数量。为了达到这一点，Python就必须跟踪所创建的每一个container对象，并将这些对象组织到一个集合中，只有这样，才能将垃圾回收的动作限制在这些对象上。而Python采用了一个双向链表，所有的container对象在创建之后，都会被插入到这个链表当中。</strong></p>
<h4 id="可收集对象链表"><a href="#可收集对象链表" class="headerlink" title="可收集对象链表"></a>可收集对象链表</h4><p><strong>在对Python对象机制的分析当中我们已经看到，任何一个Python对象都可以分为两部分，一部分是PyObject_HEAD，另一部分是对象自身的数据。然而对于一个需要被垃圾回收机制跟踪的container来说还不够，因为这个对象还必须链入到Python内部的可收集对象链表中。而一个container对象要想成为一个可收集的对象，则必须加入额外的信息，这个信息位于PyObject_HEAD之前，称为PyGC_Head。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/objimpl.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">gc_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">gc_head</span> *<span class="title">gc_next</span>;</span>  <span class="comment">//链表后向指针，指向后一个被跟踪的对象</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">gc_head</span> *<span class="title">gc_prev</span>;</span>  <span class="comment">//链表前向指针，指向前一个被跟踪的对象</span></span><br><span class="line">        Py_ssize_t gc_refs;  <span class="comment">//对象引用计数副本，在标记清除算法中使用</span></span><br><span class="line">    &#125; gc;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> dummy;  <span class="comment">//内存对齐用，确保 _gc_head 结构体大小至少是 16 字节，从而使对象地址以 8 字节对齐</span></span><br><span class="line">&#125; PyGC_Head;</span><br></pre></td></tr></table></figure>

<p><strong>所以，对于Python所创建的可收集container对象，其内存布局与我们之前所了解的内存布局是不同的，我们可以从可收集container对象的创建过程中进行窥探。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Modules/gcmodule.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GC_New(PyTypeObject *tp)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>)</span><br><span class="line">        op = PyObject_INIT(op, tp);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GC_Malloc(<span class="type">size_t</span> basicsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_GC_Alloc(<span class="number">0</span>, basicsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">_PyObject_GC_Alloc(<span class="type">int</span> use_calloc, <span class="type">size_t</span> basicsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gc_runtime_state</span> *<span class="title">state</span> =</span> &amp;_PyRuntime.gc;</span><br><span class="line">    PyObject *op;</span><br><span class="line">    PyGC_Head *g;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (basicsize &gt; PY_SSIZE_T_MAX - <span class="keyword">sizeof</span>(PyGC_Head))</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//将对象和PyGC_Head所需内存加起来</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(PyGC_Head) + basicsize;</span><br><span class="line">    <span class="comment">//为对象本身和PyGC_Head申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (use_calloc)</span><br><span class="line">        g = (PyGC_Head *)PyObject_Calloc(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g = (PyGC_Head *)PyObject_Malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    op = FROM_GC(g);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以很清晰的看到，当Python为可收集的container对象申请内存空间时，为PyGC_Head也申请了空间，并且其位置位于container对象之前。所以对于PyListObject、PyDictObject等container对象的内存分布的推测就应该变成这样。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235256306-326421086.png" alt="img"></p>
<p><strong>在可收集container对象的内存分布中，内存分为三个部分，首先第一块用于垃圾回收机制，然后紧跟着的是Python中所有对象都会有的PyObject_HEAD，最后才是container自身的数据。这里的container对象，既可以是PyDictObject、也可以是PyListObject等等。</strong></p>
<p><strong>根据PyGC_Head，我们知道里面除了两个建立链表结构的前继指针和后继指针外，还有一个gc_ref，这个成员对垃圾回收的运行直观重要，我们后面会说。</strong></p>
<p><strong>另外当垃圾回收机制运行期间，我们需要在一个可收集的container对象的PyGC_Head部分和PyObject_HEAD部分之间来回切换。更清楚的说，某些时候，我们持有一个对象A的PyObject_HEAD的地址，但是我们需要根据这个地址来获得PyGC_Head的地址；而且某些时候，我们又需要反过来进行逆运算。而Python提供了两个地址之间的转换算法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AS_GC(o) ((PyGC_Head *)(o)-1)<span class="comment">//根据PyObject_HEAD得到PyGC_Head</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))<span class="comment">//根据PyGC_Head得到PyObject_HEAD</span></span></span><br></pre></td></tr></table></figure>

<p><strong>我们在PyGC_Head中，出现了用于建立链表的两个指针，只有将创建的可收集container对象链接到Python内部维护的可收集对象链表中，Python的垃圾回收机制才能跟踪和处理这个container对象。但是我们发现，在创建可收集container对象之时，并没有立刻将这个对象链入到链表中。实际上，这个动作是发生在创建某个container对象最后一步，以PyListObject的创建举例。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyList_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    <span class="comment">//创建PyListObject对象、并设置完属性之后，返回之前</span></span><br><span class="line">    <span class="comment">//通过这一步_PyObject_GC_TRACK将所创建的container对象链接到了python中的可收集对象链表中</span></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/internal/pycore_object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_GC_TRACK(op) \</span></span><br><span class="line"><span class="meta">    _PyObject_GC_TRACK_impl(__FILE__, __LINE__, _PyObject_CAST(op))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _PyObject_GC_UNTRACK_impl(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> lineno,</span><br><span class="line">                                             PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    _PyObject_ASSERT_FROM(op, _PyObject_GC_IS_TRACKED(op),</span><br><span class="line">                          <span class="string">&quot;object not tracked by the garbage collector&quot;</span>,</span><br><span class="line">                          filename, lineno, <span class="string">&quot;_PyObject_GC_UNTRACK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PyGC_Head *gc = _Py_AS_GC(op);</span><br><span class="line">    PyGC_Head *prev = _PyGCHead_PREV(gc);</span><br><span class="line">    PyGC_Head *next = _PyGCHead_NEXT(gc);</span><br><span class="line">    _PyGCHead_SET_NEXT(prev, next);</span><br><span class="line">    _PyGCHead_SET_PREV(next, prev);</span><br><span class="line">    gc-&gt;_gc_next = <span class="number">0</span>;</span><br><span class="line">    gc-&gt;_gc_prev &amp;= _PyGC_PREV_MASK_FINALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前面我们说过，Python会将自己的垃圾回收机制限制在其维护的可收集对象链表上，因为所有的循环引用一定是发生这个链表的一群对象之间。在<code>_PyObject_GC_TRACK</code>之后，我们创建的container对象也就置身于Python垃圾回收机制的掌控机制当中了。</strong></p>
<p><strong>同样的，Python还提供将一个container对象从链表中摘除的方法，显然这个方法应该会在对象被销毁的时候调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/internal/pycore_object.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_GC_UNTRACK(op) \</span></span><br><span class="line"><span class="meta">    _PyObject_GC_UNTRACK_impl(__FILE__, __LINE__, _PyObject_CAST(op))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _PyObject_GC_UNTRACK_impl(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> lineno,</span><br><span class="line">                                             PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    _PyObject_ASSERT_FROM(op, _PyObject_GC_IS_TRACKED(op),</span><br><span class="line">                          <span class="string">&quot;object not tracked by the garbage collector&quot;</span>,</span><br><span class="line">                          filename, lineno, <span class="string">&quot;_PyObject_GC_UNTRACK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PyGC_Head *gc = _Py_AS_GC(op);</span><br><span class="line">    PyGC_Head *prev = _PyGCHead_PREV(gc);</span><br><span class="line">    PyGC_Head *next = _PyGCHead_NEXT(gc);</span><br><span class="line">    _PyGCHead_SET_NEXT(prev, next);</span><br><span class="line">    _PyGCHead_SET_PREV(next, prev);</span><br><span class="line">    gc-&gt;_gc_next = <span class="number">0</span>;</span><br><span class="line">    gc-&gt;_gc_prev &amp;= _PyGC_PREV_MASK_FINALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>很明显，<code>_PyObject_GC_UNTRACK</code>只是<code>_PyObject_GC_TRACK</code>的逆运算而已。就这样，借助 *gc_next* 和 *gc_prev* 指针，*Python* 将需要跟踪的对象一个接一个组织成双向链表。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235304762-358893665.png" alt="img"></p>
<h4 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h4><p><strong>无论什么语言，写出来的程序都有共同之处，那就是不同对象的声明周期会存在不同。有的对象所占的内存块的生命周期很短，而有的内存块的生命周期则很长，甚至可能从程序的开始持续到程序结束，这两者的比例大概在80~90%。</strong></p>
<p><strong>这对于垃圾回收机制有着重要的意义，因为我们已经知道，像标记–清除这样的垃圾回收机制所带来的额外操作实际上是和系统中内存块的数量相关，当需要回收的内存块越多的时候，垃圾检测带来的额外操作就越多，相反则越少。因此我们可以采用一种空间换时间的策略，因为目前所有对象都在一个链子上，每当进行垃圾回收机制的时候，都要把所有对象都检查一遍。而其实也有不少比较稳定的对象<code>(在多次垃圾回收的洗礼下能活下来)</code>，我们完全没有必要每次都检查，或者说检查的频率可以降低一些。于是聪明如你已经猜到了，我们再来一根链子不就可以了，把那些认为比较稳定的对象移到另外一条链子上，而新的链子进行垃圾回收的频率会低一些，总之频率不会像初始的链子那么高。</strong></p>
<p><strong>所以这种思想就是：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就称为一个”代”，垃圾回收的频率随着”代”的存活时间的增大而减小。也就是说，存活的越长的对象就越可能不是垃圾，就越可能是程序中需要一直存在的对象，就应该少去检测它。反正不是垃圾，你检测也是白检测。那么关键的问题来了，这个存活时间是如何被衡量的呢？或者我们说当对象比较稳定的时候的这个稳定是如何衡量的呢？没错，我们上面已经暴露了，就是通过经历了几次垃圾回收动作来评判，如果一个对象经历的垃圾回收次数越多，那么显然其存活时间就越长。因为Python的垃圾回收器，每当条件满足时<code>(至于什么条件我们后面会说)</code>，就会进行一次垃圾回收<code>(注意：不同的代的垃圾回收的频率是不同的)</code>，而每次扫黄的时候你都不在，吭，每次垃圾回收的时候你都能活下来，这就说明你存活的时间更长，或者像我们上面说的更稳定，那么就不应该再把你放在这个链子上了，而是会移动到新的链子上。而在新的链子上，进行垃圾回收的频率会降低，因为既然稳定了，检测就不必那么频繁了，或者说新的链子上触发垃圾回收所需要的时间更长了。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235311117-969693744.png" alt="img"></p>
<p><strong>“代”似乎是一个比较抽象的概念，但在Python中，你就把”代”想象成多个对象组成的集合，或者你把”代”想象成链表也可以，因为这些对象都串在链表上面。而属于同一”代”的内存块都被链接在同一个链表中。而在Python中总共存在三条链表，说明Python中所有的对象总共可以分为三代：零代、一代、二代。一个”代”就是一条我们上面提到的可收集对象链表。而在前面所介绍的链表的基础之上，为了支持分代机制，我们需要的仅仅是一个额外的表头而已。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/internal/mem.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_GENERATIONS 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gc_generation</span> &#123;</span></span><br><span class="line">    PyGC_Head head;</span><br><span class="line">    <span class="type">int</span> threshold; <span class="comment">//阈值, 触发垃圾回收的条件, 这个值默认是700, 具体含义后面说</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">//该链表中对象的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GEN_HEAD(n) GEN_HEAD(state, n)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gc_generation</span> <span class="title">generations</span>[<span class="title">NUM_GENERATIONS</span>] =</span> &#123;</span><br><span class="line">        <span class="comment">/* PyGC_Head,                                    threshold,    count */</span></span><br><span class="line">        &#123;&#123;(<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">0</span>), (<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">0</span>)&#125;,   <span class="number">700</span>,        <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;&#123;(<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">1</span>), (<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">1</span>)&#125;,   <span class="number">10</span>,         <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;&#123;(<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">2</span>), (<span class="type">uintptr_t</span>)_GEN_HEAD(<span class="number">2</span>)&#125;,   <span class="number">10</span>,         <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_GENERATIONS; i++) &#123;</span><br><span class="line">        state-&gt;generations[i] = generations[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    state-&gt;generation0 = GEN_HEAD(state, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gc_generation</span> <span class="title">permanent_generation</span> =</span> &#123;</span><br><span class="line">          &#123;(<span class="type">uintptr_t</span>)&amp;state-&gt;permanent_generation.head,</span><br><span class="line">           (<span class="type">uintptr_t</span>)&amp;state-&gt;permanent_generation.head&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    state-&gt;permanent_generation = permanent_generation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面这个维护了三个gc_generation结构体的数组，控制了三条可收集对象链表，这就是Python中用于分代垃圾收集的三个”代”。</strong></p>
<p><strong>对于每一个gc_generation，其中的count记录了当前这条可收集对象链表中一共有多少个container对象。而在_PyObject_GC_Alloc中我们可以看到每当分配了内存，就会进行<code>_PyRuntime.gc.generations[0].count++</code>动作，将第0代链表中所维护的内存块数量加1，这预示着所有新创建的container对象实际上都会被加入到0代链表当中，而这一点也确实如此，已经被_PyObject_GC_TRACK证明了。</strong></p>
<p><strong>当三个”代”初始化完毕之后，对应的gc_generation数据大概是这样的。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235316847-1172293069.png" alt="img"></p>
<p><strong>而gc_generation中的threshold则记录该条可收集对象链表中最多可以容纳多少个可收集对象，从Python的实现代码中，我们知道第0代链表中最多可以容纳700个对象<code>(只可能是container对象)</code>。而一旦第0代链表中的container对象超过了700个这个阈值，那么会立刻触发垃圾回收机制。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">collect_generations</span><span class="params">(<span class="keyword">struct</span> _gc_runtime_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = NUM_GENERATIONS<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//当count大于threshold的时候，但是这个仅仅针对于0代链表</span></span><br><span class="line">        <span class="keyword">if</span> (state-&gt;generations[i].count &gt; state-&gt;generations[i].threshold) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == NUM_GENERATIONS - <span class="number">1</span></span><br><span class="line">                &amp;&amp; state-&gt;long_lived_pending &lt; state-&gt;long_lived_total / <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            n = collect_with_callback(state, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里面虽然写了一个for循环，但是只有当第0代链表的count超过了threshold的时候才会触发垃圾回收，那么1代链表和2代链表触发垃圾回收的条件又是什么呢？当0代链表触发了10次垃圾回收的时候，会触发一次1代链表的垃圾回收。当1代链表触发了10次垃圾回收的时候，会触发一次2代链表的垃圾回收。而一旦经过垃圾回收，那么threshold和count变会重置为初始状态。另外：</strong></p>
<ul>
<li><code>在清理1代链表的时候，会顺带清理0代链表</code></li>
<li><code>在清理2代链表的时候，会顺带清理0代链表和1代链表</code></li>
</ul>
<h4 id="Python中的标记–清除"><a href="#Python中的标记–清除" class="headerlink" title="Python中的标记–清除"></a>Python中的标记–清除</h4><p><strong>我们上面说到，当清理1代链表会顺带清理0代链表，总是就是把比自己”代”小的链子也清理了。那么这是怎么做到的呢？其实答案就在<code>gc_list_merge</code>函数中，如果清理的是1代链表，那么在开始垃圾回收之前，Python会将0代链表<code>(比它年轻的)</code>，整个链接到1代链表之后，这样的话在清理1代的时候也会清理0代。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">gc_list_merge</span><span class="params">(PyGC_Head *from, PyGC_Head *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(from != to);</span><br><span class="line">    <span class="keyword">if</span> (!gc_list_is_empty(from)) &#123;</span><br><span class="line">        PyGC_Head *to_tail = GC_PREV(to);</span><br><span class="line">        PyGC_Head *from_head = GC_NEXT(from);</span><br><span class="line">        PyGC_Head *from_tail = GC_PREV(from);</span><br><span class="line">        assert(from_head != from);</span><br><span class="line">        assert(from_tail != from);</span><br><span class="line"></span><br><span class="line">        _PyGCHead_SET_NEXT(to_tail, from_head);</span><br><span class="line">        _PyGCHead_SET_PREV(from_head, to_tail);</span><br><span class="line"></span><br><span class="line">        _PyGCHead_SET_NEXT(from_tail, to);</span><br><span class="line">        _PyGCHead_SET_PREV(to, from_tail);</span><br><span class="line">    &#125;</span><br><span class="line">    gc_list_init(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以我们举的例子来说的话，那么这里的from就是0代链表，to就是1代链表，所以此后的标记–清除算法就将在merge之后的那一条链表上进行。</strong></p>
<p><strong>在介绍Python中的标记–清除垃圾回收方法之前，我们需要建立一个循环引用的最简单例子。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line"></span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里多了一个外部引用</span></span><br><span class="line">a = list1</span><br><span class="line"></span><br><span class="line">list3 = []</span><br><span class="line">list4 = []</span><br><span class="line">list3.append(list4)</span><br><span class="line">list4.append(list3)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235325462-1737182587.png" alt="img"></p>
<p><strong>上面的数字指的是当前对象的引用计数<code>ob_refcnt</code>的值。</strong></p>
<h5 id="寻找root-object集合"><a href="#寻找root-object集合" class="headerlink" title="寻找root object集合"></a>寻找root object集合</h5><p><strong>为了使用标记–清除算法，按照我们之前对垃圾收集算法的一般性描述，首先我们需要找到root object，那么在我们上面的那幅图中，哪些是属于root object呢？</strong></p>
<p><strong>让我们换个角度来思考，前面提到，root  object是不能被删除的对象。也就是说，在可收集对象链表的外部存在着某个引用在引用这个对象，删除这个对象会导致错误的行为，那么在我们当前这个例子中只有list1是属于root object的。但这仅仅是观察的结果，那么如何设计一种算法来得到这个结果呢？</strong></p>
<p><strong>我们注意到这样一个事实，如果两个对象的引用计数都为1，但是仅仅它们之间存在着循环引用，那么这两个对象是需要被回收的，也就是说，尽管它们的引用计数表现为非0，但是实际上有效的引用计数为0。这里，我们提出了有效引用计数的概念，为了从引用计数中获得有效的引用计数，必须将循环引用的影响消除，也就是说，将这个闭环从引用中摘除，而具体的实现就是两个对象各自的引用值都减去1。这样一来，两个对象的引用计数都成为了0，这样我们便挥去了循环引用的迷雾，是有效引用计数出现了真身。那么如何使两个对象的引用计数都减1呢，很简单，假设这两个对象为A和B，那么从A出发，由于它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，发现它有一个对A的引用，那么同样会将A的引用减1，这样就完成了循环引用对象间环的删除。</strong></p>
<blockquote>
<p><strong>总结一下就是，python会寻找那些具有循环引用的、但是没有被外部引用的对象，并尝试把它们的引用计数都减去1。</strong></p>
</blockquote>
<p><strong>但是这样就引出了一个问题，假设可收集对象链表中的container对象A有一个对对象C的引用，而C并不在这个链表中，如果将C的引用计数减去1，而最后A并没有被回收，那么显然，C的引用计数被错误地减少1，这将导致未来的某个时刻对C的引用会出现悬空。这就要求我们必须在A没有被删除的情况下恢复C的引用计数，可是如果采用这样的方案的话，那么维护引用计数的复杂度将成倍增长。换一个角度，其实我们有更好的做法，我们不改动真实的引用计数，而是改动引用计数的副本。对于副本，我们无论做什么样的改动，都不会影响对象生命周期的维护，因为这个副本的唯一作用就是寻找root  object集合，而这个副本就是PyGC_Head中的gc.gc_ref。在垃圾回收的第一步，就是遍历可收集对象链表，将每个对象的gc.gc_ref的值设置为其ob_refcnt的值。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">update_refs</span><span class="params">(PyGC_Head *containers)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *gc = GC_NEXT(containers);</span><br><span class="line">    <span class="keyword">for</span> (; gc != containers; gc = GC_NEXT(gc)) &#123;</span><br><span class="line">        gc_reset_refs(gc, Py_REFCNT(FROM_GC(gc)));</span><br><span class="line">        _PyObject_ASSERT(FROM_GC(gc), gc_get_refs(gc) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而接下来的动作就是要将环引用从引用中摘除</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">subtract_refs</span><span class="params">(PyGC_Head *containers)</span></span><br><span class="line">&#123;</span><br><span class="line">    traverseproc traverse;</span><br><span class="line">    PyGC_Head *gc = GC_NEXT(containers);</span><br><span class="line">    <span class="comment">// 遍历链表每一个对象</span></span><br><span class="line">    <span class="keyword">for</span> (; gc != containers; gc = GC_NEXT(gc)) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前对象所引用的对象，调用visit_decref将它们的引用计数减一</span></span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line">        traverse = Py_TYPE(op)-&gt;tp_traverse;</span><br><span class="line">        (<span class="type">void</span>) traverse(FROM_GC(gc),</span><br><span class="line">                       (visitproc)visit_decref,</span><br><span class="line">                       op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到里面有一个traverse，这个是和特定的container  对象有关的，在container对象的类型对象中定义。一般来说，traverse的动作就是遍历container对象中的每一个引用，然后对引用进行某种动作，而这个动作在subtract_refs中就是visit_decref，它以一个回调函数的形式传递到traverse操作中。比如：我们来看看PyListObject对象所定义traverse操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Includeobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*visitproc)</span><span class="params">(PyObject *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*traverseproc)</span><span class="params">(PyObject *, visitproc, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/listobject.c</span></span><br><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    ...</span><br><span class="line">    (traverseproc)list_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_traverse</span><span class="params">(PyListObject *o, visitproc visit, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = Py_SIZE(o); --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        <span class="comment">//对列表中的每一个元素都进行回调的操作</span></span><br><span class="line">        Py_VISIT(o-&gt;ob_item[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">visit_decref</span><span class="params">(PyObject *op, <span class="type">void</span> *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyObject_ASSERT(_PyObject_CAST(parent), !_PyObject_IsFreed(op));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//PyObject_IS_GC判断op指向的对象是不是被垃圾收集监控的</span></span><br><span class="line">    <span class="keyword">if</span> (PyObject_IS_GC(op)) &#123;</span><br><span class="line">        <span class="comment">//获取container对象PyGC_Head</span></span><br><span class="line">        PyGC_Head *gc = AS_GC(op);</span><br><span class="line">        <span class="keyword">if</span> (gc_is_collecting(gc)) &#123;</span><br><span class="line">            <span class="comment">//减少引用计数</span></span><br><span class="line">            gc_decref(gc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在完成了subtract_refs之后，可收集对象链表中所有container对象之间的环引用就被摘除了。这时有一些container对象的<code>PyGC_Head.gc_ref</code>还不为0，这就意味着存在对这些对象的外部引用，这些对象就是开始标记–清除算法的root object。</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235334247-477657936.png" alt="img"></p>
<p><strong>举个栗子：</strong></p>
<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235338000-648413294.png" alt="img"></p>
<p><strong>由于sys.getrefcount函数本身会多一个引用，所以减去1的话，那么都是3。表示它们指向的对象的引用计数为3。所以这个时候a就想到了，除了我，还有两位老铁<code>(list1、list2[0])</code>指向了我指向的内存。</strong></p>
<h5 id="垃圾标记"><a href="#垃圾标记" class="headerlink" title="垃圾标记"></a>垃圾标记</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line"></span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里多了一个外部引用</span></span><br><span class="line">a = list1</span><br><span class="line"></span><br><span class="line">list3 = []</span><br><span class="line">list4 = []</span><br><span class="line">list3.append(list4)</span><br><span class="line">list4.append(list3)</span><br></pre></td></tr></table></figure>

<p><strong>还是以上面为例，假设我们现在执行了删除操作<code>del list1, list2, list3, list4</code>，那么成功地寻找到root object集合之后，我们就可以从root object触发，沿着引用链，一个接一个地标记不能回收的内存。由于root  object集合中的对象是不能回收的，因此，被这些对象直接或间接引用的对象也是不能回收的，比如这里的list2，即便del  list2，但是因为list1不能回收，而又append了list2，所以list2指向的内存也是不可以释放的。下面在从root  object出发前，我们首先需要将现在的内存链表一分为二，一条链表维护root  object集合，成为root链表，而另一条链表中维护剩下的对象，成为unreachable链表。之所以要分解成两个链表，是出于这样一种考虑：显然，现在的unreachable链表是名不副实的，因为里面可能存在被root链表中的对象直接或者间接引用的对象，这些对象也是不可以回收的，因此一旦在标记中发现了这样的对象，那么就应该将其从unreachable中移到root链表中；当完成标记之后，unreachable链表中剩下的对象就是名副其实的垃圾对象了，那么接下来的垃圾回收只需要限制在unreachable链表中即可。</strong></p>
<p><strong>为此Python专门准备了一条名为unreachable的链表，通过move_unreachable函数完成了对原始链表的切分。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">move_unreachable</span><span class="params">(PyGC_Head *young, PyGC_Head *unreachable)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *prev = young;</span><br><span class="line">    PyGC_Head *gc = GC_NEXT(young);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 遍历链表每个对象</span></span><br><span class="line">    <span class="keyword">while</span> (gc != young) &#123;</span><br><span class="line">        <span class="comment">//如果是root object</span></span><br><span class="line">        <span class="keyword">if</span> (gc_get_refs(gc)) &#123;</span><br><span class="line">            PyObject *op = FROM_GC(gc);</span><br><span class="line">            traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;</span><br><span class="line">            <span class="comment">// 将它标记为可达</span></span><br><span class="line">            _PyObject_ASSERT_WITH_MSG(op, gc_get_refs(gc) &gt; <span class="number">0</span>,</span><br><span class="line">                                      <span class="string">&quot;refcount is too small&quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历被它引用的对象，调用visit_reachable将被引用对象标记为可达</span></span><br><span class="line">            (<span class="type">void</span>) traverse(op,</span><br><span class="line">                    (visitproc)visit_reachable,</span><br><span class="line">                    (<span class="type">void</span> *)young);</span><br><span class="line">            _PyGCHead_SET_PREV(gc, prev);</span><br><span class="line">            gc_clear_collecting(gc);</span><br><span class="line">            prev = gc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//对于非root object，移到unreachable链表中</span></span><br><span class="line">            prev-&gt;_gc_next = gc-&gt;_gc_next;</span><br><span class="line">            PyGC_Head *last = GC_PREV(unreachable);</span><br><span class="line">            last-&gt;_gc_next = (NEXT_MASK_UNREACHABLE | (<span class="type">uintptr_t</span>)gc);</span><br><span class="line">            _PyGCHead_SET_PREV(gc, last);</span><br><span class="line">            gc-&gt;_gc_next = (NEXT_MASK_UNREACHABLE | (<span class="type">uintptr_t</span>)unreachable);</span><br><span class="line">            unreachable-&gt;_gc_prev = (<span class="type">uintptr_t</span>)gc;</span><br><span class="line">        &#125;</span><br><span class="line">        gc = (PyGC_Head*)prev-&gt;_gc_next;</span><br><span class="line">    &#125;</span><br><span class="line">    young-&gt;_gc_prev = (<span class="type">uintptr_t</span>)prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果一个对象可达，*Python* 还通过 *tp_traverse* 逐个遍历它引用的对象，并调用 *visit_reachable* 函数进行标记：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">visit_reachable</span><span class="params">(PyObject *op, PyGC_Head *reachable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyObject_IS_GC(op)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyGC_Head *gc = AS_GC(op);</span><br><span class="line">    <span class="type">const</span> Py_ssize_t gc_refs = gc_get_refs(gc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略掉1代和2代、以及没有被gc跟踪的对象</span></span><br><span class="line">    <span class="keyword">if</span> (gc-&gt;_gc_next == <span class="number">0</span> || !gc_is_collecting(gc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gc-&gt;_gc_next &amp; NEXT_MASK_UNREACHABLE) &#123;</span><br><span class="line">        <span class="comment">//对于已经被挪到unreachable链表中的对象，将其再次挪动到原来的链表</span></span><br><span class="line">        PyGC_Head *prev = GC_PREV(gc);</span><br><span class="line">        PyGC_Head *next = (PyGC_Head*)(gc-&gt;_gc_next &amp; ~NEXT_MASK_UNREACHABLE);</span><br><span class="line">        _PyObject_ASSERT(FROM_GC(prev),</span><br><span class="line">                         prev-&gt;_gc_next &amp; NEXT_MASK_UNREACHABLE);</span><br><span class="line">        _PyObject_ASSERT(FROM_GC(next),</span><br><span class="line">                         next-&gt;_gc_next &amp; NEXT_MASK_UNREACHABLE);</span><br><span class="line">        prev-&gt;_gc_next = gc-&gt;_gc_next;  <span class="comment">// copy NEXT_MASK_UNREACHABLE</span></span><br><span class="line">        _PyGCHead_SET_PREV(next, prev);</span><br><span class="line"></span><br><span class="line">        gc_list_append(gc, reachable);</span><br><span class="line">        gc_set_refs(gc, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gc_refs == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//对于还没有处理的对象，恢复其gc_refs</span></span><br><span class="line">        gc_set_refs(gc, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _PyObject_ASSERT_WITH_MSG(op, gc_refs &gt; <span class="number">0</span>, <span class="string">&quot;refcount is too small&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下就是：如果被引用的对象引用计数为 *0* ，将它的引用计数设为 *1* ，之后它将被 *move_unreachable* 遍历到并设为可达；如果被引用的对象被临时移入 *unreachable* 链表，同样将它的引用计数设为 *1* ，并从 *unreachable* 链表移回原链表尾部，之后它将被 *move_unreachable* 遍历到并设为可达。</strong></p>
<p><strong>当 *move_unreachable* 完成之后，最初的一条链表就被切分成了两条链表，在 *unreachable* 链表中，就是我们发现的垃圾对象，是垃圾回收的目标。但是等一等，在 *unreachable* 链表中，所有的对象都可以安全回收吗？其实，垃圾回收在清理对象的时候，默认是会清理的，但是一旦当我们定义了函数<code>__del__</code>，那么在清理对象的时候就会调用这个<code>__del__</code>方法，因此也叫析构函数，这是Python为开发人员提供的在对象被销毁时进行某些资源释放的Hook机制。在Python3中，即使我们重写了也没事，因为Python会把含有<code>__del__</code>函数的 *PyInstanceObject* 对象都统统移动到一个名为garbage的 *PyListObject* 对象中。</strong></p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p><strong>要回收unreachable链表中的垃圾对象，就必须先打破对象间的循环引用，前面我们已经阐述了如何打破循环引用的办法，下面来看看具体的销毁过程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/gcmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">gc_list_is_empty</span><span class="params">(PyGC_Head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">list</span>-&gt;_gc_next == (<span class="type">uintptr_t</span>)<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">delete_garbage</span><span class="params">(<span class="keyword">struct</span> _gc_runtime_state *state,</span></span><br><span class="line"><span class="params">               PyGC_Head *collectable, PyGC_Head *old)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!PyErr_Occurred());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!gc_list_is_empty(collectable)) &#123;</span><br><span class="line">        PyGC_Head *gc = GC_NEXT(collectable);</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line"></span><br><span class="line">        _PyObject_ASSERT_WITH_MSG(op, Py_REFCNT(op) &gt; <span class="number">0</span>,</span><br><span class="line">                                  <span class="string">&quot;refcount is too small&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state-&gt;debug &amp; DEBUG_SAVEALL) &#123;</span><br><span class="line">            assert(state-&gt;garbage != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (PyList_Append(state-&gt;garbage, op) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                PyErr_Clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            inquiry clear;</span><br><span class="line">            <span class="keyword">if</span> ((clear = Py_TYPE(op)-&gt;tp_clear) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_INCREF(op);</span><br><span class="line">                (<span class="type">void</span>) clear(op);</span><br><span class="line">                <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                    _PyErr_WriteUnraisableMsg(<span class="string">&quot;in tp_clear of&quot;</span>,</span><br><span class="line">                                              (PyObject*)Py_TYPE(op));</span><br><span class="line">                &#125;</span><br><span class="line">                Py_DECREF(op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GC_NEXT(collectable) == gc) &#123;</span><br><span class="line">            <span class="comment">/* object is still alive, move it, it may die later */</span></span><br><span class="line">            gc_list_move(gc, old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中会调用container对象的类型对象中的tp_clear操作，这个操作会调整container对象中引用的对象的引用计数值，从而打破完成循环的最终目标。还是以PyListObject为例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_list_clear(PyListObject *a)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject **item = a-&gt;ob_item;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(a);</span><br><span class="line">        <span class="comment">//将ob_size调整为0</span></span><br><span class="line">        Py_SIZE(a) = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//ob_item是一个二级指针，本来指向一个数组的指针</span></span><br><span class="line">        <span class="comment">//现在指向为NULL</span></span><br><span class="line">        a-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//容量也设置为0</span></span><br><span class="line">        a-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//数组里面元素也全部减少引用计数</span></span><br><span class="line">            Py_XDECREF(item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放数组</span></span><br><span class="line">        PyMem_FREE(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到，在delete_garbage中，有一些unreachable链表中的对象会被重新送回到reachable链表<code>(即delete_garbage的old参数)</code>中，这是由于进行clear动作时，如果成功进行，通常一个对象会把自己从垃圾回收机制维护的链表中摘除<code>(也就是这里的collectable链表)</code>。由于某些原因，对象可能在clear动作时，没有成功完成必要的动作，从而没有将自己从collectable链表摘除，这表示对象认为自己还不能被销毁，所以Python需要讲这种对象放回到reachable链表中。</strong></p>
<p><strong>然后我们知道当对象被销毁时，肯定要调用析构函数，我们在上面看到了_list_clear，假设是调用了list3的_list_clear，那么不好意思，接下来是要调用list4的析构函数。因为list3和list4存在循环引用，所以调用了list3的_list_clear会减少list4的引用计数。由于这两位老铁都被删除了，还惺惺相惜赖在内存里面不走，所以将list4的引用计数减少1之后，只能归于湮灭了，然后会调用其list_dealloc，注意：这时候调用的是list4的list_dealloc。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listobjct.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_dealloc</span><span class="params">(PyListObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//从可收集链表中移除</span></span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_BEGIN(op)</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//依次遍历，减少内部元素的引用计数</span></span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲池机制</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道调用list3的_list_clear，减少内部元素引用计数的时候，导致list4引用计数为0。而一旦list4的引用计数为0，那么是不是也要执行和list3一样的_list_clear动作呢？然后会发现list3的引用计数也为0了，因此list3也会被销毁。循环引用，彼此共生，销毁之路，怎能独自前行？最终list3和list4都会执行内部的list_dealloc，释放内部元素，调整参数，当然还有所谓的缓冲池机制等等。总之如此一来，list3和list4就都被安全地回收了，准确的说是指向的对象被回收了。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>虽然有很多对象挂在垃圾收集机制监控的链表上，但是很多时候是引用计数在维护这些对象，只有引用计数无能为力的循环引用，垃圾收集机制才会起到作用。这里没有把引用计数看成垃圾回收，当然如果别人问你Python的垃圾回收机制的时候，你也可以把引用计数机制加上。事实上，如果不是循环引用的话，那么垃圾回收是不会出马的，因为挂在垃圾回收机制上的对象都是引用计数不为0的，如果为0早被引用计数机制干掉了。而引用计数不为0的情况只有两种：一种是被程序使用的对象，二是循环引用中的对象。被程序使用的对象是不能被回收的，所以垃圾回收只能处理那些循环引用的对象。</strong></p>
<blockquote>
<p><strong>所以python的垃圾回收就是：引用计数为主，分代回收为辅，两者结合使用，后者主要是为了弥补前者的缺点而存在的。</strong></p>
</blockquote>
<h3 id="python中的gc模块"><a href="#python中的gc模块" class="headerlink" title="python中的gc模块"></a>python中的gc模块</h3><p><strong>这个gc模块，底层就是gcmodule，我们说这些模块底层是用c写的，当python编译好时，就内嵌在解释器里面了。我们可以导入它，但是在Python安装目录上看不到。</strong></p>
<p><strong>gc.enable：开启垃圾回收</strong></p>
<p><strong>这个函数表示开启垃圾回收机制，默认是自动开启的。</strong></p>
<p><strong>gc.disable：关闭垃圾回收</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉gc</span></span><br><span class="line">gc.disable()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a1 = A()</span><br><span class="line">    a2 = A()</span><br><span class="line">    <span class="comment"># 此时内部出现了循环引用</span></span><br><span class="line">    a1.__dict__[<span class="string">&quot;attr&quot;</span>] = a2</span><br><span class="line">    a2.__dict__[<span class="string">&quot;attr&quot;</span>] = a1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由于循环引用，此时是del a1, a2，光靠引用计数是删不掉的</span></span><br><span class="line">    <span class="comment"># 需要垃圾回收，但是我们给关闭了</span></span><br><span class="line">    <span class="keyword">del</span> a1, a2</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235354251-564121521.png" alt="img"></p>
<p><strong>无限循环，并且每次循环都会创建新的对象，最终导致内存无限增大。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉gc</span></span><br><span class="line">gc.disable()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a1 = A()</span><br><span class="line">    a2 = A()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1229382-20200919235358278-1038967713.png" alt="img"></p>
<p><strong>这里即使我们关闭了gc，但是每一次循环都会指向一个新的对象，而之前的对象由于没有人指向了，那么引用计数为0，直接就被引用计数机制干掉了，内存会一直稳定，不会出现增长。所以我们看到，即使关闭了gc，但是对于那些引用计数为0的，该删除还是会删除的。所以引用计数很简单，就是按照对应的规则该加1加1，该减1减1，一旦为0直接销毁。而当出现循环引用的时候，才需要gc闪亮登场。这里关闭了gc，但是没有循环引用所以没事，而上一个例子，关闭了gc，但是出现了循环引用，而引用计数机制只会根据引用计数来判断，而发现引用计数不为0，所以就一直傻傻地不回收，程序又一直创建新的对象，最终导致内存越用越多。而上一个例子若是开启了gc，那么分代回收技术，就会通过标记–清除的方式将产生循环引用的对象的引用计数减1，而引用计数机制发现引用计数为0了，那么就会将对象回收掉。所以这个引用计数机制到底算不算垃圾回收机制的一种呢？你要说算吧，我把gc关闭了，引用计数机制还可以发挥作用，你要说不算吧，它确实是负责判定对象是否应该被回收的唯一标准，所以该怎么说就具体看情况吧。</strong></p>
<p><strong>gc.isenabled()：判断gc是否开启</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gc.isenabled())  <span class="comment"># True</span></span><br><span class="line">gc.disable() </span><br><span class="line"><span class="built_in">print</span>(gc.isenabled())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.collect()：立刻触发垃圾回收</strong></p>
<p><strong>我们说，垃圾回收触发是需要条件的，比如0代链表，清理零代链表的时候，需要对象的个数count大于阈值threshold<code>(默认是700)</code>，但是这个函数可以强制触发垃圾回收。</strong></p>
<p><strong>gc.get_threshold()：返回每一代的阈值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gc.get_threshold())  <span class="comment"># (700, 10, 10)</span></span><br><span class="line"><span class="comment"># 700：零代链表的对象超过700个，触发垃圾回收</span></span><br><span class="line"><span class="comment"># 10：零代链表，垃圾回收10次，会清理一代链表</span></span><br><span class="line"><span class="comment"># 10：一代链表，垃圾回收10次，会清理二代链表</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.set_threshold()：设置每一代的阈值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.set_threshold(<span class="number">1000</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(gc.get_threshold())  <span class="comment"># (1000, 100, 100)</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.get_count()：查看每一代的值达到了多少</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gc.get_count())  <span class="comment"># (44, 7, 5)</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.get_stats()：返回每一代的具体信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pprint(gc.get_stats())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#123;&#x27;collected&#x27;: 316, &#x27;collections&#x27;: 62, &#x27;uncollectable&#x27;: 0&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;collected&#x27;: 538, &#x27;collections&#x27;: 5, &#x27;uncollectable&#x27;: 0&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;collected&#x27;: 0, &#x27;collections&#x27;: 0, &#x27;uncollectable&#x27;: 0&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.get_objects()：返回被垃圾回收器追踪的所有对象，一个列表</strong></p>
<p><strong>gc.is_tracked(obj)：查看对象obj是否被垃圾收集器追踪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gc.is_tracked(a))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(gc.is_tracked(b))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说只有那些可能会产生循环引用的对象才会被垃圾回收器跟踪</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.get_referrers(obj)：回所有引用了obj的对象</strong></p>
<p><strong>gc.get_referents(obj)：返回所有被obj引用了的对象</strong></p>
<p><strong>gc.freeze()：冻结所有被垃圾回收器跟踪的对象并在以后的垃圾回收中不被处理</strong></p>
<p><strong>gc.unfreeze()：取消所有冻结的对象，让它们继续参数垃圾回收</strong></p>
<p><strong>gc.get_freeze_count()：获取冻结的对象个数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要参数，会自动找到被垃圾回收器跟踪的对象</span></span><br><span class="line">gc.freeze()</span><br><span class="line"><span class="comment"># 说明有很多内置对象在被跟踪，被我们冻结了</span></span><br><span class="line"><span class="built_in">print</span>(gc.get_freeze_count())  <span class="comment"># 24397</span></span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line">gc.freeze()</span><br><span class="line"><span class="comment"># 只要这里比上面多1个就行</span></span><br><span class="line"><span class="built_in">print</span>(gc.get_freeze_count())  <span class="comment"># 24398</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消冻结</span></span><br><span class="line">gc.unfreeze()</span><br><span class="line"><span class="built_in">print</span>(gc.get_freeze_count())  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.get_debug()：获取debug级别</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gc.get_debug())  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p><strong>gc.set_debug()：设置debug级别</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">DEBUG_STATS - 在垃圾收集过程中打印所有统计信息</span></span><br><span class="line"><span class="string">DEBUG_COLLECTABLE - 打印发现的可收集对象</span></span><br><span class="line"><span class="string">DEBUG_UNCOLLECTABLE - 打印unreachable对象(除了uncollectable对象)</span></span><br><span class="line"><span class="string">DEBUG_SAVEALL - 将对象保存到gc.garbage(一个列表)里面，而不是释放它</span></span><br><span class="line"><span class="string">DEBUG_LEAK - 对内存泄漏的程序进行debug (everything but STATS).</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_SAVEALL)</span><br><span class="line"><span class="built_in">print</span>(gc.garbage)  <span class="comment"># []</span></span><br><span class="line">a.b = b</span><br><span class="line">b.a = a</span><br><span class="line"><span class="keyword">del</span> a, b</span><br><span class="line">gc.collect()  <span class="comment"># 强制触发垃圾回收</span></span><br><span class="line"><span class="comment"># 下面都是自动打印的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">gc: collecting generation 2...</span></span><br><span class="line"><span class="string">gc: objects in each generation: 123 3732 20563</span></span><br><span class="line"><span class="string">gc: objects in permanent generation: 0</span></span><br><span class="line"><span class="string">gc: done, 4 unreachable, 0 uncollectable, 0.0000s elapsed</span></span><br><span class="line"><span class="string">gc: collecting generation 2...</span></span><br><span class="line"><span class="string">gc: objects in each generation: 0 0 24249</span></span><br><span class="line"><span class="string">gc: objects in permanent generation: 0</span></span><br><span class="line"><span class="string">gc: done, 0 unreachable, 0 uncollectable, 0.0150s elapsed</span></span><br><span class="line"><span class="string">gc: collecting generation 2...</span></span><br><span class="line"><span class="string">gc: objects in each generation: 525 0 23752</span></span><br><span class="line"><span class="string">gc: objects in permanent generation: 0</span></span><br><span class="line"><span class="string">gc: done, 7062 unreachable, 0 uncollectable, 0.0000s elapsed</span></span><br><span class="line"><span class="string">gc: collecting generation 2...</span></span><br><span class="line"><span class="string">gc: objects in each generation: 0 0 21941</span></span><br><span class="line"><span class="string">gc: objects in permanent generation: 0</span></span><br><span class="line"><span class="string">gc: done, 4572 unreachable, 0 uncollectable, 0.0000s elapsed</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(gc.garbage)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&lt;__main__.A object at 0x0000020CFDB50250&gt;, </span></span><br><span class="line"><span class="string">&lt;__main__.B object at 0x0000020CFDB50340&gt;, </span></span><br><span class="line"><span class="string">&#123;&#x27;b&#x27;: &lt;__main__.B object at 0x0000020CFDB50340&gt;&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: &lt;__main__.A object at 0x0000020CFDB50250&gt;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>尽管Python采用了最经典的<code>(最土的)</code>的引用计数来作为自动内存管理的方案，但是Python采用了多种方式来弥补引用计数的不足，内存池的大量使用，标记–清除<code>(分代技术采用的去除循环引用的引用计数的方式)</code>垃圾收集技术都极大地完善了Python的内存管理<code>(包括申请、回收)</code>机制。尽管引用计数机制需要花费额外的开销来维护引用计数，但是现在这个年代，这点内存算个啥。而且引用计数也有好处，不然早就随着时代的前进而被扫进历史的垃圾堆里面了。首先引用计数真的很方便，很直观，对于很多对象引用计数能够直接解决，不需要什么复杂的操作；另外引用计数将垃圾回收的开销分摊在了整个运行时，这对于Python的响应是有好处的。</strong></p>
<p><strong>当然内存管理和垃圾回收是一门给常精细和繁琐的技术，有兴趣的话各位可以自己大刀阔斧的冲进Python的源码中自由翱翔。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</title>
    <url>/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="27-Python内存管理与垃圾回收-第一部分-：深度剖析Python内存管理架构、内存池的实现原理"><a href="#27-Python内存管理与垃圾回收-第一部分-：深度剖析Python内存管理架构、内存池的实现原理" class="headerlink" title="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理"></a>27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</h3><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>内存管理，对于Python这样的动态语言来说是非常重要的一部分，它在很大程度上决定了Python的执行效率，因为Python在运行中会创建和销毁大量的对象，这些都涉及内存的管理，因此精湛的内存管理技术是确保内存使用效率的关键。</strong></p>
<p><strong>此外，我们知道Python还是一门提供了垃圾回收机制<code>(GC, garbage collection)</code>的语言，可以将开发者从繁琐的手动维护内存的工作中解放出来。</strong></p>
<p><strong>那么下面我们就来分析一下Python中的内存管理和垃圾回收。</strong></p>
<h3 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h3><p><strong>首先Python的内存管理机制是分层次的，我们可以看成是有6层：-2、-1、0、1、2、3。</strong></p>
<ul>
<li><strong>最底层，也就是-2和-1层是由操作系统提供的内存管理接口，因为计算机硬件资源由操作系统负责管理，内存资源也不例外，应用程序通过系统调用向操作系统申请内存。注意：这一层Python是无权干预的。</strong></li>
<li><strong>第0层，C的库函数会将系统调用封装成通用的内存分配器，也就是我们所熟悉的malloc系列函数。注意：这一层Python同样无法干预。</strong></li>
<li><strong>第1、2、3层，由于Python解释器实现并负责维护。</strong></li>
</ul>
<blockquote>
<p><strong>所以我们看到Python的内存管理实际上封装了C的malloc，C的malloc则是封装了系统调用。</strong></p>
</blockquote>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125532129-648009563.png" alt="img"></p>
<p><strong>我们自下而上来简单说一下，首先操作系统内部是一个基于页表的虚拟内存管理器(第-1层)，以”页(page)”为单位管理内存，而CPU内存管理单元(MMU)在这个过程中发挥重要作用。虚拟内存管理器下方则是底层存储设备(第-2层)，直接管理物理内存以及磁盘等二级存储设备。</strong></p>
<blockquote>
<p><strong>所以最后的两层是操作系统的领域，过于底层，不在我们的涉及范围内，简单了解就好。有兴趣的话，可以网上查阅相关资料，看看操作系统是如何管理内存的。</strong></p>
</blockquote>
<p><strong>C库函数实现的”通用目的内存分配器”是一个重要的分水岭，即内存管理层次中的第0层。此层之上是应用程序自己的内存管理，之下则是隐藏在冰山中的操作系统的内存管理。</strong></p>
<p><strong>第1、2、3层则是Python自己的内存管理，总共分为3层，作用如下：</strong></p>
<p><strong>第1层：基于第0层的”通用目的内存分配器”包装而成。</strong></p>
<p><strong>这一层并没有在第0层上加入太多的动作，其目的仅仅是为Python提供一层统一的raw memory的管理接口。这么做的原因就是虽然不同的操作系统都提供了ANSI C标准 所定义的内存管理接口，但是对于某些特殊情况不同操作系统有不同的行为。比如调用<code>malloc(0)</code>，有的操作系统会返回NULL，表示申请失败，但是有的操作系统则会返回一个貌似正常的指针，  但是这个指针指向的内存并不是有效的。为了最广泛的可移植性，Python必须保证相同的语义一定代表着相同的运行时行为，为了处理这些与平台相关的内存分配行为，Python必须要在C的内存分配接口之上再提供一层包装。</strong></p>
<p><strong>在Python中，第一层的实现就是一组以<code>PyMem_</code>为前缀的函数簇，下面来看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/pymem.h</span></span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Malloc(<span class="type">size_t</span> size);</span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Realloc(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size);</span><br><span class="line">PyAPI_FUNC(<span class="type">void</span>) PyMem_Free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">malloc</span>(_PyMem.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (new_size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">realloc</span>(_PyMem.ctx, ptr, new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMem_Free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyMem.<span class="built_in">free</span>(_PyMem.ctx, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在第一层，Python提供了类似于类似于C中malloc、realloc、free的语义。并且我们发现，比如 *PyMem_Malloc* ，如果申请的内存大小超过了 *PY_SSIZE_T_MAX* 直接返回NULL，并且还调用了 *_PyMem.malloc* ，这和C中的malloc几乎没啥区别，但是会对特殊值进行一些处理。到目前为止，仅仅是分配了raw memory而已。当然在第一层，Python还提供了面向对象中类型的内存分配器。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Include/pymem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_New(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \</span></span><br><span class="line"><span class="meta">        ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_NEW(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \</span></span><br><span class="line"><span class="meta">        ( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_Resize(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \</span></span><br><span class="line"><span class="meta">        (type *) PyMem_Realloc((p), (n) * sizeof(type)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_RESIZE(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \</span></span><br><span class="line"><span class="meta">        (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_Del               PyMem_Free</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_DEL               PyMem_FREE</span></span><br></pre></td></tr></table></figure>

<p><strong>很明显，在 *PyMem_Malloc* 中需要程序员自行提供所申请的空间大小。然而在 *PyMem_New* 中，只需要提供类型和数量，Python会自动侦测其所需的内存空间大小。</strong></p>
<p><strong>第2层：在第1层提供的通用 *PyMem_* 接口基础上，实现统一的对象内存分配(object.tp_alloc)</strong></p>
<p><strong>第1层所提供的内存管理接口的功能是非常有限的，如果创建一个PyLongObject对象，还需要做很多额外的工作，比如设置对象的类型参数、初始化对象的引用计数值等等。因此为了简化Python自身的开发，Python在比第1层更高的抽象层次上提供了第2层内存管理接口。在这一层，是一组以<code>PyObject_</code>为前缀的函数簇，主要提供了创建Python对象的接口。这一套函数簇又被称为Pymalloc机制，因此在第2层的内存管理机制上，Python对于一些内建对象构建了更高抽象层次的内存管理策略。</strong></p>
<p><strong>第3层：为特定对象服务</strong></p>
<p><strong>这一层主要是用于对象的缓存机制，比如：小整数对象池，浮点数缓存池等等。</strong></p>
<p><strong>所以Python中GC是隐藏在哪一层呢？不用想，肯定是第二层，也是在Python的内存管理中发挥巨大作用的一层，我们后面也会基于第二层进行剖析。</strong></p>
<h3 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h3><h4 id="为什么要引入内存池"><a href="#为什么要引入内存池" class="headerlink" title="为什么要引入内存池"></a>为什么要引入内存池</h4><p><strong>在Python中，很多时候申请的内存都是小块的内存，这些小块的内存在申请后很快又被释放，并且这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间需要大量地执行底层的malloc和free操作，导致操作系统在用户态和内核态之间进行切换，这将严重影响Python的效率。所以为了提高执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放，这就是之前说的Pymalloc机制，并且提供了<code>pymalloc_alloc</code>，<code>pymalloc_realloc</code>，<code>pymalloc_free</code>三个接口。</strong></p>
<p><strong>而整个小块内存的内存池可以视为一个层次结构，从下至上分别是：block、pool、arena。当然内存池只是一个概念上的东西，表示Python对整个小块内存分配和释放行为的内存管理机制。</strong></p>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p><strong>在最底层，block是一个确定大小的内存块。而Python中，有很多种block，不同种类的block都有不同的内存大小，这个内存大小的值被称之为<code>size class</code>。为了在当前主流的32位平台和64位平台都能获得最佳性能，所有的block的长度都是8字节对齐的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT               8               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，Python为什么要有这么多种类的block呢？为了更好理解这一点，我们需要了解”内存碎片化”这个概念。</strong></p>
<p><strong>“内存碎片化”是困扰经典内存分配器的一大难题，碎片化导致的结果也是惨重的。看一个典型的内存碎片化例子：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125540072-1741043173.png" alt="img"></p>
<p><strong>虽然还有1350K的可用内存，但由于分散在一系列不连续的碎片上，因此连675K、总可用内存的一半都分配不出来。</strong></p>
<p><strong>那么如何避免内存碎片化呢？想要解决问题，就必须先分析导致问题的根源。</strong></p>
<p><strong>我们知道，应用程序请求内存尺寸是不确定的，有大有小；释放内存的时机也是不确定的，有先有后。经典内存分配器将不同尺寸的内存混合管理，按照先来后到的顺序分配：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125545745-2114131433.png" alt="img"></p>
<p><strong>由此可见，将不同尺寸内存块混合管理，将大块内存切分后再次分配的做法是罪魁祸首。</strong></p>
<p><strong>找到了问题的原因，那么解决方案也就自然而然浮出水面了，那就是将内存空间划分成不同区域，独立管理，比如：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125551739-1476151263.png" alt="img"></p>
<p><strong>如图，内存被划分成小、中、大三个不同尺寸的区域，区域可由若干内存页组成，每个页都划分为统一规格的内存块。这样一来，小块内存的分配，不会影响大块内存区域，使其碎片化。</strong></p>
<p><strong>不过每个区域的碎片仍无法完全避免，但这些碎片都是可以被重新分配出去的，影响不大。此外，通过优化分配策略，碎片还可被进一步合并。以小块内存为例，新内存优先从内存页1分配，内存页2将慢慢变空，最终将被整体回收。</strong></p>
<p><strong>在 *Python* 虚拟机内部，每时每刻都有对象创建、销毁，这引发频繁的内存申请、释放动作。这类内存尺寸一般不大，但分配、释放频率非常高，因此 *Python* 专门设计内存池对此进行优化。</strong></p>
<p><strong>那么，尺寸多大的内存才会动用内存池呢？*Python* 以 *512* 字节为上限，小于等于 *512* 的内存分配才会被内存池接管。所以当申请的内存大小不超过这个上限时， *Python* 可以使用不同种类的block满足对内存的需求；当申请的内存大小超过了上限， *Python* 就会将对内存的请求转交给第一层的内存管理机制，即PyMem函数簇来处理。所以这个上限值在 *Python* 中被设置为 *512* ，如果超过了这个值还是要经过操作系统临时申请的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_REQUEST_THRESHOLD 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>0: 直接调用 malloc 函数</code></li>
<li><code>1 ~ 512: 由专门的内存池负责分配，内存池以内存尺寸进行划分</code></li>
<li><code>512以上: 直接调动 malloc 函数 </code></li>
</ul>
<p><strong>那么，*Python* 是否为每个尺寸的内存都准备一个独立内存池呢？答案是否定的，原因有几个：</strong></p>
<ul>
<li><code>内存规格有 512 种之多，如果内存池分也分 512 种，徒增复杂性</code></li>
<li><code>内存池种类越多，额外开销越大</code></li>
<li><code>如果某个尺寸内存只申请一次，将浪费内存页内其他空闲内存</code></li>
</ul>
<p><strong>相反，*Python* 以 *8* 字节为梯度，将内存块分为：*8* 字节、*16* 字节、*24* 字节，以此类推。总共 *64* 种block：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* Request in bytes     Size of allocated block      Size <span class="class"><span class="keyword">class</span> <span class="title">idx</span></span></span><br><span class="line"><span class="class">* ----------------------------------------------------------------</span></span><br><span class="line"><span class="class">*        1-8                     8                       0</span></span><br><span class="line"><span class="class">*        9-16                   16                       1</span></span><br><span class="line"><span class="class">*       17-24                   24                       2</span></span><br><span class="line"><span class="class">*       25-32                   32                       3</span></span><br><span class="line"><span class="class">*       33-40                   40                       4</span></span><br><span class="line"><span class="class">*       41-48                   48                       5</span></span><br><span class="line"><span class="class">*       49-56                   56                       6</span></span><br><span class="line"><span class="class">*       57-64                   64                       7</span></span><br><span class="line"><span class="class">*       65-72                   72                       8</span></span><br><span class="line"><span class="class">*        ...                   ...                     ...</span></span><br><span class="line"><span class="class">*      497-504                 504                      62</span></span><br><span class="line"><span class="class">*      505-512                 512                      63</span></span><br></pre></td></tr></table></figure>

<p><strong>当然Python也提供了一个宏，来描述”Size of allocated block”和”Size class idx”之间的关系：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)</span></span><br><span class="line"><span class="comment">//索引为0的话, 就是1 &lt;&lt; 3, 显然结果为8</span></span><br><span class="line"><span class="comment">//索引为1的话, 就是2 &lt;&lt; 3, 显然结果为16</span></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<p><strong>因此当我们申请一个 *44* 字节的内存时， *PyObject_Malloc* 会从内存池中划分一个 *48* 字节的block给我们。</strong></p>
<p><strong>但是这样也暴露了一个问题，首先内存池是由多个内存页组成，每个内存页划分为多个内存块(block)，这些后面会说。假设我们申请 *7* 字节的内存，那么毫无疑问会给我们一个 *8* 字节的块；但是当我们申请 *1* 字节的时候，分配给我们的还是 *8* 字节的块，因为最小的块就是 *8* 字节。</strong></p>
<p><strong>这种做法好处显而易见，前面提到的问题均得到解决。此外这种方式是字对齐的，内存以字对齐的方式可以提高读写速度。字大小从早期硬件的 *2* 字节、*4* 字节，慢慢发展到现在的 *8* 字节，甚至 *16* 字节。</strong></p>
<p><strong>当然了，有得必有失，内存利用率成了被牺牲的因素，以8字节内存块为例，平均利用率为 *(1+8)&#x2F;2&#x2F;8*100%* ，大约只有 *56.25%* 。当然对于现在的机器而言，完全是可以容忍的。</strong></p>
<p><strong>另外在 *Python* 中，block其实也只是一个概念，在 *Python* 源码中没有与之对应的实体存在。之前我们说对象，对象在源码中有对应的 *PyObject* ，列表在源码中则有对应的 *PyListObject* ，但是这里的block仅仅是概念上的东西，我们知道它是具有一定大小的内存，但是它并不与 *Python* 源码里面的某个东西对应。但是， *Python* 提供了一个管理block的东西，也就是我们下面要分析的pool。</strong></p>
<h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p><strong>一组block的集合称为一个pool，换句话说，一个pool管理着一堆具有固定大小的内存块(block)。事实上，pool管理着一大块内存，它有一定的策略，将这块大的内存划分为多个小的内存块。在Python中，一个pool的大小通常是为一个系统内存页，也就是4kb。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>

<p><strong>虽然Python没有为block提供对应的结构，但是提供了和pool相关的结构，我们说Python是将内存页看成由一个个内存块(block)组成的池子(pool)，我们来看看pool的结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* 当前pool里面已分配出去的block数量 */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* 指向空闲block链表的第一块 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 底层会有多个pool, 多个pool之间也会形成一个链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* 所以nextpool指向下一个pool */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* prevpool指向上一个pool */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* 在area里面的索引(area后面会说) */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* 尺寸类别编号, 如果是2, 那么管理的block的大小就是24 */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* 下一个可用block的内存偏移量 */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* 最后一个block距离开始位置的偏移量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们刚才说了一个pool的大小在Python中是4KB，但是从当前的这个pool的结构体来看，用鼻子想也知道吃不完4KB(4048字节)的内存，事实上这个结构体只占48字节。所以呀，这个结构体叫做pool_header，它仅仅一个pool的头部，除去这个pool_header，剩下的内存才是维护的所有block的集合所占的内存。</strong></p>
<p><strong>我们注意到，pool_header里面有一个szidx，这就意味着pool里面管理的内存块大小都是一样的。也就是说，一个pool管理的block可以是32字节、也可以是64字节，但是不会出现既有32字节的block、又有64字节的block。每一个pool都和一个size联系在一起，更确切的说都和一个<code>size class index</code>联系在一起，表示pool里面存储的block都是多少字节的。这就是里面的域<code>szidx</code>存在的意义。</strong></p>
<p><strong>我们以16字节(szidx&#x3D;1)的block为例，看看Python是如何将一块4KB的内存改造成管理16字节block的pool：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    init_pool: <span class="comment">//pool指向了一块4KB的内存</span></span><br><span class="line">        next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        pool-&gt;prevpool = next;</span><br><span class="line">        next-&gt;nextpool = pool;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">//设置pool的size class index</span></span><br><span class="line">        pool-&gt;szidx = size;</span><br><span class="line">        <span class="comment">//一个宏, 将szidx转成内存块的大小, 比如: 0-&gt;8， 1-&gt;16， 63-&gt;512</span></span><br><span class="line">        size = INDEX2SIZE(size);</span><br><span class="line">        <span class="comment">//跳过用于pool_header的内存，并进行对齐</span></span><br><span class="line">        bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">        <span class="comment">//等价于pool-&gt;nextoffset = POOL_OVERHEAD+size+size</span></span><br><span class="line">        pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">        pool-&gt;freeblock = bp + size;</span><br><span class="line">        *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">success:</span><br><span class="line">    assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意最后的<code>(void \*)bp;</code>，它指的就是pool的freeblock域。我们说它指向的是pool中的第一块空闲block、或者说可用block，但是新内存页总是由内存请求触发，所以第一个block一定会被分配出去，因此这里的bp最后指向的只能是第二个、或者第二个之后的内存块。而且从ref.count中我们也可以看出端倪，我们说ref.count记录了当前已经被分配的block的数量，但初始化的时候不是0，而是1。最终改造成pool之后的4kb内存如图所示：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125607338-965966475.png" alt="img"></p>
<blockquote>
<p><strong>实线箭头是指针，但是虚线箭头则是偏移位置的形象表示。在nextoffset，maxnextoffset中存储的是相对于pool头部的偏移位置。</strong></p>
</blockquote>
<p><strong>在了解初始化之后的pool的样子之后，可以来看看Python在申请block时，pool_header中的各个域是怎么变动的。假设我们再申请1块16字节的内存块：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">        <span class="comment">//首先pool中已分配的block数自增1</span></span><br><span class="line">        ++pool-&gt;ref.count;</span><br><span class="line">        <span class="comment">//这里的freeblock指向的是下一个可用的block的起始地址</span></span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因此当再次申请16字节block时，只需要返回freeblock指向的地址就可以了。</span></span><br><span class="line">        <span class="comment">//那么很显然，freeblock需要前进，指向下一个可用的block，这个时候nextoffset就现身了</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">            <span class="comment">//当nextoffset小于等于maxoffset时候</span></span><br><span class="line">            <span class="comment">//freeblock等于当前block的地址 + nextoffset(下一个可用block的内存偏移量)</span></span><br><span class="line">            <span class="comment">//所以freeblock正好指向了下一个可用block的地址</span></span><br><span class="line">            pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                              pool-&gt;nextoffset;</span><br><span class="line">            <span class="comment">//同理，nextoffset也要向前移动一个block的距离</span></span><br><span class="line">            pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">            <span class="comment">//依次反复，即可对所有的block进行遍历。而maxnextoffset指明了该pool中最后一个可用的block距离pool开始位置的偏移</span></span><br><span class="line">            <span class="comment">//当pool-&gt;nextoffset &gt; pool-&gt;maxnextoffset就意味着遍历完pool中的所有block了</span></span><br><span class="line">            <span class="comment">//再次获取显然就是NULL了</span></span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Pool is full, unlink from used pools. */</span></span><br><span class="line">        next = pool-&gt;nextpool;</span><br><span class="line">        pool = pool-&gt;prevpool;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以当我们再申请1块16字节的内存块时，pool的结构图就变成了这样：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125617964-1871506331.png" alt="img"></p>
<p><strong>首先freeblock指向了第三块block，仍然是第一块可用block；注意：nextoffset，它表示下一块可用block的偏移量，显然下一块的可用block是第三块，因此48 + 16 * 3 &#x3D; 96，前进了16字节的偏移量；至于maxnextoffset仍然是4080，它是不变的。</strong></p>
<p><strong>随着内存分配的请求不断发起，空闲的block(内存块)也将不断地分配出去，freeblock不断前进、指向下一个可用内存块，nextoffset也在不断前进、偏移量每次增加内存块的大小，直到所有的空闲内存块被消耗完。</strong></p>
<p><strong>所以，申请、前进、申请、前进，一直重复着相同的动作，整个过程非常自然，也很容易理解。但是我们知道一个pool里面的block都是相同大小的，这就使得一个pool只能满足<code>POOL_SIZE / size</code>次对block的申请，但是这样存在一个问题，举个栗子：</strong></p>
<blockquote>
<p><strong>我们知道内存块不可能一直被使用，肯定有释放的那一天。假设我们分配了两个内存块，理论上下一次应该申请第三个内存块，但是某一时刻第一个内存块被释放了，那么下一次申请的时候，Python是申请第一个内存块、还是第三个内存块呢？</strong></p>
<p><strong>显然为了pool的使用效率，最好分配第一个block。因此可以想象，一旦Python运转起来，内存的释放动作将导致pool中出现大量的离散的自由block，Python为了知道哪些block是被使用之后再次被释放的，必须建立一种机制，将这些离散自由的block组合起来，再次使用。这个机制就是所有的自由block链表(freeblock list)，这个链表的关键就在pool_header中的那个freeblock身上。</strong></p>
</blockquote>
<p><strong>再来回顾一下pool_header的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          </span><br><span class="line">    block *freeblock;                   <span class="comment">/* 指向空闲block链表的第一块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       </span><br><span class="line">    uint arenaindex;                    </span><br><span class="line">    uint szidx;                         </span><br><span class="line">    uint nextoffset;                    </span><br><span class="line">    uint maxnextoffset;                 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>当pool初始化完后之后，freeblock指向了一个有效的地址，也就是下一个可以分配出去的block的地址。然而奇特的是，当Python设置了freeblock时，还设置了 *freeblock。这个动作看似诡异，然而我们马上就能看到设置  *freeblock的动作正是建立离散自由block链表的关键所在。目前我们看到的freeblock只是在机械地前进前进，因为它在等待一个特殊的时刻，在这个特殊的时刻，你会发现freeblock开始成为一个苏醒的精灵，在这4kb的内存上开始灵活地舞动，这个特殊的时刻就是一个block被释放的时刻。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基于地址P获得离P最近的pool的边界地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_ADDR(P) ((poolp)_Py_ALIGN_DOWN((P), POOL_SIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pymalloc_free</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="comment">//如果p不再pool里面，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!address_in_range(p, pool)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放，那么ref.count就势必大于0</span></span><br><span class="line">    assert(pool-&gt;ref.count &gt; <span class="number">0</span>);            <span class="comment">/* else it was empty */</span></span><br><span class="line">    *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">    pool-&gt;freeblock = (block *)p;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在释放block时，神秘的freeblock惊鸿一瞥，显然覆盖在freeblock身上的那层面纱就要被揭开了。我们知道，这是freeblock虽然指向了一个有效的pool里面的地址，但是 *freeblock是为NULL的。假设这时候Python释放的是block 1，那么block 1中的第一个字节的值被设置成了当前freeblock的值，然后freeblock的值被更新了，指向了block  1的首地址。就是这两个步骤，一个block被插入到了离散自由的block链表中。</strong></p>
<blockquote>
<p><strong>简单点，说人话就是：原来freeblock指向block 3，现在变成了block 1指向block 3，而freeblock则指向了block 1。</strong></p>
</blockquote>
<p><strong>所以pool的结构图变化如下：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125626518-102748426.png" alt="img"></p>
<p><strong>到了这里，这条实现方式非常奇特的block链表被我们挖掘出来了，从freeblock开始，我们可以很容易的以<code>freeblock = \*freeblock</code>的方式遍历这条链表，而当发现了<code>\*freeblock</code>为NULL时，则表明到达了该链表<code>(可用自由链表)</code>的尾部了，那么下次就需要申请新的block了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">        ++pool-&gt;ref.count;</span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//如果这里的条件不为真，表明离散自由链表中已经不存在可用的block了</span></span><br><span class="line">        <span class="comment">//如果为真那么代表存在，则会继续分配pool的nextoffset指定的下一块block</span></span><br><span class="line">        <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//离散自由block链表中不存在，则从pool里面申请新的block</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">            pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                              pool-&gt;nextoffset;</span><br><span class="line">            pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以得出，一个pool在其声明周期内，可以处于以下三种状态：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125634428-1296151636.png" alt="img"></p>
<p><strong>为什么要讨论pool的状态呢？我们在上面的代码中说自由链表中不存在可用的block时，会从pool中申请，但是显然是有条件的。我们看到必须满足：<code>pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset</code>才行，但如果连这个条件都不成立了呢？而这个条件不成立显然意味着pool中已经没有可用的block了，因为pool是有大小限制的。所以这个时候想在申请一个block要怎么做？答案很简单，再来一个pool不就好了，然后从新的pool里面申请。</strong></p>
<p><strong>所以block组合起来可以成为一个pool，那么同理多个pool也是可以组合起来的。而多个pool组合起来会得到什么呢，我们说内存池是分层次的，从下至上分别是：block、pool、arena，显然多个pool组合起来，可以得到我们下面要介绍的arena。</strong></p>
<h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><p><strong>在Python中，多个pool聚合的结果就是一个arena。上一节提到，pool的大小默认是4kb，同样每个arena的大小也有一个默认值。<code>#define ARENA_SIZE (256 &lt;&lt; 10)</code>，显然这个值默认是256KB，也就是<code>ARENA_SIZE / POOL_SIZE = 64</code>个pool的大小。我们来看看arena的底层结构体定义，同样藏身于 *Objects&#x2F;obmalloc.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">//arena的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//池对齐指针，指向下一个被划分的pool</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该arena中可用pool的数量</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该arena中所有pool的数量</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们在介绍pool的时候说过，pool之间也会形成一个链表，而这里freepools指的是第一个可用pool</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从名字上也能看出：nextarena指向下一个arena、prevarena指向上一个arena</span></span><br><span class="line">    <span class="comment">//是不是说明arena之间也会组成链表呢？答案不是的，其实多个arena之间组成的是一个数组，至于为什么我们下面说</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个概念上的arena在Python源码中就对应一个arena_object结构体实例，确切的说，arena_object仅仅是arena的一部分。就像pool_header仅仅是pool的一部分一样，一个完整的pool包括一个pool_header和透过这个pool_header管理的block集合；一个完整的arena也包括一个arena_object和透过这个arena_object管理的pool集合。</strong></p>
<p><strong>“未使用的”的arena和”可用”的arena</strong></p>
<p><strong>在arena_object结构体的定义中，我们看到了nextarena和prevarena这两个东西，这似乎意味着在Python中会有一个或多个arena构成的链表。呃，这种猜测实际上只对了一半，实际上，在Python中确实会存在多个arena_object构成的集合，但是这个集合不够成链表，而是一个数组。数组的首地址由arenas来维护，这个数组就是Python中的通用小块内存的内存池。另一方面，nextarea和prevarena也确实是用来连接arena_object组成链表的，咦，不是已经构成或数组了吗？为啥又要来一个链表。</strong></p>
<p><strong>我们曾说arena是用来管理一组pool的集合的，arena_object的作用看上去和pool_header的作用是一样的。但是实际上，pool_header管理的内存(block所使用)和arena_object管理的内存(pool所使用)有一点细微的差别，pool_header管理的内存pool_header自身是一块连续的内存，但是arena_object与其管理的内存则是分离的：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125643819-1760241218.png" alt="img"></p>
<p><strong>咋一看，貌似没啥区别，不过一个是连着的，一个是分开的。但是这后面隐藏了这样一个事实：当pool_header被申请时，它所管理的内存也一定被申请了；但是当arena_object被申请时，它所管理的pool集合的内存则没有被申请。换句话说，arena_object和pool集合在某一时刻需要建立联系。</strong></p>
<p><strong>当一个arena的arena_object没有与pool集合建立联系的时候，这时的arena就处于”未使用”状态；一旦建立了联系，这时arena就转换到了”可用”状态。对于每一种状态，都有一个arena链表。”未使用”的arena链表表头是<code>unused_arena_objects</code>，多个arena之间通过nextarena连接，并且是一个单向的链表；而”可用的”arena链表表头是<code>usable_arenas</code>，多个arena之间通过nextarena、prevarena连接，是一个双向链表。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125651170-218981901.png" alt="img"></p>
<p><strong>申请arena</strong></p>
<p><strong>在运行期间，Python使用new_arena来创建一个arena，我们来看看它是如何被创建的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arenas，多个arena组成的数组的首地址</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当arena数组中的所有arena的个数</span></span><br><span class="line"><span class="type">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未使用的arena的个数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可用的arena的个数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化需要申请的arena的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> arena_object*</span><br><span class="line"><span class="title function_">new_arena</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//arena，一个arena_object结构体对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[1]：判断是否需要扩充&quot;未使用&quot;的arena列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="type">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]：确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        arenaobj = (<span class="keyword">struct</span> arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]：初始化新申请的arena_object，并将其放入&quot;未使用&quot;arena链表中</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">    <span class="comment">//[4]：从&quot;未使用&quot;arena链表中取出一个&quot;未使用&quot;的arena</span></span><br><span class="line">    assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//[5]：申请arena管理的内存</span></span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="type">uintptr_t</span>)address;</span><br><span class="line">    <span class="comment">//调整个数</span></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    <span class="comment">//[6]：设置poo集合的相关信息，这是设置为NULL</span></span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = MAX_POOLS_IN_ARENA;</span><br><span class="line">    <span class="comment">//将pool的起始地址调整为系统页的边界</span></span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以看到，Python首先会检查当前”未使用”链表中是否还有”未使用”arena，检查的结果将决定后续的动作。</strong></p>
<p><strong>如果在”未使用”链表中还存在未使用的arena，那么Python会从”未使用”arena链表中抽取一个arena，接着调整”未使用”链表，让它和抽取的arena断绝一切联系。然后Python申请了一块256KB大小的内存，将申请的内存地址赋给抽取出来的arena的address。我们已经知道，arena中维护的是pool集合，这块256KB的内存就是pool的容身之处，这时候arena就已经和pool集合建立联系了。这个arena已经具备了成为”可用”内存的条件，该arena和”未使用”arena链表脱离了关系，就等着被”可用”arena链表接收了，不过什么时候接收呢？先别急。</strong></p>
<p><strong>随后，python在代码的[6]处设置了一些arena用于维护pool集合的信息。需要注意的是，Python将申请到的256KB内存进行了处理，主要是放弃了一些内存，并将可使用的内存边界(pool_address)调整到了与系统页对齐。然后通过<code>arenaobj-&gt;freepools = NULL;</code>将freepools设置为NULL，这不奇怪，基于对freeblock的了解，我们知道要等到释放一个pool时，这个freepools才会有用。最后我们看到，pool集合占用的256KB内存在进行边界对齐后，实际是交给pool_address来维护了。</strong></p>
<p><strong>回到new_arena中的[1]处，如果unused_arena_objects为NULL，则表明目前系统中已经没有”未使用”arena了，那么Python首先会扩大系统的arena集合(小块内存内存池)。Python在内部通过一个maxarenas的变量维护了存储arena的数组的个数，然后在[2]处将待申请的arena的个数设置为当然arena个数(maxarenas)的2倍。当然首次初始化的时候maxarenas为0，此时为16。</strong></p>
<p><strong>在获得了新的maxarenas后，Python会检查这个新得到的值是否溢出了。如果检查顺利通过，Python就会在[3]处通过realloc扩大arenas指向的内存，并对新申请的arena_object进行设置，特别是那个不起眼的address，要将新申请的address一律设置为0。实际上，这是一个标识arena是出于”未使用”状态还是”可用”状态的重要标记。而一旦arena(arena_object)和pool集合建立了联系，这个address就变成了非0，看代码的[6]处。当然别忘记我们为什么会走到[3]这里，是因为<code>unused_arena_objects == NULL</code>了，而且最后还设置了unused_arena_objects，这样系统中又有了”未使用”的arena了，接下来Python就在[4]处对一个arena进行初始化了。</strong></p>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p><strong>通过<code>#define SMALL_REQUEST_THRESHOLD 512</code>我们知道Python内部默认的小块内存与大块内存的分界点为512个字节。也就是说，当申请的内存小于512个字节，pymalloc_alloc会在内存池中申请内存，而当申请的内存超过了512字节，那么pymalloc_alloc将退化为malloc，通过操作系统来申请内存。当然，通过修改Python源代码我们可以改变这个值，从而改变Python的默认内存管理行为。</strong></p>
<p><strong>当申请的内存小于512字节时，Python会使用area所维护的内存空间。那么Python内部对于area的个数是否有限制呢？换句话说，Python对于这个小块空间内存池的大小是否有限制？其实这个决策取决于用户，Python提供了一个编译符号，用于控制是否限制内存池的大小，不过这里不是重点，只需要知道就行。</strong></p>
<p><strong>尽管我们在前面花了不少篇幅介绍arena，同时也看到arena是Python小块内存池的最上层结构，其实所有arena的集合就是小块内存池。然而在实际的使用中，Python并不直接与arenas和arena数组打交道。当Python申请内存时，最基本的操作单元并不是arena，而是pool。估计到这里懵了，别急，慢慢来。</strong></p>
<p><strong>举个例子，当我们申请一个28字节的内存时，Python内部会在内存池寻找一块能够满足需求的pool，从中取出一个block返回，而不会去寻找arena。这实际上是由pool和arena的属性决定的，在Python中，pool是一个有size概念的内存管理抽象体，一个pool中的block总是有确定的大小，这个pool总是和某个size class  index对应，还记得pool_header中的那个szidx么？而arena是没有size概念的内存管理抽象体。这就意味着，同一个arena在某个时刻，其内部的pool集合管理的可能都是相同字节的block，比如：32字节；而到了另一个时刻，由于系统需要，这个arena可能被重新划分，其中的pool集合管理的block可能变成是64字节了，甚至pool集合中一半的pool管理的是32字节block，另一半管理64字节block。这就决定了在进行内存分配和销毁时，所有的动作都是在pool上完成的。</strong></p>
<blockquote>
<p><strong>所以一个arena，并不要求pool集合中所有pool管理的block必须一样；可以有管理16字节block的pool，也可以有管理32字节block的pool，等等。</strong></p>
</blockquote>
<p><strong>当然内存池中的pool不仅仅是一个有size概念的内存管理抽象体，更进一步的，它还是一个有状态的内存管理抽象体。正如我们之前说的，一个pool在Python运行的任何一个时刻，总是处于以下三种状态中的一种：</strong></p>
<ul>
<li><code>empty状态：pool中所有的block都未被使用</code></li>
<li><code>used状态：pool中至少有一个block已经被使用，并且至少有一个block未被使用</code></li>
<li><code>full状态：pool中所有的block都已经被使用，这种状态的pool在arena中，但是不在arena的freepools链表中。</code></li>
</ul>
<p><strong>而且pool处于不同的状态，也会得到Python不同的对待：</strong></p>
<ul>
<li><code>如果pool完全空闲，那么Python会将它占用的内存页归还给操作系统、或者缓存起来，后续需要重新分配时直接拿来用。</code></li>
<li><code>如果pool完全用满，Python就无需关注它了，直接丢在一边。</code></li>
<li><code>如果pool只是部分使用，说明它还有内存块未分配，Python会将它们以双向链表的形式组织起来；</code></li>
</ul>
<p><strong>可用pool链表</strong></p>
<p><strong>由于used状态的pool只是部分使用，内部还有内存块未分配，将它们组织起来可供后续分配。Python通过pool_header中的nextpool和prevpool指针，将它们连成一个双向循环链表。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125705521-1922371939.png" alt="img"></p>
<p><strong>注意到，同个可用pool链表中的内存块大小规格都是一样的，我们还以16字节为例。另外，为了简化链表处理逻辑，Python引入了一个虚拟节点，这是一个常见的C语言链表实现技巧。一个空的pool链表是这样的，判断条件是：<code>pool -&gt; nextpool == pool</code>：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125712421-1081485272.png" alt="img"></p>
<p><strong>虚拟节点只参与链表维护，并不实际管理内存块。因为无需为虚拟节点分配一个完整的4k内存页，64字节pool_header结构体足以。然而实际上Python作者们更抠，只分配刚好足够nextpool和prevpool指针用的内存，手法非常精妙，后续会体现。</strong></p>
<p><strong>Python优先从链表的第一个pool中分配内存块，如果pool的可用内存块用完了，就将其从可用pool链表中剔除。</strong><br> <img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125720390-1296515696.png" alt="img"></p>
<p><strong>当一个内存块(block)被回收，Python根据块地址计算得到距离该块最近的pool边界地址，计算方式就是我们上面说的那个宏：POOL_ADDR，将块(block)地址对齐为内存页(pool)尺寸的整数倍，便得到pool地址。</strong></p>
<p><strong>得到pool地址后，Python将空闲内存块插入到空闲内存块链表的头部，如果pool状态是由full变成used，那么Python还会将它插回到可用pool链表的头部。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125727553-202377014.png" alt="img"></p>
<p><strong>插入到可用pool链表头部是为了保证较满的pool在链表的前面，以便优先使用。位于尾部的pool被使用的概率很低，随着时间的推移，更多的内存块被释放出来，慢慢变空。因此可用pool链表很明显头重脚轻，靠前的pool比较慢，靠后的pool比较空。</strong></p>
<p><strong>当一个pool中所有的内存块(block)都被释放，状态就变成了empty，那么Python就会将它移除可用pool链表，内存页可能直接归还给操作系统，或者缓存起来备用：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125735866-1825560716.png" alt="img"></p>
<p><strong>实际上，pool链表任一节点均有机会完全空闲下来，这由概率决定，尾部节点概率最高。</strong></p>
<p><strong>可用pool链表数组</strong></p>
<p><strong>Python内存池管理内存块，按照尺寸分门别类进行。因此每种规格都需要维护一个独立可执行的可用pool链表，以8直接为梯度，那么会有64中pool链表。</strong></p>
<p><strong>那么如何组织这么多pool链表呢？最直接的办法就是分配一个长度为64的虚拟节点数组，这个虚拟节点数组就是我们上面提到过的usedpools。Python内部维护的usedpools数组是一个非常巧妙的实现，该数组维护着所有的处于used状态的pool。当申请内存时，Python就会通过usedpools寻找到一个可用的pool<code>(处于used状态)</code>，从中分配一个block。因此我们想，一定有一个usedpools相关联的机制，完成从申请的内存的大小到size class  index之间的转换，否则Python就无法找到最合适的pool了。这种机制和usedpools的结构有着密切的关系，而usedpools也藏身于 *Objects&#x2F;obmalloc.c* 中。但是我们暂时先不看它的结构，因为还缺少一个东西，我们后面会说。</strong></p>
<p><strong>然后如果程序请求 *5* 字节，*Python* 将分配 *8* 字节内存块，通过数组第 *0* 个虚拟节点即可找到 *8* 字节 *pool* 链表；如果程序请求 *56* 字节，*Python* 将分配 *64* 字节内存块，则需要从数组第 *7* 个虚拟节点出发；其他以此类推。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125744109-301358749.png" alt="img"></p>
<p><strong>那么，虚拟节点数组需要占用多少内存呢？很好计算：48 * 64 &#x3D; 3072字节，也就是3KB的内存，0.75个内存页。</strong></p>
<p><strong>话说3KB的内存，你们觉得多吗？对于现在的机器来说，3KB可以忽略不计吧。但是高级程序猿对内存的精打细算，完全堪比、甚至凌驾于菜市场买菜的大妈，所以Python的作者从中还扣掉了三分之二。相当于只给虚拟机节点原来的三分之一、也就是1KB的内存，那么这是如何做到的呢？</strong></p>
<p><strong>事实上我们在前面已经埋下伏笔了，虚拟节点只参与维护链表结构，并不管了内存页。因此虚拟节点其实只使用pool_header结构体中参与链表维护的nextpool和prevpool两个指针字段。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125751082-1101271502.png" alt="img"></p>
<p><strong>为避免浅蓝色部分内存浪费，*Python* 作者们将虚拟节点想象成一个个卡片，将深蓝色部分首尾相接，最终转换成一个纯指针数组。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125756178-1820000253.png" alt="img"></p>
<p><strong>而这个纯指针数组就是在 *Objects&#x2F;obmalloc.c* 中定义的 *usedpools* ，每个虚拟节点对应数组里面的两个指针。所以之前我们说先不看 *usedpools* 的结构体定义，就是因为直接看的话绝对会一脸懵，因为不知道数组里面存的是啥，但是现在我们知道了数组里面存的就是一堆指针：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> block;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NB_SMALL_SIZE_CLASSES之前好像出现过，但是不用说也知道这表示当前配置下有多少个不同size的块</span></span><br><span class="line"><span class="comment">//在我当前的机器就是512/8=64个，对应的size class index就是从0到63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 8</span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 16</span></span><br><span class="line">    , PT(<span class="number">16</span>), PT(<span class="number">17</span>), PT(<span class="number">18</span>), PT(<span class="number">19</span>), PT(<span class="number">20</span>), PT(<span class="number">21</span>), PT(<span class="number">22</span>), PT(<span class="number">23</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 24</span></span><br><span class="line">    , PT(<span class="number">24</span>), PT(<span class="number">25</span>), PT(<span class="number">26</span>), PT(<span class="number">27</span>), PT(<span class="number">28</span>), PT(<span class="number">29</span>), PT(<span class="number">30</span>), PT(<span class="number">31</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 32</span></span><br><span class="line">    , PT(<span class="number">32</span>), PT(<span class="number">33</span>), PT(<span class="number">34</span>), PT(<span class="number">35</span>), PT(<span class="number">36</span>), PT(<span class="number">37</span>), PT(<span class="number">38</span>), PT(<span class="number">39</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 40</span></span><br><span class="line">    , PT(<span class="number">40</span>), PT(<span class="number">41</span>), PT(<span class="number">42</span>), PT(<span class="number">43</span>), PT(<span class="number">44</span>), PT(<span class="number">45</span>), PT(<span class="number">46</span>), PT(<span class="number">47</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 48</span></span><br><span class="line">    , PT(<span class="number">48</span>), PT(<span class="number">49</span>), PT(<span class="number">50</span>), PT(<span class="number">51</span>), PT(<span class="number">52</span>), PT(<span class="number">53</span>), PT(<span class="number">54</span>), PT(<span class="number">55</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 56</span></span><br><span class="line">    , PT(<span class="number">56</span>), PT(<span class="number">57</span>), PT(<span class="number">58</span>), PT(<span class="number">59</span>), PT(<span class="number">60</span>), PT(<span class="number">61</span>), PT(<span class="number">62</span>), PT(<span class="number">63</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;NB_SMALL_SIZE_CLASSES should be less than 64&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 56 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 48 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 40 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 32 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 24 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 16 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后将对应的两个指针的前后空间都想象成是自己的，这样就能够得到一个虚无缥缈、但又非常完整的pool_header结构体。尽管它们前后的空间不是自己的，但是不妨碍精神层面上YY一下，不过由于我们不会访问除了nextpool和prevpool指针之外的其它字段，所以虽然有内存越界，但也无伤大雅。</strong></p>
<p><strong>以一个代表空链表的虚拟节点为例，*nextpool* 和 *prevpool* 指针均指向 *pool_header* 自己。虽然实际上 *nextpool* 和 *prevpool* 都指向了数组中的其他虚拟节点，但逻辑上可以想象成指向当前的 *pool_header* 结构体：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125802713-934784644.png" alt="img"></p>
<p><strong>经过这番优化，数组只需要 16 * 64 &#x3D; 1024  字节的内存空间即可，也就是1KB，所以节省了三分之二。然而为了节省这三分之二的内存，代码变得难以理解。当然Python诞生的那个年代，内存还是比较精贵的，所以秉承着能省则省的策略，然后这个优良传统一直保持到了现在。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>对于一个用C开发的庞大的软件<code>(python是一门高级语言，但是执行对应代码的解释器则可以看成是c的一个软件)</code>，其中的内存管理可谓是最复杂、最繁琐的地方了。不同尺度的内存会有不同的抽象，这些抽象在各种情况下会组成各式各样的链表，非常复杂。但是我们还是有可能从一个整体的尺度上把握整个内存池，尽管不同的链表变幻无常，但我们只需记住，所有的内存都在arenas<code>(或者说那个存放多个arena的数组)</code>的掌握之中 。</strong></p>
<p><strong>更详细的内容可以自己进入 *Objects&#x2F;obmalloc.c* 中查看对应源码，主要看两个函数：</strong></p>
<ul>
<li><code>pymalloc_alloc: 负责内存分配</code></li>
<li><code>pymalloc_free: 负责内存释放</code></li>
</ul>
<p><strong>关于内存管理和内存池我们就说到这里，下一篇介绍Python中的垃圾回收。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>29-源码解密 map、filter、zip 底层实现，对比列表解析式</title>
    <url>/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="29-源码解密-map、filter、zip-底层实现，对比列表解析式"><a href="#29-源码解密-map、filter、zip-底层实现，对比列表解析式" class="headerlink" title="29-源码解密 map、filter、zip 底层实现，对比列表解析式"></a>29-源码解密 map、filter、zip 底层实现，对比列表解析式</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python 现在如此流行，拥有众多开源、高质量的第三方库是一个重要原因，不过 Python 的简单、灵巧、容易上手也是功不可没的，而其背后的内置函数（类）则起到了很大的作用。举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 将里面每一个元素都加1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, numbers)))  <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">strings = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;kf&quot;</span>, <span class="string">&quot;ghtc&quot;</span>]</span><br><span class="line"><span class="comment"># 筛选出长度大于等于3的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt;= <span class="number">3</span>, strings)))  <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghtc&#x27;]</span></span><br><span class="line"></span><br><span class="line">keys = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>]</span><br><span class="line">values = [<span class="string">&quot;夏色祭&quot;</span>, <span class="number">17</span>, <span class="string">&quot;female&quot;</span>]</span><br><span class="line"><span class="comment"># 将keys 和 values 里面的元素按照顺序组成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values)))  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: 17, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一行代码就搞定了，那么问题来了，这些内置函数（类）在底层是怎么实现的呢？下面我们就来通过源码来分析一下，这里我们介绍 map、filter、zip。</strong></p>
<p><strong>首先这些类（map、filter、zip都是类）都位于 builtin  名字空间中，而我们之前在介绍源码的时候提到过一个文件：Python&#x2F;bltinmodule.c，我们说该文件是和内置函数（类）相关的，那么显然  map、filter、zip 也藏身于此。</strong></p>
<h3 id="map底层实现"><a href="#map底层实现" class="headerlink" title="map底层实现"></a>map底层实现</h3><p><strong>我们知道map是将一个序列中的每个元素都作用于同一个函数（当然类、方法也可以）：</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193821363-702374811.png" alt="img"></p>
<p><strong>当然，我们知道调用map的时候并没有马上执行上面的操作，而是返回一个map对象。既然是对象，那么底层必有相关的定义。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD	  </span><br><span class="line">    PyObject *iters;  </span><br><span class="line">    PyObject *func;   </span><br><span class="line">&#125; mapobject;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>PyObject_HEAD：见过很多次了，它是Python中任何对象都会有的头部信息。包含一个引用计数ob_refcnt、和一个类型对象的指针ob_type；</strong></p>
<p><strong>iters：一个指针，这里实际上是一个PyTupleObject *，以 <code>map(lambda x: x + 1, [1, 2, 3])</code> 为例，那么这里的 iters 就相当于是 <code>([1, 2, 3, 4, 5].__iter__(),)</code>。至于为什么，分析源码的时候就知道了；</strong></p>
<p><strong>func：显然就是函数指针了，PyFunctionObject *；</strong></p>
</blockquote>
<p><strong>通过底层结构体定义，我们也可以得知在调用map时并没有真正的执行；对于函数和可迭代对象，只是维护了两个指针去指向它。</strong></p>
<p><strong>而一个PyObject占用16字节，再加上两个8字节的指针总共32字节。因此在64位机器上，任何一个map对象所占大小都是32字节。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line">strings = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 都占32字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">3</span>, numbers).__sizeof__())  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">3</span>, strings).__sizeof__())  <span class="comment"># 32</span></span><br></pre></td></tr></table></figure>

<p><strong>再来看看map的用法，Python中的 map 不仅可以作用于一个序列，还可以作用于任意多个序列。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>] + x[<span class="number">1</span>] + x[<span class="number">2</span>], [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m1))  <span class="comment"># [6, 9, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># map 还可以接收任意个可迭代对象</span></span><br><span class="line">m2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m2))  <span class="comment"># [6, 9, 12]</span></span><br><span class="line"><span class="comment"># 所以底层结构体中的iters在这里就相当于 ([1, 2, 3].__iter__(), [2, 3, 4].__iter__(), [3, 4, 5].__iter__())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说map的第一个参数是一个函数, 后面可以接收任意多个可迭代对象</span></span><br><span class="line"><span class="comment"># 但是注意: 可迭代对象的数量 和 函数的参数个数 一定要匹配</span></span><br><span class="line">m3 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: <span class="built_in">str</span>(x) + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], <span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m3))  <span class="comment"># [&#x27;1aa&#x27;, &#x27;2bb&#x27;, &#x27;3cc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是可迭代对象之间的元素个数不要求相等, 会以最短的为准</span></span><br><span class="line">m4 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m4))  <span class="comment"># [6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也支持更加复杂的形式</span></span><br><span class="line">m5 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x[<span class="number">0</span>] + x[<span class="number">1</span>] + y, [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m5))  <span class="comment"># [6, 9]</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到 map 会将后面所有可迭代对象中的每一个元素按照顺序依次取出，然后传递到函数中，因此函数的参数个数 和 可迭代对象的个数 一定要相等。</strong></p>
<p><strong>那么map对象在底层是如何创建的呢？很简单，因为map是一个类，那么调用的时候一定会执行里面的 <strong>new</strong> 方法。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *it, *iters, *func;</span><br><span class="line">    mapobject *lz;</span><br><span class="line">    Py_ssize_t numargs, i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// map对象在底层对应的是 mapobject、map类本身在底层对应的则是 PyMap_Type</span></span><br><span class="line">    <span class="comment">// _PyArg_NoKeywords表示检验是否没有传递关键字参数, 如果没传递, 那么结果为真; 传递了, 结果为假;</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyMap_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;map&quot;</span>, kwds))</span><br><span class="line">        <span class="comment">// 可以看到 map 不接受关键字参数</span></span><br><span class="line">        <span class="comment">// 如果传递了, 那么会报如下错误: TypeError: map() takes no keyword arguments, 可以自己尝试一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 位置参数都在 args 里面, 上面的 kwds 是关键字参数</span></span><br><span class="line">    <span class="comment">// 这里获取位置参数的个数, 1个函数、numargs - 1个可迭代对象, 这里的args 是一个 PyTupleObject *</span></span><br><span class="line">    numargs = PyTuple_Size(args);</span><br><span class="line">    <span class="comment">// 如果参数个数小于2</span></span><br><span class="line">    <span class="keyword">if</span> (numargs &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛出 TypeError, 表示 map 至少接受两个位置参数: 一个函数 和 至少一个可迭代对象</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">           <span class="string">&quot;map() must have at least two arguments.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 申请一个元组, 容量为 numargs - 1, 用于存放传递的所有可迭代对象(对应的迭代器)</span></span><br><span class="line">    iters = PyTuple_New(numargs<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">    <span class="keyword">if</span> (iters == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 依次循环</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span> ; i&lt;numargs ; i++) &#123;</span><br><span class="line">        <span class="comment">// PyTuple_GET_ITEM(args, i) 表示获取索引为 i 的可迭代对象</span></span><br><span class="line">        <span class="comment">// PyObject_GetIter 表示获取对应的迭代器, 相当于内置函数 iter</span></span><br><span class="line">        it = PyObject_GetIter(PyTuple_GET_ITEM(args, i));</span><br><span class="line">        <span class="comment">// 为NULL表示获取失败, 但是iters这个元组已经申请了, 所以减少其引用计数, 将其销毁</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(iters);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将对应的迭代器设置在元组iters中</span></span><br><span class="line">        PyTuple_SET_ITEM(iters, i<span class="number">-1</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 PyMap_Type 的 tp_alloc, 为其实例对象申请空间</span></span><br><span class="line">    lz = (mapobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败, 减少iters的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(iters);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让lz的iters成员 等于 iters</span></span><br><span class="line">    lz-&gt;iters = iters;</span><br><span class="line">    <span class="comment">// 获取第一个参数, 也就是函数</span></span><br><span class="line">    func = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 增加引用计数, 因为该函数被作为参数传递给map了</span></span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    <span class="comment">// 让lz的func成员 等于 func</span></span><br><span class="line">    lz-&gt;func = func;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 转成 PyObject *泛型指针, 然后返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到map_new做的工作很简单，就是实例化一个map对象，然后对内部的成员进行赋值。我们用Python来模拟一下上述过程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;MyMap不接受关键字参数&quot;</span>)</span><br><span class="line">        numargs = <span class="built_in">len</span>(args)</span><br><span class="line">        <span class="keyword">if</span> numargs &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;MyMap至少接收两个参数&quot;</span>)</span><br><span class="line">        <span class="comment"># 元组内部的元素不可以改变(除非本地修改), 所以这里使用列表来模拟</span></span><br><span class="line">        iters = [<span class="literal">None</span>] * (numargs - <span class="number">1</span>)  <span class="comment"># 创建一个长度为 numargs - 1 的列表, 元素都是None, 模拟C中的NULL</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; numargs:  <span class="comment"># 逐步循环</span></span><br><span class="line">            it = <span class="built_in">iter</span>(args[i])  <span class="comment"># 获取可迭代对象, 得到其迭代器</span></span><br><span class="line">            iters[i - <span class="number">1</span>] = it  <span class="comment"># 设置在 iters 中</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 为实例对象申请空间</span></span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="comment"># 设置成员</span></span><br><span class="line">        instance.iters = iters  </span><br><span class="line">        instance.func = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> instance  <span class="comment"># 返回实例对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = MyMap(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(m)  <span class="comment"># &lt;__main__.MyMap object at 0x00000167F4552E80&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.func)  <span class="comment"># &lt;function &lt;lambda&gt; at 0x0000023ABC4C51F0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.func(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.iters)  <span class="comment"># [&lt;list_iterator object at 0x0000025F13AF2940&gt;, &lt;list_iterator object at 0x0000025F13AF2CD0&gt;]</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">list</span>(it) <span class="keyword">for</span> it <span class="keyword">in</span> m.iters])  <span class="comment"># [[1, 2, 3], [11, 22, 33]]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到非常简单，这里我们没有设置构造函数__init__，这是因为 map 内部没有 __init__，它的成员都是在__new__里面设置的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map的__init__ 实际上就是 object的__init__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>.__init__ <span class="keyword">is</span> <span class="built_in">object</span>.__init__)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>.__init__)  <span class="comment"># &lt;slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>事实上，你会发现map对象非常类似迭代器，而事实上它们也正是迭代器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(m, Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(m, Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为了能更方便地理解后续内容，这里我们来提一下Python中的迭代器，可能有人觉得Python的迭代器很神奇，但如果你看了底层实现的话，你肯定会觉得：”就这？”</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/iterobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t it_index;  <span class="comment">// 每迭代一次, index自增1</span></span><br><span class="line">    PyObject *it_seq; <span class="comment">// 走到头之后, 将it_seq设置为NULL</span></span><br><span class="line">&#125; seqiterobject;</span><br></pre></td></tr></table></figure>

<p><strong>这就是Python的迭代器，非常简单，我们直接用Python来模拟一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, it_seq</span>):</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)  <span class="comment"># 创建实例对象</span></span><br><span class="line">        instance.it_index = <span class="number">0</span></span><br><span class="line">        instance.it_seq = it_seq</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果 self.it_seq 为None, 证明此迭代器已经迭代完毕</span></span><br><span class="line">        <span class="keyword">if</span> self.it_seq <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 逐步迭代, 说白了就是使用索引获取, 每迭代一次、索引自增1</span></span><br><span class="line">            val = self.it_seq[self.it_index]</span><br><span class="line">            self.it_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="comment"># 出现索引越界, 证明已经遍历完毕</span></span><br><span class="line">            <span class="comment"># 直接将 self.it_seq 设置为None即可</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> MyIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">    <span class="built_in">print</span>(_, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2 3</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">my_it = MyIterator([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 只能迭代一次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(my_it))  <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(my_it))  <span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<p><strong>Python的迭代器底层就是这么做的，可能有人觉得这不就是把  可迭代对象 和 索引 进行了一层封装嘛。每迭代一次，索引自增1，当出现索引越界时，证明迭代完了，直接将 it_seq 设置为 NULL  即可（这也侧面说明了为什么迭代器从开始到结束只能迭代一次）。</strong></p>
<p><strong>是的，迭代器就是这么简单，没有一点神秘。当然不仅是迭代器，再比如关键字 in，在C的层面其实就是一层 for 循环罢了。而迭代器除了通过 <strong>iter</strong> 实现之外，我们还可以通过  <strong>getitem__，__iter</strong> 我们下一章分析，下面看看 <strong>getitem</strong> 在源码中是如何体现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/iterobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PySeqIter_New</span><span class="params">(PyObject *seq)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    seqiterobject *it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果不是一个序列的话, 那么调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (!PySequence_Check(seq)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    it = PyObject_GC_New(seqiterobject, &amp;PySeqIter_Type);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// it_index 初始化为0</span></span><br><span class="line">    it-&gt;it_index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为seq被传递了, 所以指向的对象的引用计数要加1</span></span><br><span class="line">    Py_INCREF(seq);</span><br><span class="line">    <span class="comment">// 将成员it_seq初始化为seq</span></span><br><span class="line">    it-&gt;it_seq = seq;</span><br><span class="line">    <span class="comment">// 将该迭代器对象链接到 第0代链表 中, 并由GC负责跟踪(此处和垃圾回收机制相关, 这里不做过多介绍)</span></span><br><span class="line">    _PyObject_GC_TRACK(it);</span><br><span class="line">    <span class="comment">// 返回迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">iter_iternext</span><span class="params">(PyObject *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">    seqiterobject *it;  <span class="comment">// 迭代器对象</span></span><br><span class="line">    PyObject *seq;     <span class="comment">// 迭代器对象内部的可迭代对象</span></span><br><span class="line">    PyObject *result;  <span class="comment">// 迭代结果</span></span><br><span class="line"></span><br><span class="line">    assert(PySeqIter_Check(iterator));  <span class="comment">// 一定是迭代器</span></span><br><span class="line">    it = (seqiterobject *)iterator;  <span class="comment">// 将泛型指针PyObject * 转成 seqiterobject *</span></span><br><span class="line">    seq = it-&gt;it_seq;  <span class="comment">// 获取内部可迭代对象</span></span><br><span class="line">    <span class="comment">// 如果是NULL, 那么证明此迭代器已经迭代完毕, 直接返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 索引达到了最大值, 因为容器内部的元素个数是有限制的; 但如果不是吃撑了写恶意代码, 这个限制几乎不可能会触发</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;iter index too large&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据索引获取 seq 内部的元素</span></span><br><span class="line">    result = PySequence_GetItem(seq, it-&gt;it_index);</span><br><span class="line">    <span class="comment">// 如果不为NULL, 证明确实迭代出了元素</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引自增1</span></span><br><span class="line">        it-&gt;it_index++;</span><br><span class="line">        <span class="comment">// 然后返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当result为NULL的时候, 证明出异常了, 也说明遍历到头了</span></span><br><span class="line">    <span class="comment">// 进行异常匹配, 如果出现的异常能匹配 IndexError 或者 StopIteration</span></span><br><span class="line">    <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_IndexError) ||</span><br><span class="line">        PyErr_ExceptionMatches(PyExc_StopIteration))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 那么不会让异常抛出, 而是通过 PyErr_Clear() 将异常回溯栈清空</span></span><br><span class="line">        <span class="comment">// 所以使用 for i in 迭代器, 或者 list(迭代器) 等等不会报错, 原因就在于此; 尽管它们也是不断迭代, 但是在最后会捕获异常</span></span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="comment">// 将it_seq设置为NULL, 表示此迭代器大限已至、油尽灯枯</span></span><br><span class="line">        it-&gt;it_seq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 因为将it_seq赋值NULL, 那么原来的可迭代对象就少了一个引用, 因此要将引用计数减1</span></span><br><span class="line">        Py_DECREF(seq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以这就是迭代器，真的一点都不神秘。</strong></p>
<p><strong>在迭代器上面多扯皮了一会儿，但这肯定是值得的，那么回到主题。我们说调用map只是得到一个map对象，从上面的分析我们也可以得出，在整个过程并没有进行任何的计算。如果要计算的话，我们可以调用__next__、或者使用for循环等等。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> m])  <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们知道 for 循环的背后本质上会调用迭代器的 __next__</span></span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x) + <span class="number">1</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(m.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然上面都不是最好的方式</span></span><br><span class="line"><span class="comment"># 如果只是单纯的将元素迭代出来, 而不做任何处理的话, 那么交给tuple、list、set等类型对象才是最佳的方式</span></span><br><span class="line"><span class="comment"># 像tuple(m)、list(m)、set(m)等等</span></span><br><span class="line"><span class="comment"># 所以如果你是[x for x in it]这种做法的话, 那么更建议你使用list(m), 效率会更高, 因为它用的是C中的for循环</span></span><br><span class="line"><span class="comment"># 当然不管是哪种做法, 底层都是一个不断调用__next__、逐步迭代的过程</span></span><br></pre></td></tr></table></figure>

<p><strong>所以下面我们来看看map底层是怎么做的？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_next</span><span class="params">(mapobject *lz)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// small_stack显然是一个数组, 里面存放 PyObject *, 显然它用来存放 map 中所有可迭代对象的索引为i(i=0,1,2,3...)的元素</span></span><br><span class="line">    <span class="comment">// 但这个_PY_FASTCALL_SMALL_STACK是什么呢? 我们需要详细说一下</span></span><br><span class="line">    PyObject *small_stack[_PY_FASTCALL_SMALL_STACK];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _PY_FASTCALL_SMALL_STACK 是一个宏, 定义在 Include/cpython/abstract.h 中, 结果就等于5</span></span><br><span class="line"><span class="comment">    small_stack这个数组会首先尝试在栈区分配，如果通过位置参数来调用一个函数的话, 可以不用申请在堆区</span></span><br><span class="line"><span class="comment">    但是数量不能过大, 官方将这个值设置成5, 如果参数个数小于等于5的话, 便可申请在栈中</span></span><br><span class="line"><span class="comment">    然后通过传递位置参数的方式对函数进行调用, 在C中调用一个 Python函数 有很多种方式；</span></span><br><span class="line"><span class="comment">    这里会通过 PyObject_Vectorcall 系列函数(矢量调用, 会更快) 来对函数进行调用, 是的，调用一个函数需要借助另一个函数</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    之所以将其设置成5, 是为了不滥用C的栈, 从而减少栈溢出的风险</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二级指针, 指向 small_stack 数组的首元素, 所以是 PyObject **</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">// 函数调用的返回值</span></span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取当前的线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取iters内置迭代器的数量, 同时也是调用函数时的参数数量</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t niters = PyTuple_GET_SIZE(lz-&gt;iters);</span><br><span class="line">    <span class="comment">// 如果这个参数小于等于5, 那么在获取这些迭代器中的元素时, 可以直接使用在C栈中申请的数组进行存储</span></span><br><span class="line">    <span class="keyword">if</span> (niters &lt;= (Py_ssize_t)Py_ARRAY_LENGTH(small_stack)) &#123;</span><br><span class="line">        <span class="built_in">stack</span> = small_stack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果超过了5, 那么不好意思, 只能在堆区重新申请了</span></span><br><span class="line">        <span class="built_in">stack</span> = PyMem_Malloc(niters * <span class="keyword">sizeof</span>(<span class="built_in">stack</span>[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 返回NULL, 表示申请失败, 说明没有内存了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里传入线程状态对象, 会在内部设置异常</span></span><br><span class="line">            _PyErr_NoMemory(tstate);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 走到这里说明一切顺利, 那么下面就开始迭代了</span></span><br><span class="line">    <span class="comment">// 如果是 map(func, [1, 2, 3], [&quot;xx&quot;, &quot;yy&quot;, &quot;zz&quot;], [2, 3, 4]), 那么第一次迭代出来的元素就是 (1, &quot;xx&quot;, 2)</span></span><br><span class="line">    Py_ssize_t nargs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Py_ssize_t i=<span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取索引为i对应的迭代器, </span></span><br><span class="line">        PyObject *it = PyTuple_GET_ITEM(lz-&gt;iters, i);</span><br><span class="line">        <span class="comment">// Py_TYPE表示获取对象的 ob_type(类型对象), 然后调用tp_iternext成员进行迭代</span></span><br><span class="line">        <span class="comment">// 类似于 type(it).__next__(it)</span></span><br><span class="line">        PyObject *val = Py_TYPE(it)-&gt;tp_iternext(it);</span><br><span class="line">        <span class="comment">// 如果val为NULL, 直接跳转到 exit 这个label中</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 val 设置在数组索引为i的位置中, 然后进行下一轮循环, 也就是获取下一个迭代器中的元素设置在数组stack中</span></span><br><span class="line">        <span class="built_in">stack</span>[i] = val;</span><br><span class="line">        <span class="comment">// nargs++, 和参数个数、迭代器个数 保持一致</span></span><br><span class="line">        <span class="comment">// 如果可迭代对象个数是3, 那么小于5, 所以stack会申请在栈区; 但是在栈区申请的话, 长度默认为5, 因此后两个是元素是无效的</span></span><br><span class="line">        <span class="comment">// 所以在调用的时候需要指定有效的参数个数</span></span><br><span class="line">        nargs++;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 进行调用, 得到结果, 这个函数是Python3.9新增的; 如果是Python3.8的话, 调用的是_PyObject_FastCall</span></span><br><span class="line">    result = _PyObject_VectorcallTstate(tstate, lz-&gt;func, <span class="built_in">stack</span>, nargs, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 调用完毕之后, 将stack中指针指向的对象的引用计数减1</span></span><br><span class="line">    <span class="keyword">for</span> (Py_ssize_t i=<span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_DECREF(<span class="built_in">stack</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不相等的话, 说明该stack是在堆区申请的, 要释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> != small_stack) &#123;</span><br><span class="line">        PyMem_Free(<span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后突然发现map对象还有一个鲜为人知的一个方法，也是一个没有什么卵用的方法。说来惭愧，要不是看源码，我还真没注意过。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_reduce</span><span class="params">(mapobject *lz, PyObject *Py_UNUSED(ignored))</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 获取迭代器的元素个数</span></span><br><span class="line">    Py_ssize_t numargs = PyTuple_GET_SIZE(lz-&gt;iters);</span><br><span class="line">    <span class="comment">// 申请一个元素, 空间是numargs + 1 个</span></span><br><span class="line">    PyObject *args = PyTuple_New(numargs+<span class="number">1</span>);</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(lz-&gt;func);</span><br><span class="line">    <span class="comment">// 将函数设置为args的第一个元素</span></span><br><span class="line">    PyTuple_SET_ITEM(args, <span class="number">0</span>, lz-&gt;func);</span><br><span class="line">    <span class="comment">// 然后再将剩下的迭代器也设置在args中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;numargs; i++)&#123;</span><br><span class="line">        PyObject *it = PyTuple_GET_ITEM(lz-&gt;iters, i);</span><br><span class="line">        Py_INCREF(it);</span><br><span class="line">        PyTuple_SET_ITEM(args, i+<span class="number">1</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将 Py_TYPE(lz) 和 args 打包成一个元组返回</span></span><br><span class="line">    <span class="comment">// 所以从结果上看, 返回的内容应该是: ( &lt;class &#x27;map&#x27;&gt;, (函数, 迭代器1, 迭代器2, 迭代器3, ......) )</span></span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;ON&quot;</span>, Py_TYPE(lz), args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef map_methods[] = &#123;</span><br><span class="line">    <span class="comment">// 然后这个函数叫 __reduce__</span></span><br><span class="line">    &#123;<span class="string">&quot;__reduce__&quot;</span>,   (PyCFunction)map_reduce,   METH_NOARGS, reduce_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,           <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">pprint(m.__reduce__())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(&lt;class &#x27;map&#x27;&gt;,</span></span><br><span class="line"><span class="string"> (&lt;function &lt;lambda&gt; at 0x000001D2791451F0&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D279348640&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D279238700&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D27950AF40&gt;))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="filter底层实现"><a href="#filter底层实现" class="headerlink" title="filter底层实现"></a>filter底层实现</h3><p><strong>然后我们filter的实现原理，看完了map之后，再看filter就简单许多了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> !=<span class="number">0</span>, lst)))  <span class="comment"># [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>首先filter接收两个元素，第一个参数是一个函数（类、方法），第二个参数是一个可迭代对象。然后当我们迭代的时候会将可迭代对象中每一个元素都传入到函数中，如果返回的结果为真，则保留；为假，则丢弃。</strong></p>
<p><strong>但是，其实第一个参数除了是一个可调用的对象之外，它还可以是None。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;&quot;</span>, [], <span class="number">123</span>, <span class="number">0</span>, &#123;&#125;, [<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 会自动选择结果为真的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, lst)))  <span class="comment"># [&#x27;夏色祭&#x27;, 123, [1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>至于为什么，一会看源码filter的实现就清楚了。</strong></p>
<p><strong>下面看看底层结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *func;</span><br><span class="line">    PyObject *it;</span><br><span class="line">&#125; filterobject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到和map对象是一致的，没有什么区别。因为map、filter都不会立刻调用，而是返回一个相应的对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">filter_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *seq;  <span class="comment">// 函数、可迭代对象</span></span><br><span class="line">    PyObject *it;  <span class="comment">// 可迭代对象的迭代器</span></span><br><span class="line">    filterobject *lz;  <span class="comment">// 返回值, filter对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// filter也不接受关键字参数</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyFilter_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;filter&quot;</span>, kwds))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 只接受两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(args, <span class="string">&quot;filter&quot;</span>, <span class="number">2</span>, <span class="number">2</span>, &amp;func, &amp;seq))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取seq对应的迭代器</span></span><br><span class="line">    it = PyObject_GetIter(seq);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为filter对象申请空间</span></span><br><span class="line">    lz = (filterobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(it);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加函数的引用计数</span></span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    <span class="comment">// 初始化成员</span></span><br><span class="line">    lz-&gt;func = func;</span><br><span class="line">    lz-&gt;it = it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和map是类似的，因为本质上它们做的事情都是差不多的，下面看看迭代过程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">filter_next</span><span class="params">(filterobject *lz)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item; <span class="comment">// 迭代器中迭代出来的每一个元素</span></span><br><span class="line">    PyObject *it = lz-&gt;it;  <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="type">long</span> ok;  <span class="comment">// 是否为真, 1表示真、0表示假</span></span><br><span class="line">    PyObject *(*iternext)(PyObject *);  <span class="comment">// 函数指针, 接收一个PyObject *, 返回一个PyObject *</span></span><br><span class="line">    <span class="comment">// 如果 func == None 或者 func == bool, 那么checktrue为真; 会走单独的方法, 所以给func传递一个None是完全合法的</span></span><br><span class="line">    <span class="type">int</span> checktrue = lz-&gt;func == Py_None || lz-&gt;func == (PyObject *)&amp;PyBool_Type;</span><br><span class="line">    <span class="comment">// 迭代器的 __next__ 方法</span></span><br><span class="line">    iternext = *Py_TYPE(it)-&gt;tp_iternext;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 迭代出迭代器的每一个元素</span></span><br><span class="line">        item = iternext(it);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果checkture, 或者说如果func == None || func == bool</span></span><br><span class="line">        <span class="keyword">if</span> (checktrue) &#123;</span><br><span class="line">            <span class="comment">// PyObject_IsTrue(item)实际上就是在判断item是否为真, 像0、长度为0的序列、False、None为假</span></span><br><span class="line">            <span class="comment">// 另外我们在if语句的时候经常会写 if item: 这种形式, 但是很少会写 if bool(item):</span></span><br><span class="line">            <span class="comment">// 因为bool(item)底层也是调用 PyObject_IsTrue</span></span><br><span class="line">            <span class="comment">// 而if item: 如果你查看它的字节码的话, 会发现有这么一条指令: POP_JUMP_IF_FALSE</span></span><br><span class="line">            <span class="comment">// 它在底层也是调用了 PyObject_IsTrue, 因此完全没有必要写成 if bool(item): 这种形式</span></span><br><span class="line">            ok = PyObject_IsTrue(item);</span><br><span class="line">            <span class="comment">// 而如果func为None或者bool的话, 那么直接走PyObject_IsTrue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话, 会调用我们传递的func</span></span><br><span class="line">            <span class="comment">// 这里的 good 就是函数调用的返回值</span></span><br><span class="line">            PyObject *good;</span><br><span class="line">            <span class="comment">// 调用函数, 将返回值赋值给good</span></span><br><span class="line">            good = PyObject_CallFunctionObjArgs(lz-&gt;func, item, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 如果 good 等于 NULL, 说明函数调用失败; 说句实话, 源码中做的很多异常捕获都是针对解释器内部的</span></span><br><span class="line">            <span class="comment">// 尤其像底层这种和NULL进行比较的, 我们在使用Python的时候, 很少会出现</span></span><br><span class="line">            <span class="keyword">if</span> (good == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(item);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 good 是否为真</span></span><br><span class="line">            ok = PyObject_IsTrue(good);</span><br><span class="line">            Py_DECREF(good); <span class="comment">// 减少其引用计数, 因为它不被外界所使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ok大于0, 说明将item传给函数调用之后返回的结果为真, 那么将item返回</span></span><br><span class="line">        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        <span class="comment">// 同时减少其引用计数</span></span><br><span class="line">        <span class="comment">// 如果等于0, 说明为假, 那么进行下一轮循环</span></span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">        <span class="comment">// 小于0的话, 表示PyObject_IsTrue调用失败了, 调用失败会返回-1</span></span><br><span class="line">        <span class="comment">// 但还是那句话, 这种情况, 在Python的使用层面上几乎不可能发生</span></span><br><span class="line">        <span class="keyword">if</span> (ok &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以看到这里你还觉得Python神秘吗，从源代码层面我们看的非常流畅，只要你有一定的C语言基础即可。还是那句话，尽管我们不可能写一个解释器，因为背后涉及的东西太多了，但至少我们在看的过程中，很清楚底层到底在做什么。而且这背后的实现，如果让你设计一个方案的话，那么相信你也一样可以做到。</strong></p>
<p><strong>还是拿关键字 in 举例子，像<code>&quot;b&quot; in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>我们知道结果为真。那如果让你设计关键字 in 的实现，你会怎么做呢？反正基本上都会想到，遍历 in 后面的可迭代对象呗，将里面的元素 依次和  in前面的元素进行比较，如果出现相等的，返回真；遍历完了也没发现相等的，那么返回假。如果你是这么想的，那么恭喜你，Python解释器内部也是这么做的，我们以列表为例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// item in 列表: 本质上就是调用 list.__contains__(列表, item) 或者 列表.__contains__(item)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_contains</span><span class="params">(PyListObject *a, PyObject *el)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item; <span class="comment">// 列表中的每一个元素</span></span><br><span class="line">    Py_ssize_t i;  <span class="comment">// 循环变量</span></span><br><span class="line">    <span class="type">int</span> cmp;  <span class="comment">// 比较的结果</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// cmp初始为0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, cmp = <span class="number">0</span> ; cmp == <span class="number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取PyListObject中的每一个元素</span></span><br><span class="line">        item = PyList_GET_ITEM(a, i);</span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        <span class="comment">// 调用PyObject_RichCompareBool进行比较, 大于、小于、不等于之类的都是使用这个函数, 具体是哪一种则通过第三个参数控制</span></span><br><span class="line">        <span class="comment">// 而前两个元素则是比较的对象</span></span><br><span class="line">        cmp = PyObject_RichCompareBool(el, item, Py_EQ);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果出现相等的元素, 那么cmp为1, 因此cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)会不成立, 直接结束循环</span></span><br><span class="line">    <span class="comment">// 如果没有出现相等的元素, 那么会一直遍历整个列表, 始终没有出现相等的元素, 那么cmp还是0</span></span><br><span class="line">    <span class="comment">// 为1代表真, 为0代表假</span></span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上便是关键字  in，是不是很简单呢？所以个人推荐没事的话可以多读一读Python解释器，如果你不使用Python &#x2F; C  API进行编程的话，那么不需要你有太高的C语言水平（况且现在还有Cython）。如果你想写出高质量、并且精简利落的Python代码，那么就势必要懂得背后的实现原理。比如：我们看几道思考题，自己乱编的。</strong></p>
<p><strong>1. 为什么 方法一 要比 方法二 更高效？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f&quot;item: <span class="subst">&#123;item&#125;</span>&quot;</span> <span class="keyword">for</span> item <span class="keyword">in</span> lst]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        res.append(<span class="string">f&quot;item: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以这道题考察的实际上是列表解析为什么更快？首先Python中的变量在底层本质上都是一个泛型指针PyObject *，调用res.append的时候实际上会进行一次属性查找。会调用 <code>PyObject_GetAttr(res, &quot;append&quot;)</code> ，去寻找该对象是否有 append  函数，如果有的话，那么进行获取然后调用；而列表解析，Python在编译的时候看到左右的两个中括号就知道这是一个列表解析式，所以它会立刻知道自己该干什么，会直接调用C一级函数 PyList_Append，因为Python对这些内置对象非常熟悉。所以列表解析少了一层属性查找的过程，因此它的效率会更高。</strong></p>
</blockquote>
<p><strong>2.  假设有三个变量a、b、c，三个常量 “xxx”、123、3.14，我们要判断这三个变量对应的值 和  这三个常量是否相等，该怎么做呢？注意：顺序没有要求，可以是 a &#x3D;&#x3D; “xxx”、也可以是 b  &#x3D;&#x3D; “xxx”，只要这个三个变量对应的值正好也是 “xxx”、123、3.14 就行。</strong></p>
<p><strong>显然最方便的是使用集合：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">3.14</span>, <span class="string">&quot;xxx&quot;</span>, <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> &#123;a, b, c&#125; - &#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">3.14</span>, <span class="number">123</span>&#125;)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 令人困惑的生成器解析式，请问下面哪段代码会报错？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码一</span></span><br><span class="line">x = (<span class="string">&quot;xxx&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> dasdasdad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码二</span></span><br><span class="line">x = (dasdasdad <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>首先生成器解析式，只有在执行的时候才会真正的产出值。但是关键字 in 后面的变量是会提前确定的，所以代码一会报错，抛出 NameError；但代码二不会，因为只有在产出值的时候才会去寻找变量 dasdasdad 指向的值。</strong></p>
<p><strong>再留个两个思考题，为什么会出现这种结果呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思考题一: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    lst = [x <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">NameError: name &#x27;x&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思考题二: </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>([<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">NameError: name &#x27;a&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>像这样类似的问题还有很多很多，当然最关键的还是理解底层的数据结构 以及 解释器背后的执行原理，只有这样才能写出更加高效的代码。</strong></p>
<p><strong>回到正题，filter 也有 <strong>reduce</strong> 方法，和 map 类似。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">filter</span>(<span class="literal">None</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, [], <span class="string">&quot;xx&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(f.__reduce__())  <span class="comment"># (&lt;class &#x27;filter&#x27;&gt;, (None, &lt;list_iterator object at 0x00000239AF2AB0D0&gt;))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(f.__reduce__()[<span class="number">1</span>][<span class="number">1</span>]))  <span class="comment"># [1, 2, 3, 0, &#x27;&#x27;, [], &#x27;xx&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="zip底层实现"><a href="#zip底层实现" class="headerlink" title="zip底层实现"></a>zip底层实现</h3><p><strong>最后看看 zip，其实 zip 和 map 也是有着高度相似之处的，首先它们都可以接受任意个可迭代对象。而且 zip，我们完全可以使用 map 来进行模拟。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: (x, y, z), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> *args: args, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们看到实现zip, 完全可以使用 map, 只需要多指定一个函数即可</span></span><br></pre></td></tr></table></figure>

<p><strong>所以 zip 的底层实现同样很简单，我们来看一下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t          tuplesize;</span><br><span class="line">    PyObject *ittuple;                  </span><br><span class="line">    PyObject *result;</span><br><span class="line">&#125; zipobject;</span><br><span class="line"><span class="comment">// 以上便是zip对象的底层定义, 这些字段的含义, 我们暂时先不讨论, 它们会体现在zip_new方法中, 我们到时候再说</span></span><br></pre></td></tr></table></figure>

<p><strong>目前我们根据结构体里面的成员，可以得到一个 zipobject 显然是占 40 字节的，16 + 8 + 8 + 8，那么结果是不是这样呢？我们来试一下就知道了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z1 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line">z2 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">z3 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z1.__sizeof__())  <span class="comment"># 40  </span></span><br><span class="line"><span class="built_in">print</span>(z2.__sizeof__())  <span class="comment"># 40</span></span><br><span class="line"><span class="built_in">print</span>(z3.__sizeof__())  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们分析的没有错，任何一个 zip 对象所占的大小都是 40 字节。所以在计算内存大小的时候，有人会好奇这到底是怎么计算的，其实就是根据底层的结构体进行计算的。</strong></p>
<blockquote>
<p><strong>注意：如果你使用 sys.getsizeof 函数计算的话，可能会多出  16 个字节，这是因为对于可变对象，它们是会被 GC 跟踪的。在创建的时候，它们会被挂到零代链表中，所以它们额外还会有一个 前继指针 和 一个  后继指针，而 sys.getsizeof 将这两个指针的大小也算在内了。</strong></p>
</blockquote>
<p><strong>下面看看 zip 对象是如何被实例化的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">zip_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    zipobject *lz;  <span class="comment">// zip 对象</span></span><br><span class="line">    Py_ssize_t i;  <span class="comment">// 循环变量</span></span><br><span class="line">    PyObject *ittuple;  <span class="comment">// 所有可迭代对象的迭代器组成的元组</span></span><br><span class="line">    PyObject *result;   <span class="comment">// &quot;代码中有体现&quot;</span></span><br><span class="line">    Py_ssize_t tuplesize;  <span class="comment">// 可迭代对象的数量</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// zip同样不需要关键字参数, 但是在3.10的时候将会提供一个关键字参数strict, 如果为True, 表示可迭代对象之间的长度必须相等, 否则报错</span></span><br><span class="line">    <span class="comment">// strict如果为False, 则和目前是等价的, 会自动以短的为准</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyZip_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;zip&quot;</span>, kwds))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// args必须使用一个PyTupleObject *</span></span><br><span class="line">    assert(PyTuple_Check(args));</span><br><span class="line">    <span class="comment">// 获取可迭代对象的数量</span></span><br><span class="line">    tuplesize = PyTuple_GET_SIZE(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个元组, 长度为tuplesize, 用于存放可迭代对象对应的迭代器</span></span><br><span class="line">    ittuple = PyTuple_New(tuplesize);</span><br><span class="line">    <span class="keyword">if</span> (ittuple == <span class="literal">NULL</span>) <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 然后依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; tuplesize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取传递的可迭代对象</span></span><br><span class="line">        PyObject *item = PyTuple_GET_ITEM(args, i);</span><br><span class="line">        <span class="comment">// 通过PyObject_GetIter获取对应的迭代器</span></span><br><span class="line">        PyObject *it = PyObject_GetIter(item);</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 为NULL表示获取失败, 减少ittuple的引用计数, 返回NULL</span></span><br><span class="line">            Py_DECREF(ittuple);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置在ittuple中</span></span><br><span class="line">        PyTuple_SET_ITEM(ittuple, i, it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里又申请一个元组result, 长度也为tuplesize</span></span><br><span class="line">    result = PyTuple_New(tuplesize);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(ittuple);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将内部的所有元素都设置为None, Py_None就是Python中的None</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">        Py_INCREF(Py_None);</span><br><span class="line">        PyTuple_SET_ITEM(result, i, Py_None);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个zip对象</span></span><br><span class="line">    lz = (zipobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 申请失败减少引用计数, 返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(ittuple);</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 初始化成员</span></span><br><span class="line">    lz-&gt;ittuple = ittuple;</span><br><span class="line">    lz-&gt;tuplesize = tuplesize;</span><br><span class="line">    lz-&gt;result = result;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 转成泛型指针PyObject *之后返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再来看看，zip对象的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t          tuplesize;</span><br><span class="line">    PyObject *ittuple;                  </span><br><span class="line">    PyObject *result;</span><br><span class="line">&#125; zipobject;</span><br></pre></td></tr></table></figure>

<p><strong>如果以：<code>zip([1, 2, 3], [11, 22, 33], [111, 222, 333])</code>为例的话，那么：</strong></p>
<ul>
<li><code>tuplesize: 3</code></li>
<li><code>ittuple: ([1, 2, 3].__iter__(), [11, 22, 33].__iter__(), [111, 222, 333].__iter__())</code></li>
<li><code>result: (None, None, None)</code></li>
</ul>
<p><strong>所以目前来说，其它的很好理解，唯独这个result让人有点懵，搞不懂它是干什么的。不过既然有这个成员，那就说明它肯定有用武之地，而派上用场的地方不用想，肯定是在迭代的时候使用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">zip_next</span><span class="params">(zipobject *lz)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i; <span class="comment">// 循环遍变量</span></span><br><span class="line">    Py_ssize_t tuplesize = lz-&gt;tuplesize;  <span class="comment">// 可迭代对象数量</span></span><br><span class="line">    PyObject *result = lz-&gt;result;   <span class="comment">// (None, None, ....)</span></span><br><span class="line">    PyObject *it;  <span class="comment">// 每一个迭代器 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码中体现</span></span><br><span class="line">    PyObject *item;</span><br><span class="line">    PyObject *olditem;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// tuplesize == 0, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tuplesize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果 result 的引用计数为1, 证明该元组的空间的被申请了</span></span><br><span class="line">    <span class="keyword">if</span> (Py_REFCNT(result) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为它要作为返回值返回, 引用计数加1</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">            <span class="comment">// 依次获取每一个迭代器</span></span><br><span class="line">            it = PyTuple_GET_ITEM(lz-&gt;ittuple, i);</span><br><span class="line">            <span class="comment">// 迭代出相应的元素</span></span><br><span class="line">            item = (*Py_TYPE(it)-&gt;tp_iternext)(it);</span><br><span class="line">            <span class="comment">// 如果出现了NULL, 证明迭代结束了, 会直接停止</span></span><br><span class="line">            <span class="comment">// 所以会以元素最少的可迭代对象(迭代器)为准</span></span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置在 result 中, 但是要先获取result中原来的元素, 并将其引用计数减1, 因为元组不再持有对它的引用</span></span><br><span class="line">            olditem = PyTuple_GET_ITEM(result, i);</span><br><span class="line">            PyTuple_SET_ITEM(result, i, item);</span><br><span class="line">            Py_DECREF(olditem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话同样的逻辑, 只不过需要自己重新手动申请一个tuple</span></span><br><span class="line">        result = PyTuple_New(tuplesize);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 然后下面的逻辑是类似的</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">            it = PyTuple_GET_ITEM(lz-&gt;ittuple, i);</span><br><span class="line">            item = (*Py_TYPE(it)-&gt;tp_iternext)(it);</span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PyTuple_SET_ITEM(result, i, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回元组 result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以当我们进行迭代的时候，迭代出来的是一个元组。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># (1, 11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使只有一个可迭代对象, 依旧是一个元组, 因为底层返回的result就是一个元组</span></span><br><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># (1,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可迭代对象的嵌套也是一样的规律, 直接把里面的列表看成一个标量即可</span></span><br><span class="line">z = <span class="built_in">zip</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># ([1, 2, 3],)</span></span><br></pre></td></tr></table></figure>

<p><strong>最后，zip 也有一个__reduce__ 方法：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__reduce__())</span><br><span class="line"><span class="comment"># (&lt;class &#x27;zip&#x27;&gt;, (&lt;list_iterator object at 0x0000018D1723B0D0&gt;, &lt;list_iterator object at 0x0000018D1723B040&gt;))</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">tuple</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> z.__reduce__()[<span class="number">1</span>]])  <span class="comment"># [(1, 2, 3), (11, 22, 33)]</span></span><br></pre></td></tr></table></figure>

<h3 id="map、filter-和-列表解析之间的区别"><a href="#map、filter-和-列表解析之间的区别" class="headerlink" title="map、filter 和 列表解析之间的区别"></a>map、filter 和 列表解析之间的区别</h3><p><strong>其实在使用 map、filter 的时候，我们完全可以使用列表解析来实现。比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> lst])  <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, lst)))  <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>这两者之间实际上是没有什么太大区别的，都是将 lst  中的元素一个一个迭代出来、然后调用 str 、返回结果。如果非要找出区别话，就是列表解析使用的是 Python  的for循环，而调用list的时候使用的是C中的for循环。从这个角度来说，使用 map 的效率会更高一些。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193830267-1530099100.png" alt="img"></p>
<p><strong>所以后者的效率稍微更高一些，因为列表解析用的是 Python 的for循环，<code>list(map(func, iter))</code> 用的是C的for循环。但是注意：如果是下面这种做法的话，会得到相反的结果。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193834669-1119332528.png" alt="img"></p>
<p><strong>我们看到 map 貌似变慢了，其实原因很简单，后者多了一层匿名函数的调用，所以速度变慢了。</strong></p>
<p><strong>如果列表解析也是函数调用的话：</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193841219-1119337106.png" alt="img"></p>
<p><strong>会发现速度更慢了，当然这种做法完全是吃饱了撑的。之所以说这些，是想说明在同等条件下，list(map)  这种形式是要比列表解析快的。当然在工作中，这两者都是可以使用的，这点效率上的差别其实不用太在意，如果真的到了需要在乎这点差别的时候，那么你应该考虑的是换一门更有效率的静态语言。</strong></p>
<p><strong>filter 和 列表解析之间的差别，也是如此。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193847064-600779731.png" alt="img"></p>
<p><strong>对于过滤含有 1000个 False 和 1个True  的元组，它们的结果都是一样的，但是谁的效率更高呢？首先第一种方式 肯定比  第二种方式快，因为第二种方式涉及到函数的调用；但是第三种方式，我们知道它在底层会走单独的分支，所以再加上之前的结论，我们认为第三种方式是最快的。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193853552-1339478062.png" alt="img"></p>
<p><strong>结果也确实是我们分析的这样，当然我们说在底层 None 和 bool  都会走相同的分支，所以这里将 None 换成 bool 也是可以的。虽然 bool 是一个类，但是通过 filter_new  函数我们知道，底层不会进行调用，也是直接使用 PyObject_IsTrue，可以将 None 换成 bool 看看结果如何，应该是差不多的。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193858542-1189251065.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>所以 map、filter 完全可以使用列表解析替代，如果执行的逻辑比较复杂的话，那么对于 map、filter 而言就要写匿名函数了。但逻辑简单的话，比如：获取为真的元素，完全可以通过<code>list(filter(None, lst))</code>实现，效率更高，因为它走的是相当于是C的循环；但如果获取大于3的元素，那么就需要使用<code>list(filter(lambda x: x &gt; 3, lst))</code>这种形式了，而我们说它的效率是不如列表解析<code>[x for x in lst if x &gt; 3]</code>的，因为前者多了一层函数调用。</strong></p>
<p><strong>但是在工作中，这两种方式都是可以的，使用哪一种就看个人喜好。到此我们发现，如果排除那一点点效率上的差异，那么确实有列表解析式就完全足够了，因为列表解析式可以同时实现 map、filter 的功能，而且表达上也更加地直观。只不过是 map、filter 先出现，然后才有的列表解析式，但是前者依旧被保留了下来。</strong></p>
<blockquote>
<p><strong>当然 map、filter 返回的是一个可迭代对象，它不会立即计算，可以节省资源；当然这个功能，我们也可以通过生成器表达式来实现。</strong></p>
</blockquote>
<p><strong>map、filter、zip 的底层实现我们就看完了，是不是很简单呢？</strong></p>
<blockquote>
<p><strong>另外，如果你得到的结论和我这里的不一致，那么不妨把可迭代对象的元素个数设置的稍微大一些，最终结论和我这里一定是一样的。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>30-源码解密内置函数 iter、next</title>
    <url>/2023/04/26/30-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-iter%E3%80%81next/</url>
    <content><![CDATA[<h2 id="30-源码解密内置函数-iter、next"><a href="#30-源码解密内置函数-iter、next" class="headerlink" title="30-源码解密内置函数 iter、next"></a>30-源码解密内置函数 iter、next</h2><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p><strong>这次我们来看看 iter 和 next 这两个内置函数的用法，我们知道 iter 是将一个可迭代对象变成一个迭代器，next 是将迭代器里的值一步一步迭代出来。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(it)  <span class="comment"># &lt;list_iterator object at 0x000001DC6E898640&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用next, 可以对迭代器进行迭代</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：iter 还有一个鲜为人知的用法，我们来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> val</span><br><span class="line">    val += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># iter可以接收一个参数: iter(可迭代对象)</span></span><br><span class="line"><span class="comment"># iter可以接收两个参数: iter(可调用对象, value)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">iter</span>(foo, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行迭代的时候, 会不停的调用内部接收的 可调用对象</span></span><br><span class="line"><span class="comment"># 直到返回值等于传递第二个参数 value(在底层被称为哨兵), 然后终止迭代</span></span><br></pre></td></tr></table></figure>

<p><strong>当然 next 函数也有一个特殊用法，就是它在接收一个迭代器的时候，还可以指定一个默认值；如果元素迭代完毕之后再次迭代的话，不会抛出StopIteration，而是会返回默认值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it, <span class="string">&quot;xxx&quot;</span>))  <span class="comment"># xxx</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it, <span class="string">&quot;yyy&quot;</span>))  <span class="comment"># yyy</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：iter 内部接收可迭代对象的类型不同，那么得到的迭代器种类也不同。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(<span class="string">&quot;xyz&quot;</span>))  <span class="comment"># &lt;str_iterator object at 0x00000234493B8640&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))  <span class="comment"># &lt;tuple_iterator object at 0x00000234493B8640&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># &lt;list_iterator object at 0x00000234493B8640&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="iter-函数底层实现"><a href="#iter-函数底层实现" class="headerlink" title="iter 函数底层实现"></a>iter 函数底层实现</h2><p><strong>我们看一下 iter 函数底层是如何实现的，其实之前已经见识过了，还想的起来吗？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin_iter</span><span class="params">(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// iter函数要么接收一个参数, 要么接收两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!_PyArg_CheckPositional(<span class="string">&quot;iter&quot;</span>, nargs, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    v = args[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 如果接收一个参数, 那么直接使用 PyObject_GetIter 获取对应的迭代器即可</span></span><br><span class="line">    <span class="comment">// 在这个函数中, 可迭代对象的类型不同, 那么得到的迭代器也不同</span></span><br><span class="line">    <span class="keyword">if</span> (nargs == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> PyObject_GetIter(v);</span><br><span class="line">    <span class="comment">// 如果接收的不是一个参数, 那么一定是两个参数</span></span><br><span class="line">    <span class="comment">// 如果是两个参数, 那么第一个参数一定是可调用对象</span></span><br><span class="line">    <span class="keyword">if</span> (!PyCallable_Check(v)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;iter(v, w): v must be callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取value(哨兵)</span></span><br><span class="line">    PyObject *sentinel = args[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 调用PyCallIter_New, 得到一个可调用的迭代器, calliterobject 对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    位于 Objects/iterobject.c 中</span></span><br><span class="line"><span class="comment">    typedef struct &#123;</span></span><br><span class="line"><span class="comment">        PyObject_HEAD</span></span><br><span class="line"><span class="comment">        PyObject *it_callable; </span></span><br><span class="line"><span class="comment">        PyObject *it_sentinel; </span></span><br><span class="line"><span class="comment">	&#125; calliterobject;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> PyCallIter_New(v, sentinel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以核心就在于 *PyObject_GetIter* 中，它是根据可迭代对象生成迭代器的关键，那么它都做了哪些事情呢？不用想肯定是执行：<code>obj.__iter__()</code>，当然更准确的说应该是：<code>type(obj).__iter__(obj)</code>，我们来看一下。该函数定义在 *Objects&#x2F;abstract.c* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GetIter</span><span class="params">(PyObject *o)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 获取该可迭代对象的类型对象</span></span><br><span class="line">    PyTypeObject *t = Py_TYPE(o);</span><br><span class="line">    <span class="comment">// 我们说类型对象的方法和属性 决定了 实例对象的行为, 实例对象调用的那些方法都是属于类型对象的</span></span><br><span class="line">    <span class="comment">// 还是那句话 obj.func()  等价于  type(obj).func(obj)</span></span><br><span class="line">    getiterfunc f;</span><br><span class="line">    <span class="comment">// 所以这里是获取类型对象的 tp_iter成员, 也就是Python中的 __iter__</span></span><br><span class="line">    f = t-&gt;tp_iter;</span><br><span class="line">    <span class="comment">// 如果 f 为 NULL, 说明该类型对象内部的 tp_iter 成员被初始化为NULL, 即内部没有定义 __iter__ 方法</span></span><br><span class="line">    <span class="comment">// 像str、tuple、list等类型对象, 它们的 tp_iter 成员都是不为NULL的</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 tp_iter 为 NULL, 那么解释器会退而求其次, 检测该类型对象中是否定义了 __getitem__, 我们后面会介绍</span></span><br><span class="line">        <span class="comment">// 如果定义了, 那么直接调用PySeqIter_New, 得到一个 seqiterobject 对象, 我们在上一篇博客介绍过的</span></span><br><span class="line">        <span class="comment">// PySequence_Check 里面的逻辑就是检测类型对象是否初始化了 tp_as_sequence-&gt;sq_item 成员, 它对应 __getitem__</span></span><br><span class="line">        <span class="keyword">if</span> (PySequence_Check(o))</span><br><span class="line">            <span class="keyword">return</span> PySeqIter_New(o);</span><br><span class="line">        <span class="comment">// 走到这里说明该类型对象的实例对象不具备可迭代的性质, 抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">&quot;&#x27;%.200s&#x27; object is not iterable&quot;</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话, 直接进行调用, Py_TYPE(o)-&gt;tp_iter(o)</span></span><br><span class="line">        PyObject *res = (*f)(o);</span><br><span class="line">        <span class="comment">// 如果返回值 res 不为NULL, 并且它还不是一个迭代器, 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span> &amp;&amp; !PyIter_Check(res)) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">&quot;iter() returned non-iterator &quot;</span></span><br><span class="line">                         <span class="string">&quot;of type &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                         Py_TYPE(res)-&gt;tp_name);</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">            res = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 res</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到这便是 iter 函数的底层实现，里面我们提到了 __getitem__。我们说如果类型对象内部没有定义 __iter__，那么解释器会退而求其次检测内部是否定义了 __getitem__。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;参数item: <span class="subst">&#123;item&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 内部定义了 __getitem__, 首先可以让实例对象像字典一样</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 参数item: name</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;夏色祭&quot;</span>])  <span class="comment"># 参数item: 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还可以像迭代器一个被for循环</span></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(val)</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">参数item: 0</span></span><br><span class="line"><span class="string">参数item: 1</span></span><br><span class="line"><span class="string">参数item: 2</span></span><br><span class="line"><span class="string">参数item: 3</span></span><br><span class="line"><span class="string">参数item: 4</span></span><br><span class="line"><span class="string">参数item: 5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到循环的时候会自动给item传值, 这个值是0 1 2 3...., 因此这个循环是无限的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.names = [<span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;神乐七奈&quot;</span>, <span class="string">&quot;夜空梅露&quot;</span>, <span class="string">&quot;雫_るる&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            val = self.names[item]</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration  <span class="comment"># 让for循环结束</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">神乐七奈</span></span><br><span class="line"><span class="string">夜空梅露</span></span><br><span class="line"><span class="string">雫_るる</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 当出现 StopIteration 异常的时候, 再次循环时传递的item会被重置为0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(g))  <span class="comment"># [&#x27;夏色祭&#x27;, &#x27;神乐七奈&#x27;, &#x27;夜空梅露&#x27;, &#x27;雫_るる&#x27;]</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">lst.extend(g)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;夏色祭&#x27;, &#x27;神乐七奈&#x27;, &#x27;夜空梅露&#x27;, &#x27;雫_るる&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>以上被称为解释器的退化功能，就是在找不到某个实现的时候，会进行退化、尝试寻找其它实现。类似的做法还有其它，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当进行布尔判断的时候, 会尝试获取内部 __bool__ 方法的返回值</span></span><br><span class="line"><span class="comment"># 如果没有定义 __bool__, 那么解释器会退化尝试寻找 __len__ 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(A()))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>如果内部定义了 __iter__，则直接调用即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果type(obj)内部定义了__iter__, 那么iter(obj)  &lt;==&gt;  type(obj).__iter__(obj)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__iter__(<span class="string">&quot;123&quot;</span>))  <span class="comment"># &lt;str_iterator object at 0x00000213CC2A8640&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.__iter__([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># &lt;list_iterator object at 0x00000213CC2A8640&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>.__iter__((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))  <span class="comment"># &lt;tuple_iterator object at 0x00000213CC2A8640&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>.__iter__(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))  <span class="comment"># &lt;set_iterator object at 0x00000213CC478E80&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="next函数底层实现"><a href="#next函数底层实现" class="headerlink" title="next函数底层实现"></a>next函数底层实现</h2><p><strong>了解 iter 之后，我们再来看看 next 函数；如果内部定义了 <strong>next</strong> 函数，那么不用想，结果肯定是<code>type(obj).__next__(obj)</code>，我们看一下底层实现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin_next</span><span class="params">(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *it, *res;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同样接收一个参数或者两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!_PyArg_CheckPositional(<span class="string">&quot;next&quot;</span>, nargs, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    it = args[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 第一个参数必须是一个迭代器, 也就是类型对象的tp_iternext成员不能为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!PyIter_Check(it)) &#123;</span><br><span class="line">        <span class="comment">// 否则的话, 抛出TypeError, 表示第一个参数传递的不是一个迭代器</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">            <span class="string">&quot;&#x27;%.200s&#x27; object is not an iterator&quot;</span>,</span><br><span class="line">            it-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    列表对应的迭代器是: listiterobject, 其类型为: PyListIter_Type</span></span><br><span class="line"><span class="comment">    元组对应的迭代器是: tupleiterobject, 其类型为: PyTupleIter_Type</span></span><br><span class="line"><span class="comment">    字符串对应的迭代器是: unicodeiterobject, 其类型为: PyUnicodeIter_Type</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 通过 ob_type 获取对应的类型对象, 然后获取成员 tp_iternext 的值, 相当于__next__</span></span><br><span class="line">    <span class="comment">// 再传入迭代器进行迭代</span></span><br><span class="line">    res = (*it-&gt;ob_type-&gt;tp_iternext)(it);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 res 不为 NULL, 那么证明迭代到值了, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nargs &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则的话, 看nargs是否大于1, 如果大于1, 说明设置了默认值</span></span><br><span class="line">        PyObject *def = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 出现异常的话, 将异常清空</span></span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!PyErr_ExceptionMatches(PyExc_StopIteration))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加引用计数, 并返回</span></span><br><span class="line">        Py_INCREF(def);</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PyErr_SetNone(PyExc_StopIteration);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还是比较简单的，我们以 列表 对应的迭代器为例，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="comment"># 对应的类型是list_iterator, 但在底层我们知道类型是PyListIter_Type</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(it))  <span class="comment"># &lt;class &#x27;list_iterator&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后迭代</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(it).__next__(it))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(it).__next__(it))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(it).__next__(it))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上就等价于 next(it), 但是我们知道内置函数 next 要更强大一些, 因为它还可以做一些其它处理</span></span><br><span class="line"><span class="comment"># 当然默认情况下, 和 type(it).__next__(it) 最终是殊途同归的</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很简单呢？</strong></p>
<p><strong>我们看到一个变量 obj 不管指向什么可迭代对象，都可以交给  iter，得到对应的迭代器；不管什么迭代器，都可以交给 next 进行迭代。原因就在于它们接收的不是对象本身，而是对象对应的 PyObject  * 泛型指针。不管你是谁的指针，只要你指向的对象是一个可迭代对象，那么都可以交给 iter。至于 next  也是同理，不管你指向的是哪一种迭代器，只要是迭代器，就可以交给 next，然后会自动调用迭代器内部的 __next__（底层是  tp_iternext）将值给迭代出来。所以这是不是相当于实现了多态呢？所以这就是 Python  的设计哲学，变量只是一个指针，传递变量的时候相当于传递指针（将指针拷贝一份），但是操作一个变量的时候会自动操作变量（指针）指向的内存。比如：a &#x3D; 12345; b &#x3D; a，相当于把 a 拷贝了一份给 b，但 a 是一个指针，所以此时 a 和 b  保存的地址是相同的，也就是指向了同一个对象。但 a + b 的时候则不是两个指针相加、而是将 a、b  指向的对象进行相加，也就是操作变量会操作变量指向的内存。因此在 Python 中，说传递方式是值传递或者引用传递都是不准确的，应该是****变量之间的赋值传递，对象之间的引用传递。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>33-为什么 obj == obj 为 False、[obj] == [obj] 为 True</title>
    <url>/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/</url>
    <content><![CDATA[<h2 id="33-为什么-obj-x3D-x3D-obj-为-False、-obj-x3D-x3D-obj-为-True"><a href="#33-为什么-obj-x3D-x3D-obj-为-False、-obj-x3D-x3D-obj-为-True" class="headerlink" title="33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True"></a>33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>今天同事在用 pandas 做数据处理的时候，不小心被 nan 坑了一下，他当时被坑的原因类似下面：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.nan == np.nan)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>([np.nan] == [np.nan])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为了严谨，我们再举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 == a1, a2 == a2)  <span class="comment"># False False</span></span><br><span class="line"><span class="built_in">print</span>([a1, a2] == [a1, a2])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会出现这个结果呢？我们知道两个列表（元组也是同理）如果相等，那么首先列表里面的元素个数要相同、并且相同索引对应的元素也要相等。但问题是这里的 a1 不等于 a1、a2 也不等于 a2，那为啥 [a1, a2] 和 [a1, a2] 就相等了呢？</strong></p>
<p><strong>其实原因很好想，那就是 Python  解释器在比较两个列表中的元素的时候，会先比较它们的引用的对象的地址是否相等，也就是看它们是否引用了同一个对象，如果是同一个对象，那么直接得到  True，然后比较下一个，如果不是同一个对象，那么再比较对应的值是否相同。所以这里 a1 &#x3D;&#x3D; a1 明明返回  False，但是放在列表中就变成了 True，原因就在于它们引用的是同一个对象。</strong></p>
<p><strong>那么下面就来从解释器源代码的角度来验证这一结论（版本为 3.9.0），其实后续涉及到的内容在之前就已经说过了，只不过因为比较简单就一笔带过了，所以这次就针对这个例子专门分析一下。</strong></p>
<h3 id="Python-的列表之间是如何比较的"><a href="#Python-的列表之间是如何比较的" class="headerlink" title="Python 的列表之间是如何比较的"></a>Python 的列表之间是如何比较的</h3><p><strong>要想知道底层是如何比较的，那么最好的办法就是先看一下字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;[] == []&quot;</span></span><br><span class="line">dis.dis(<span class="built_in">compile</span>(code, <span class="string">&quot;&lt;file&gt;&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 BUILD_LIST               0</span></span><br><span class="line"><span class="string">              2 BUILD_LIST               0</span></span><br><span class="line"><span class="string">              4 COMPARE_OP               2 (==)</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>第一列：表示源代码的行号，我们这里只有一行代码。</strong></p>
<p><strong>第二列：表示指令的偏移量，每一条指令都占两个字节，第一个字节存放指令序列本身，第二个字节存放指令所需要的参数。所以指令从上到下的偏移量是 0 2 4 6 8 ……。</strong></p>
<p><strong>第三列：表示指令序列，在 C 中就是一个宏，会被替换为一个整数。Python 底层总共定义 120 多个指令序列，可以在 *Include&#x2F;opcode.h* 头文件中查看。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134015525-325179387.png" alt="img"></p>
<p><strong>第四列：表示指令参数。</strong></p>
<p><strong>所以开头的两个 BUILD_LIST 表示构建列表，后面的指令参数表示元素个数，因为是空列表，所以为 0。两个列表构建完毕显然就要进行比较了，因此指令序列是 COMPARE_OP，而后面的指令参数是 2，代表啥含义呢？</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134026508-902648107.png" alt="img"></p>
<p><strong>COMPARE_OP  表示比较，但是比较也分为：小于、小于等于、等于、不等于、大于、大于等于，那么到底是哪一种呢？显然要通过指零参数给出，而这里指定的是等于，所以指令参数是 2。至于指令参数后面的 (&#x3D;&#x3D;) 则是 dis 模块帮你添加的，告诉你该指令参数的含义，方便理解。</strong></p>
<p><strong>因此我们的关注点就在 COMPARE_OP 这条指令序列对应的实现当中，而 Python 底层的指令序列对应的实现都位于 *Python&#x2F;ceval.c* 中，在里面有一个 _PyEval_EvalFrameDefault 函数，以栈帧（PyFrameObject）为单位。该函数里面有一个无限的 for  循环，会不断地循环取出字节码中每一条指令序列和指令参数进行执行，直到将该栈帧内部的字节码全部执行完毕，然后退出循环。因此执行逻辑也是在这个  for 循环里面的，没错，for 循环里面有一个巨型的 switch，每一个指令序列都对应一个 case 语句，所以这个 switch 里面有  120 多个 case 语句，然后不同的指令序列走不同的 case，因此 _PyEval_EvalFrameDefault  这个函数非常长，总共多达 3000 行。</strong></p>
<p><strong>那么下面我们就来看看 COMPARE_OP 对应的指令实现，不过这里多提一句：不光是列表，其它对象进行比较的时候对应的指令序列也是 COMPARE_OP。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134035158-926311510.png" alt="img"></p>
<p><strong>我们来分析一下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(COMPARE_OP)</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里的 oparg 表示的就是指令参数，显然它和指令序列（opcode）在进入 switch 语句之前就已经被获取</span></span><br><span class="line">    <span class="comment">// 然后这里断言 oparg 必须要小于等于 Py_GE，因为比较操作符中最大的就是 Py_GE，而我们这里是 ==，所以 oparg 的值等于 2</span></span><br><span class="line">    assert(oparg &lt;= Py_GE);</span><br><span class="line">    <span class="comment">// BUILD_LIST 构建的两个列表（指针）会被压入运行时栈，然后这里再将其获取</span></span><br><span class="line">    <span class="comment">// 当然这里只是以列表为例，但我们说进行比较的不一定是列表，可以是任意对象</span></span><br><span class="line">    <span class="comment">// 因此 right 就是比较操作符（我们这里是 ==）右边的变量，left 就是左边的变量</span></span><br><span class="line">    PyObject *right = POP();  <span class="comment">// 元素会从栈中弹出</span></span><br><span class="line">    PyObject *left = TOP();   <span class="comment">// 注意这里是 TOP()，不是 POP()，所以操作符左边的变量还留在栈里面</span></span><br><span class="line">    <span class="comment">// 调用 PyObject_RichCompare，传入 left、right、oparg 进行调用，得到返回结果 res</span></span><br><span class="line">    <span class="comment">// 显然具体的比较逻辑就在 PyObject_RichCompare 里面</span></span><br><span class="line">    PyObject *res = PyObject_RichCompare(left, right, oparg);</span><br><span class="line">    <span class="comment">// 用 res 将栈顶的元素替换掉，所以操作符左边的变量不需要从栈里面弹出，直接将结果与之替换即可</span></span><br><span class="line">    <span class="comment">// 最后再返回</span></span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    PREDICT(POP_JUMP_IF_FALSE);</span><br><span class="line">    PREDICT(POP_JUMP_IF_TRUE);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里涉及到了运行时栈，具体细节就不再赘述了，总之运行时栈是必不可少的，因为 Python 的指令只能有一个指令参数，但是 PyObject_RichCompare 函数需要三个参数，因此其它的参数只能通过运行时栈给出。</strong></p>
<p><strong>我们这里只需要知道，Python 中的比较，在底层会调用 PyObject_RichCompare 函数即可：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a == b  <span class="comment"># PyObject_RichCompare(a, b, Py_EQ)</span></span><br><span class="line">a &gt;= b  <span class="comment"># PyObject_RichCompare(a, b, Py_GE)</span></span><br><span class="line">a != b  <span class="comment"># PyObject_RichCompare(a, b, Py_NE)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>下面来看看 PyObject_RichCompare 里面的逻辑，该函数藏身于 *Objects&#x2F;object.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_RichCompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;   <span class="comment">// 参数 v 就是上面的 left、w 就是 right、op 就是 oparg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取线程状态对象，这里不需要关注</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    <span class="comment">// 0 &lt;= op &lt;= 5</span></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="comment">// 如果有一方为 NULL，则调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            PyErr_BadInternalCall();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 _Py_EnterRecursiveCall 和结尾的 _Py_LeaveRecursiveCall 会成对出现，主要是用于递归比较的，举个栗子</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a = [None]</span></span><br><span class="line"><span class="comment">        a.append(a)</span></span><br><span class="line"><span class="comment">        print(a)  # [None, [...]]</span></span><br><span class="line"><span class="comment">        print(a[1][1][1][1][1][1][1][1][1][1])  # [None, [...]]</span></span><br><span class="line"><span class="comment">        print(a[1][1][1][1][1][1][1][1][1][0])  # None</span></span><br><span class="line"><span class="comment">        print(a == a)  # True</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 显然 a 后面无论接多少个 [1] 都是合法的，因此就意味着要无限地比较下去，而 Python 显然不会允许这种情况发生</span></span><br><span class="line">    <span class="comment">// 因此这一步就是为了应对这种情况出现</span></span><br><span class="line">    <span class="keyword">if</span> (_Py_EnterRecursiveCall(tstate, <span class="string">&quot; in comparison&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 do_richcompare，得到返回结果</span></span><br><span class="line">    PyObject *res = do_richcompare(tstate, v, w, op);</span><br><span class="line">    _Py_LeaveRecursiveCall(tstate);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到 PyObject_RichCompare 里面也不是真正负责执行比较逻辑的，该函数相当于做了一些检测，而比较的结果是调用 do_richcompare 得到的，显然我们需要到这个函数中查看，该函数同样位于 *Objects&#x2F;object.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">do_richcompare</span><span class="params">(PyThreadState *tstate, PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// richcmpfunc f 相当于声明一个比较函数，因为 Python 将每个比较操作都抽象成了一个魔法方法，比如：__ge__、__eq__ 等等</span></span><br><span class="line">    <span class="comment">// 虽然在 Python 中不同的比较操作对应不同的魔法方法，但底层对应的都是 PyTypeObject 的 tp_richcompare 成员</span></span><br><span class="line">    <span class="comment">// 该成员负责所有的比较操作，至于到底是哪一种，则由参数来控制</span></span><br><span class="line">    <span class="comment">/* 因此我们看到具体的比较逻辑，还是定义在对应的类对象中</span></span><br><span class="line"><span class="comment">       比如：</span></span><br><span class="line"><span class="comment">           list 对象的比较逻辑定义在 PyList_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           tuple 对象的比较逻辑定义在 PyTuple_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           Dict 对象的比较逻辑定义在 PyDict_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           Set 对象的比较逻辑定义在 PySet_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    richcmpfunc f;</span><br><span class="line">    <span class="comment">// 用于存储比较之后的结果</span></span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="type">int</span> checked_reverse_op = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Py_TYPE(obj) 表示获取 obj 的类型；</span></span><br><span class="line"><span class="comment">       Py_IS_TYPE(obj, cls) 则是判断 obj 的类型是否为 cls</span></span><br><span class="line"><span class="comment">       PyType_IsSubtype(cls1, cls2) 负责判断 cls1 是否是 cls2 的子类</span></span><br><span class="line"><span class="comment">       所以下面 if 语句的含义就是：当 v 和 w 的类型不同、并且 w 的类型是 v 的类型的子类、</span></span><br><span class="line"><span class="comment">       并且 w 的类型对象内部的 tp_richcompare 成员不为 NULL，然后走这个分支。</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       直接说的话，可能不是很好解释这个 if 语句到底在做什么，我们可以用一个 Python 测试用例解释一下：</span></span><br><span class="line"><span class="comment">       class A:</span></span><br><span class="line"><span class="comment">           def __eq__(self, other):</span></span><br><span class="line"><span class="comment">               return &quot;A&quot;</span></span><br><span class="line"><span class="comment">       class B(A):</span></span><br><span class="line"><span class="comment">           def __eq__(self, other):</span></span><br><span class="line"><span class="comment">               return &quot;B&quot;</span></span><br><span class="line"><span class="comment">       print(A() == B())  # B</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       我们知道默认情况下，如果操作符左边的两个对象之间没有任何关系，那么比较的时候优先会找操作符左边的对象的魔法方法</span></span><br><span class="line"><span class="comment">       所以如果 B 不继承 A，也就是 A 和 B 自己没有任何关系，那么按照优先级，A() == B() 就会返回字符串 &quot;A&quot;</span></span><br><span class="line"><span class="comment">       但如果操作符 &quot;右侧的对象的类对象&quot; 是 &quot;左侧的对象的类对象&quot; 的子类，那么这个规则就会被打破</span></span><br><span class="line"><span class="comment">       解释器就会执行操作符右侧的对象的魔法方法，所以这里 B 继承 A，A() == B() 返回了字符串 &quot;B&quot;</span></span><br><span class="line"><span class="comment">       这个 if 语句就是来干这件事的，因此这里的 f 等于 Py_TYPE(w)-&gt;tp_richcompare</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!Py_IS_TYPE(v, Py_TYPE(w)) &amp;&amp;</span><br><span class="line">        PyType_IsSubtype(Py_TYPE(w), Py_TYPE(v)) &amp;&amp;</span><br><span class="line">        (f = Py_TYPE(w)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        checked_reverse_op = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 会取出 w 对应的 tp_richcompare，将参数传递进去，进行调用</span></span><br><span class="line">        <span class="comment">// 其中 _Py_SwappedOp[op] 是负责将 op 以宏的形式传递，比如 op 是 2，那么 _Py_SwappedOp[op] 就是 Py_EQ，不过结果也是 2</span></span><br><span class="line">        <span class="comment">// 调用之后将结果保存起来</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="comment">/* 然后这里对 res 有一个判断，它是做什么的呢？</span></span><br><span class="line"><span class="comment">        首先我们上面说了，==、!=、&gt;=、&lt;=、&lt;、&gt; 在 Python 中对应不同的魔法方法</span></span><br><span class="line"><span class="comment">        但在底层解释器的角度而言，对应的都是类型对象的 tp_richcompare</span></span><br><span class="line"><span class="comment">        至于底层执行这个函数的时候，到底执行哪一个比较操作，则是由参数控制</span></span><br><span class="line"><span class="comment">        比如我们上面实现了 __eq__，意味着 tp_richcompare 不为 NULL，那么进行比较的时候毫无疑问肯定会走这个分支</span></span><br><span class="line"><span class="comment">        但如果我们执行的不是 A() == B()，而是 A() != B()，那么这里的 res 就返回 Py_NotImplemented</span></span><br><span class="line"><span class="comment">        因为 A 和 B 内部都没有定义 __ne__，因此 tp_richcompare 内部也就不包含处理比较操作为 != 时的逻辑</span></span><br><span class="line"><span class="comment">        所以这个分支一定会走，但返回的 res 会等于 Py_NotImplemented</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="comment">// 返回了 res，并且不等于 Py_NotImplemented，才会返回</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是上面那种情况，那么就看 v 是否定义了相应的魔法方法，也就是 Py_TYPE(v) 的 tp_richcompare 成员是否不为 NULL</span></span><br><span class="line">    <span class="comment">// 如果有的话就取出，然后传递参数进行调用，其它逻辑类似</span></span><br><span class="line">    <span class="keyword">if</span> ((f = Py_TYPE(v)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = (*f)(v, w, op);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 Py_TYPE(v) 的 tp_richcompare 成员为 NULL，或者 res 为 Py_NotImplemented</span></span><br><span class="line">    <span class="comment">// 就意味着在 Python 的层面，操作符左边的对象内部没有定义该操作符对应的魔法方法（可能定义了别的）</span></span><br><span class="line">    <span class="comment">// 那么此时会去看操作符右侧的对象内部是否有相应的魔法方法，所以这里会看 Py_TYPE(w) 的 tp_richcompare 是否不为 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!checked_reverse_op &amp;&amp; (f = Py_TYPE(w)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 走到这里说明，要么上面的三个 if 分支一个都没有通过，即操作两边的对象的内部都没有定义任何关于比较操作的魔法方法</span></span><br><span class="line"><span class="comment">    或者通过了，但返回的 res 等于 Py_NotImplemented，也就是定义了比较操作的魔法方法，</span></span><br><span class="line"><span class="comment">    但是当前执行的操作符对应的魔法方法没有实现 */</span></span><br><span class="line">    <span class="comment">// 不过对于 Python 而言，== 和 != 是永远不会报错的，所以还要检测操作符是不是 == 或 !=</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">/* 尽管指定的操作符没有实现，但如果操作符是 == 或者 !=，也就是 op 为 Py_EQ 或者 Py_NE 时</span></span><br><span class="line"><span class="comment">    那么就比较两个对象的内存地址，比如 class A: pass</span></span><br><span class="line"><span class="comment">    A 里面没有实现任何的魔法方法，但 a = A(); a == a 就是 True，因为对象的内存地址是一样的</span></span><br><span class="line"><span class="comment">    这里说明一下，Python 中的变量在 C 的层面就是一个泛型指针（PyObject *），它存储的不是对象（PyObject），而是对象的地址</span></span><br><span class="line"><span class="comment">    变量在传递的时候会传递地址，但是在操作一个变量时会自动操作变量指向的内存</span></span><br><span class="line"><span class="comment">    所以在判断两个变量是否指向同一个对象的时候（相当于 is），在 C 的层面只需要比较两个指针是否相等即可</span></span><br><span class="line"><span class="comment">    而在比较两个变量指向的对象是否相等（也就是 == ），那么会将两个变量指向的对象所维护的值取出来，调用 PyObject_RichCompare 进行比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        <span class="comment">// 这里的 v 和 w 显然就相当于 Python 中的变量，就是一个指针</span></span><br><span class="line">        <span class="comment">// 因此判断两个变量是否指向同一个对象，直接判断这两个指针存的地址是否相等即可</span></span><br><span class="line">        res = (v == w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        res = (v != w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果比较操作符不是 == 或者 !=，那么就不好意思了，这两个实例之间不允许执行当前的比较操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                      <span class="string">&quot;&#x27;%s&#x27; not supported between instances of &#x27;%.100s&#x27; and &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                      opstrings[op],</span><br><span class="line">                      Py_TYPE(v)-&gt;tp_name,</span><br><span class="line">                      Py_TYPE(w)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加引用计数，返回</span></span><br><span class="line">    Py_INCREF(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上就是 do_richcompare 的逻辑，它里面干了哪些事情呢？我们说里面三个 if 语句，主要用于确定到底该执行谁的魔法方法，比如 A 和 B 的实例进行比较：</strong></p>
<ul>
<li><code>1. 如果 A 和 B 是不同的类、并且 B 还是 A 的子类，那么 &quot;A() 操作符 B()&quot; 会优先去 B 中查找操作符对应的魔法方法</code></li>
<li><code>2. 否则的话，会按照优先级，先找 A（操作符左边）的魔法方法</code></li>
<li><code>3. 如果左边没有，那么就最后再找右边</code></li>
</ul>
<p><strong>如果成功执行则直接返回，否则的话再对操作符进行判定，如果是 &#x3D;&#x3D; 或者 !&#x3D; ，那么就比较两个对象是否是同一个对象。</strong></p>
<p><strong>虽然花了一定的笔墨解释完了比较操作在底层的逻辑，但是我们上面的问题本质上依旧没有得到解决，我们还是不知道列表是如何比较的。因为很明显，比较的核心在于类型对象的 tp_richcompare 中，它返回的结果就是这里的 res，所以如果我们想知道列表是如何比较的，那么就去 PyList_Type  的 tp_richcompare 成员中查看即可。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134048797-1008013922.png" alt="img"></p>
<p><strong>而 PyList_Type 的 tp_richcompare 成员对应的是 list_richcompare 函数，我们来看一下，其藏身于 *Objects&#x2F;listobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_richcompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;    </span><br><span class="line">    PyListObject *vl, *wl;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">// v 和 w 一定是 PyListObject *</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(v) || !PyList_Check(w))</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    <span class="comment">// 将 PyObject * 转成 PyListObject *</span></span><br><span class="line">    vl = (PyListObject *)v;</span><br><span class="line">    wl = (PyListObject *)w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快分支：如果两个列表连长度都不相等，那么当比较操作符是 == 或 != 的时候可以直接出结果</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(vl) != Py_SIZE(wl) &amp;&amp; (op == Py_EQ || op == Py_NE)) &#123;</span><br><span class="line">        <span class="comment">// op 是 ==，返回 False</span></span><br><span class="line">        <span class="comment">// op 是 !=，返回 True</span></span><br><span class="line">        <span class="keyword">if</span> (op == Py_EQ)</span><br><span class="line">            Py_RETURN_FALSE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Py_RETURN_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当列表长度相等，或者操作不是 == 或者 !=，那么就需要将两个列表中的元素进行逐个比较了</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(vl) &amp;&amp; i &lt; Py_SIZE(wl); i++) &#123;</span><br><span class="line">        PyObject *vitem = vl-&gt;ob_item[i];</span><br><span class="line">        PyObject *witem = wl-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">/*我们说 Python 中变量本质上是一个指针，当然不光是变量，列表、元组、字典等容器里面容纳的也是指针</span></span><br><span class="line"><span class="comment">        如果 vitem == witem，说明这两个列表存储的是同一个对象的指针（在 Python 里面也可以说引用）</span></span><br><span class="line"><span class="comment">        所以直接就 continue 了，说明当前位置的两个元素是相等的</span></span><br><span class="line"><span class="comment">        因此我们就解释了在最开始的问题中，为什么 a1 != a1、np.nan != np.nan，但 [a1] == [a1] 和 [np.nan] == [np.nan] 却都是成立的</span></span><br><span class="line"><span class="comment">        再比如 None &gt; None 会报错，但是 [None] &gt; [None] 却不会，原因就在于 None 是单例的，地址相同</span></span><br><span class="line"><span class="comment">        而地址相同，那么就不比了（不管这两个对象能不能比），而是直接看下一个元素 */</span></span><br><span class="line">        <span class="keyword">if</span> (vitem == witem) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        Py_INCREF(vitem);</span><br><span class="line">        Py_INCREF(witem);</span><br><span class="line">        <span class="comment">/*当不是同一个对象时，那就比较对象维护的值是否相同，这里又出现了一个 PyObject_RichCompareBool</span></span><br><span class="line"><span class="comment">        它在底层会调用之前说的 PyObject_RichCompare，只不过在调用之前会先检测对象的地址是否相同</span></span><br><span class="line"><span class="comment">        如果是同一个对象，并且操作符是 ==、!=，那么会直接根据对象的地址判断</span></span><br><span class="line"><span class="comment">        如果不是同一个对象，或者操作符不是 == 或者 !=，再调用 PyObject_RichCompare 比较对象维护的值之间的关系，</span></span><br><span class="line"><span class="comment">        此外该函数返回的是整型，为真返回 1、为假返回 0，报错了返回 -1 */</span></span><br><span class="line">        <span class="type">int</span> k = PyObject_RichCompareBool(vitem, witem, Py_EQ);</span><br><span class="line">        Py_DECREF(vitem);</span><br><span class="line">        Py_DECREF(witem);</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 为假直接 break，否则继续下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> (!k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个列表如果长度不相等，那么不断遍历的话，肯定有一方先结束</span></span><br><span class="line">    <span class="comment">// 下面逻辑就是处理长度不相等的情况，比较简单，可以自己看一下</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Py_SIZE(vl) || i &gt;= Py_SIZE(wl)) &#123;</span><br><span class="line">        <span class="comment">/* No more items to compare -- compare sizes */</span></span><br><span class="line">        Py_RETURN_RICHCOMPARE(Py_SIZE(vl), Py_SIZE(wl), op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have an item that differs -- shortcuts for EQ/NE */</span></span><br><span class="line">    <span class="keyword">if</span> (op == Py_EQ) &#123;</span><br><span class="line">        Py_RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == Py_NE) &#123;</span><br><span class="line">        Py_RETURN_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compare the final item again using the proper operator */</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_RichCompare(vl-&gt;ob_item[i], wl-&gt;ob_item[i], op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此到这里我们才算真正解释了最开始的问题，在调用  PyObject_RichCompare 进行比较的时候，a1 &#x3D;&#x3D; a1 会走内部的 __eq__，而在里面返回的 False。而 [a1]  &#x3D;&#x3D; [a1] 会走列表的 __eq__，而里面在比较元素的时候会先比较地址是否一样，如果一样直接就过了，根本不会走 type(a1) 里面的  __eq__。</strong></p>
<p><strong>Python 中的 in 也是同理，我们知道 a in b 等价于  b.<strong>contains</strong>(a)，逻辑就是不断地对 b 进行迭代，将得到的元素依次和 a 进行比较，如果相等则直接返回  True；如果迭代结束时一直没有找到和 a 相等的元素，那么返回  False。所以逻辑很简单，但我想说的是，这里比较相等的逻辑也会先比较对象的地址是否相同，如果地址相同直接为  True，当地址不同时，才会比较值是否一致。而从底层来看的话，这里的比较会调用 PyObject_RichCompareBool，而我们知道在这个函数里面会先比较地址是否一样，地址不一样再比较维护的值是否一样（调用对应的 __eq__）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 底层调用 PyObject_RichCompare，然后调用 __eq__</span></span><br><span class="line"><span class="built_in">print</span>(a == a)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 底层会调用 PyObject_RichCompareBool，会先判断两者是不是同一个对象</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">in</span> (a,))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">in</span> [a])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是由 nan 引发的一些思考，当然还是比较简单的，因为是一些之前说过的内容。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>32-Python 和 Go 联合编程</title>
    <url>/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="32-Python-和-Go-联合编程"><a href="#32-Python-和-Go-联合编程" class="headerlink" title="32-Python 和 Go 联合编程"></a>32-Python 和 Go 联合编程</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python 可以和 C 无缝结合，通过 C 来为 Python  编写扩展可以极大地提升 Python 的效率，但是使用 C 来编程显然不是很方便，于是本人想到了 Go。对比 C 和 Go  会发现两者非常相似，没错，Go 语言具有强烈的 C 语言背景，其设计者以及语言的设计目标都和 C 有着千丝万缕的联系。因为 Go  语言的诞生就是因为 Google 中的一些开发者觉得 C++ 太复杂了，所以才决定开发一门简单易用的语言，而 Google 的工程师大部分都有 C 的背景，因此在设计 Go 语言的时候保持了 C 语言的风格。</strong></p>
<p><strong>而在 Go 和 C 的交互方面，Go  语言也是提供了非常大的支持（CGO），可以直接通过注释的方式将 C 源代码嵌入在 Go 文件中，这是其它语言所无法比拟的。最初 CGO  是为了能复用 C 资源这一目的而出现的，而现在它已经变成 Go 和 C 之间进行双向通讯的桥梁，也就是 Go 不仅能调用 C  的函数，还能将自己的函数导出给 C 调用。也正因为如此，Python 和 Go 之间才有了交互的可能。因为 Python 和 Go  本身其实是无法交互的，但是它们都可以和 C 勾搭上，所以需要通过 C 充当媒介，来为 Python 和 Go 牵线搭桥。</strong></p>
<p><strong>我们知道 Python 和 C 之间是双向的，也就是可以互相调用，而 Go 和 C 之间也是双向的，那么 Python 和 Go 之间自然仍是双向的。我们可以在 Python 为主导的项目中引入 Go，也可以在 Go  为主导的项目中引入 Python，而对于我本人来说，Python 是我的主语言、或者说老本行，因此这里我只介绍如何在 Python  为主导的项目中引入 Go。</strong></p>
<p><strong>而在 Python 为主导的项目中引入 Go 有以下几种方式：</strong></p>
<ul>
<li><code>将 Go 源文件编译成动态库，然后直接通过 Python 的 ctypes 模块调用</code></li>
<li><code>将 Go 源文件编译成动态库或者静态库，再结合 Cython 生成对应的 Python 扩展模块，然后直接 import 即可</code></li>
<li><code>将 Go 源文件直接编译成 Python 扩展模块，当然这要求在使用 CGO 的时候需要遵循 Python 提供的 C API</code></li>
</ul>
<p><strong>对于第一种方式，使用哪种操作系统无关紧要，操作都是一样的。但是对于第二种和第三种，我只在 Linux 上成功过，当然 Windows 肯定也是可以的，只不过操作方式会复杂一些（个人不是很熟悉）。因此这里我统一使用 Linux  进行演示，下面介绍一下我的相关环境：</strong></p>
<ul>
<li><code>Python 版本：3.6.8，系统自带的 Python，当然 3.7、3.8、3.9 同样是没有问题的（个人最喜欢 3.8）</code></li>
<li><code>Go 版本：1.16.4，一个比较新的版本了，至于其它版本也同样可以</code></li>
<li><code>gcc 版本：4.8.5，系统自带（Windows 系统的话，需要去下载 MingGW）</code></li>
</ul>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172801098-1418721316.png" alt="img"></p>
<p><strong>下面我们来介绍一下上面这几种方式。</strong></p>
<h3 id="Go-源文件编译成动态库"><a href="#Go-源文件编译成动态库" class="headerlink" title="Go 源文件编译成动态库"></a>Go 源文件编译成动态库</h3><p><strong>首先如果 Go 想要编译成动态库给 Python 调用，那么必须启用  CGO 特性，并将想要被 Python 调用的函数导出。而启用 CGO 则需要保证环境变量 CGO_ENABLE 的值设置为  1，在本地构建的时候默认是开启的，但是交叉编译（比如在 Windows 上编译 Linux 动态库）的时候，则是禁止的。</strong></p>
<p><strong>下面来看看一个最简单的 CGO 程序是什么样子的。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你好，古明地觉，我的公主大人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相较于普通的 Go 只是多了一句 import “C”，除此之外没有任何和 CGO 相关的代码，也没有调用 CGO 的相关函数。但是由于这个 import，会使得 go build 命令在编译和链接阶段启动 gcc  编译器，所以这已经是一个完整的 CGO 程序了。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">你好，古明地觉，我的公主大人</span><br></pre></td></tr></table></figure>

<p><strong>直接运行，打印输出。当然我们也可以基于 C 标准库函数来输出字符串：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// C.CString 表示将 Go 的字符串转成 C 的字符串</span></span><br><span class="line">    C.puts(C.CString(<span class="string">&quot;觉大人，你能猜到此刻我在想什么吗&quot;</span>)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可能有人好奇  import “C” 上面那段代码是做什么的，答案是导入 C 中的标准库。我们说 Go 里面是可以直接编写 C 代码的，而 C 代码要通过注释的形式写在 import “C”  这行语句上方（中间不可以有空格，这是规定）。而一旦导入，就可以通过 C 这个名字空间进行调用，比如这里的 C.puts、C.CString  等等。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">觉大人，你能猜到此刻我在想什么吗</span><br></pre></td></tr></table></figure>

<p><strong>至于这里的  import “C”，它不是导入一个名为 C 的包，我们可以将其理解为一个名字空间，C 语言的所有类型、函数等等都可以通过这个名字空间去调用。</strong></p>
<p><strong>最后注意里面的 C.CString，我们说这是将 Go 的字符串转成 C 的字符串，但是当我们不用了的时候它依旧会停留在内存里，所以我们要将其释放掉，具体做法后面会说。但是对于当前这个小程序来说，这样是没有问题的，因为程序退出后操作系统会回收所有的资源。</strong></p>
<p><strong>我们也可以自己定义一个函数：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">void SayWhat(const char *s) &#123;</span></span><br><span class="line"><span class="comment">    puts(s);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 上面也可以写多行注释</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 即便是我们自己定义的函数也是需要通过 C 来调用, 不然的话 go 编译器怎么知道这个函数是 C 的函数还是 go 的函数呢</span></span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;少女觉&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样是可以执行成功的。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">少女觉</span><br></pre></td></tr></table></figure>

<p><strong>除此之外我们还可以将 C 的代码放到单独的文件中，比如：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后 Go 源文件如下：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.c&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;古明地恋&quot;</span>))  <span class="comment">// 古明地恋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接执行即可打印出结果，当然我们会更愿意把 C 函数的声明写在头文件当中，具体实现写在C源文件中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后在 Go 只需要导入头文件即可使用，比如：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;恋，对不起，我爱的是你姐姐&quot;</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重点来了，这个时候如果执行 go run file.go 是会报错的：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">/tmp/go-build24597302/b001/_x002.o：在函数‘_cgo_f2c21e79afe5_Cfunc_SayWhat’中：</span><br><span class="line">/tmp/go-build/cgo-gcc-prolog:49：对‘SayWhat’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>

<p><strong>虽然文件中出现了 #include “1.h”，但是和 1.h  相关的源文件 1.c 则没有任何体现，除非你在go的注释里面再加上 #include  “1.c”，但这样头文件就没有意义了。因此在编译的时候，我们不能对这个具体的 file.go 源文件进行编译；也就是说不要执行 go build file.go，而是要在这个 Go 文件所在的目录直接执行 go build，会对整个包进行编译，此时就可以找到当前目录中对应的 C  源文件了。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go build -o a.out</span></span><br><span class="line">[root@satori go_py]<span class="comment"># ./a.out </span></span><br><span class="line">恋，对不起，我爱的是你姐姐</span><br></pre></td></tr></table></figure>

<p><strong>但是需要注意的是：我当前目录为 &#x2F;root&#x2F;go_py，里面的 Go 文件只有一个 file.go，但如果内部有多个 Go文件的话，那么对整个包进行编译的时候，要确保只能有一个文件有 main 函数。</strong></p>
<blockquote>
<p><strong>另外对于 go1.16 而言，需要先通过 go mod init 来初始化项目，否则编译包的时候会失败。</strong></p>
</blockquote>
<h3 id="Go-导出函数给-Python-调用"><a href="#Go-导出函数给-Python-调用" class="headerlink" title="Go 导出函数给 Python 调用"></a>Go 导出函数给 Python 调用</h3><p><strong>上面算是简单介绍了一下 CGO 以及 Go 如何调用 C 函数，但是 Go 调用 C 函数并不是我们的重点，我们的重点是 Go 导出函数给 Python 使用。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayWhat</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayWhat</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">    <span class="comment">// C.GoString 是将 C 的字符串转成 Go 的字符串</span></span><br><span class="line">    fmt.Println(C.GoString(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这个main函数我们不用, 但是必须要写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到函数上面有一行注释：&#x2F;&#x2F;export  SayWhat，这一行注释必须要有，即 &#x2F;&#x2F;export 函数名。并且该注释要和函数紧挨着，之间不能有空行，而它的作用就是将 SayWhat  函数导出，然后 Python 才可以调用，如果不导出的话，Python 会调用不到的。而且导出的时候是 C 函数的形式导出的，因为 Python 和 Go 交互需要 C 作为媒介，因此导出函数的参数和返回值都必须是 C 的类型。</strong></p>
<blockquote>
<p><strong>导出函数的名称不要求首字母大写，小写的话依旧可以导出。</strong></p>
</blockquote>
<p><strong>最后是 main 函数，这个 main 函数也是必须要有的，尽管里面可以什么都不写，但是必须要有，否则编译不通过。然后我们来将这个文件编译成动态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build -buildmode=c-shared -o 动态库 [go源文件 go源文件 go源文件 ...]</span><br></pre></td></tr></table></figure>

<p><strong>以当前的 file.go 为例：gcc build -buildmode&#x3D;c-shared -o libgo.so file.go，如果是对整个包编译，那么不指定 go源文件即可。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go build -buildmode=c-shared -o libgo.so file.go</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我们将 file.go 编译成动态库 libgo.so，然后 Python 来调用一下试试。</strong></p>
<blockquote>
<p><strong>在 Linux 上，动态库的后缀名为 .so；在 Windows  上，动态库的后缀名为 .dll。而 Python 的扩展模块在 Linux 上的后缀名也为 .so，在 Windows 上的的后缀名则是  .pyd（pyd 也可以看做是 dll）。因此我们发现所谓 Python 扩展模块实际上就是对应系统上的一个动态库，如果是遵循标准  Python&#x2F;C API 的 C 源文件生成的动态库，Python 解释器是可以直接识别的，我们可以通过 import  导入；但如果不是，比如我们上面刚生成的 libgo.so，或者 Linux 自带的大量动态库，那么我们就需要通过 ctypes 的方式加载了。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;芙兰朵露&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;雾雨魔理沙&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">古明地觉</span></span><br><span class="line"><span class="string">芙兰朵露</span></span><br><span class="line"><span class="string">雾雨魔理沙</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到成功打印了，那么打印是哪里来的呢？显然是 Go 里面的 fmt.Println。</strong></p>
<p><strong>以上就实现了 Go 导出 Python 函数给 Python 调用，但是很明显这还不够，我们还需要能够传递参数、以及获取返回值。而想要实现这一点，我们必须要了解一下不同语言之间类型的对应关系。</strong></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>在 Go 语言中访问 C 语言的符号时，一般是通过虚拟的 “C”  包访问，比如 C.int 对应 C 语言的 int 类型。但有些 C 语言的类型是由多个关键字组成，而通过虚拟的 “C” 包访问 C  语言类型时名称部分不能有空格字符，比如 unsigned int 不能直接通过 C.unsigned int 访问，这是不合法的。因此 CGO 为 C 语言的基础数值类型都提供了相应转换规则，比如 C.uint 对应 C 语言的 unsigned int。</strong></p>
<p><strong>Go 语言中数值类型和 C 语言数据类型基本上是相似的，以下是它们的对应关系表。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20201104000443585-817470338.png" alt="img"></p>
<p><strong>数值类型虽然有很多，但是整型我们直接使用 long、浮点型使用 double 即可，另外我们在 Go 中定义的函数名不可以和 C 中的关键字冲突。</strong></p>
<p><strong>下面我们举个栗子演示一下：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export Int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(val C.long)</span></span> C.long &#123;</span><br><span class="line">    <span class="comment">// C 的整型可以直接和 Go 的整型相加</span></span><br><span class="line">    <span class="comment">// 但前提是个常量，如果是变量，那么需要使用 C.long 转化一下</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="comment">// Go 对类型的要求很严格，这里需要转化，但如果是 val + 1 是可以的，因为 1 是个常量</span></span><br><span class="line">    <span class="keyword">return</span> val + C.long(a) </span><br><span class="line">    <span class="comment">// 这里函数不能起名为 int，因为 int 是 C 中的关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Double</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span><span class="params">(val C.double)</span></span> C.double &#123;</span><br><span class="line">    <span class="comment">// 对于浮点型也是需要转化，但如果是常量，也可以直接相加</span></span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">2.2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export boolean</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boolean</span><span class="params">(val C._Bool)</span></span> C._Bool &#123;</span><br><span class="line">    <span class="comment">// 接收一个 bool 类型，true 返回 false，false 返回 true</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="type">bool</span>(val)</span><br><span class="line">    <span class="keyword">return</span> C._Bool(!flag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Char</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Char</span><span class="params">(val C.char)</span></span> C.char &#123;</span><br><span class="line">    <span class="comment">// 接收一个字符，进行大小写转化</span></span><br><span class="line">    <span class="keyword">return</span> val ^ <span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 函数必须要有</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重新编译生成动态库，交给 Python 调用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意: Python 在获取返回值的时候，默认都是按照整型解析的，如果 Go 的导出函数返回的不是整型，那么再按照整型解析的话必然会出问题</span></span><br><span class="line"><span class="string">因此我们需要在调用函数之前指定返回值的类型，我们这里调用类 CDLL 返回的就是动态库, 假设里面有一个 xxx 函数, 返回了一个 cgo 中的 C.double</span></span><br><span class="line"><span class="string">那么我们就需要在调用 xxx 函数之前, 通过 go_ext.xxx.restype = c_double 提前指定返回值的类型, 这样才能获取正常的结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为默认是按照整型解析的，所以对于返回整型的函数我们无需指定返回值类型，当然指定的话也是好的</span></span><br><span class="line"><span class="built_in">print</span>(libgo.Int(c_long(<span class="number">123</span>)))  <span class="comment"># 124</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Float 函数，接收一个浮点数，然后加上 2.2 返回</span></span><br><span class="line">libgo.Double.restype = c_double</span><br><span class="line"><span class="built_in">print</span>(libgo.Double(c_double(<span class="number">2.5</span>)))  <span class="comment"># 4.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># boolean: 接收一个布尔值, 返回相反的布尔值</span></span><br><span class="line">libgo.boolean.restype = c_bool</span><br><span class="line"><span class="built_in">print</span>(libgo.boolean(c_bool(<span class="literal">True</span>)))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(libgo.boolean(c_bool(<span class="literal">False</span>)))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Char: 接收一个字符，然后进行大小写转换</span></span><br><span class="line">libgo.Char.restype = c_char</span><br><span class="line"><span class="built_in">print</span>(libgo.Char(c_char(<span class="number">97</span>)))  <span class="comment"># b&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(libgo.Char(c_char(<span class="string">b&#x27;v&#x27;</span>)))  <span class="comment"># b&#x27;V&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很简单呢？</strong></p>
<p><strong>我们在生成 libgo.so 的同时，还会自动帮我们生成一个 libgo.h，在里面会为 Go 语言的字符串、切片、字典、接口和管道等特有的数据类型生成对应的 C 语言类型：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172901991-935228913.png" alt="img"></p>
<p><strong>不过需要注意的是，其中只有字符串和切片在 CGO  中有一定的使用价值，因为二者可以直接被 C 和 Python 调用。但是 CGO 并未针对其它的类型提供相关的辅助函数，且 Go  语言特有的内存模型导致我们无法保持这些由 Go 语言管理的内存指针，所以它们在编写动态库给 Python 调用这一场景中并无使用价值，比如  channel，这东西在 Python 里面根本没法用，还有 Map 也是同样道理。</strong></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>字符串可以说是用的最为频繁了，而且使用字符串还需要考虑内存泄漏的问题，至于为什么会有内存泄漏以及如何解决它后面会说，目前先来看看如何操作字符串。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export unicode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unicode</span><span class="params">(val *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 将 C 的字符串转成 Go 的字符串, 可以使用 C.GoString</span></span><br><span class="line">    <span class="keyword">var</span> s = C.GoString(val)</span><br><span class="line">    s += <span class="string">&quot;古明地觉&quot;</span></span><br><span class="line">    <span class="comment">//然后转成 C 的字符串返回, 字符串无论是从 Go 转 C, 还是 C 转 Go, 都是拷贝一份</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还是调用 go build -buildmode&#x3D;c-shared -o libgo.so file.go 将其编译成动态库，然后 Python 进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">go_ext = CDLL(<span class="string">r&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># unicode: 接收一个 c_char_p，返回一个 c_char_p，注意 c_char_p 里面的字符串要转成字节</span></span><br><span class="line">go_ext.unicode.restype = c_char_p</span><br><span class="line"><span class="comment"># 调用函数返回的也是一个字节，我们需要再使用 utf-8 转回来</span></span><br><span class="line"><span class="built_in">print</span>(go_ext.unicode(c_char_p(<span class="string">&quot;我永远喜欢🍺&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 我永远喜欢🍺古明地觉</span></span><br></pre></td></tr></table></figure>

<p><strong>同理我们也可以修改传递的字符串，当然与其说修改，倒不如说仍是重新创建一份。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export char_array</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">char_array</span><span class="params">(arr *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 转成 Go 的 string 之后，我们还需要转成 rune，不然无法修改，因为有的字符需要三字节</span></span><br><span class="line">    r := []<span class="type">rune</span>(C.GoString(arr))</span><br><span class="line">    r[<span class="number">3</span>] = <span class="string">&#x27;恋&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="type">string</span>(r))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译之后给 Python 调用：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">go_ext = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">go_ext.char_array.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    go_ext.char_array(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 古明地恋</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里必须要保证至少传递长度为 4 的字符串, 因为在 go 中我们有一个 r[3] = &#x27;恋&#x27; 的操作</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>字符串操作基本上使用 C.GoString 和 C.CString 就足够了，但是正如我们之前说的，C.CString 存在着内存泄漏问题，后面会解决它。</strong></p>
</blockquote>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>结构体应该算是 Go 中最重要的成员了吧，但是 Go 的结构体是不能作为导出函数的参数或返回值的，我们需要使用C中的结构体。</strong></p>
<blockquote>
<p><strong>如果尝试导出一个参数或返回值为 Go 的结构体的函数，那么会报错：<code>Go type not supported in export: struct</code></strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">    char *type;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 对于结构体来说, 不要使用 typedef 的方式, 而是直接使用 struct xxx&#123;&#125; 的方式定义, 那么 Go 便可以通过 C.struct_xxx 的方式来访问这个结构体</span></span><br><span class="line"><span class="comment">// 至于为什么要这么写, 我也不知道, 大概这是 Go 的设计原则吧</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(g C.struct_Girl)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 这里的结构体就可以通过C.struct_Girl来访问</span></span><br><span class="line">    name := C.GoString(g.name)</span><br><span class="line">    age := <span class="type">int</span>(g.age)</span><br><span class="line">    gender := C.GoString(g.gender)</span><br><span class="line">    <span class="comment">// type 是 Go 语言中的关键字, 那么访问的时候需要在前面加上一个下划线</span></span><br><span class="line">    _type := C.GoString(g._type)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;名字: %s 年龄: %d 性别: %s 类型: %s&quot;</span>, name, age, gender, _type))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于 Python 而言，我们看看如何在 Python 中创建一个结构体：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;type&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libgo.test_struct.restype = c_char_p</span><br><span class="line">g = Girl(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_long(<span class="number">16</span>),</span><br><span class="line">         c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_char_p(<span class="string">&quot;高冷&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(libgo.test_struct(g).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 名字: 古明地觉 年龄: 16 性别: 女 类型: 高冷</span></span><br></pre></td></tr></table></figure>

<p><strong>还是比较简单的，只不过定义变量的时候最好不要和关键字冲突。但是 Go  给我们提供了一个隐形的转化方式，即便我们在 C 中定义的变量和 Go  关键字冲突了，也可以通过在变量前面加上一个下划线的方式访问。那么问题来了，如果有两个成员：一个成员以 Go  语言关键字命名，另一个成员以下划线加上相同的关键字命名，那么以关键字命名的成员将无法访问（被屏蔽）。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">    int   type;   // type 是 Go 语言的关键字</span></span><br><span class="line"><span class="comment">    float _type;  // 将屏蔽 CGO 对 type 成员的访问</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到参数只能是 C 的结构体，那么 Go 的结构体就无法使用了吗？答案不是的，只要 Go 的结构体不作为导出函数的参数或者返回值就可以。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个结构体</span></span><br><span class="line"><span class="keyword">type</span> Girl1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="type">string</span></span><br><span class="line">    age    <span class="type">int</span></span><br><span class="line">    gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Girl2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   *C.char</span><br><span class="line">    age    C.long</span><br><span class="line">    gender *C.char</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct1</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 当然，这里有点多此一举了</span></span><br><span class="line">    g := Girl1&#123;C.GoString(name), <span class="type">int</span>(age), C.GoString(gender)&#125;</span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;你的名字: %s 你的年龄: %d 你的性别: %s&quot;</span>, g.name, g.age, g.gender))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct2</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> *C.char &#123;</span><br><span class="line">    g := Girl2&#123;name, age, gender&#125;</span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;你的名字: %s 你的年龄: %d 你的性别: %s&quot;</span>, C.GoString(g.name), C.long(g.age), C.GoString(g.gender)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后交给 Python 来访问：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">libgo.test_struct1.restype = c_char_p</span><br><span class="line">libgo.test_struct2.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.test_struct1(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">                        c_long(<span class="number">16</span>),</span><br><span class="line">                        c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 你的名字:古明地觉 年龄: 16 性别: 女</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.test_struct2(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">                        c_long(<span class="number">16</span>),</span><br><span class="line">                        c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 你的名字:古明地觉 年龄: 16 性别: 女</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 Python 依旧可以正常调用，两个结构体成员的类型可以是 Go 的类型、也可以是 C 的类型，区别就是需要类型转化的地方不同罢了。Go  中的结构体，它没有作为参数和返回的话是可以正常使用的，但是一旦作为参数或者返回值就不可以了，因为 Go 不允许我们这么做，所以我们只能使用 C  中的结构体。</strong></p>
<h5 id="返回一个结构体"><a href="#返回一个结构体" class="headerlink" title="返回一个结构体"></a>返回一个结构体</h5><p><strong>下面来看看如何返回一个结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> C.struct_Girl &#123;</span><br><span class="line">    g := C.struct_Girl&#123;name, age, gender&#125;</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 调用的话依旧很简单：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定返回值类型</span></span><br><span class="line">libgo.test_struct.restype = Girl</span><br><span class="line">g = libgo.test_struct(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)), c_long(<span class="number">16</span>), c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(g.name.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"><span class="built_in">print</span>(g.age)  <span class="comment"># 16</span></span><br><span class="line"><span class="built_in">print</span>(g.gender.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 女</span></span><br></pre></td></tr></table></figure>

<h5 id="传入结构体指针"><a href="#传入结构体指针" class="headerlink" title="传入结构体指针"></a>传入结构体指针</h5><p><strong>结构体指针我们也是可以传递的，举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(g *C.struct_Girl)</span></span>&#123;</span><br><span class="line">    g.name = C.CString(<span class="string">&quot;古明地恋&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 Python 中创建一个结构体传进去，然后值会被修改：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">g = Girl(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_long(<span class="number">16</span>),</span><br><span class="line">         c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">libgo.test_struct(pointer(g))</span><br><span class="line"><span class="built_in">print</span>(g.name.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地恋</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：传递一个指针可以，但是返回一个指针不行。因为 Go  语言是类型安全的，比如一个变量究竟该分配在堆上、还是分配在栈上，Go  编译器会进行逃逸分析，是否返回指针便是决定一个变量究竟分配在什么地方的一个主要因素。而一旦返回指针给其他语言，那么 Go  就无法决定这块内存究竟何时该被回收，所以 Go 中不允许返回指针。而且对于 Python 来讲，Go 返回一个值还是指针，对于 Python  而言几乎没什么区别，无非是获取的方式不一样。所以我们不会在 Go 中返回一个指针，但是传递一个指针是可以的。</strong></p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p><strong>函数是 C 语言编程的核心，通过 CGO 技术我们不仅仅可以在 Go 语言中调用 C 语言函数，也可以将 Go 语言函数导出为 C 语言函数。对于一个启用 CGO 特性的程序，CGO 会构造一个虚拟的 C 包，通过这个虚拟的 C 包可以调用 C 语言函数。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int add(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(C.add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这一点我们之前就见过了，但是 Go 文件里面的 C 函数不仅可以让 Go  自身调用，还可以交给 Python 调用。Go 文件里面的 C 函数和使用 export 导出的 Go 函数（导出之后就变成了 C  函数）是等价的，都是可以被 Python 调用的，我们还是对该文件进行编译得到动态库。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">r&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h5 id="Python-向-C-传递函数"><a href="#Python-向-C-传递函数" class="headerlink" title="Python 向 C 传递函数"></a>Python 向 C 传递函数</h5><p><strong>Python 不能直接向 Go 的导出函数中传递函数，我们需要在里面定义一个 C 的函数，Python 只能向 C 的函数中传递函数。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int add(int a, int b, int (*f)(int *, int *))&#123;</span></span><br><span class="line"><span class="comment">  return f(&amp;a, &amp;b);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面的 add 接收两个整型和一个函数指针，这个函数指针指向的函数接收两个 int *，我们依旧实现两个数相加。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接库中的函数接收的函数的参数是两个 int *，所以我们这里的 a 和 b 也是一个 pointer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 调用 pointer.contents 可以得到 C 的变量, 在调用 value 属性可以获取对应值(Python中的)</span></span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们把 C 中的函数用 Python 表达了, 但是这样肯定是不可能直接传递的, 能传就见鬼了</span></span><br><span class="line"><span class="comment"># 那我们要如何转化呢?</span></span><br><span class="line"><span class="comment"># 可以通过 ctypes 里面的函数 CFUNCTYPE 转化一下, 这个函数接收任意个参数</span></span><br><span class="line"><span class="comment"># 但是第一个参数是函数的返回值类型, 然后函数的参数写在后面, 有多少写多少。</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 int, 接收两个 int *, 所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值, 那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t, 此时的类型 t 就等同于 C 中的 typedef int (*t)(int*, int*);</span></span><br><span class="line"><span class="comment"># 将我们的函数传进去，就得到了 C 语言可以识别的函数 func</span></span><br><span class="line">func = t(add)</span><br><span class="line"><span class="comment"># 然后调用, 别忘了定义返回值类型, 当然这里是 int（long同理）就无所谓了</span></span><br><span class="line">libgo.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">88</span>, <span class="number">97</span>, func))</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">59</span>, <span class="number">55</span>, func))</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">94</span>, <span class="number">105</span>, func))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">184</span></span><br><span class="line"><span class="string">114</span></span><br><span class="line"><span class="string">199</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然如果函数比较复杂的话，或者内容比较多的话，我们还可以分成多个源文件来写。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*function)</span> <span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, function)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, function f)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时 Go 源文件的代码就变得简单了；</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后编译成动态库就不要加上文件名了，直接 <code>go build -buildmode=c-shared -o libgo.so</code> 对整个目录进行编译。那么 Python 可不可以调用呢？我们试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line">func = t(add)</span><br><span class="line">libgo.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">11</span>, <span class="number">22</span>, func))  <span class="comment"># 33</span></span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">22</span>, <span class="number">33</span>, func))  <span class="comment"># 55</span></span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">33</span>, <span class="number">44</span>, func))  <span class="comment"># 77</span></span><br></pre></td></tr></table></figure>

<p><strong>不仅如此，我们还可以直接使用 Go 中的导出函数作为 C 函数中的一个参数，我们的 .h 和 .c 文件都不变，只修改一下 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a *C.<span class="type">int</span>, b *C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们在 Go 文件中定义相应的函数，不在 Python 中定义了，然后 Python 直接调用：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.add(c_int(<span class="number">101</span>), c_int(<span class="number">202</span>), libgo.f))  <span class="comment"># 303</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>再来看看如何操作数组，这里操作的数组只能是 C 中的数组，因为在 Go 里面不允许导出一个参数或返回值是数组的函数。最关键的是，Go 数组的表达能力没有 C 数组那么丰富。</strong></p>
<blockquote>
<p><strong>在 Go 里面数组的长度也是类型的一部分，这一点完全限制了数组的表达能力。而 C 中的数组类型与长度无关，比如在 C 的结构体中声明一个长度为 1 的数组，但是我们可以把它当成长度为 n 的数组来用。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int sum(int *arr, int size) &#123;</span></span><br><span class="line"><span class="comment">    // 传递一个数组，里面全部是 int 类型，我们把它们加在一起</span></span><br><span class="line"><span class="comment">    // 由于数组在作为参数传递的时候会退化为指针，所以我们不知道数组有多少个元素，因此还必须要指定个数</span></span><br><span class="line"><span class="comment">    int i = 0, values = 0;</span></span><br><span class="line"><span class="comment">    for (; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        values += *(arr + i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return values;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来在 Python 中构建一个数组：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (c_int * n) 便是一个长度为 n 的 int 数组类型</span></span><br><span class="line"><span class="comment"># 然后通过类似于函数调用的方式，得到数组</span></span><br><span class="line">v = (c_int * <span class="number">4</span>)(<span class="number">13212</span>, <span class="number">211</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.<span class="built_in">sum</span>(v, <span class="number">4</span>))  <span class="comment"># 13478</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">13212</span> + <span class="number">211</span> + <span class="number">22</span> + <span class="number">33</span>)  <span class="comment"># 13478</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>需要注意的是，数组的类型一定要正确，我们之前说对于整数而言，long 和  int 实际上没有太大差别。如果一个函数接收的是 long，那么我们传递一个 int  也是可以的，反之亦然（只要都存的下，不会溢出即可）。但是对于数组而言就不行了，函数中接收的数组里面的元素是 int，我们也必须要传递  int，否则指针在移动的时候会出问题。</strong></p>
</blockquote>
<p><strong>我们往 C 里面传递一个数组是没有问题的，因为内存是在 Python  中申请的，C 拿到的只是一个指针罢了。但是我们不能在 C 中构建一个数组然后返回，因为如果 C  中返回了一个数组，那么它要么是静态数组、要么是堆上申请的数组。但是问题来了，这些数组的内存最终由谁来释放？Python  显然是无能为力的，更何况这些 C 代码还嵌套在 Go 里面。</strong></p>
<p><strong>尽管 C 无法返回一个数组，但是可以对我们传递的数组进行修改。或者说先创建一个普通数组，然后把内容再拷贝到我们传递的数组中，函数结束后 C 中的数组再被释放掉。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int modify_arr(int *arr, int size) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int i = 0, values = 0;</span></span><br><span class="line"><span class="comment">    for (; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        *(arr + i) += 100;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们将传递过来的数组里面的元素都加上 100：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">v = (c_int * <span class="number">6</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 此时 v 内部的元素就被修改了，而且该数组是 Python 创建的，与 C 无关，因此不需要担心内存泄露的问题</span></span><br><span class="line">libgo.modify_arr(v, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 我们将其转成 ndarray</span></span><br><span class="line"><span class="comment"># 参数一：shape</span></span><br><span class="line"><span class="comment"># dtype：元素类型</span></span><br><span class="line"><span class="comment"># buffer：缓冲区，这里的 v</span></span><br><span class="line"><span class="comment"># order：数组是 C 连续还是 Fortran 连续，这里显然是 C 连续，因为是 C 的数组</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">6</span>,), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))  <span class="comment"># [101 102 103 104 105 106]</span></span><br><span class="line"><span class="comment"># 当然我们在获取的时候也可以改变形状</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">2</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[101 102]</span></span><br><span class="line"><span class="string"> [103 104]</span></span><br><span class="line"><span class="string"> [105 106]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们这里的缓冲区当中有 6 个元素，但是 shape 是 3 行 1 列，所以只拿前三个元素构建 shape 为 (3, 1) 的数组</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">1</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[101]</span></span><br><span class="line"><span class="string"> [102]</span></span><br><span class="line"><span class="string"> [103]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 但是注意：我们指定的元素个数不能超过缓冲区的大小</span></span><br><span class="line"><span class="comment"># 下面表示构建 3 X 3 的数组，也就是有 9 个元素，但是这里的缓冲区中只有 6 个元素</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">3</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>)) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    print(np.ndarray((3, 3), dtype=c_int, buffer=v, order=&quot;C&quot;))</span></span><br><span class="line"><span class="string">TypeError: buffer is too small for requested array</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是 Python 向 C 传递数组，例子比较简单。</strong></p>
<p><strong>但是问题来了，此时貌似压根就没有 Go 什么事情，因为里面根本就没有涉及到 Go。原因就是 Go 无法导出一个参数或者返回值为 Go 数组的函数（由于数组的长度也是类型的一部分，导致灵活性也大大降低），并且我们也不能像 C 一样声明一个 arr *C.int、然后把 arr 当成数组使用，这是不允许的，在 Go 里面该 arr  只能是一个指向整型的指针。于是可能有人想到了切片，在 Go 里面切片可以作为导出函数的参数或返回值，但是 Go  里面的切片比较特殊、它本质上是一个结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 传递一个数组过来的话，我们在操作的时候可能会出问题。我们先举个栗子看看 Go 自身访问是什么情况：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    header := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    data := header.Data</span><br><span class="line">    <span class="comment">// 相当于访问第 3 个元素</span></span><br><span class="line">    fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(data + <span class="number">2</span>*unsafe.Sizeof(<span class="number">0</span>))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s []C.<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    header := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    data := header.Data</span><br><span class="line">    <span class="comment">// 相当于访问第 3 个元素</span></span><br><span class="line">    fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(data + <span class="number">2</span>*unsafe.Sizeof(C.<span class="type">int</span>(<span class="number">0</span>)))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    s2 := []C.<span class="type">int</span>&#123;C.<span class="type">int</span>(<span class="number">1</span>), C.<span class="type">int</span>(<span class="number">2</span>), C.<span class="type">int</span>(<span class="number">3</span>), C.<span class="type">int</span>(<span class="number">4</span>)&#125;</span><br><span class="line"></span><br><span class="line">    test1(s1)  <span class="comment">// 3</span></span><br><span class="line">    test2(s2)  <span class="comment">// 17179869187</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到对于 Go 的 int 而言，结果是正常的，但是对于 C.int 却得到了一个乱七八糟的脏数据。Go 自身访问会得到错误数据，如果是作为导出函数让 Python 访问，那么首先会报错，并且解释器还会异常退出。</strong></p>
<p><strong>那么我们能不能直接通过下标的方式来访问呢？答案是：在 Go 里面是可以的，因为 Go 的导出函数接收的是一个切片，只要我们也传递切片即可。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export sum_slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum_slice</span><span class="params">(s []C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    sum := C.<span class="type">int</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        sum += s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(sum_slice([]C.<span class="type">int</span>&#123;C.<span class="type">int</span>(<span class="number">11</span>), C.<span class="type">int</span>(<span class="number">22</span>), C.<span class="type">int</span>(<span class="number">33</span>), C.<span class="type">int</span>(<span class="number">44</span>)&#125;))  <span class="comment">// 110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但如果这个函数给 Python 调用的话，会产生如下后果：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172915360-1571851068.png" alt="img"></p>
<p><strong>我们看到会出现段错误，此时解释器会直接异常退出，不是使用异常捕获能解决的了的问题。原因就在于操作了一个无效的内存地址，Go 不会出问题是因为它接收的是切片、传递的也是切片，而 Python 传递的是一个数组，对于 Go 而言切片和数组是不同的。</strong></p>
<p><strong>结论：我们可以传递一个数组，但只能向 C 的函数传递，因为 Go 的导出函数的参数或返回值不能是 Go 数组。也不要试图使用切片，很容易造成段错误。</strong></p>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><strong>我们目前的做法是将 Go 的函数导出给 Python  使用，因此就会受到很多限制，比如不能返回指针等等。原因就是我们之前说的，Go 是一个类型安全的语言，一旦返回指针之后给 Python 使用，那么 Go 编译器就无法把控该指针指向的变量的声明周期了。举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_pointer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_pointer</span><span class="params">()</span></span> *C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a C.<span class="type">int</span> = <span class="number">123</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(return_pointer())  <span class="comment">// 0xc00001c084</span></span><br><span class="line">    fmt.Println(*return_pointer()) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到 return_pointer 返回了一个指针，但是在 Go  里面使用是没有任何问题的，原因就是 Go 编译器会进行逃逸分析，或者说此时对函数的调用仍然是发生在 Go 里面。只要是在 Go  里面，那么编译器就能牢牢地把控，可一旦交给 Python 使用，就意味着它要独立于 Go 了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="comment"># 指定返回值的类型为整型指针</span></span><br><span class="line">libgo.return_pointer.restype = POINTER(c_int)</span><br><span class="line">libgo.return_pointer()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172925972-2134322710.png" alt="img"></p>
<p><strong>Python 在调用导出函数的时候直接就异常了，告诉我们 Go  的导出函数中返回了一个指针，所以 Python 在和 Go 交互的时候是会受到很多限制的。但是 C 和 Go  交互的时候是没有限制的，不仅可以返回指针，而且还可以通过 C 来为 Go 创建一个超过 2GB 的切片。因为 Go  的切片是有大小限制的，不能超过 2 GB，但是我们可以通过 C 的 malloc 申请超过 2 GB 的内存，然后再转成 Go 的切片。</strong></p>
<p><strong>Go 和 C 之间的访问是很自由的，主要是 Go  编译器能够把握全局，然而一旦导出函数给别的语言使用，Go 编译器就鞭长莫及了。所以 Python 在访问 Go  的时候才会有这么多限制，毕竟两门语言的内存模型不同，当同一段内存被跨语言操作时肯定会非常危险，因此对于 Go  这种类型安全的语言压根就不允许访问一个返回指针的导出函数。</strong></p>
<p><strong>但我们之前返回一个 *C.char  为什么可以呢？原因就是我们调用了 C.CString，此时返回的字符串是在 C 中申请的，所以它可以返回。而像  var a C.int  这种，此时 a 的内存是在 Go 里面被申请的，因此我们不能返回 &amp;a。举个栗子，如果我们返回字符串不是调用 C.CString  的话，看看会有什么后果：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">var</span> s = []<span class="type">byte</span>(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> (*C.char)(unsafe.Pointer(&amp;s[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(C.GoString(return_string()))  <span class="comment">// 古明地觉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>假设我们有一个切片，那么我们可以直接将底层数组的地址返回转成 * C.char 返回，注意：此时 C 字符串和 Go 的底层数组之间是共享内存的，因此省去了开销。</strong></p>
<p><strong>但是这个 return_string 不可以给 Python  调用，因为我们将切片对应的底层数组的地址返回了。换句话说内存依旧是在 Go 里面申请的，而我们返回了指向该内存的指针，所以 Python  调用的话依旧会出现 panic: runtime error: cgo result has Go pointer。</strong></p>
<blockquote>
<p><strong>不要试图返回一个指向 Go 申请的内存的指针给 Python。</strong></p>
</blockquote>
<p><strong>问题来了，我们之前就说 C.CString 存在一个巨大的缺陷， 那就是返回的字符串是 C 在堆区申请的，那么这个字符串最后要由谁来释放？</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们给 Python 来调用：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.return_string(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 古明地觉你好呀</span></span><br></pre></td></tr></table></figure>

<p><strong>这种做法看似没有问题，虽然结果也是正确的，但是却有一个重大的隐患。因为在返回 C 的字符串之后，Python 会拷贝得到一份 bytes 对象，但问题是这个 C  字符串它是不会主动释放的。假设我们的字符串比较长，而且是在一个不间断的服务中调用 Go 编写的动态库，那么后果是很严重的。我们将 Python  的代码改一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    libgo.return_string(c_char_p((<span class="string">&quot;古明地觉&quot;</span> * <span class="number">100</span>).encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>你会发现，内存没一会就被占满了，执行的时候可以通过 top 命令看到内存使用率蹭蹭的网上长。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172940005-912620905.png" alt="img"></p>
<p><strong>而导致这一点的原因就是返回的 C 字符串没有被释放，每一次执行都会创建这么一个字符串。因此我们一定要将其释放掉，释放的方式是使用 free，但问题是这个 free 要如何使用？下面这种做法可以吗？</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    <span class="comment">// 先使用变量保存</span></span><br><span class="line">    res := C.CString(s1)</span><br><span class="line">    <span class="comment">// 然后通过 C.free 释放, 但是需要导入 stdlib 这个库（完全就像写 C 语言一样）</span></span><br><span class="line">    <span class="comment">// 但是 C.free 接收一个 void *，我们需要调用一下 unsafe.Pointer</span></span><br><span class="line">    C.free(unsafe.Pointer(res))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果你编译成动态库之后让 Python 调用的话，你会发现解释器得不到正确结果，而且有可能会异常退出，原因就是我们在将字符串返回给 Python 之前，就已经将其回收了，那么 Python 拿到的就是一块非法的内存。</strong></p>
<p><strong>因此正确的做法是：先正常返回，Python 在获取到值之后 Go  再将其释放掉，不过这样就又产生了一个问题：那就是地址要如何保存。因为必须要确保 Python 能够获取字符串（意味着 Go 中导出的执行函数的  return 语句结束，显然此时该函数也已经结束），然后再将 C 字符串销毁，所以我们肯定还需要一个函数，这个函数接收一个地址、然后专门用来对 C 字符串进行释放。</strong></p>
<p><strong>那么又回到了开始的问题，地址怎么办？由谁来保存，思考一下不难发现应该由  Go 负责保存。因为 Python 获取结果的时候，实际上也是将 C 的字符串拷贝一份得到 Python 的 bytes 对象，因此在  Python 中你是拿不到相应的地址的，使用 id 查看得到也是 Python 对象的地址。所以解决办法是我们可以在 Go  中使用一个全局变量专门负责保存地址，举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address unsafe.Pointer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res := C.CString(s1)</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存, 注意这里是 res、不是 &amp;res, 因为 res 本身就是个 C 中的char *, 因此不能再取 &amp;, 否则反而会出问题</span></span><br><span class="line">    address = unsafe.Pointer(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export release_memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">release_memory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 释放 C 字符串所占内存</span></span><br><span class="line">    <span class="keyword">if</span> address != <span class="literal">nil</span> &#123;</span><br><span class="line">        C.free(address)</span><br><span class="line">        address = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们使用 Python 来进行测试，看看是否有效：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="comment"># 指定返回值的类型为整型指针</span></span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.return_string(c_char_p(<span class="string">b&quot;komeiji satori&quot;</span>)).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># komeiji satori你好呀</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    libgo.return_string(c_char_p((<span class="string">&quot;古明地觉&quot;</span> * <span class="number">10000</span>).encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    libgo.release_memory()</span><br></pre></td></tr></table></figure>

<p><strong>此时不管持续多长时间，内存都不会有太大变化，证明该方法是有效的。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173053033-1833359267.png" alt="img"></p>
<p><strong>如果我们将 libgo.release_memory()  给注释掉的话，那么会发现内存使用率再度蹭蹭往上涨。所以对于那些需要回收的数据，我们就可以通过这种方式来释放，每调用一次就释放一次即可。对于数值类型我们无需担心，我们只需要关注字符串即可，至于结构体，如果里面包含 char *，那么同样需要考虑字符串的释放问题，但是不建议返回这种复杂的数据结构。</strong></p>
<p><strong>因此我们更关心字符串，因为它非常容易造成内存泄漏，那么什么时候应该进行回收呢？答案是：如果是使用 C.CString 返回的字符串，我们是一定要进行回收的；如果看一下上面的 Go 代码的话，你会发现参数是一个 char * 类型的变量  s，那么这个变量 s 不需要回收吗？其实是不需要的，还是那句话我们只需要对 C.CString 返回的字符串进行回收即可。</strong></p>
<p><strong>如果 C.CString  返回的字符串作为了返回值，那么显然不能在执行函数的过程中删除，使用 defer 也不可以，因为要确保 Python  能够拿到返回值，就不能在函数执行过程中回收；而解决办法就是我们上面说的定义一个专门用来释放的函数，但是程序中未必只有一个 C.CString  啊。是的，如果不止一个，那么就把不被 Python 接收的C字符串在函数执行过程中释放掉。比如：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res1 := C.CString(s1)</span><br><span class="line">    res2 := C.CString(s1)</span><br><span class="line">    res3 := C.CString(s1)</span><br><span class="line">    C.free(unsafe.Pointer(res1))</span><br><span class="line">    C.free(unsafe.Pointer(res2))</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存</span></span><br><span class="line">    address = unsafe.Pointer(res3)</span><br><span class="line">    <span class="keyword">return</span> res3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们 return 了 res3，那么 res1 和 res2 在用完之后就直接释放掉即可，而 res3 是需要被 Python 接收的，所以它需要使用另一个函数单独释放。还是那句话：只需要释放 C.CString 返回的字符串，如果把上面代码改一下：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res1 := C.CString(s1)</span><br><span class="line">    res2 := res1</span><br><span class="line">    res3 := res2</span><br><span class="line">    C.free(unsafe.Pointer(res1))</span><br><span class="line">    C.free(unsafe.Pointer(res2))</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存</span></span><br><span class="line">    address = unsafe.Pointer(res3)</span><br><span class="line">    <span class="keyword">return</span> res3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么你会发现 Python 解释器在调用的时候直接就异常退出了，原因是上面 res1、res2、res3 都是指向同一个字符串，而 C.free  对其释放了两次。所以当调用这个执行函数的时候就直接崩溃了，解决办法就是将那两个 C.free 注释掉即可，因为 res3  被返回了，所以它应该由专门的函数进行一次释放即可。当两个 C.free 被注释掉之后，会发现 Python 又调用正常了。</strong></p>
<blockquote>
<p><strong>总结：</strong></p>
<p><strong>1. 关于字符串，我们需要对其进行释放，否则会一直停留在堆区，如果字符串比较大、或者是长时间运行的服务，很容易造成内存溢出；</strong></p>
<p><strong>2. 一旦字符串作为返回值返回，那么不可以在执行函数内部释放它，而是保存它的地址，然后由专门的函数去释放；</strong></p>
<p><strong>3. 我们只需要对 C.CString 返回的字符串进行释放，所以应该使用变量进行接收，如果一旦使用完毕就直接释放掉；</strong></p>
<p><strong>4. 因为 C  字符串是由一个指针指向，所以如果是变量之间的传递的话，那么不管有多少个变量，字符串在内存中只有一份；因此最直观的做法就是：有多少个  C.CString 就释放多少次，所以使用变量作为左值，然后只对那些出现 C.CString 的赋值语句中的左值进行 free 即可。</strong></p>
</blockquote>
<p>​        <strong>这里多提一句，关于 Go 给 Python 提供动态库，需要遵循一个原则：Go  中导出的执行函数的内部逻辑可以很复杂，但是参数和返回值一定要简单。因为这两者之间是需要通过 C 来作为媒介，参数和返回值必须能用 C  准确表达，所以建议只选择整型、浮点型、字符串这三种。</strong>    </p>
<p>​        <strong>最关键的是内存方面，对于 Go 中的数据结构我们完全不需要关心，因为 Go 的垃圾回收机制会解决它，我们只需要关注 C  中的字符串即可，而原则就是我们上面说的那样。另外在 Go 中不允许返回指针，原因我们也说过了，因为 Go 中的指针是类型安全的，只要在 Go  里面，那么 Go 的编译器便可以牢牢地把控它们。但是一旦将指针返回了，不好意思，即使你能编译成功，当 Python 调用时也会报错，会提示你  panic: runtime error: cgo result has Go pointer。所以只要返回值带有”取址符”，Python  在调用时都是不允许的，当然返回切片也是不允许的，甚至(*C.char)(unsafe.Pointer(&amp;s))也不允许，因为它也是一个指针，C 的字符串只能通过 C.CString 的方式。</strong>    </p>
<p>​        <strong>因此我们只建议返回整型、浮点型或者字符串，像数组、map 我们可以转成 json，然后再让 Python 对其进行解析即可。</strong>    </p>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_json</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_json</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 这里就不加锁了，因为多个 goroutine 不会操作同一个 key</span></span><br><span class="line">            m[fmt.Sprintf(<span class="string">&quot;satori_%d&quot;</span>, i)] = []<span class="type">int</span>&#123;i + <span class="number">100</span>, i + <span class="number">101</span>&#125;</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    data, _ := json.Marshal(m)</span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将 json 变成 C 字符串，然后返回，这里为了简便就不写释放逻辑了：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> orjson</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_json.restype = c_char_p</span><br><span class="line">start = time.perf_counter()</span><br><span class="line">res = libgo.return_json() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;耗时：<span class="subst">&#123;time.perf_counter() - start&#125;</span>&quot;</span>)  <span class="comment"># 耗时：2.0029728785157204</span></span><br><span class="line">pprint(orjson.loads(res)) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;satori_0&#x27;: [100, 101],</span></span><br><span class="line"><span class="string"> &#x27;satori_1&#x27;: [101, 102],</span></span><br><span class="line"><span class="string"> &#x27;satori_2&#x27;: [102, 103],</span></span><br><span class="line"><span class="string"> &#x27;satori_3&#x27;: [103, 104],</span></span><br><span class="line"><span class="string"> &#x27;satori_4&#x27;: [104, 105]&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pprint(orjson.loads(res)[<span class="string">&quot;satori_1&quot;</span>])  <span class="comment"># [101, 102]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到导出函数中可以编写更加复杂的逻辑，可以做很多的操作，但是参数和返回值一定要简单。因为内部逻辑再复杂，那也是在 Go 的内部，不需要 Python 关心。但参数和返回值就不一样了，它们是需要 Python 和 Go  同时理解的，因此我们要秉承着最保守的原则，使用那些 Python 和 Go 都能准确理解、并且不会产生歧义的数据结构。</strong></p>
<h3 id="Go-源文件编译成静态库、动态库并结合-Cython"><a href="#Go-源文件编译成静态库、动态库并结合-Cython" class="headerlink" title="Go 源文件编译成静态库、动态库并结合 Cython"></a>Go 源文件编译成静态库、动态库并结合 Cython</h3><p><strong>对于使用 ctypes 调用而言，Go  的动态库叫什么名字其实无关紧要，但是在 Linux 中静态库和动态库的命名是有规范的，我们在使用 gcc  进行链接的时候需要遵循这种规范。首先静态库以 .a 为后缀、动态库以 .so 为后缀，并且它们的名字都必须以 lib 开头。比如我们上面指定的  libgo.so，然后在链接的时候把开头的 lib 和结尾的 .so 去掉、也就是只需要指定 “go” 即可，会自动寻找 libgo.so  这个动态库，如果没有 libgo.so，那么会去寻找静态库 libgo.a。</strong></p>
<p><strong>我们还是编写 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：go_fib.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export go_fib</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go_fib</span><span class="params">(n C.<span class="type">int</span>)</span></span> C.double &#123;</span><br><span class="line">    <span class="keyword">var</span> i C.<span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> a, b C.double = <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">        a, b = a + b, a</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;斐波那契计算完毕，我是 Go 语言&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来使用 go build 根据 go 源文件生成静态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build -buildmode=c-archive -o 静态库文件 [go源文件1, go源文件2, go源文件3, ...]</span><br><span class="line">[root@satori go_py]# go build -buildmode=c-archive -o libfib.a go_fib.go </span><br><span class="line">[root@satori go_py]# </span><br></pre></td></tr></table></figure>

<p><strong>然后我们还需要一个头文件，这里定义为 go_fib.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">go_fib</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>里面只需要放入一个函数声明即可，具体实现在 libfib.a 中，然后编写 Cython 源文件：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名：fib.pyx</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;go_fib.h&quot;</span>:</span><br><span class="line">    double go_fib(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_with_go</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;调用 Go 编写的斐波那契数列，以静态库形式存在&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> go_fib(n)</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来进行编译：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名：setup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们不能在 sources 里面写上 [&quot;fib.pyx&quot;, &quot;libfib.a&quot;]，这是不合法的，因为 sources 里面需要放入源文件</span></span><br><span class="line"><span class="comment"># 静态库和动态库需要通过 library_dirs 和 libraries 指定</span></span><br><span class="line">ext = Extension(name=<span class="string">&quot;wrapper_gofib&quot;</span>,</span><br><span class="line">                sources=[<span class="string">&quot;fib.pyx&quot;</span>],</span><br><span class="line">                <span class="comment"># 相当于 gcc 的 -L 参数，路径可以指定多个</span></span><br><span class="line">                library_dirs=[<span class="string">&quot;.&quot;</span>],</span><br><span class="line">                <span class="comment"># 相当于 gcc 的 -l 参数，链接的库可以指定多个</span></span><br><span class="line">                <span class="comment"># 注意：不能写 libfib.a，直接写 fib 就行，所以静态命名需要遵循规范，要以 lib 开头、.a 结尾</span></span><br><span class="line">                <span class="comment"># 动态库同理，lib 开头、.so 结尾</span></span><br><span class="line">                libraries=[<span class="string">&quot;fib&quot;</span>]</span><br><span class="line">                <span class="comment"># 如果还需要头文件的话，那么通过 include_dirs 指定</span></span><br><span class="line">                <span class="comment"># 只不过由于头文件就在当前目录中，所以我们不需要指定</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">setup(ext_modules=cythonize(ext, language_level=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>然后我们执行 python3 setup.py build，执行成功之后，会生成一个 build 目录，我们将里面的扩展模块移动到当前目录，然后进入交互式 Python 中导入它，看看会有什么结果。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173105899-2064899979.png" alt="img"></p>
<p><strong>除了静态库之外，Cython 还可以包装动态库，我们只需要生成  libfib.so 即可，其它不需要有任何改动。因为 gcc 在链接的时候，如果指定的是 fib、那么优先链接 libfib.so，当  libfib.so 不存在的时候才会去链接  libfib.a。只不过在生成扩展模块之后，对应的动态库不可以丢，它是在运行的时候被动态加载的，不仅不能丢、还要将所在路径配置到  &#x2F;etc&#x2F;ld.so.conf  中，否则找不到；而对于静态库而言，在链接的时候会把静态库的内容都包含进去，所以编译之后是可以独立于相应的静态库的。</strong></p>
<p><strong>因此这就是 Cython 的强大之处，它将 C 的性能引入了 Python 中，Cython 同时理解 C 和 Python，可以直接包装 C、C++ 源文件、静态库、动态库。关于 Cython，它是一门单独的技术，值得去学习。</strong></p>
<blockquote>
<p><strong>关于 Cython，可以看 <a href="https://www.cnblogs.com/traditional/tag/Cython/">https://www.cnblogs.com/traditional/tag/Cython/</a> 。</strong></p>
</blockquote>
<h4 id="由-Cython-释放内存"><a href="#由-Cython-释放内存" class="headerlink" title="由 Cython 释放内存"></a>由 Cython 释放内存</h4><p><strong>本来这一部分之前是没有的，然而在 B 站上有一个小伙伴问了我一个问题：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20211014130209405-1856212629.png" alt="img"></p>
<p><strong>这个问题很简单，我们看一下怎么做。首先编写 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：return_string.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export get_name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_name</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译成静态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build -buildmode=c-archive -o libreturn_string.a return_string.go</span><br></pre></td></tr></table></figure>

<p><strong>然后编写头文件：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 return_string.h</span></span><br><span class="line"><span class="comment">// 对函数进行声明，函数的返回值、参数要和 Go 的导出函数保持一致</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_name</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：Go 编译器在生成 libreturn_string.a 的同时，也会自动生成一个 libreturn_string.h，我们直接用自动生成的头文件也是可以的。</strong></p>
<p><strong>最后是 Cython 源文件：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名：return_string.pyx</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;return_string.h&quot;</span>:</span><br><span class="line">    <span class="comment"># 我们说对于 Cython 而言，想使用哪些函数都必须要在 cdef extern from 块里面声明好</span></span><br><span class="line">    <span class="comment"># 因此我们在得到库之后，还需要定义一个头文件</span></span><br><span class="line">    char *get_name()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name_py</span>():</span><br><span class="line">    <span class="keyword">return</span> get_name()</span><br></pre></td></tr></table></figure>

<p><strong>以上就完事了，然后编译成 Python 扩展模块：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">ext = Extension(name=<span class="string">&quot;return_string&quot;</span>,</span><br><span class="line">                sources=[<span class="string">&quot;return_string.pyx&quot;</span>],</span><br><span class="line">                library_dirs=[<span class="string">&quot;.&quot;</span>],</span><br><span class="line">                libraries=[<span class="string">&quot;return_string&quot;</span>])</span><br><span class="line"></span><br><span class="line">setup(ext_modules=cythonize(ext, language_level=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来测试一下：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20211014130157463-665693272.png" alt="img"></p>
<p><strong>结果上是没有问题的，上面的小伙伴调用之后得到的整型，估计是函数声明的时候返回值类型写错了。当然我这里之所以单独拿出来说一下，并不是为了这个，而是为了引出内存释放这一话题。我们在 Go 里面返回了字符串，这个字符串是 C 在堆区创建的，Python 在调用之后，这个字符串依旧会停在堆区，不会被释放。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> return_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    return_string.get_name_py()</span><br></pre></td></tr></table></figure>

<p><strong>调用这个死循环，会发现内存占用瞬间飙升，原因就是每调用一次就会在堆区创建一个字符串，并且字符串还不会被回收。所以问题来了，我们要如何将 C 在堆区申请的字符串给释放掉呢？</strong></p>
<p><strong>在 Python 使用 ctypes 调用动态库的时候，我们说过，在 Go 里面需要有一个全局变量来保存字符串的指针，然后再定义一个函数，在里面调用 C.free 进行释放。但是在 Cython  中我们完全不需要这么做，因为 Cython 同时理解 C 和 Python，我们完全可以在 Cython 里面去释放这个堆区的字符串。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport free</span><br><span class="line"></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;return_string.h&quot;</span>:</span><br><span class="line">    char *get_name()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name_py</span>():</span><br><span class="line">    <span class="comment"># 此时 s 也指向了这个堆区字符串的首元素</span></span><br><span class="line">    cdef char *s = get_name()</span><br><span class="line">    <span class="comment"># 用 Python 变量接收，此时会将堆区字符串拷贝一份得到 bytes 对象</span></span><br><span class="line">    name = s</span><br><span class="line">    <span class="comment"># 然后将堆区字符串释放掉，因为这里的 char *s 指向的字符串和 Go 里面 C.CString 申请的字符串是同一个字符串</span></span><br><span class="line">    <span class="comment"># 因此在 Go 里面调用 C.free 释放，和这里直接使用 free 释放是等价的</span></span><br><span class="line">    free(&lt;void *&gt;s)</span><br><span class="line">    <span class="keyword">return</span> name  <span class="comment"># 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>此时重新编译，然后再调用的话，会发现不管调用多少次，内存占用都不会往上涨，因为堆区字符串会被回收。而之前内存占用上涨的原因是我们直接 return get_name()，那么在将堆区的字符串拷贝一份得到 bytes 对象之后就直接返回了，但堆区的字符串并没有被回收。</strong></p>
<p><strong>显然此时就方便多了，我们不需要再通过回调的方式在 Go 里面释放了，因为在 Go 里面也是要通过 C 来释放的（调用 C.free）。而我们说 Cython 同时理解 C 和 Python，所以在 Cython  里面释放完全等价。并且此时对导出函数的返回值也没有任何要求，返回数组、结构体、指针统统都是没有问题的，Cython 都是支持的。</strong></p>
<p><strong>这也算是一个比较重要的地方吧，值得说明一下。</strong></p>
<h3 id="Go-源文件直接编译成-Python-扩展模块"><a href="#Go-源文件直接编译成-Python-扩展模块" class="headerlink" title="Go 源文件直接编译成 Python 扩展模块"></a>Go 源文件直接编译成 Python 扩展模块</h3><p><strong>直接编写扩展是一件难度比较大的事情，因为这要求你严格遵循 Python&#x2F;C API，所以才有了 Cython。那么如何用 Go 来给 Python 写扩展呢，首先还是那句话，Python 和 Go 之间是通过 C  进行交互的，所以用 Go 写扩展实际上还是相当于用 C 写扩展。但其实 Go 写扩展并没有 C 写扩展方便，因为 CPython 提供的一些宏在 Go 里面没办法通过 C 这个名字空间进行引用，而且还不能调用具有可变参数的 C 函数。比如 CPython 解析函数参数时会使用一个函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int PyArg_ParseTuple(PyObject *args, const char *format, ...);</span><br></pre></td></tr></table></figure>

<p><strong>这个函数你在 Go 里面没法直接用，因为它包含可变参数 <code>...</code>，如果我们调用 C.PyArg_ParseTuple，Go 编译器会报错。解决办法是你要在 <code>import &quot;C&quot;</code> 上面的 C 代码中单独定义一个包装器，所以还是比较麻烦的。那么下面我们来简单实现一下 Python 的 binascii 模块里面的两个函数，看看 Go 是如何编写 Python 扩展的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">b&quot;satori&quot;</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(data))  <span class="comment"># b&#x27;7361746f7269&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="string">b&quot;7361746f7269&quot;</span>))  <span class="comment"># satori</span></span><br></pre></td></tr></table></figure>

<p><strong>在 binascii 里面有这两个函数，我们下面就来用 Go 实现它们，先来介绍一下这两个函数吧。binascii.hexlify 是将数据用 16 进制表示，binascii.unhexlify 则是前者的逆运算。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">b&quot;satori&quot;</span></span><br><span class="line"><span class="comment"># 说白了就是将每一个字节都变成 16 进制</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(data))  <span class="comment"># b&#x27;7361746f7269&#x27;</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">hex</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># [&#x27;0x73&#x27;, &#x27;0x61&#x27;, &#x27;0x74&#x27;, &#x27;0x6f&#x27;, &#x27;0x72&#x27;, &#x27;0x69&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># [&#x27;73&#x27;, &#x27;61&#x27;, &#x27;74&#x27;, &#x27;6f&#x27;, &#x27;72&#x27;, &#x27;69&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data]))  <span class="comment"># 7361746f7269</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unhexlify 则是逆运算</span></span><br><span class="line">data = <span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">hex_data = <span class="string">&quot;&quot;</span>.join([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># 将数据手动转成 16 进制</span></span><br><span class="line"><span class="comment"># unhexlify 可以接收字节串、也可以接收字符串，但是 hexlify 只接收字节串</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(hex_data).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们仍然可以手动 unhexlify</span></span><br><span class="line">unhex_data = <span class="built_in">bytes</span>([<span class="built_in">int</span>(hex_data[i: i + <span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(hex_data), <span class="number">2</span>)])</span><br><span class="line"><span class="built_in">print</span>(unhex_data.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br></pre></td></tr></table></figure>

<p><strong>了解完函数原理之后，我们接下来就用 Go 来写扩展实现它们。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo linux pkg-config: python3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &quot;Python.h&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">extern PyObject *PyInit_binascii();</span></span><br><span class="line"><span class="comment">extern PyObject *hexlify(PyObject *, PyObject *);</span></span><br><span class="line"><span class="comment">extern PyObject *unhexlify(PyObject *, PyObject *);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static PyObject *__PyInit_binascii(void)&#123;</span></span><br><span class="line"><span class="comment">    static PyMethodDef methods[] = &#123;</span></span><br><span class="line"><span class="comment">        &#123;&quot;hexlify&quot;, (PyCFunction) hexlify, METH_O, &quot;&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;unhexlify&quot;, (PyCFunction) unhexlify, METH_O, &quot;&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;NULL, NULL, 0, NULL&#125;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    static PyModuleDef module = &#123;</span></span><br><span class="line"><span class="comment">        PyModuleDef_HEAD_INIT,</span></span><br><span class="line"><span class="comment">        &quot;binascii&quot;,</span></span><br><span class="line"><span class="comment">        &quot;this is a module named binascii&quot;,</span></span><br><span class="line"><span class="comment">        -1,</span></span><br><span class="line"><span class="comment">        methods,</span></span><br><span class="line"><span class="comment">        NULL, NULL, NULL, NULL</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    return PyModule_Create(&amp;module);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export hexlify</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexlify</span><span class="params">(self, arg *C.PyObject)</span></span> *C.PyObject &#123;</span><br><span class="line">    <span class="comment">// arg 必须是一个 bytes 对象，这里我们就不做参数检测了</span></span><br><span class="line"></span><br><span class="line">    buf := strings.Builder&#123;&#125;</span><br><span class="line">    <span class="comment">// 字符串转成 C 的字符串、再转成 Go 字符串</span></span><br><span class="line">    go_string := C.GoString(C.PyBytes_AsString(arg))</span><br><span class="line">    <span class="comment">// 遍历字符串，将整型转成 16 进制</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> []<span class="type">byte</span>(go_string) &#123;</span><br><span class="line">        buf.WriteString(strconv.FormatInt(<span class="type">int64</span>(char), <span class="number">16</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转成 C 字符串</span></span><br><span class="line">    c_string := C.CString(buf.String())</span><br><span class="line">    <span class="comment">// 根据 C 字符串创建 Python 的 bytes 对象</span></span><br><span class="line">    res := C.PyBytes_FromString(c_string)</span><br><span class="line">    <span class="comment">// 记得将堆区申请的 C 字符串给删除</span></span><br><span class="line">    C.free(unsafe.Pointer(c_string))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export unhexlify</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhexlify</span><span class="params">(self, arg *C.PyObject)</span></span> *C.PyObject &#123;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 得到 Go bytes</span></span><br><span class="line">    go_bytes := []<span class="type">byte</span>(C.GoString(C.PyBytes_AsString(arg)))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(go_bytes); i += <span class="number">2</span> &#123;</span><br><span class="line">        n, _ := strconv.ParseInt(<span class="type">string</span>(go_bytes[i:i+<span class="number">2</span>]), <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, <span class="type">byte</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    c_string := C.CString(<span class="type">string</span>(buf))</span><br><span class="line">    res := C.PyBytes_FromString(c_string)</span><br><span class="line">    C.free(unsafe.Pointer(c_string))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export PyInit_binascii</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PyInit_binascii</span><span class="params">()</span></span> *C.PyObject &#123;</span><br><span class="line">    <span class="keyword">return</span> C.__PyInit_binascii()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面涉及到的一些细节就不详细说了，使用 Go 写扩展首先需要了解如何使用 C 写扩展，而且正如之前所说，用 Go 写扩展反而会没有 C 方便。原因就是 CPython 解释器内置了大量的宏，这些宏在 Go  里面没法直接通过 C 这个名字来进行引用，还有上面说的具有可变参数的 C  函数，不能直接调用，必须定义一个包装器才可以（个人觉得这算是最大的硬伤）；以及 Python 底层的数据结构、C 的数据结构、Go  的数据结构三者要经常来回转化，还有引用计数的增加、减少，堆区上 C  字符串的释放等等，个人觉得这些东西处理起来不是一件简单的事情。个人觉得最好的做法还是前两种，如果熟悉 Cython  则更推荐第二种，至于这里的第三种：用 Go 直接给 Python 写扩展，个人不是很推荐。</strong></p>
<p><strong>而上面的代码则是简单实现了 hexlify、unhexlify 两个函数，我们来测试一下吧。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173121632-1835895119.png" alt="img"></p>
<p><strong>从结果上来看是没有任何问题的，但这是参数类型传递正确的前提下。因为我们这里没有对参数进行检测，假设我们传递了一个整型过去，那么在执行 C.PyBytes_AsString 的时候很明显是会报错的。</strong></p>
<p><strong>当然这里关于扩展的更多细节，这里就不讨论了，个人觉得不管啥语言，直接写扩展都不是一件简单的事情。所以本人特别喜欢 Cython，因为它同时理解 C 和 Python，将 C 的高性能和 Python 的动态特性结合在了一起。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>以上就是在 Python 中引入 Go 的几种方式，当然 Go 里面也可以引入 Python，只不过个人是以 Python 作为主语言，所以只关注前者。而 Python 引入 Go 也有三种方式：</strong></p>
<ul>
<li><code>1. Go 直接编写动态库给 Python，然后 Python 解释器通过 ctypes 调用</code></li>
<li><code>2. Go 编写静态库或者动态库，然后再由 Cython 包装成 Python 扩展，Python解释器直接 import</code></li>
<li><code>3. Go 直接为 Python 提供扩展</code></li>
</ul>
<p><strong>第三种个人不推荐，因为受到的限制太多了，可以尝试前两种。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</title>
    <url>/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<h2 id="34-侵入-Python-虚拟机，动态修改底层数据结构和运行时"><a href="#34-侵入-Python-虚拟机，动态修改底层数据结构和运行时" class="headerlink" title="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时"></a>34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>之前分析了那么久的虚拟机，多少会有点无聊，那么本次我们来介绍一个好玩的，看看如何修改 Python 解释器的底层数据结构和运行时。了解虚拟机除了可以让我们写出更好的代码之外，还可以对 Python 进行改造。举个栗子：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134842860-1005929349.png" alt="img"></p>
<p><strong>是不是很有趣呢？通过 Python 内置的 ctypes 模块即可做到，而具体实现方式我们一会儿说。所以本次我们的工具就是 ctypes 模块（Python 版本为 3.8），需要你对它已经或多或少有一些了解，哪怕只有一点点也是没关系的。</strong></p>
<blockquote>
<p><strong>注意：本次介绍的内容绝不能用于生产环境，仅仅只是为了更好地理解 Python 虚拟机、或者做测试的时候使用，用于生产环境是绝对的大忌。</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
</blockquote>
<p><strong>那么废话不多说，下面就开始吧。</strong></p>
<h3 id="使用-Python-表示-C-的数据结构"><a href="#使用-Python-表示-C-的数据结构" class="headerlink" title="使用 Python 表示 C 的数据结构"></a>使用 Python 表示 C 的数据结构</h3><p><strong>Python 是用 C 实现的，如果想在 Python 的层面修改底层逻辑，那么我们肯定要能够将 C 的数据结构用 Python 表示出来。而 ctypes 提供了大量的类，专门负责做这件事情，下面按照类型属性分别介绍。</strong></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>C 语言的数值类型分为如下：</strong></p>
<ul>
<li><code>int：整型</code></li>
<li><code>unsigned int：无符号整型</code></li>
<li><code>short：短整型</code></li>
<li><code>unsigned short：无符号短整型</code></li>
<li><code>long：长整形</code></li>
<li><code>unsigned long：无符号长整形</code></li>
<li><code>long long：64 位机器上等同于 long</code></li>
<li><code>unsigned long long：64 位机器上等同于 unsigned long</code></li>
<li><code>float：单精度浮点型</code></li>
<li><code>double：双精度浮点型</code></li>
<li><code>long double：看成是 double 即可</code></li>
<li><code>_Bool：布尔类型</code></li>
<li><code>ssize_t：等同于 long 或者 long long</code></li>
<li><code>size_t：等同于 unsigned long 或者 unsigned long long</code></li>
</ul>
<p><strong>和 Python 以及 ctypes 之间的对应关系如下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134851148-1943662743.png" alt="img"></p>
<p><strong>下面来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面都是 ctypes 中提供的类，将 Python 中的数据传进去，就可以转换为 C 的数据</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_uint(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_short(<span class="number">1</span>))  <span class="comment"># c_short(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ushort(<span class="number">1</span>))  <span class="comment"># c_ushort(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_long(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulong(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_longlong 等价于 c_long，c_ulonglong 等价于 c_ulong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longlong(<span class="number">1</span>))  <span class="comment"># c_longlong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulonglong(<span class="number">1</span>))  <span class="comment"># c_ulonglong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_float(<span class="number">1.1</span>))  <span class="comment"># c_float(1.100000023841858)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_double(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在64位机器上，c_longdouble等于c_double</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longdouble(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_bool(<span class="literal">True</span>))  <span class="comment"># c_bool(True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于c_longlong和c_ulonglong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ssize_t(<span class="number">10</span>))  <span class="comment"># c_longlong(10)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_size_t(<span class="number">10</span>))  <span class="comment"># c_ulonglong(10)</span></span><br></pre></td></tr></table></figure>

<p><strong>而 C 的数据转成 Python 的数据也非常容易，只需要在此基础上调用一下 value 即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1024</span>).value)  <span class="comment"># 1024</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1024</span>).value == <span class="number">1024</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p><strong>C 语言的字符类型分为如下：</strong></p>
<ul>
<li><code>char：一个 ascii 字符或者 -128~127 的整型</code></li>
<li><code>wchar：一个 unicode 字符</code></li>
<li><code>unsigned char：一个 ascii 字符或者 0~255 的一个整型</code></li>
</ul>
<p><strong>和 Python 以及 ctypes 之间的对应关系如下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134901625-1142939073.png" alt="img"></p>
<p><strong>举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传递一个字节（里面是 ascii 字符），或者一个 int，来代表 C 里面的字符</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="string">b&quot;a&quot;</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="number">97</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># 和 c_char 类似，但是 c_char 既可以传入单个字节、也可以传整型</span></span><br><span class="line"><span class="comment"># 而这里的 c_byte 和则要求必须传递整型</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_byte(<span class="number">97</span>))  <span class="comment"># c_byte(97)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递一个 unicode 字符，当然 ascii 字符也是可以的，并且不是字节形式</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># c_wchar(&#x27;憨&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样只能传递整型，</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ubyte(<span class="number">97</span>))  <span class="comment"># c_ubyte(97)</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>下面看看如何构造一个 C 中的数组：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># C 里面创建数组的方式如下：int a[5] = &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># 使用 ctypes 的话</span></span><br><span class="line">array = (ctypes.c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># (ctypes.c_int * N) 等价于 int a[N]，相当于构造出了一个类型，然后再通过类似函数调用的方式指定数组的元素即可</span></span><br><span class="line"><span class="comment"># 这里指定元素的时候直接输入数字即可，会自动转成 C 中的 int，当然我们也可以使用 c_int 手动包装</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(array))  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># &lt;__main__.c_int_Array_5 object at 0x7f96276fd4c0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">    <span class="built_in">print</span>(array[i], end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array = (ctypes.c_char * <span class="number">3</span>)(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(array))  <span class="comment"># [b&#x27;a&#x27;, b&#x27;b&#x27;, b&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看一下数组在 Python 里面的类型，因为数组存储的元素类型为  c_int、数组长度为 5，所以这个数组在 Python 里面的类型就是 c_int_Array_5，而打印的时候则显示为  c_int_Array_5 的实例对象。我们可以调用 len  方法获取长度，也可以通过索引的方式去指定的元素，并且由于内部实现了迭代器协议，我们还可以使用 for 循环去遍历，或者使用 list  直接转成列表等等，都是可以的。</strong></p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>结构体应该是 C 里面最重要的结构之一了，假设 C 里面有这样一个结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> field1;</span><br><span class="line">    <span class="type">float</span> field2;</span><br><span class="line">    <span class="type">long</span> field3[<span class="number">5</span>];</span><br><span class="line">&#125; MyStruct;</span><br></pre></td></tr></table></figure>

<p><strong>要如何在 Python 里面表示它呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C 中的结构体在 Python 里面显然通过类来实现，但是这个类一定要继承 ctypes.Structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(ctypes.Structure):</span><br><span class="line">    <span class="comment"># 结构体的每一个成员对应一个元组，第一个元素为字段名，第二个元素为类型</span></span><br><span class="line">    <span class="comment"># 然后多个成员放在一个列表中，并用变量 _fields_ 指定</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&quot;field3&quot;</span>, (ctypes.c_long * <span class="number">5</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># field1、field2、field3 就类似函数参数一样，可以通过位置参数、关键字参数指定</span></span><br><span class="line">s = MyStruct(field1=ctypes.c_int(<span class="number">123</span>),</span><br><span class="line">             field2=ctypes.c_float(<span class="number">3.14</span>),</span><br><span class="line">             field3=(ctypes.c_long * <span class="number">5</span>)(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;__main__.MyStruct object at 0x7ff9701d0c40&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.field1)  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(s.field2)  <span class="comment"># 3.140000104904175</span></span><br><span class="line"><span class="built_in">print</span>(s.field3)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x7ffa3a5f84c0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>就像实例化一个普通的类一样，然后也可以像获取实例属性一样获取结构体成员。这里获取之后会自动转成 Python 中的数据，比如 c_int 类型会自动转成 int，c_float 会自动转成 float，而数组由于 Python  没有内置，所以直接打印为 “c_long_Array_5 的实例对象”。</strong></p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><strong>指针是 C 语言灵魂，而且绝大部分的 Bug 也都是指针所引起的，那么指针类型在 Python 里面如何表示呢？非常简单，通过 ctypes.POINTER 即可表示 C 的指针类型，比如：</strong></p>
<ul>
<li><code>C 中的 int *，在 Python 里面就是 ctypes.POINTER(c_int)</code></li>
<li><code>C 中的 float *，在 Python 里面就是 ctypes.POINTER(c_float)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, POINTER(c_long)),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, POINTER(c_double)),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>所以通过 POINTER(类型) 即可表示对应类型的指针，而获取指针则是通过 pointer 函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 C 里面就相当于，long a = 1024; long *p = &amp;a;</span></span><br><span class="line">p = pointer(c_long(<span class="number">1024</span>))</span><br><span class="line"><span class="built_in">print</span>(p)  <span class="comment"># &lt;__main__.LP_c_long object at 0x7ff3639d0dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_long&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pointer 可以获取任意类型的指针</span></span><br><span class="line"><span class="built_in">print</span>(pointer(c_float(<span class="number">3.14</span>)).__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pointer(c_double(<span class="number">2.71</span>)).__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_double&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>同理，我们也可以通过指针获取指向的值，也就是对指针进行解引用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = pointer(c_long(<span class="number">123</span>))</span><br><span class="line"><span class="comment"># 调用 contents 即可获取指向的值，相当于对指针进行解引用</span></span><br><span class="line"><span class="built_in">print</span>(p.contents)  <span class="comment"># c_long(123)</span></span><br><span class="line"><span class="built_in">print</span>(p.contents.value)  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果对 p 再使用一次 pointer 函数，那么相当于获取 p 的指针</span></span><br><span class="line"><span class="comment"># 此时相当于二级指针 long **，所以类型为 LP_LP_c_long</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer_p))  <span class="comment"># &lt;__main__.LP_LP_c_long object at 0x7fe6121d0bc0&gt;</span></span><br><span class="line"><span class="comment"># 三级指针，类型为 LP_LP_LP_c_long</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)))  <span class="comment"># &lt;__main__.LP_LP_LP_c_long object at 0x7fb2a29d0bc0&gt;</span></span><br><span class="line"><span class="comment"># 三次解引用，获取对应的值</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)).contents.contents.contents)  <span class="comment"># c_long(123)</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)).contents.contents.contents.value)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p><strong>总的来说，还是比较好理解的。但我们知道，在 C 中数组等于数组首元素的地址，我们除了传一个指针过去之外，传数组也是可以的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, POINTER(c_long)),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, POINTER(c_double)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构体也可以先创建，再实例化成员</span></span><br><span class="line">s = MyStruct()</span><br><span class="line">s.field1 = pointer(c_long(<span class="number">1024</span>))</span><br><span class="line">s.field2 = (c_double * <span class="number">3</span>)(<span class="number">3.14</span>, <span class="number">1.732</span>, <span class="number">2.71</span>)</span><br></pre></td></tr></table></figure>

<p><strong>数组在作为参数传递的时候会退化为指针，所以此时数组的长度信息就丢失了，使用 sizeof 计算出来的结果就是一个指针的大小。因此将数组作为参数传递的时候，应该将当前数组的长度信息也传递过去，否则可能会访问非法的内存。</strong></p>
<p><strong>然后在 C 里面还有 char *、wchar_t *、void *，这些指针在 ctypes 里面专门提供了几个类与之对应。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134909949-514832209.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_char_p 就是 c 里面字符数组了，其实我们可以把它看成是 Python 中的 bytes 对象</span></span><br><span class="line"><span class="comment"># char *s = &quot;hello world&quot;;</span></span><br><span class="line"><span class="comment"># 那么这里面也要传递一个 bytes 类型的字符串，返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># c_char_p(140451925798832)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接传递一个字符串，同样返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(c_wchar_p(<span class="string">&quot;古明地觉&quot;</span>))  <span class="comment"># c_wchar_p(140451838245008)</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>最后看一下如何在 Python 中表示 C 的函数，首先 C 的函数可以有多个参数，但只有一个返回值。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> *a, <span class="type">long</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数接收两个 long *、返回一个 long，那么这种函数类型要如何表示呢？答案是通过 ctypes.CFUNCTYPE。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数是函数的返回值类型，然后函数的参数写在后面，有多少写多少</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 long，接收两个 long *，所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_long, POINTER(c_long), POINTER(c_long))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值，那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t，此时的类型 t 就等同于 C 中的 typedef long (*t)(long*, long*);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Python 函数，a、b 为 long *，返回值为 c_long</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将我们自定义的函数传进去，就得到了 C 语言可以识别的函数</span></span><br><span class="line">c_add = t(add)</span><br><span class="line"><span class="built_in">print</span>(c_add)  <span class="comment"># &lt;CFunctionType object at 0x7fa52fa29040&gt;</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    c_add(pointer(c_long(<span class="number">22</span>)),</span><br><span class="line">          pointer(c_long(<span class="number">33</span>)))</span><br><span class="line">)  <span class="comment"># 55</span></span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>以上就是 C 中常见的数据结构，然后再说一下类型转化，ctypes 提供了一个 cast 函数，可以将指针的类型进行转化。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># cast 的第一个参数接收的必须是某种指针的 ctypes 对象，第二个参数是 ctypes 指针类型</span></span><br><span class="line"><span class="comment"># 这里相当于将 long * 转成了 float *</span></span><br><span class="line">p1 = pointer(c_long(<span class="number">123</span>))</span><br><span class="line">p2 = cast(p1, POINTER(c_float))</span><br><span class="line"><span class="built_in">print</span>(p2)  <span class="comment"># &lt;__main__.LP_c_float object at 0x7f91be201dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p2.contents)  <span class="comment"># c_float(1.723597111119525e-43)</span></span><br></pre></td></tr></table></figure>

<p><strong>指针在转换之后，还是引用相同的内存块，所以整型指针转成浮点型指针之后，打印的结果乱七八糟。当然数组也可以转化，我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">t1 = (c_int * <span class="number">3</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将 int * 转成 long *</span></span><br><span class="line">t2 = cast(t1, POINTER(c_long))</span><br><span class="line"><span class="built_in">print</span>(t2[<span class="number">0</span>])  <span class="comment"># 8589934593</span></span><br></pre></td></tr></table></figure>

<p><strong>原来数组元素是 int 类型（4 字节），现在转成了 long（8 字节），但是内存块并没有变。因此 t2 获取元素时会一次性获取 8 字节，所以 t1[0] 和 t1[1] 组合起来等价于 t2[0]。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">t1 = (c_int * <span class="number">3</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = cast(t1, POINTER(c_long))</span><br><span class="line"><span class="built_in">print</span>(t2[<span class="number">0</span>])  <span class="comment"># 8589934593</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">2</span> &lt;&lt; <span class="number">32</span> &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span>) + (<span class="number">1</span> &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span>))  <span class="comment"># 8589934593</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟底层数据结构，观察运行时表现"><a href="#模拟底层数据结构，观察运行时表现" class="headerlink" title="模拟底层数据结构，观察运行时表现"></a>模拟底层数据结构，观察运行时表现</h3><p><strong>我们说 Python 的对象本质上就是 C 的 malloc  函数为结构体实例在堆区申请的一块内存，比如整数是 PyLongObject、浮点数是 PyFloatObject、列表是  PyListObject，以及所有的类型都是 PyTypeObject 等等。那么在介绍完 ctypes  的基本用法之后，下面就来构造这些数据结构来观察 Python 对象在运行时的表现。</strong></p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p><strong>这里先说浮点数，因为浮点数比整数要简单，先来看看底层的定义。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了 PyObject 这个公共的头部信息之外，只有一个额外的 ob_fval，用于存储具体的值，而且直接使用的 C 中的 double。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;PyObject，所有对象底层都会有这个结构体&quot;&quot;&quot;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p)  <span class="comment"># 类型对象一会说，这里就先用 void * 模拟</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyFloatObject</span>(<span class="title class_ inherited__">PyObject</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义 PyFloatObject，继承 PyObject&quot;&quot;&quot;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_fval&quot;</span>, c_double)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个浮点数</span></span><br><span class="line">f = <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 构造 PyFloatObject，可以通过对象的地址进行构造</span></span><br><span class="line"><span class="comment"># float_obj 就是浮点数 f 在底层的表现形式</span></span><br><span class="line">float_obj = PyFloatObject.from_address(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_fval)  <span class="comment"># 3.14</span></span><br><span class="line"><span class="comment"># 修改一下</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;f = <span class="subst">&#123;f&#125;</span>，id(f) = <span class="subst">&#123;<span class="built_in">id</span>(f)&#125;</span>&quot;</span>)  <span class="comment"># f = 3.14，id(f) = 140625653765296</span></span><br><span class="line">float_obj.ob_fval = <span class="number">1.73</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;f = <span class="subst">&#123;f&#125;</span>，id(f) = <span class="subst">&#123;<span class="built_in">id</span>(f)&#125;</span>&quot;</span>)  <span class="comment"># f = 1.73，id(f) = 140625653765296</span></span><br></pre></td></tr></table></figure>

<p><strong>我们修改 float_obj.ob_fval 也会影响 f，并且修改前后 f 的地址没有发生改变。同时我们也可以观察一个对象的引用计数，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="number">3.14</span></span><br><span class="line">float_obj = PyFloatObject.from_address(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="comment"># 此时 3.14 这个浮点数对象被 3 个变量所引用</span></span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 再来一个</span></span><br><span class="line">f2 = f</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 4</span></span><br><span class="line">f3 = f</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">del</span> f2, f3</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p><strong>所以这就是引用计数机制，当对象被引用，引用计数加 1；当引用该对象的变量被删除，引用计数减 1；当对象的引用计数为 0 时，对象被销毁。</strong></p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p><strong>再来看看整数，我们知道 Python 中的整数是不会溢出的，换句话说，它可以计算无穷大的数。那么问题来了，它是怎么办到的呢？想要知道答案，只需看底层的结构体定义即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];  <span class="comment">// digit 等价于 unsigned int</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>明白了，原来 Python 的整数在底层是用数组存储的，通过串联多个无符号 32 位整数来表示更大的数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyLongObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_digit&quot;</span>, (c_uint32 * <span class="number">1</span>))</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">1024</span></span><br><span class="line">long_obj = PyLongObject.from_address(<span class="built_in">id</span>(num))</span><br><span class="line"><span class="built_in">print</span>(long_obj.ob_digit[<span class="number">0</span>])  <span class="comment"># 1024</span></span><br><span class="line"><span class="comment"># PyLongObject 的 ob_size 除了表示 ob_digit 数组的长度，此时显然为 1</span></span><br><span class="line"><span class="built_in">print</span>(long_obj.ob_size)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在介绍整型的时候说过，ob_size 除了表示 ob_digit 数组的长度之外，还表示整数的符号</span></span><br><span class="line"><span class="comment"># 我们将 ob_size 改成 -1，再打印 num</span></span><br><span class="line">long_obj.ob_size = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num)  <span class="comment"># -1024</span></span><br><span class="line"><span class="comment"># 我们悄悄地将 num 改成了负数</span></span><br></pre></td></tr></table></figure>

<p><strong>当然我们也可以修改值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1024</span></span><br><span class="line">long_obj = PyLongObject.from_address(<span class="built_in">id</span>(num))</span><br><span class="line">long_obj.ob_digit[<span class="number">0</span>] = <span class="number">4096</span></span><br><span class="line"><span class="built_in">print</span>(num)  <span class="comment"># 4096</span></span><br></pre></td></tr></table></figure>

<p><strong>digit 是 32 位无符号整型，不过虽然占 32 个位，但是只用 30 个位，这也意味着一个 digit 能存储的最大整数就是 2 的 30 次方减 1。如果数值再大一些，那么就需要两个 digit 来存储，第二个 digit 的最低位从 31 开始。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时一个 digit 能够存储的下，所以 ob_size 为 1</span></span><br><span class="line">num1 = <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span></span><br><span class="line">long_obj1 = PyLongObject.from_address(<span class="built_in">id</span>(num1))</span><br><span class="line"><span class="built_in">print</span>(long_obj1.ob_size)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时一个 digit 存不下了，所以需要两个 digit，因此 ob_size 为 2</span></span><br><span class="line">num2 = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">long_obj2 = PyLongObject.from_address(<span class="built_in">id</span>(num2))</span><br><span class="line"><span class="built_in">print</span>(long_obj2.ob_size)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>当然了，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<h4 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h4><p><strong>字节串也就是 Python 中的 bytes 对象，在存储或网络通讯时，传输的都是字节串。bytes 对象在底层的结构体为 PyBytesObject，看一下相关定义。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyBytesObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们解释一下里面的成员对象：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD：变长对象的公共头部</code></li>
<li><code>ob_shash：保存该字节序列的哈希值，之所以选择保存是因为在很多场景都需要 bytes 对象的哈希值。而 Python  在计算字节序列的哈希值的时候，需要遍历每一个字节，因此开销比较大。所以会提前计算一次并保存起来，这样以后就不需要算了，可以直接拿来用，并且  bytes 对象是不可变的，所以哈希值是不变的</code></li>
<li><code>ob_sval：这个和 PyLongObject 中的 ob_digit 的声明方式是类似的，虽然声明的时候长度是 1,  但具体是多少则取决于 bytes 对象的字节数量。这是 C 语言中定义&quot;变长数组&quot;的技巧, 虽然写的长度是 1, 但是你可以当成 n 来用, n 可取任意值。显然这个 ob_sval 存储的是所有的字节，因此 Python 中的 bytes  对象在底层是通过字符数组存储的。而且数组会多申请一个空间，用于存储 \0，因为 C 中是通过 \0 来表示一个字符数组的结束，但是计算  ob_size 的时候不包括 \0</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyBytesObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_shash&quot;</span>, c_ssize_t),</span><br><span class="line">        <span class="comment"># 这里我们就将长度声明为 100</span></span><br><span class="line">        (<span class="string">&quot;ob_sval&quot;</span>, (c_char * <span class="number">100</span>))</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = <span class="string">b&quot;hello&quot;</span></span><br><span class="line">bytes_obj = PyBytesObject.from_address(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line"><span class="built_in">print</span>(bytes_obj.ob_size, <span class="built_in">len</span>(b))  <span class="comment"># 5 5</span></span><br><span class="line"><span class="comment"># 哈希值</span></span><br><span class="line"><span class="built_in">print</span>(bytes_obj.ob_shash)  <span class="comment"># 967846336661272849</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(b))  <span class="comment"># 967846336661272849</span></span><br><span class="line"><span class="comment"># 修改哈希值，再调用 hash 函数会发现结果变了</span></span><br><span class="line"><span class="comment"># 说明 hash(b) 会直接获取底层已经计算好的 ob_shash 成员的值</span></span><br><span class="line">bytes_obj.ob_shash = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(b))  <span class="comment"># 666</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 ob_sval</span></span><br><span class="line">bytes_obj.ob_sval = <span class="string">b&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 我们看到打印的依旧是 &quot;hello&quot;，原因是 ob_size 为 5，只会选择前 5 个字节</span></span><br><span class="line"><span class="comment"># 修改之后再次打印</span></span><br><span class="line">bytes_obj.ob_size = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello world&#x27;</span></span><br><span class="line">bytes_obj.ob_size = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello world\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>除了 bytes 对象之外，Python 中还有一个 bytearray 对象，它和 bytes 对象类似，只不过 bytes 对象是不可变的，而 bytearray 对象是可变的。</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><strong>Python 中的列表可以说使用的非常广泛了，在初学列表的时候，有人会告诉你列表就是一个大仓库，什么都可以存放。但我们知道，列表中存放的元素其实都是泛型指针 PyObject *。</strong></p>
<p><strong>下面来看看列表的底层结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面有如下成员：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 变长对象的公共头部信息</code></li>
<li><code>ob_item：一个二级指针，指向一个 PyObject * 类型的指针数组，这个指针数组保存的便是对象的指针，而操作底层数组都是通过 ob_item 来进行操作的。</code></li>
<li><code>allocated：容量, 我们知道列表底层是使用了 C 的数组, 而底层数组的长度就是列表的容量</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyListObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        <span class="comment"># ctypes 下面有一个 py_object 类，它等价于底层的 PyObject *</span></span><br><span class="line">        <span class="comment"># 但 ob_item 类型为 **PyObject，所以这里类型声明为 POINTER(py_object)</span></span><br><span class="line">        (<span class="string">&quot;ob_item&quot;</span>, POINTER(py_object)),</span><br><span class="line">        (<span class="string">&quot;allocated&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_obj = PyListObject.from_address(<span class="built_in">id</span>(lst))</span><br><span class="line"><span class="comment"># 列表在计算长度的时候，会直接获取 ob_size 成员的值，该值负责维护列表的长度</span></span><br><span class="line"><span class="comment"># 对元素进行增加、删除，ob_size 也会动态变化</span></span><br><span class="line"><span class="built_in">print</span>(list_obj.ob_size)  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst))  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 ob_size 为 2，打印列表只会显示两个元素</span></span><br><span class="line">list_obj.ob_size = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst[<span class="number">2</span>]  <span class="comment"># 访问索引为 2 的元素会越界</span></span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># list index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素，注意：ob_item 里面的元素是 PyObject*，所以这里需要调用 py_object 转一下</span></span><br><span class="line">list_obj.ob_item[<span class="number">0</span>] = py_object(<span class="string">&quot;😂&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;😂&#x27;, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p><strong>下面来看看元组，我们可以把元素看成不支持元素添加、修改、删除等操作的列表。元组的实现机制非常简单，可以看做是在列表的基础上丢弃了增删改等操作。既然如此，那要元组有什么用呢？毕竟元组的功能只是列表的子集。元组存在的最大一个特点就是，它可以作为字典的  key、以及可以作为集合的元素。因为字典和集合存储数据的原理是哈希表，对于列表这样的可变对象来说是可以动态改变的，而哈希值是一开始就计算好的，显然如果支持动态修改的话，那么哈希值肯定会变，这是不允许的。所以如果我们希望字典的 key 是一个序列，显然元组再适合不过了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，对于不可变对象来说，它底层结构体定义也非常简单。一个引用计数、一个类型、一个指针数组。这里的 1 可以想象成 n，我们上面说过它的含义。并且我们发现不像列表，元组没有 allocated，这是因为它是不可变的，不支持扩容操作。</strong></p>
<p><strong>这里再对比一下元组和列表的 ob_item  成员，PyTupleObject 的 ob_item 是一个指针数组，数组里面是泛型指针 PyObject *；而 PyListObject 的 ob_item 是一个二级指针，该指针指向了一个存放 PyObject * 的指针数组的首元素。</strong></p>
<p><strong>所以 Python 中的 “列表本身” 和 “列表里面的值”  在底层是分开存储的，因为 PyListObject  结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组首元素的二级指针。显然我们添加、删除、修改元素等操作，都是通过这个二级指针来间接操作这个指针数组。这么做的原因就在于对象一旦被创建，那么它在内存中的大小就不可以变了，因此这就意味着那些可以容纳可变长度数据的可变对象，要在内部维护一个指向可变大小的内存区域的指针，遵循这样的规则可以使维护对象的工作变得非常简单。</strong></p>
<blockquote>
<p><strong>试想一下这样一个场景：一旦允许对象的大小可在运行期改变，那么假设在内存中有对象 A，并且其后面紧跟着对象 B。如果运行的某个时候，A 的大小增大了，这就意味着必须将 A 整个移动到内存中的其他位置，否则 A  增大的部分会覆盖掉原本属于 B 的数据。只要将 A 移动到内存的其他位置，那么所有指向 A  的指针就必须立即得到更新。可想而知这样的工作是多么的繁琐，而通过一个指针去操作就变得简单多了。</strong></p>
</blockquote>
<p><strong>可以看到 PyListObject 实例本身和指针数组之间是分离的，两者通过二级指针（ob_item）建立联系；但元组不同，它的大小不允许改变，因此 PyTupleObject 直接存储了指针数组本身（ob_item）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyTupleObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        <span class="comment"># 这里我们假设里面可以存 10 个元素</span></span><br><span class="line">        (<span class="string">&quot;ob_item&quot;</span>, (py_object * <span class="number">10</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tpl = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line">tuple_obj = PyTupleObject.from_address(<span class="built_in">id</span>(tpl))</span><br><span class="line"><span class="built_in">print</span>(tuple_obj.ob_size)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tpl))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们修改元组内的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改前：id(tpl) = <span class="subst">&#123;<span class="built_in">id</span>(tpl)&#125;</span>，tpl = <span class="subst">&#123;tpl&#125;</span>&quot;</span>)</span><br><span class="line">tuple_obj.ob_item[<span class="number">0</span>] = py_object(<span class="string">&quot;🍑&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后：id(tpl) = <span class="subst">&#123;<span class="built_in">id</span>(tpl)&#125;</span>，tpl = <span class="subst">&#123;tpl&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">修改前：id(tpl) = 140570376749888，tpl = (11, 22, 33)</span></span><br><span class="line"><span class="string">修改后：id(tpl) = 140570376749888，tpl = (&#x27;🍑&#x27;, 22, 33)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时我们就成功修改了元组里面的元素，并且修改前后元组的地址没有改变。</strong></p>
<blockquote>
<p><strong>要是以后谁跟你说 Python 元组里的元素不能修改，就拿这个例子堵他嘴。好吧，元组就是不可变的，举这个例子有点不太合适。</strong></p>
</blockquote>
<h3 id="给类对象增加属性"><a href="#给类对象增加属性" class="headerlink" title="给类对象增加属性"></a>给类对象增加属性</h3><p><strong>我们知道类对象（或者说类型对象）是有自己的属性字典的，但这个字典不允许修改，因为准确来说它不是字典，而是一个 mappingproxy 对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__dict__.__class__)  <span class="comment"># &lt;class &#x27;mappingproxy&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">str</span>.__dict__[<span class="string">&quot;嘿&quot;</span>] = <span class="string">&quot;蛤&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure>

<p><strong>我们无法通过修改 mappingproxy  对象来给类增加属性，因为它不支持增加、修改以及删除操作。当然对于自定义的类可以通过 setattr  方法实现，但是内置的类是行不通的，内置的类无法通过 setattr 进行属性添加。因此如果想给内置的类增加属性，只能通过  mappingproxy 入手，我们看一下它的底层结构。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134918602-366203763.png" alt="img"></p>
<p><strong>所谓的 mappingproxy  就是对字典包了一层，并只提供了查询功能。而且从函数 mappingproxy_len、mappingproxy_getitem  可以看出，mappingproxy 对象的长度就是内部字典的长度，获取 mappingproxy  对象的元素实际上就是获取内部字典的元素，因此操作 mappingproxy 对象就等价于操作其内部的字典。</strong></p>
<p><strong>所以我们只要能拿到 mappingproxy 对象内部的字典，那么可以直接操作字典来修改类属性。而 Python 有一个模块叫 gc，它可以帮我们实现这一点，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>, <span class="string">&quot;😒&quot;</span>]</span><br><span class="line"><span class="comment"># gc.get_referents(obj) 返回所有被 obj 引用的对象</span></span><br><span class="line"><span class="built_in">print</span>(gc.get_referents(lst))  <span class="comment"># [&#x27;😒&#x27;, 123, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="comment"># 显然 lst 引用的就是内部的三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还有 gc.get_referrers(obj)，它是返回所有引用了 obj 的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>那么问题来了，你觉得 mappingproxy 对象引用了谁呢？显然就是内部的字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.__dict__ 是一个 mappingproxy 对象，这里拿到其内部的字典，</span></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 随便增加一个属性</span></span><br><span class="line">d[<span class="string">&quot;嘿&quot;</span>] = <span class="string">&quot;蛤&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.嘿)  <span class="comment"># 蛤</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;嘿&quot;</span>.嘿)  <span class="comment"># 蛤</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们也可以增加一个函数，记得要有一个 self 参数</span></span><br><span class="line">d[<span class="string">&quot;smile&quot;</span>] = <span class="keyword">lambda</span> self: self + <span class="string">&quot;😊&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;微笑&quot;</span>.smile())  <span class="comment"># 微笑😊</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.smile(<span class="string">&quot;微笑&quot;</span>))  <span class="comment"># 微笑😊</span></span><br></pre></td></tr></table></figure>

<p><strong>但是需要注意的是，我们上面添加的是之前没有的新属性，如果是覆盖一个已经存在的属性或者函数，那么还缺一步。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line">d[<span class="string">&quot;split&quot;</span>] = <span class="keyword">lambda</span> self, *args: <span class="string">&quot;我被 split 了&quot;</span>  <span class="comment"># 覆盖 split 函数</span></span><br><span class="line"><span class="comment"># 可以通过 pythonapi 来调用 CPython 对外暴露的 API，后面会说</span></span><br><span class="line"><span class="comment"># 这里需要调用 pythonapi.PyType_Modified 来更新上面所做的修改</span></span><br><span class="line"><span class="comment"># 如果没有这一步，那么是没有效果的，甚至还会出现丑陋的段错误，使得解释器异常退出</span></span><br><span class="line">pythonapi.PyType_Modified(py_object(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># 我被 split 了</span></span><br></pre></td></tr></table></figure>

<p><strong>不过上面的代码还有一个缺点，那就是函数的名字没有修改：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split.__name__)  <span class="comment"># split</span></span><br><span class="line"></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line">d[<span class="string">&quot;split&quot;</span>] = <span class="keyword">lambda</span> self, *args: <span class="string">&quot;我被 split 了&quot;</span>  <span class="comment"># 覆盖 split 函数</span></span><br><span class="line">pythonapi.PyType_Modified(py_object(<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.split.__name__)  <span class="comment"># &lt;lambda&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到函数在修改之后名字就变了，匿名函数的名字就叫 <lambda>，所以我们可以再完善一下。</lambda></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_builtin_class</span>(<span class="params">cls, name, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param cls: 要修改的类</span></span><br><span class="line"><span class="string">    :param name: 属性名或者函数名</span></span><br><span class="line"><span class="string">    :param value: 值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(cls) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">type</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cls 必须是一个内置的类对象&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取 cls.__dict__ 内部的字典</span></span><br><span class="line">    cls_attrs = gc.get_referents(cls.__dict__)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果该属性或函数不存在，结果为 None；否则将值取出来，赋值给 old_value</span></span><br><span class="line">    old_value = cls_attrs.get(name, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 将 name、value 组合起来放到 cls_attrs 中，为 cls 这个类添砖加瓦</span></span><br><span class="line">    cls_attrs[name] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 old_value 为 None，说明我们添加了的一个新的属性或函数</span></span><br><span class="line">    <span class="comment"># 如果 old_value 不为 None，说明我们覆盖了的一个已存在的属性或函数</span></span><br><span class="line">    <span class="keyword">if</span> old_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 将原来函数的 __name__、__qualname__ 赋值给新的函数</span></span><br><span class="line">            <span class="comment"># 如果不是函数，而是普通属性，那么会因为没有 __name__ 而抛出 AttributeError</span></span><br><span class="line">            <span class="comment"># 这里我们直接 pass 掉即可，无需关心</span></span><br><span class="line">            value.__name__ = old_value.__name__</span><br><span class="line">            value.__qualname__ = old_value.__qualname__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 但是原来的属性或函数最好也不要丢弃，我们可以改一个名字</span></span><br><span class="line">        <span class="comment"># 假设我们修改 split 函数，那么修改之后，原来的 split 就需要通过 _str_split 进行调用</span></span><br><span class="line">        cls_attrs[<span class="string">f&quot;_<span class="subst">&#123;cls.__name__&#125;</span>_<span class="subst">&#123;name&#125;</span>&quot;</span>] = old_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不要忘了最关键的一步</span></span><br><span class="line">    pythonapi.PyType_Modified(py_object(cls))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.title())  <span class="comment"># Hello World</span></span><br><span class="line"><span class="comment"># 修改内置属性</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;title&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;我单词首字母大写了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.title())  <span class="comment"># 我单词首字母大写了</span></span><br><span class="line"><span class="built_in">print</span>(s.title.__name__)  <span class="comment"># title</span></span><br><span class="line"><span class="comment"># 而原来的 title 则需要通过 _str_title 进行调用</span></span><br><span class="line"><span class="built_in">print</span>(s._str_title())  <span class="comment"># Hello World</span></span><br></pre></td></tr></table></figure>

<p><strong>很明显，我们不仅可以修改 str，任意的内置的类都是可以修改的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 将 append 函数换成 pop 函数</span></span><br><span class="line">patch_builtin_class(<span class="built_in">list</span>, <span class="string">&quot;append&quot;</span>, <span class="keyword">lambda</span> self: <span class="built_in">list</span>.pop(self))</span><br><span class="line"><span class="comment"># 我们知道 append 需要接收一个参数，但这里我们不需要传，因为函数已经被换掉了</span></span><br><span class="line">lst.append()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># 而原来的 append 函数，则需要通过 _list_append 进行调用</span></span><br><span class="line">lst._list_append(<span class="number">666</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 666]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们还可以添加一个类方法或静态方法：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">patch_builtin_class(</span><br><span class="line">    <span class="built_in">list</span>,</span><br><span class="line">    <span class="string">&quot;new&quot;</span>,</span><br><span class="line">    <span class="built_in">classmethod</span>(<span class="keyword">lambda</span> cls, n: <span class="built_in">list</span>(<span class="built_in">range</span>(n)))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.new(<span class="number">5</span>))  <span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>还是很有趣的，但需要注意的是，我们目前的 patch_builtin_class 只能为类添加属性或函数，但其 “实例对象” 使用操作符时的表现是无法操控的。什么意思呢？我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment"># 每一个操作背后都被抽象成了一个魔法方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__add__(a, b))  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(a.__add__(b))  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写 __add__</span></span><br><span class="line">patch_builtin_class(<span class="built_in">int</span>, <span class="string">&quot;__add__&quot;</span>, <span class="keyword">lambda</span> self, other: self * other)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__add__(a, b))  <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(a.__add__(b))  <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 7 </span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到重写了 <strong>add</strong> 之后，直接调用魔法方法的话是没有问题的，打印的是重写之后的结果。而使用操作符的话（a + b），却没有走我们重写之后的 __add__，所以 a + b 的结果还是 7。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1, s2 = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__sub__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(s1.__sub__(s2))  <span class="comment"># (&#x27;hello&#x27;, &#x27;world&#x27;)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s1 - s2</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unsupported operand type(s) for -: &#x27;str&#x27; and &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们重写了 <strong>sub</strong> 之后，直接调用魔法方法的话也是没有问题的，但是用操作符（s1 - s2）就会报错，告诉我们字符串不支持减法操作，但我们明明实现了 <strong>sub</strong> 方法啊。想要知道原因并改变它，我们就要先知道类对象在底层是怎么实现的。</strong></p>
<h3 id="类对象的底层结构-PyTypeObject"><a href="#类对象的底层结构-PyTypeObject" class="headerlink" title="类对象的底层结构 PyTypeObject"></a>类对象的底层结构 PyTypeObject</h3><p><strong>首先思考两个问题：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p><strong>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</strong></p>
<p><strong>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的 PyObject 中的 ob_type，也就是类型的指针。我们通过对象的 ob_type 成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</strong></p>
<p><strong>下面我们来看看类型对象在底层是怎么定义的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头部信息，PyVarObject ob_base; 里面包含了 引用计数、类型、ob_size</span></span><br><span class="line">    <span class="comment">// 而创建这个结构体实例的话，Python 提供了一个宏，PyVarObject_HEAD_INIT(type, size)</span></span><br><span class="line">    <span class="comment">// 传入类型和 ob_size 可以直接创建，至于引用计数则默认为 1</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">// 创建之后的类名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    <span class="comment">// 大小，用于申请空间的，注意了，这里是两个成员</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    <span class="comment">// 析构方法__del__，当删除实例对象时会调用这个操作</span></span><br><span class="line">    <span class="comment">// typedef void (*destructor)(PyObject *); 函数接收一个 PyObject *，没有返回值</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    <span class="comment">// 打印其实例对象时调用的函数</span></span><br><span class="line">    <span class="comment">// typedef int (*printfunc)(PyObject *, FILE *, int); 函数接收一个PyObject *、FILE * 和 int</span></span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    <span class="comment">// 获取属性，内部的 __getattr__ 方法， typedef PyObject *(*getattrfunc)(PyObject *, char *);</span></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    <span class="comment">// 设置属性,内部的 __setattr__ 方法，typedef int (*setattrfunc)(PyObject *, char *, PyObject *);</span></span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    <span class="comment">// Python3.5 新增，协程对象所拥有的方法</span></span><br><span class="line">    PyAsyncMethods *tp_as_async; </span><br><span class="line">    <span class="comment">// 内部的 __repr__方法，typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    <span class="comment">// 一个对象作为数值所有拥有的方法</span></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    <span class="comment">// 一个对象作为序列所有拥有的方法</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    <span class="comment">// 一个对象作为映射所有拥有的方法</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    <span class="comment">// 内部的 __hash__ 方法，typedef Py_hash_t (*hashfunc)(PyObject *);</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    <span class="comment">// 内部的 __call__ 方法， typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    <span class="comment">// 内部的 __str__ 方法，typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    <span class="comment">// 获取属性，typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);</span></span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    <span class="comment">// 设置属性，typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    <span class="comment">// 用于实现缓冲区协议，实现了该协议可以和 Numpy 的 array 无缝集成</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="comment">// 这个类的特点，比如：</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HEAPTYPE：是否在堆区申请空间</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_BASETYPE：是否允许这个类被其它类继承</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_IS_ABSTRACT：是否为抽象类</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HAVE_GC: 是否被垃圾回收跟踪</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line">    <span class="comment">// 这个类的注释</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; </span><br><span class="line">    <span class="comment">// 用于检测是否出现循环引用，和下面的 tp_clear 是一组</span></span><br><span class="line">    <span class="comment">// typedef int (*traverseproc)(PyObject *, visitproc, void *);</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line">    <span class="comment">// 清除对包含对象的引用</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    <span class="comment">// 富比较，typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line">    <span class="comment">// 弱引用，不需要关心</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line">    <span class="comment">// __iter__方法，typedef PyObject *(*getiterfunc) (PyObject *);</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    <span class="comment">// __next__方法，typedef PyObject *(*iternextfunc) (PyObject *);</span></span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="comment">// 内部的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="comment">// 内部的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="comment">// 用于实现 getset</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="comment">// 继承的基类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    <span class="comment">// 内部的属性字典</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    <span class="comment">// 描述符，__get__ 方法，typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    <span class="comment">// 描述符，__set__ 方法</span></span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    <span class="comment">// 生成的实例对象是否有属性字典</span></span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    <span class="comment">// 初始化函数，typedef int (*initproc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    initproc tp_init;</span><br><span class="line">    <span class="comment">// 为实例对象分配空间的函数，typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);</span></span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    <span class="comment">// __new__ 方法，typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);</span></span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    <span class="comment">// 释放一个实例对象，typedef void (*freefunc)(void *); 一般会在析构函数中调用</span></span><br><span class="line">    freefunc tp_free; </span><br><span class="line">    <span class="comment">// typedef int (*inquiry)(PyObject *); 是否被 gc 跟踪</span></span><br><span class="line">    inquiry tp_is_gc; </span><br><span class="line">    <span class="comment">// 继承哪些类，这里可以指定继承多个类</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    <span class="comment">// __mro__</span></span><br><span class="line">    PyObject *tp_mro; </span><br><span class="line">    <span class="comment">// 下面的就不用管了</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而 Python 中的类对象（类型对象）在底层就是一个  PyTypeObject 实例，它保存了实例对象的元信息，描述对象的类型。所以 Python  中的实例对象在底层对应不同的结构体实例，而类对象则是对应同一个结构体实例，换句话说无论是 int、str、dict，还是其它的类对象，它们在 C 的层面都是由 PyTypeObject 这个结构体实例化得到的，只不过成员的值不同，PyTypeObject  这个结构体在实例化之后得到的类型对象也不同。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134927805-1711522230.png" alt="img"></p>
<p><strong>这里我们重点看一下里面的 tp_as_number、tp_as_sequence、tp_as_mapping  三个成员，它们表示实例对象为数值、序列、映射时所支持的操作。它们都是指向结构体的指针，该结构体中的每一个成员都是一个函数指针，指向的函数便是实例对象可执行的操作。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134933886-1744810130.png" alt="img"></p>
<p><strong>我们再看一下类对象 int 在底层的定义：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134940314-400340278.png" alt="img"></p>
<p><strong>我们注意到它的类型被设置成了 PyType_Type，所以在 Python 里面 int 的类型为 type。然后重点是 tp_as_number 成员，它被初始化为  &amp;long_as_number，而整型对象不支持序列和映射操作，所以 tp_as_sequence、tp_as_mapping 设置为  0。当然这三者都是指向结构体的指针类型，我们看一下 long_as_number。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134947996-1135053741.png" alt="img"></p>
<p><strong>因此 PyNumberMethods 的成员就是整数所有拥有的魔法方法，当然也包括浮点数。</strong></p>
<p><strong>至此，整个结构就很清晰了。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134953293-889612449.png" alt="img"></p>
<p><strong>若想改变操作符的表现行为，我们需要修改的是  tp_as_* 里面的成员的值，而不是简单的修改属性字典。比如我们想修改 a + b 的表现行为，那么就将类对象的 tp_as_number  里面的 nb_add 给改掉。如果是整形，那么就覆盖掉 long_add，也就是 “PyLong_Type -&gt;  long_as_number -&gt; nb_add”；同理，如果是浮点型，那么就覆盖掉  float_add，也就是 “PyFloat_Type -&gt; float_as_number -&gt; nb_add”。</strong></p>
<h3 id="重写操作符"><a href="#重写操作符" class="headerlink" title="重写操作符"></a>重写操作符</h3><p><strong>我们说类对象里面有 4 个方法集，分别是 tp_as_number、tp_as_sequence、tp_as_mapping、tp_as_async，如果我们想改变操作符的表现结果，那么就重写里面对应的函数即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这些对象提前声明好，之后再进行成员的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyObject</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyTypeObject</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyNumberMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PySequenceMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyMappingMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyAsyncMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyFile</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject._fields_ = [(<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">                     (<span class="string">&quot;ob_type&quot;</span>, POINTER(PyTypeObject))]</span><br><span class="line"></span><br><span class="line">PyTypeObject._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;ob_base&#x27;</span>, PyObject),</span><br><span class="line">    (<span class="string">&#x27;ob_size&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_name&#x27;</span>, c_char_p),</span><br><span class="line">    (<span class="string">&#x27;tp_basicsize&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_itemsize&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_dealloc&#x27;</span>, CFUNCTYPE(<span class="literal">None</span>, py_object)),</span><br><span class="line">    (<span class="string">&#x27;printfunc&#x27;</span>, CFUNCTYPE(c_int, py_object, POINTER(PyFile), c_int)),</span><br><span class="line">    (<span class="string">&#x27;getattrfunc&#x27;</span>, CFUNCTYPE(py_object, py_object, c_char_p)),</span><br><span class="line">    (<span class="string">&#x27;setattrfunc&#x27;</span>, CFUNCTYPE(c_int, py_object, c_char_p, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_async&#x27;</span>, CFUNCTYPE(PyAsyncMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_repr&#x27;</span>, CFUNCTYPE(py_object, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_number&#x27;</span>, POINTER(PyNumberMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_sequence&#x27;</span>, POINTER(PySequenceMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_mapping&#x27;</span>, POINTER(PyMappingMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_hash&#x27;</span>, CFUNCTYPE(c_int64, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_call&#x27;</span>, CFUNCTYPE(py_object, py_object, py_object, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_str&#x27;</span>, CFUNCTYPE(py_object, py_object)),</span><br><span class="line">    <span class="comment"># 不需要的可以不用写</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法集就是一个结构体实例，结构体成员都是函数</span></span><br><span class="line"><span class="comment"># 所以这里我们要相关的函数类型声明好</span></span><br><span class="line">inquiry = CFUNCTYPE(c_int, py_object)</span><br><span class="line">unaryfunc = CFUNCTYPE(py_object, py_object)</span><br><span class="line">binaryfunc = CFUNCTYPE(py_object, py_object, py_object)</span><br><span class="line">ternaryfunc = CFUNCTYPE(py_object, py_object, py_object, py_object)</span><br><span class="line">lenfunc = CFUNCTYPE(c_ssize_t, py_object)</span><br><span class="line">ssizeargfunc = CFUNCTYPE(py_object, py_object, c_ssize_t)</span><br><span class="line">ssizeobjargproc = CFUNCTYPE(c_int, py_object, c_ssize_t, py_object)</span><br><span class="line">objobjproc = CFUNCTYPE(c_int, py_object, py_object)</span><br><span class="line">objobjargproc = CFUNCTYPE(c_int, py_object, py_object, py_object)</span><br><span class="line"></span><br><span class="line">PyNumberMethods._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;nb_add&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_subtract&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_remainder&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_divmod&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_power&#x27;</span>, ternaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_negative&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_positive&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_absolute&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_bool&#x27;</span>, inquiry),</span><br><span class="line">    (<span class="string">&#x27;nb_invert&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_lshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_rshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_and&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_xor&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_or&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_int&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_reserved&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;nb_float&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_add&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_subtract&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_remainder&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_power&#x27;</span>, ternaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_lshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_rshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_and&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_xor&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_or&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_floor_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_true_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_floor_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_true_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_index&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_matrix_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_matrix_multiply&#x27;</span>, binaryfunc)]</span><br><span class="line"></span><br><span class="line">PySequenceMethods._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;sq_length&#x27;</span>, lenfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_concat&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_repeat&#x27;</span>, ssizeargfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_item&#x27;</span>, ssizeargfunc),</span><br><span class="line">    (<span class="string">&#x27;was_sq_slice&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;sq_ass_item&#x27;</span>, ssizeobjargproc),</span><br><span class="line">    (<span class="string">&#x27;was_sq_ass_slice&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;sq_contains&#x27;</span>, objobjproc),</span><br><span class="line">    (<span class="string">&#x27;sq_inplace_concat&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_inplace_repeat&#x27;</span>, ssizeargfunc)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这些魔法方法的名字和底层的结构体成员组合起来</span></span><br><span class="line">magic_method_dict = &#123;</span><br><span class="line">    <span class="string">&quot;__add__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_add&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__sub__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_subtract&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__mul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__mod__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_remainder&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__pow__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_power&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__neg__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_negative&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__pos__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_positive&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__abs__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_absolute&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__bool__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_bool&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__inv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_invert&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__invert__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_invert&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__lshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_lshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__rshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_rshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__and__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_and&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__xor__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_xor&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__or__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_or&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__int__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_int&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__float__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_float&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iadd__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_add&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__isub__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_subtract&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imod__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_remainder&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ipow__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_power&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ilshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_lshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__irshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_rshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iand__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_and&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ixor__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_xor&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ior__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_or&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__floordiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_floor_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__div__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_true_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ifloordiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_floor_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__idiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_true_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__index__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_index&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__matmul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_matrix_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imatmul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_matrix_multiply&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;__len__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_length&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__concat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_concat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__repeat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_repeat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__getitem__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_item&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__setitem__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_ass_item&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__contains__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_contains&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iconcat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_inplace_concat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__irepeat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_inplace_repeat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keep_method_alive= &#123;&#125;</span><br><span class="line">keep_method_set_alive= &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上就准备就绪了，下面再将之前的 patch_builtin_class 函数补充一下即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_builtin_class</span>(<span class="params">cls, name, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param cls: 要修改的类</span></span><br><span class="line"><span class="string">    :param name: 属性名或者函数名</span></span><br><span class="line"><span class="string">    :param value: 值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(cls) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">type</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cls 必须是一个内置的类对象&quot;</span>)</span><br><span class="line">    cls_attrs = gc.get_referents(cls.__dict__)[<span class="number">0</span>]</span><br><span class="line">    old_value = cls_attrs.get(name, <span class="literal">None</span>)</span><br><span class="line">    cls_attrs[name] = value</span><br><span class="line">    <span class="keyword">if</span> old_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value.__name__ = old_value.__name__</span><br><span class="line">            value.__qualname__ = old_value.__qualname__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        cls_attrs[<span class="string">f&quot;_<span class="subst">&#123;cls.__name__&#125;</span>_<span class="subst">&#123;name&#125;</span>&quot;</span>] = old_value</span><br><span class="line">    pythonapi.PyType_Modified(py_object(cls))</span><br><span class="line">    <span class="comment"># 以上逻辑不变，然后对参数 name 进行检测</span></span><br><span class="line">    <span class="comment"># 如果是魔方方法、并且 value 是一个可调用对象，那么修改操作符，否则直接 return</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> magic_method_dict <span class="keyword">and</span> <span class="built_in">callable</span>(value):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 比如 name 是 __sub__，那么 tp_as_name, rewrite == &quot;tp_as_number&quot;, &quot;nb_sub&quot;</span></span><br><span class="line">    tp_as_name, rewrite = magic_method_dict[name]</span><br><span class="line">    <span class="comment"># 获取类对应的底层结构，PyTypeObject 实例</span></span><br><span class="line">    type_obj = PyTypeObject.from_address(<span class="built_in">id</span>(cls))</span><br><span class="line">    <span class="comment"># 根据 tp_as_name 判断到底是哪一个方法集，这里我们没有实现 tp_as_mapping 和 tp_as_async</span></span><br><span class="line">    struct_method_set_class = (PyNumberMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_number&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PySequenceMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_sequence&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PyMappingMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_mapping&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PyAsyncMethods)</span><br><span class="line">    <span class="comment"># 获取具体的方法集（指针）</span></span><br><span class="line">    struct_method_set_ptr = <span class="built_in">getattr</span>(type_obj, tp_as_name, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> struct_method_set_ptr:</span><br><span class="line">        <span class="comment"># 如果不存在此方法集，我们实例化一个，然后设置到里面去</span></span><br><span class="line">        struct_method_set = struct_method_set_class()</span><br><span class="line">        <span class="comment"># 注意我们要传一个指针进去</span></span><br><span class="line">        <span class="built_in">setattr</span>(type_obj, tp_as_name, pointer(struct_method_set))</span><br><span class="line">    <span class="comment"># 然后对指针进行解引用，获取方法集，也就是对应的结构体实例</span></span><br><span class="line">    struct_method_set = struct_method_set_ptr.contents</span><br><span class="line">    <span class="comment"># 遍历 struct_method_set_class，判断到底重写的是哪一个魔法方法</span></span><br><span class="line">    cfunc_type = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> field, ftype <span class="keyword">in</span> struct_method_set_class._fields_:</span><br><span class="line">        <span class="keyword">if</span> field == rewrite:</span><br><span class="line">            cfunc_type = ftype</span><br><span class="line">    <span class="comment"># 构造新的函数</span></span><br><span class="line">    cfunc = cfunc_type(value)</span><br><span class="line">    <span class="comment"># 更新方法集</span></span><br><span class="line">    <span class="built_in">setattr</span>(struct_method_set, rewrite, cfunc)</span><br><span class="line">    <span class="comment"># 至此我们的功能就完成了，但还有一个非常重要的点，就是上面的 cfunc</span></span><br><span class="line">    <span class="comment"># 虽然它是一个底层可以识别的 C 函数，但它本质上仍然是一个 Python 对象</span></span><br><span class="line">    <span class="comment"># 其内部维护了 C 级数据，赋值之后底层会自动提取，而这一步不会增加引用计数</span></span><br><span class="line">    <span class="comment"># 所以这个函数结束之后，cfunc 就被销毁了（连同内部的 C 级数据）</span></span><br><span class="line">    <span class="comment"># 这样后续再调用相关操作符的时候就会出现段错误，解释器异常退出</span></span><br><span class="line">    <span class="comment"># 因此我们需要在函数结束之前创建一个在外部持有它的引用</span></span><br><span class="line">    keep_method_alive[(cls, name)] = cfunc</span><br><span class="line">    <span class="comment"># 当然还有我们上面的方法集，也是同理</span></span><br><span class="line">    keep_method_set_alive[(cls, name)] = struct_method_set</span><br></pre></td></tr></table></figure>

<p><strong>代码量还是稍微有点多的，但是不难理解，我们将这些代码放在一个单独的文件里面，文件名就叫 unsafe_magic.py，然后导入它。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch_builtin_class(<span class="built_in">int</span>, <span class="string">&quot;__getitem__&quot;</span>, <span class="keyword">lambda</span> self, item: <span class="string">&quot;_&quot;</span>.join([<span class="built_in">str</span>(self)] * item))</span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__matmul__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__sub__&quot;</span>, <span class="keyword">lambda</span> self, other: other + self)</span><br></pre></td></tr></table></figure>

<p><strong>你觉得之后会发生什么呢？我们测试一下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031135007088-270878613.png" alt="img"></p>
<p><strong>怎么样，是不是很好玩呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch_builtin_class(<span class="built_in">tuple</span>, <span class="string">&quot;append&quot;</span>, <span class="keyword">lambda</span> self, item: self + (item, ))</span><br><span class="line">t = ()</span><br><span class="line"><span class="built_in">print</span>(t.append(<span class="number">1</span>).append(<span class="number">2</span>).append(<span class="number">3</span>).append(<span class="number">4</span>))  <span class="comment"># (1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>

<p><strong>因此 Python 给开发者赋予的权限是非常高的，你可以玩出很多意想不到的新花样。</strong></p>
<p><strong>另外再多说一句，当对象不支持某个操作符的时候，我们能够让它实现该操作符；但如果对象已经实现了某个操作符，那么其逻辑就改不了了，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"><span class="comment"># str 没有 __div__，我们可以为其实现，此时字符串便拥有了除法的功能</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__div__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> / <span class="string">&quot;world&quot;</span>)  <span class="comment"># (&#x27;hello&#x27;, &#x27;world&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但 __add__ 是 str 本身就有的，也就是说字符串本身就可以相加</span></span><br><span class="line"><span class="comment"># 而此时我们就无法覆盖加法这个操作符了</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__add__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span> + <span class="string">&quot;好&quot;</span>)  <span class="comment"># 你好</span></span><br><span class="line"><span class="comment"># 我们看到使用加号，并没有走我们重写之后的 __add__ 方法，因为字符串本身就支持加法运算</span></span><br><span class="line"><span class="comment"># 但也有例外，就是当出现 TypeError 的时候，那么解释器会执行我们重写的方法</span></span><br><span class="line"><span class="comment"># 字符串和整数相加会出现异常，因此解释器会执行我们重写的 __add__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span> + <span class="number">123</span>)  <span class="comment"># (&#x27;你&#x27;, 123)</span></span><br><span class="line"><span class="comment"># 但如果是调用魔方方法，那么会直接走我们重写的 __add__，前面说过的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span>.__add__(<span class="string">&quot;好&quot;</span>))  <span class="comment"># (&#x27;你&#x27;, &#x27;好&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>不过上述这个问题在 3.6 版本的时候是没有的，操作符会无条件地执行我们重写的魔法方法。但在 3.8 的时候出现了这个现象，可以自己测试一下。</strong></p>
<p><strong>最后再来说一说 Python&#x2F;C API，Python 解释器暴露了大量的 C 一级的 API 供我们调用，而调用方式可以通过 ctypes.pythonapi 来实现。我们之前用过一次，就是  pythonapi.PyType_Modified。那么再举个例子来感受一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 函数原型：PyList_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)</span></span><br><span class="line"><span class="comment"># 调用的时候类型一定要匹配，否则很容易导致解释器异常退出</span></span><br><span class="line">pythonapi.PyList_SetItem(py_object(lst), <span class="number">1</span>, py_object(<span class="number">666</span>))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 666, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>ctypes.pythonapi 用的不是很多，像 Python 提供的 C 级 API 一般在编写扩展的时候有用。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>以上我们就用 ctypes 玩了一些骚操作，内容还是有点单调，当然你也可以玩的再嗨一些。但是无论如何，一定不要在生产上使用，线上不要出现这种会改变解释器运行逻辑的代码。如果只是为了调试、或者想从实践的层面更深入的了解虚拟机，那么没事可以玩一玩。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>35-Numba是如何解决Python的三大性能瓶颈的</title>
    <url>/2023/04/26/35-Numba%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Python%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%9A%84/</url>
    <content><![CDATA[<h2 id="35-Numba是如何解决Python的三大性能瓶颈的"><a href="#35-Numba是如何解决Python的三大性能瓶颈的" class="headerlink" title="35-Numba是如何解决Python的三大性能瓶颈的"></a>35-Numba是如何解决Python的三大性能瓶颈的</h2><h3 id="为什么python这么慢"><a href="#为什么python这么慢" class="headerlink" title="为什么python这么慢"></a><strong>为什么python这么慢</strong></h3><h4 id="1、动态变量："><a href="#1、动态变量：" class="headerlink" title="1、动态变量："></a><strong>1、动态变量：</strong></h4><p>在c中我们编写一些功能性代码，需要严格定义变量的类型，比如进行加法计算，需要定义我们的数据是int、float还是其它类型，而python中则不需要，<strong>这是我在实践中发现影响python运行速度最大的因素之一，具体的原因在于：</strong></p>
<p><img src="/2023/04/26/35-Numba%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Python%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%9A%84/image-20230320161133920.png" alt="image-20230320161133920"></p>
<p>在python中，所有的变量都是对象，例如：</p>
<p><img src="/2023/04/26/35-Numba%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Python%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%9A%84/image-20230320161159252.png" alt="image-20230320161159252"></p>
<p>​    我们可以看到一个简单的a中，有这么多的methods。。。python的变量定义的便利性也给python的效率带来了很大的问题，</p>
<p>​     Python等动态类型语言之所以慢，就是因为每一个简单的操作都需要大量的指令才能完成。他们的虚拟机拥有很强的优化器，却是为静态语言设计的。对Python几乎没有效果。举一个例子。对于整数加法，C语言很简单，只要一个机器指令ADD就可以了，最多不过再加一些内存读写。但是，对于Python来说，a+b这样的简单二元运算，可就真的很麻烦了。Python是动态语言，变量只是对象的引用，变量a和b本身都没有类型，而它们的值有类型。<strong>所以，在相“加”之前，必须先判断类型。</strong></p>
<h4 id="2、大量重复的编译"><a href="#2、大量重复的编译" class="headerlink" title="2、大量重复的编译"></a>2、<strong>大量重复的编译</strong></h4><p>前面提到过了，编译型语言，可以一次编译，下次使用直接运行，而python这种解释性语言，每次运行的时候都要重新将源代码通过解释器转化为机器码；</p>
<h4 id="3、gil锁"><a href="#3、gil锁" class="headerlink" title="3、gil锁"></a><strong>3、gil锁</strong></h4><p>在理解gil锁之前需要理解一下基本概念</p>
<p>GIL：Global Interpreter Lock又称全局解释器锁。简单来说是一个互斥锁，每个线程在执行的过程中都需要先获取GIL，作用就是限制多线程同时执行，使得在同一进程内任何时刻仅有一个线程在执行。</p>
<p>由于GIL的存在，在Python上开启多个线程时，每个单独线程都会在竞争到GIL后才运行，因此在我们的Python语言中多线程其实是假的多线程，它只会在一个CPU上运行。即使在具有多核CPU中，Python的多线程也是串行执行的，并不会同一时间多个线程分布在多个CPU上运行。</p>
<p>GIL的优缺点<br>优点：<font color="red">线程是非独立的，所以同一进程里线程是数据共享，当各个线程访问数据资源时会出现“竞争”状态，即数据可能会同时被多个线程占用，造成数据混乱，这就是线程的不安全。所以引进了互斥锁，确保某段关键代码、共享数据只能由一个线程从头到尾完整地执行。</font></p>
<p>缺点： <font color="red">单个进程下，开启多个线程，无法实现并行，只能实现并发，牺牲执行效率。</font></p>
<p><font color="red">由于GIL锁的限制，所以多线程不适合计算密集型任务，更适合IO密集型任务</font></p>
<p> <font color="red">常见IO密集型任务：网络IO（抓取网页数据）、磁盘操作（读写文件）、键盘输入</font></p>
<p>面试常见</p>
<p>描述Python GIL的概念， 以及它对Python多线程的影响？<br>编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p>
<p>参考答案：</p>
<pre><code>GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。
Python语言和GIL没有任何关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GIL。
线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL
Python使用多进程是可以利用多核的CPU资源的。
多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁。
</code></pre>
<h3 id="numba是如何解决python的三大问题的"><a href="#numba是如何解决python的三大问题的" class="headerlink" title="numba是如何解决python的三大问题的"></a><strong>numba是如何解决python的三大问题的</strong></h3><h4 id="1、动态变量问题"><a href="#1、动态变量问题" class="headerlink" title="1、动态变量问题"></a><strong>1、动态变量问题</strong></h4><p>使用过numba的用户应该知道，如果在jit装饰的时候，nopython设置为True，则numba几乎不会提速甚至反而会更慢一点，numba在nopython模式下不适用python  定义的动态变量，而是使用静态变量定义，因此有效的避免了python动态变量的一大堆复杂的检查，但是这也意味着nopython模型下，编程的灵活性变低，你额能无法像python环境中一样自由地进行字符的四则运算；</p>
<h4 id="2、-编译问题"><a href="#2、-编译问题" class="headerlink" title="2、 编译问题"></a>2、 <strong>编译问题</strong></h4><p><strong>这里要写了解什么是jit 编译：</strong></p>
<p>即时编译（英语：Just-in-time  compilation），又译及时编译、实时编译[3]，动态编译的一种形式，是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态编译。静态编译的程序在执行前全部被翻译为机器码，而动态编译执行的则是一句一句边运行边翻译。即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。</p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>31-Python 和 C  C++ 联合编程</title>
    <url>/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="31-Python-和-C-x2F-C-联合编程"><a href="#31-Python-和-C-x2F-C-联合编程" class="headerlink" title="31-Python 和 C &#x2F; C++ 联合编程"></a>31-Python 和 C &#x2F; C++ 联合编程</h1><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p><strong>Python 和 C &#x2F; C++ 混合编程已经屡见不鲜了，那为什么要将这两种语言结合起来呢？或者说，这两种语言混合起来能给为我们带来什么好处呢？首先，Python 和 C &#x2F; C++ 联合，无非两种情况。</strong></p>
<ul>
<li><code>1. C / C++ 为主导的项目中引入 Python;</code></li>
<li><code>2. Python 为主导的项目中引入 C / C++;</code></li>
</ul>
<p><strong>首先是第一种情况，因为 C &#x2F; C++  是编译型语言，而它们的编译调试的成本是很大的。如果用 C &#x2F; C++  开发一个大型项目的话，比如游戏引擎，这个时候代码的修改、调试是无可避免的。而对于编译型语言来说，你对代码做任何一点改动都需要重新编译，而这个耗时是比较长的，所以这样算下来成本会非常高。这个时候一个比较不错的做法是，将那些跟性能无关的内容开放给脚本，可以是 Lua 脚本、也可以是 Python 脚本，而脚本语言不需要编译，我们可以随时修改，这样可以减少编译调试的成本。还有就是引入了 Python  脚本之后，我们可以把 C &#x2F; C++ 做的更加模块化，由 Python 将 C &#x2F; C++ 各个部分联合起来，这样可以降低 C &#x2F; C++  代码的耦合度，从而加强可重用性。</strong></p>
<p><strong>然后是第二种情况，Python 项目中引入 C &#x2F; C++。我们知道  Python 的效率不是很高，如果你希望 Python 能够具有更高的性能，那么可以把一些和性能相关的逻辑使用 C &#x2F; C++  进行重写。此外，Python 有大量的第三方库，特别是诸如 Numpy、Pandas、Scipy 等等和科学计算密切相关的库，底层都是基于 C &#x2F; C++ 的。再比如机器学习，底层核心算法都是基于 C &#x2F; C++ 编写的，然后在业务层暴露给 Python  去调用，因此对于一些需要高性能的领域，Python 是必须要引入 C &#x2F; C++ 的。此外 Python 还有一个最让人诟病的问题，就是由于  GIL 的限制导致 Python 无法有效利用多核，而引入 C &#x2F; C++ 可以绕过 GIL 的限制。</strong></p>
<blockquote>
<p><strong>此外有一个项目叫做 Cython，从名字你就能看出来这是将 Python 和 C &#x2F; C++ 结合在了一起，之所以把它们结合在一起，很明显，因为这两者不是对立的，而是互补的。Python  是高阶语言、动态、易于学习，并且灵活。但是这些优秀的特性是需要付出代价的，因为 Python  的动态性、以及它是解释型语言，导致其运行效率比静态编译型语言慢了好几个数量级。而 C &#x2F; C++  是非常古老的静态编译型语言，并且至今也被广泛使用。从时间来算的话，其编译器已有将近半个世纪的历史，在性能上做了足够的优化。而 Cython  的出现，就是为了让你编写的代码具有 C &#x2F; C++ 的高效率的同时，还能有 Python 的开发速度。</strong></p>
</blockquote>
<p><strong>而笔者本人是主 Python  的，所以我们只会介绍第二种，也就是 Python 项目中引入 C &#x2F; C++。而在 Python 中引入 C &#x2F;  C++，也涉及两种情况。第一种是，Python 通过 ctypes 模块直接调用 C &#x2F; C++ 编写好的动态链接库，此时不会涉及任何的  Python &#x2F; C API，只是单纯的通过 ctypes 模块将 Python 中的数据转成 C  中的数据传递给函数进行调用，调用完之后再将返回值转成 Python 中的数据。因此这种方式它和 Python 底层提供的 Python &#x2F; C  API 无关，和 Python  的版本也无关，因此会很方便。但很明显这种方式是有局限性的，至于局限性在哪儿，我们后面慢慢聊，因此还有一种选择是通过 C &#x2F; C++ 为  Python 编写扩展模块的方式，来在 Python 中引入 C &#x2F; C++，比如 OpenCV。</strong></p>
<p><strong>无论是 ctypes 调用动态链接库，还是 C &#x2F; C++ 为 Python 编写扩展模块，我们都会介绍。</strong></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>首先是 Python 的安装，估计这应该不用我说了，我这里使用的 Python 版本是 3.8.7。</strong></p>
<p><strong>然后重点是 C &#x2F; C++ 编译器的安装，我这里使用的是 64 位的 Windows 10 操作系统，所以我们需要手动安装相应的编译环境。可以下载一个 gcc，然后配置到环境变量中，就可以使用了。</strong></p>
<p><strong>或者安装 Visual Studio，我的 Visual Studio 版本是 2017，在命令行中可以通过 cl 命令进行编译。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015141779-226451671.png" alt="img"></p>
<p><strong>当然这两种命令的使用方式都是类似的，或者你也可以使用 Linux，比如  CentOS，基本上自带 gcc。当然 Linux 的话，环境什么的比较简单，这里就不再废话了。重点是如果你是在 Windows 上使用  Visual Studio 的话，在命令行中输入命令 cl，很可能会提示你命令找不到；再或者编译的时候，会提示你 fatal error  不包括路径集等等。出现以上问题的话，说明你的环境变量没有配置正确，下面来说一下环境变量的配置。再次强调，我操作系统是 64 位 Windows  10，Visual Studio 版本是  2017，相信大部分人应该我是一样的，如果完全一样的话，那么路径啥的应该也是一致的，当然最好还是检查一下。</strong></p>
<p><strong>首先在 path 中添加如下几个路径：</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x64</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015149372-462263121.png" alt="img"></p>
<p><strong>然后，新建一个环境变量。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015154132-1559314596.png" alt="img"></p>
<p><strong>变量名为 LIB，变量值为以下路径，由于是写在一行，所以路径之间需要使用分号进行隔开。</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um\x64</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\ucrt\x64</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x64</code></li>
</ul>
<p><strong>最后，还是新建一个环境变量，变量名为 INCLUDE，变量值为以下路径：</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\include</code></li>
</ul>
<p><strong>以上就是 Windows 系统中配置 Visual Studio 2017 环境变量的整个过程，配置完毕之后重启命令行之后就可以使用了。注意：以上是我当前机器的路径，如果你的配置和我不一样，记得仔细检查。</strong></p>
<blockquote>
<p><strong>不过个人更习惯使用 gcc，因此后面我们会使用 gcc 进行编译。</strong></p>
</blockquote>
<h2 id="Python-ctypes-模块调用-C-x2F-C-动态链接库"><a href="#Python-ctypes-模块调用-C-x2F-C-动态链接库" class="headerlink" title="Python ctypes 模块调用 C &#x2F; C++ 动态链接库"></a>Python ctypes 模块调用 C &#x2F; C++ 动态链接库</h2><p><strong>通过 ctypes 模块（Python 自带的）调用 C &#x2F; C++  动态库，也算是 Python 和 C &#x2F; C++ 联合编程的一种方案，而且是最简单的一种方案。因为它只对你的操作系统有要求，比如 Windows 上编译的动态库是 .dll 文件，Linux 上编译的动态库是 .so 文件，只要操作系统一致，那么任何提供了 ctypes 模块的  Python 解释器都可以调用。这种方式的使用场景是 Python 和 C &#x2F; C++  不需要做太多的交互，比如嵌入式设备，可能只是简单调用底层驱动提供的某个接口而已。</strong></p>
<p><strong>再比如我们使用 C &#x2F; C++ 写了一个高性能的算法，然后通过  Python 的 ctypes 模块进行调用也是可以的，但我们之前说使用 ctypes 具有相应的局限性，这个局限性就是 C &#x2F; C++  提供的接口不能太复杂。因为 ctypes  提供的交互能力还是比较有限的，最明显的问题就是不同语言数据类型不同，一些复杂的交互方式还是比较难做到的，还有多线程的控制问题等等。</strong></p>
<h3 id="举个小栗子"><a href="#举个小栗子" class="headerlink" title="举个小栗子"></a>举个小栗子</h3><p><strong>首先我们来举个栗子，演示一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是个简单到不能再简单的 C 函数，然后我们来编译成动态库。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编译方式: gcc -o .dll文件或者.so文件 -shared c或者c++源文件</span><br></pre></td></tr></table></figure>

<p><strong>如果你用的是 Visual Studio，那么把 gcc 换成 cl 即可。我当前的源文件叫做 main.c，我们编译成 main.dll，那么命令就需要这么写：gcc -o main.dll -shared main.c。</strong></p>
<p><strong>编译成功之后，我们通过 ctypes 来进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ctypes 很简单，直接import进来，然后使用 ctypes.CDLL 这个类来加载动态链接库</span></span><br><span class="line"><span class="comment"># 或者是用 ctypes.cdll.LoadLibrary(&quot;./main.dll&quot;)</span></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="comment"># 我们可以直接通过 . 的方式去调用里面的函数了，会发现成功打印</span></span><br><span class="line"><span class="built_in">print</span>(lib.f())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是为了确定是否存在这个函数，我们一般会使用反射去获取</span></span><br><span class="line"><span class="comment"># 因为如果函数不存在通过 . 的方式调用会抛异常的</span></span><br><span class="line">func = <span class="built_in">getattr</span>(lib, <span class="string">&quot;f&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> func:</span><br><span class="line">    <span class="built_in">print</span>(func)  <span class="comment"># &lt;_FuncPtr object at 0x0000029F75F315F0&gt;</span></span><br><span class="line">    func()  <span class="comment"># hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不存在 f2 这个函数，所以得到的结果为 None</span></span><br><span class="line">func1 = <span class="built_in">getattr</span>(lib, <span class="string">&quot;f2&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(func1)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>所以使用ctypes去调用动态链接库非常方便，过程很简单：</strong></p>
<ul>
<li><code>1. 通过 ctypes.CDLL 去加载动态库，另外注意的是：dll 或者 so  文件的路径最好是绝对路径，即便不是也要表明层级。比如我们这里的 py 文件和 dll 文件是在同一个目录下，但是我们加载的时候不可以写  main.dll，这样会报错找不到，我们需要写成 ./main.dll</code></li>
<li><code>2. 加载动态链接库之后会返回一个对象，我们上面起名为 lib，这个 lib 就是得到的动态链接库了</code></li>
<li><code>3. 然后可以直接通过 lib 调用里面的函数，但是一般我们会使用反射的方式来获取，因为不知道函数到底存不存在，如果不存在直接调用会抛出异常，如果存在这个函数我们才会调用。</code></li>
</ul>
<blockquote>
<p><strong>Linux 和 Mac 也是一样的，这里不演示了，只不过编译之后的名字不一样。Linux 系统是 .so，Mac 系统是 .dylib。</strong></p>
</blockquote>
<p><strong>此外我们也可以在 C 中进行打印，举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后编译，进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line">lib.f()  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>另外，Python 的 ctypes 调用的都是 C  语言函数，如果你用的 C++ 编译器，那么会编译成 C++ 中的函数。我们知道 C 语言的函数不支持重载，说白了就是不可以定义两个同名的函数，而 C++ 的函数是支持重载的，只要参数类型不一致即可，然后调用的时候会根据传递的参数调用对应的函数。所以当我们使用 C++  编译器的时候，需要通过 extern “C” 将函数包起来，这样 C++ 编译器在编译的时候会将其编译成 C 的函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 我们不能直接通过 extern &quot;C&quot; &#123;&#125; 将函数包起来, 因为这不符合 C 的语法, extern 在 C 中是用来声明一个外部变量的</span></span><br><span class="line"><span class="comment">// 所以我们应该使用宏替换的方式, 如果是 C++ 编译器的话, 那么编译的时候 #ifdef __cplusplus 是会通过的, 因为 __cplusplus 是一个预定义的宏</span></span><br><span class="line"><span class="comment">// 如果是 C 编译器, 那么 #ifdef __cplusplus 不会通过</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>当然我们在介绍 ctypes 使用的 gcc 都是 C 编译器，会编译成 C 的函数，所以后面 extern “C” 的逻辑就不加了。</strong></p>
<p><strong>我们以上就演示了，如何通过 Python 的 ctypes 模块来调用 C &#x2F; C++ 动态库，但显然目前还是远远不够的。比如说：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们调用的时候，会得到什么结果呢？来试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="built_in">print</span>(lib.f())  <span class="comment"># 1374389535</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到得到一个不符合预期的结果，我们暂且不纠结它是怎么来的，现在的问题是它返回的为什么不是 3.14 呢？原因是 ctypes 在解析的时候默认是按照整型来解析的，但很明显我们 C 函数返回是浮点型，因此我们在调用之前需要显式的指定其返回值。</strong></p>
<p><strong>不过在这之前，我们需要先来看看 Python 类型和 C 类型之间的转换关系。</strong></p>
<h3 id="Python-类型与-C-语言类型之间的转换"><a href="#Python-类型与-C-语言类型之间的转换" class="headerlink" title="Python 类型与 C 语言类型之间的转换"></a>Python 类型与 C 语言类型之间的转换</h3><p><strong>我们说可以使用 ctypes  调用动态链接库，主要是调用动态链接库中使用C编写好的函数，但这些函数肯定都是需要参数的，还有返回值，不然编写动态链接库有啥用呢。那么问题来了，不同的语言变量类型不同，所以 Python 能够直接往 C 编写的函数中传参吗？显然不行，因此 ctypes 提供了大量的类，帮我们将 Python 中的类型转成 C  语言中的类型。</strong></p>
<p><strong>我们说了，Python 中类型不能直接往 C 语言的函数中传递（整型是个例外），而 ctypes 可以帮助我们将 Python 的类型转成 C 类型。而常见的类型分为以下几种：数值、字符、指针。</strong></p>
<h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p><strong>C 语言的数值类型分为如下：</strong></p>
<ul>
<li><code>int：整型</code></li>
<li><code>unsigned int：无符号整型</code></li>
<li><code>short：短整型</code></li>
<li><code>unsigned short：无符号短整型</code></li>
<li><code>long：长整形</code></li>
<li><code>unsigned long：无符号长整形</code></li>
<li><code>long long：64位机器上等同于 long</code></li>
<li><code>unsigned long long：等同于 unsigned long</code></li>
<li><code>float：单精度浮点型</code></li>
<li><code>double：双精度浮点型</code></li>
<li><code>long double：看成是 double 即可</code></li>
<li><code>_Bool：布尔类型</code></li>
<li><code>ssize_t：等同于 long 或者 long long</code></li>
<li><code>size_t：等同于 unsigned long 或者 unsigned long long</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015202708-1325772424.png" alt="img"></p>
<p><strong>下面来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面都是 ctypes 中提供的类，将 Python 中的对象传进去，就可以转换为 C 语言能够识别的类型</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_uint(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_short(<span class="number">1</span>))  <span class="comment"># c_short(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ushort(<span class="number">1</span>))  <span class="comment"># c_ushort(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_long(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulong(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_longlong 等价于 c_long，c_ulonglong 等价于c_ulong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longlong(<span class="number">1</span>))  <span class="comment"># c_longlong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulonglong(<span class="number">1</span>))  <span class="comment"># c_ulonglong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_float(<span class="number">1.1</span>))  <span class="comment"># c_float(1.100000023841858)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_double(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在64位机器上，c_longdouble等于c_double</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longdouble(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_bool(<span class="literal">True</span>))  <span class="comment"># c_bool(True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于c_longlong和c_ulonglong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ssize_t(<span class="number">10</span>))  <span class="comment"># c_longlong(10)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_size_t(<span class="number">10</span>))  <span class="comment"># c_ulonglong(10)</span></span><br></pre></td></tr></table></figure>

<h4 id="字符类型转换、指针类型转换"><a href="#字符类型转换、指针类型转换" class="headerlink" title="字符类型转换、指针类型转换"></a>字符类型转换、指针类型转换</h4><p><strong>C 语言的字符类型分为如下：</strong></p>
<ul>
<li><code>char：一个 ascii 字符或者 -128~127 的整型</code></li>
<li><code>wchar：一个 unicode 字符</code></li>
<li><code>unsigned char：一个 ascii 字符或者 0~255 的一个整型</code></li>
</ul>
<p><strong>C 语言的指针类型分为如下：</strong></p>
<ul>
<li><code>char *：字符指针</code></li>
<li><code>wchar_t *：字符指针</code></li>
<li><code>void *：空指针</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015210704-1251164677.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传递一个字节(里面是 ascii 字符)，或者一个 int，来代表 C 里面的字符</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="string">b&quot;a&quot;</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="number">97</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递一个 unicode 字符，当然 ascii 字符也是可以的，并且不是字节形式</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># c_wchar(&#x27;憨&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和 c_char 类似，但是 c_char 既可以传入单个字节、也可以传整型，而这里的 c_byte 则要求必须传递整型。</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_byte(<span class="number">97</span>))  <span class="comment"># c_byte(97)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ubyte(<span class="number">97</span>))  <span class="comment"># c_ubyte(97)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_char_p 就是 c 里面字符数组了，其实我们可以把它看成是 Python 中的 bytes 对象</span></span><br><span class="line"><span class="comment"># char *s = &quot;hello world&quot;;</span></span><br><span class="line"><span class="comment"># 那么这里面也要传递一个 bytes 类型的字符串，返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># c_char_p(2082736374464)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接传递一个字符串，同样返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar_p(<span class="string">&quot;憨八嘎~&quot;</span>))  <span class="comment"># c_wchar_p(2884583039392)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctypes.c_void_p后面演示</span></span><br></pre></td></tr></table></figure>

<p><strong>常见的类型就是上面这些，至于其他的类型，比如整型指针、数组、结构体、回调函数等等，ctypes 也是支持的，我们后面会介绍。</strong></p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>下面我们来看看如何传递参数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> f, <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %.2f, s = %s\n&quot;</span>, a, f, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是一个很简单的 C 文件，然后编译成 dll 之后，让 Python 去调用，这里我们编译之后的文件名叫做还叫做 main.dll。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lib.test(<span class="number">1</span>, <span class="number">1.2</span>, <span class="string">b&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 2: &lt;class &#x27;TypeError&#x27;&gt;: Don&#x27;t know how to convert parameter 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到一个问题，那就是报错了，告诉我们不知道如何转化第二个参数</span></span><br><span class="line"><span class="comment"># 正如我们之前说的，整型是会自动转化的，但是浮点型是不会自动转化的</span></span><br><span class="line"><span class="comment"># 因此我们需要使用 ctypes 来包装一下，当然还有整型，即便整型会自动转，我们还是建议手动转化一下</span></span><br><span class="line"><span class="comment"># 这里传入 c_int(1) 和 1 都是一样的，但是建议传入 c_int(1)</span></span><br><span class="line">lib.test(c_int(<span class="number">1</span>), c_float(<span class="number">1.2</span>), c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># a = 1, b = 1.20, s = hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到完美的打印出来了，我们再来试试布尔类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">_Bool</span> flag)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//布尔类型本质上是一个int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line">import ctypes</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line">lib.test(c_bool(True))  <span class="meta"># a = 1</span></span><br><span class="line">lib.test(c_bool(False))  <span class="meta"># a = 0</span></span><br><span class="line"># 可以看到 True 被解释成了 <span class="number">1</span>，False 被解释成了 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 我们说整型会自动转化，而布尔类型继承自整型所以布尔类型也可以直接传递</span><br><span class="line">lib.test(True)  <span class="meta"># a = 1</span></span><br><span class="line">lib.test(False)  <span class="meta"># a = 0</span></span><br></pre></td></tr></table></figure>

<p><strong>然后再来看看字符和字符数组的传递：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> age, <span class="type">char</span> *gender)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(gender, <span class="string">&quot;female&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &gt;= 18, gender is female\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &gt;= 18, gender is male\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(gender, <span class="string">&quot;female&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &lt; 18, gender is female\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &lt; 18, gender is main\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test(c_int(<span class="number">20</span>), c_char_p(b<span class="string">&quot;female&quot;</span>))  <span class="meta"># age &gt;= 18, gender is female</span></span><br><span class="line">lib.test(c_int(<span class="number">20</span>), c_char_p(b<span class="string">&quot;male&quot;</span>))  <span class="meta"># age &gt;= 18, gender is male</span></span><br><span class="line">lib.test(c_int(<span class="number">14</span>), c_char_p(b<span class="string">&quot;female&quot;</span>))  <span class="meta"># age &lt; 18, gender is female</span></span><br><span class="line">lib.test(c_int(<span class="number">14</span>), c_char_p(b<span class="string">&quot;male&quot;</span>))  <span class="meta"># age &lt; 18, gender is main</span></span><br><span class="line"></span><br><span class="line"># 我们看到 C 中的字符数组，我们直接通过 c_char_p 来传递即可</span><br><span class="line"># 至于单个字符，使用 c_char 即可</span><br></pre></td></tr></table></figure>

<p><strong>同理我们也可以打印宽字符，逻辑是类似的。</strong></p>
<h3 id="传递可变的字符串"><a href="#传递可变的字符串" class="headerlink" title="传递可变的字符串"></a>传递可变的字符串</h3><p><strong>我们知道 C 中不存在字符串这个概念，Python 中的字符串在 C 中也是通过字符数组来实现的，我们通过 ctypes 像 C 函数传递一个字符串的时候，在 C 中是可以被修改的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test(c_char_p(b<span class="string">&quot;satori&quot;</span>))  # Satori</span><br></pre></td></tr></table></figure>

<p><strong>我们看到小写的字符串，第一个字符变成了大写，但即便能修改我们也不建议这么做，因为 bytes 对象在 Python 中是不能更改的，所以在 C  中也不应该更改。当然不是说不让修改，而是应该换一种方式。如果是需要修改的话，那么不要使用 c_char_p 的方式来传递，而是建议通过  create_string_buffer 来给 C 语言传递可以修改字符的空间。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个 int，表示创建一个具有固定大小的字符缓存，这里是 10 个</span></span><br><span class="line">s = create_string_buffer(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 直接打印就是一个对象</span></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_10 object at 0x000001E2E07667C0&gt;</span></span><br><span class="line"><span class="comment"># 也可以调用 value 方法打印它的值，可以看到什么都没有</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 并且它还有一个 raw 方法，表示 C 语言中的字符数组，由于长度为 10，并且没有内容，所以全部是 \x00，就是C语言中的 \0</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 还可以查看长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它类型也是一样的</span></span><br><span class="line">v = c_int(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 我们看到 c_int(1) 它的类型就是 ctypes.c_long</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_long&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 当然你把 c_int，c_long，c_longlong 这些花里胡哨的都当成是整型就完事了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外我们还能够拿到它的值，调用 value 方法</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># 1 &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_char(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_char&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># b&#x27;a&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_char_p(<span class="string">b&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_char_p&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># b&#x27;hello world&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_wchar_p(<span class="string">&quot;夏色祭&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_wchar_p&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># 夏色祭 &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 因此 ctypes 中的对象调用 value 即可得到 Python 中的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>当然 create_string_buffer 如果只传一个 int，那么表示创建对应长度的字符缓存。除此之外，还可以指定字节串，此时的字符缓存大小和指定的字节串大小是一致的：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们直接创建了一个字符缓存</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_6 object at 0x0000021944E467C0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 我们知道在 C 中，字符数组是以 \0 作为结束标记的，所以结尾会有一个 \0，因为 raw 表示 C 中原始的字符数组</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hello\x00&#x27;</span></span><br><span class="line"><span class="comment"># 长度为 6，b&quot;hello&quot; 五个字符再加上 \0 一共 6 个</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure>

<p><strong>当然 create_string_buffer 还可以在指定字节串的同时，指定空间大小。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们直接创建了一个字符缓存，如果不指定容量，那么默认和对应的字符数组大小一致</span></span><br><span class="line"><span class="comment"># 但是我们还可以同时指定容量，记得容量要比前面的字节串的长度要大。</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_10 object at 0x0000019361C067C0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 长度为 10，剩余的 5 个显然是 \0</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hello\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看如何使用 create_string_buffer 来传递：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//变量的形式依旧是char *s</span></span><br><span class="line">    <span class="comment">//下面的操作就是相当于把字符数组的索引为5到11的部分换成&quot; satori&quot;</span></span><br><span class="line">    s[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    s[<span class="number">6</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    s[<span class="number">7</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    s[<span class="number">8</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    s[<span class="number">9</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    s[<span class="number">10</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    s[<span class="number">11</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">s = create_string_buffer(b<span class="string">&quot;hello&quot;</span>, <span class="number">20</span>)</span><br><span class="line">lib.test(s)  <span class="meta"># s = hello satori</span></span><br></pre></td></tr></table></figure>

<p><strong>此时就成功地修改了，我们这里的 b”hello” 占五个字节，下一个正好是索引为 5 的地方，然后把索引为 5 到 11 的部分换成对应的字符。但是需要注意的是，一定要小心 <code>\0</code>，我们知道 C 语言中一旦遇到了 <code>\0</code> 就表示这个字符数组结束了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"><span class="comment"># 这里把&quot;hello&quot;换成&quot;hell&quot;，看看会发生什么</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hell&quot;</span>, <span class="number">20</span>)</span><br><span class="line">lib.test(s)  <span class="comment"># s = hell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这里只打印了&quot;hell&quot;，这是为什么？</span></span><br><span class="line"><span class="comment"># 我们看一下这个s</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hell\x00 satori\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这个 create_string_buffer 返回的对象是可变的，在将 s 传进去之后被修改了</span></span><br><span class="line"><span class="comment"># 如果没有传递的话，我们知道它是长这样的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;hell\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">hell的后面全部是C语言中的 \0</span></span><br><span class="line"><span class="string">修改之后变成了这样</span></span><br><span class="line"><span class="string">b&#x27;hell\x00 satori\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们看到确实是把索引为5到11(包含11)的部分变成了&quot; satori&quot;</span></span><br><span class="line"><span class="string">但是我们知道 C 语言中扫描字符数组的时候一旦遇到了 \0，就表示结束了，而hell后面就是 \0,</span></span><br><span class="line"><span class="string">因为即便后面还有内容也不会输出了，所以直接就只打印了 hell</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>另外除了 create_string_buffer 之外，还有一个 create_unicode_buffer，针对于 wchar_t *，用法和 create_string_buffer 类似。</strong></p>
<h3 id="调用操作系统的库函数"><a href="#调用操作系统的库函数" class="headerlink" title="调用操作系统的库函数"></a>调用操作系统的库函数</h3><p><strong>我们知道 Python 解释器本质上就是使用 C 语言写出来的一个软件，那么操作系统呢？操作系统本质上它也是一个软件，不管是 Windows、Linux 还是 MacOS 都自带了大量的共享库，那么我们就可以使用 Python 去调用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前的操作系统平台。</span></span><br><span class="line"><span class="comment"># Windows 平台返回 &quot;Windows&quot;，Linux 平台返回 &quot;Linux&quot;，MacOS 平台返回 &quot;Darwin&quot;</span></span><br><span class="line">system = platform.system()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同的平台共享库不同</span></span><br><span class="line"><span class="keyword">if</span> system == <span class="string">&quot;Windows&quot;</span>:</span><br><span class="line">    lib = cdll.msvcrt</span><br><span class="line"><span class="keyword">elif</span> system == <span class="string">&quot;Linux&quot;</span>:</span><br><span class="line">    lib = CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> system == <span class="string">&quot;Darwin&quot;</span>:</span><br><span class="line">    lib = CDLL(<span class="string">&quot;libc.dylib&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不支持的平台，程序结束&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用对应的函数，比如 printf，注意里面需要传入字节</span></span><br><span class="line">lib.printf(<span class="string">b&quot;my name is %s, age is %d\n&quot;</span>, <span class="string">b&quot;van&quot;</span>, <span class="number">37</span>)  <span class="comment"># my name is van, age is 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果包含汉字就不能使用 b&quot;&quot; 这种形式了，因为这种形式只适用于 ascii 字符，我们需要手动 encode 成 utf-8</span></span><br><span class="line">lib.printf(<span class="string">&quot;姓名: %s, 年龄: %d\n&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>), <span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>), <span class="number">17</span>)  <span class="comment"># 姓名: 古明地觉, 年龄: 17</span></span><br></pre></td></tr></table></figure>

<p><strong>我们上面是在 Windows 上调用的，这段代码即便拿到 Linux 和 MacOS 上也可以正常执行。</strong></p>
<p><strong>当然这里面还支持其他的函数，我们这里以 Windows 为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = cdll.msvcrt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个大小为 10 的buffer</span></span><br><span class="line">s = create_string_buffer(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># strcpy 表示将字符串进行拷贝</span></span><br><span class="line">libc.strcpy(s, c_char_p(<span class="string">b&quot;hello satori&quot;</span>))</span><br><span class="line"><span class="comment"># 由于 buffer 只有10个字节大小，所以无法完全拷贝</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello sato&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 unicode buffer</span></span><br><span class="line">s = create_unicode_buffer(<span class="number">10</span>)</span><br><span class="line">libc.strcpy(s, c_wchar_p(<span class="string">&quot;我也觉得很变态啊&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># 我也觉得很变态啊</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如 puts 函数</span></span><br><span class="line">libc.puts(<span class="string">b&quot;hello world&quot;</span>)  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>对于 Windows 来说，我们还可以调用一些其它的函数，但是不再是通过 cdll.msvcrt 这种方式了。在 Windows 上面有一个 user32 这么个东西，我们来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们通过 cdll.user32 本质上还是加载了 Windows 上的一个共享库</span></span><br><span class="line"><span class="comment"># 这个库给我们提供了很多方便的功能</span></span><br><span class="line">win = cdll.user32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如查看屏幕的分辨率</span></span><br><span class="line"><span class="built_in">print</span>(win.GetSystemMetrics(<span class="number">0</span>))  <span class="comment"># 1920</span></span><br><span class="line"><span class="built_in">print</span>(win.GetSystemMetrics(<span class="number">1</span>))  <span class="comment"># 1080</span></span><br></pre></td></tr></table></figure>

<p><strong>我们还可以用它来打开 MessageBoxA：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015220536-1208285821.png" alt="img"></p>
<p><strong>可以看到我们通过 cdll.user32 就可以很轻松地调用 Windows 的 api，具体有哪些 api 可以去网上查找，搜索 win32 api 即可。</strong></p>
<p><strong>除了 ctypes，还有几个专门用来操作 win32  服务的模块，win32gui、win32con、win32api、win32com、win32process。直接 pip install  pywin32 即可，或者 pip install pypiwin32。</strong></p>
<h4 id="显示窗体和隐藏窗体"><a href="#显示窗体和隐藏窗体" class="headerlink" title="显示窗体和隐藏窗体"></a>显示窗体和隐藏窗体</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先查找窗体，这里查找 qq。需要传入 窗口类名 窗口标题名，至于这个怎么获取可以使用 spy 工具查看</span></span><br><span class="line">qq = win32gui.FindWindow(<span class="string">&quot;TXGuifoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"><span class="comment"># 然后让窗体显示出来</span></span><br><span class="line">win32gui.ShowWindow(qq, win32con.SW_SHOW)</span><br><span class="line"><span class="comment"># 还可以隐藏</span></span><br><span class="line">win32gui.ShowWindow(qq, win32con.SW_HIDE)</span><br></pre></td></tr></table></figure>

<h4 id="控制窗体的位置和大小"><a href="#控制窗体的位置和大小" class="headerlink" title="控制窗体的位置和大小"></a>控制窗体的位置和大小</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line">qq = win32gui.FindWindow(<span class="string">&quot;TXGuiFoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要要接收如下参数</span></span><br><span class="line"><span class="comment"># 参数一：控制的窗体</span></span><br><span class="line"><span class="comment"># 参数二：大致方位：HWND_TOPMOST，位于上方</span></span><br><span class="line"><span class="comment"># 参数三：位置x</span></span><br><span class="line"><span class="comment"># 参数四：位置y</span></span><br><span class="line"><span class="comment"># 参数五：长度</span></span><br><span class="line"><span class="comment"># 参数六：宽度</span></span><br><span class="line"><span class="comment"># 参数七：比较固定，就是让窗体一直显示</span></span><br><span class="line">win32gui.SetWindowPos(qq, win32con.HWND_TOPMOST, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, win32con.SWP_SHOWWINDOW)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015229559-1641962774.png" alt="img"></p>
<p><strong>那么我们还可以让窗体满屏幕乱跑：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">qqWin = win32gui.FindWindow(<span class="string">&quot;TXGuiFoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将位置变成随机数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = random.randint(<span class="number">1</span>, <span class="number">1920</span>)</span><br><span class="line">    y = random.randint(<span class="number">1</span>, <span class="number">1080</span>)</span><br><span class="line">    win32gui.SetWindowPos(qqWin, win32con.HWND_TOPMOST, x, y, <span class="number">300</span>, <span class="number">300</span>, win32con.SWP_SHOWWINDOW)</span><br></pre></td></tr></table></figure>

<h4 id="语音播放"><a href="#语音播放" class="headerlink" title="语音播放"></a>语音播放</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client</span><br><span class="line"><span class="comment"># 直接调用操作系统的语音接口</span></span><br><span class="line">speaker = win32com.client.Dispatch(<span class="string">&quot;SAPI.SpVoice&quot;</span>)</span><br><span class="line"><span class="comment"># 输入你想要说的话，前提是操作系统语音助手要认识。一般中文和英文是没有问题的</span></span><br><span class="line">speaker.Speak(<span class="string">&quot;他能秒我，他能秒杀我？他要是能把我秒了，我当场······&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Python 中 win32 模块的 api 非常多，几乎可以操作整个 Windows 提供的服务，win32 模块就是相当于把 Windows 服务封装成了一个一个的接口。不过这些服务、或者调用这些服务具体都能干些什么，可以自己去研究，这里就到此为止了。</strong></p>
<h3 id="ctypes-获取返回值"><a href="#ctypes-获取返回值" class="headerlink" title="ctypes 获取返回值"></a>ctypes 获取返回值</h3><p><strong>我们前面已经看到了，通过 ctypes  向动态链接库中的函数传参时是没有问题的，但是我们如何拿到返回值呢？我们之前都是使用 printf  直接打印的，但是这样显然不行，我们肯定是要拿到返回值去做一些别的事情的。那么我们在 C 函数中直接 return  不就可以啦，还记得之前演示的返回浮点型的例子吗？我们明明返回了 3.14，但得到的确是一大长串整数，所以我们需要在调用函数之前告诉 ctypes 返回值的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">print(lib.test1(<span class="number">25</span>, <span class="number">33</span>))  # <span class="number">58</span></span><br><span class="line">print(lib.test2())  # <span class="number">-883932787</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到对于 test1 的结果是正常的，但是对于 test2 来说即便返回的是 void，在 Python 中依旧会得到一个整型，因为默认都会按照整型进行解析，但这个结果肯定是不正确的。不过对于整型来说，是完全没有问题的。</strong></p>
<p><strong>正如我们传递参数一样，需要使用 ctypes 转化一下，那么在获取返回值的时候，也需要提前使用 ctypes 指定一下返回值到底是什么类型，只有这样才能拿到动态链接库中函数的正确的返回值。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;hello satori&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> * <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遇到 wchar_t 的时候，一定要导入 wchar.h 头文件</span></span><br><span class="line">    <span class="type">wchar_t</span> *s = <span class="string">L&quot;憨八嘎&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"># 不出所料，我们在动态链接库中返回的是一个字符数组的首地址，我们希望拿到指向的字符串</span><br><span class="line"># 然而 Python 拿到的仍是一个整型，而且一看感觉这像是一个地址。如果是地址的话那么从理论上讲是对的，返回地址、获取地址</span><br><span class="line">print(lib.test1())  # <span class="number">1788100608</span></span><br><span class="line"># 但我们希望的是获取地址指向的字符数组，所以我们需要指定一下返回的类型</span><br><span class="line"># 指定为 c_char_p，告诉 ctypes 你在解析的时候将 test1 的返回值按照 c_char_p 进行解析</span><br><span class="line">lib.test1.restype = c_char_p</span><br><span class="line"># 此时就没有问题了</span><br><span class="line">print(lib.test1())  <span class="meta"># b<span class="string">&#x27;hello satori&#x27;</span></span></span><br><span class="line"></span><br><span class="line"># 同理对于 unicode 也是一样的，如果不指定类型，得到的依旧是一个整型</span><br><span class="line">lib.test2.restype = c_wchar_p</span><br><span class="line">print(lib.test2())  # 憨八嘎</span><br></pre></td></tr></table></figure>

<p><strong>因此我们就将 Python 中的类型和 C 语言中的类型通过 ctypes 关联起来了，我们传参的时候需要转化，同理获取返回值的时候也要使用 ctypes 来声明一下类型。因为默认 Python  调用动态链接库的函数返回的都是整型，至于返回的整型的值到底是什么？从哪里来的？我们不需要关心，你可以理解为地址、或者某块内存的脏数据，但是不管怎么样，结果肯定是不正确的（如果函数返回的就是整形除外）。因此我们需要提前声明一下返回值的类型。声明方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib.CFunction.restype = ctypes类型</span><br></pre></td></tr></table></figure>

<p><strong>我们说 lib 就是 ctypes 调用 dll 或者 so  得到的动态链接库，而里面的函数就相当于是一个个的 CFunction，然后设置内部的  restype（返回值类型），就可以得到正确的返回值了。另外即便返回值设置的不对，比如：test1 返回一个 char *，但是我们将类型设置为 c_float，调用的时候也不会报错而且得到的也是一个 float，但是这个结果肯定是不对的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test1.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(lib.test1())  <span class="comment"># b&#x27;hello satori&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为 c_float</span></span><br><span class="line">lib.test1.restype = c_float</span><br><span class="line"><span class="comment"># 获取了不知道从哪里来的脏数据</span></span><br><span class="line"><span class="built_in">print</span>(lib.test1())  <span class="comment"># 2.5420596244190436e+20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外 ctypes 调用还有一个特点</span></span><br><span class="line">lib.test2.restype = c_wchar_p</span><br><span class="line"><span class="built_in">print</span>(lib.test2(<span class="number">123</span>, c_float(<span class="number">1.35</span>), c_wchar_p(<span class="string">&quot;呼呼呼&quot;</span>)))  <span class="comment"># 憨八嘎</span></span><br><span class="line"><span class="comment"># 我们看到 test2 是不需要参数的，如果我们传了那么就会忽略掉，依旧能得到正常的返回值</span></span><br><span class="line"><span class="comment"># 但是不要这么做，因为没准就出问题了，所以还是该传几个参数就传几个参数</span></span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看浮点类型的返回值怎么获取，当然方法和上面是一样的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    c = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 得到的结果是一个整型，默认都是整型。</span><br><span class="line"># 我们不知道这个整型是从哪里来的，就把它理解为地址吧，但是不管咋样，结果肯定是不对的</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">1084227584</span></span><br><span class="line"></span><br><span class="line"># 我们需要指定返回值的类型，告诉 ctypes 返回的是一个 <span class="type">float</span></span><br><span class="line">lib.test1.restype = c_float</span><br><span class="line"># 此时结果就是对的</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">5.0</span></span><br><span class="line"></span><br><span class="line"># 如果指定为 <span class="type">double</span> 呢？</span><br><span class="line">lib.test1.restype = c_double</span><br><span class="line"># 得到的结果也有问题，总之类型一定要匹配</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">5.356796015e-315</span></span><br><span class="line"></span><br><span class="line"># 至于 <span class="type">int</span> 就不用说了，因为默认就是 <span class="type">int</span>。所以和第一个结果是一样的</span><br><span class="line">lib.test1.restype = c_int</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">1084227584</span></span><br></pre></td></tr></table></figure>

<p><strong>所以类型一定要匹配，该是什么类型就是什么类型。即便动态链接库中返回的是  float，我们在 Python 中通过 ctypes 也要指定为 float，而不是指定为 double，尽管都是浮点数并且 double  的精度还更高，但是结果依旧不是正确的。至于整型就不需要关心了，但即便如此，int、long 也建议不要混用，而且传参的时候最好也进行转化。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200129145849006-1139771193.jpg" alt="img"></p>
<h3 id="ctypes-给动态链接库中的函数传递指针"><a href="#ctypes-给动态链接库中的函数传递指针" class="headerlink" title="ctypes 给动态链接库中的函数传递指针"></a>ctypes 给动态链接库中的函数传递指针</h3><p><strong>我们使用 ctypes  可以创建一个字符数组并且拿到首地址，但是对于整型、浮点型我们怎么创建指针呢？下面就来揭晓。另外，一旦涉及到指针操作的时候就要小心了，因为这往往是比较危险的，所以 Python 把指针给隐藏掉了，当然不是说没有指针，肯定是有指针的。只不过操作指针的权限没有暴露给程序员，能够操作指针的只有对应的解释器。</strong></p>
<h4 id="ctypes-byref-和-ctypes-pointer-创建指针"><a href="#ctypes-byref-和-ctypes-pointer-创建指针" class="headerlink" title="ctypes.byref 和 ctypes.pointer 创建指针"></a>ctypes.byref 和 ctypes.pointer 创建指针</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">v = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 我们知道可以通过 value 属性获取相应的值</span></span><br><span class="line"><span class="built_in">print</span>(v.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是我们还可以修改</span></span><br><span class="line">v.value = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(v)  <span class="comment"># c_long(456)</span></span><br><span class="line"></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>)</span><br><span class="line">s[<span class="number">3</span>] = <span class="string">b&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hel&gt;o&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何创建指针呢？通过 byref 和 pointer</span></span><br><span class="line">v2 = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(byref(v2))  <span class="comment"># &lt;cparam &#x27;P&#x27; (000001D9DCF86888)&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pointer(v2))  <span class="comment"># &lt;__main__.LP_c_long object at 0x000001D9DCF868C0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 byref 和 pointer 都可以创建指针，那么这两者有什么区别呢？byref 返回的指针相当于右值，而 pointer 返回的指针相当于左值。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以整型的指针为例：</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num </span><br></pre></td></tr></table></figure>

<p><strong>对于上面的例子，如果是 byref，那么结果相当于 &amp;num，拿到的就是一个具体的值。如果是 pointer，那么结果相当于 p。这两者在传递的时候是没有区别的，只是对于 pointer 来说，它返回的是一个左值，我们是可以继续拿来做文章的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 拿到变量 n 的指针</span></span><br><span class="line">p1 = byref(n)</span><br><span class="line">p2 = pointer(n)</span><br><span class="line"><span class="comment"># pointer 返回的是左值，我们可以继续做文章，比如继续获取指针，此时获取的就是 p2 的指针</span></span><br><span class="line"><span class="built_in">print</span>(byref(p2))  <span class="comment"># &lt;cparam &#x27;P&#x27; (0000023953796888)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是 p1 不行，因为 byref 返回的是一个右值</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(byref(p1))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># byref() argument must be a ctypes instance, not &#x27;CArgObject&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此两者的区别就在这里，但是还是那句话，我们在传递的时候是无所谓的，传递哪一个都可以。</strong></p>
<h4 id="传递指针"><a href="#传递指针" class="headerlink" title="传递指针"></a>传递指针</h4><p><strong>我们知道了可以通过 ctypes.byref、ctypes.pointer 的方式传递指针，但是如果函数返回的也是指针呢？我们知道除了返回 int 之外，都要指定返回值类型，那么指针如何指定呢？答案是通过 ctypes.POINTER。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收两个 float *，返回一个 float *</span></span><br><span class="line"><span class="type">float</span> *<span class="title function_">test1</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为返回指针，所以为了避免被销毁，我们使用 static 静态声明</span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> c;</span><br><span class="line">    c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 声明一下，返回的类型是一个 POINTER(c_float)，也就是 <span class="type">float</span> 的指针类型</span><br><span class="line">lib.test1.restype = POINTER(c_float)</span><br><span class="line"># 别忘了传递指针，因为函数接收的是指针，两种传递方式都可以</span><br><span class="line">res = lib.test1(byref(c_float(<span class="number">3.14</span>)), pointer(c_float(<span class="number">5.21</span>)))</span><br><span class="line">print(res)  # &lt;__main__.LP_c_float object at <span class="number">0x000001FFF1F468C0</span>&gt;</span><br><span class="line">print(type(res))  # &lt;class <span class="string">&#x27;__main__.LP_c_float&#x27;</span>&gt;</span><br><span class="line"># 这个 res 是 ctypes 类型，和 pointer(c_float(<span class="number">5.21</span>)) 的类型是一样的，都是 &lt;class <span class="string">&#x27;__main__.LP_c_float&#x27;</span>&gt;</span><br><span class="line"># 我们调用 contents 即可拿到 ctypes 中的值，那么显然在此基础上再调用 value 就能拿到 Python 中的值</span><br><span class="line">print(res.contents)  # c_float(<span class="number">8.350000381469727</span>)</span><br><span class="line">print(res.contents.value)  # <span class="number">8.350000381469727</span></span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到了如果返回的是指针类型可以使用 POINTER(类型) 来声明，也就是说 POINTER 是用来声明指针类型的，而 byref、pointer 则是用来获取指针的。</strong></p>
<h3 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h3><p><strong>我们知道可以事先声明返回值的类型，这样才能拿到正确的返回值。而我们传递的时候，直接传递正确的类型即可，但是其实也是可以事先声明的。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 argtypes，我们可以事先指定需要传入两个 float 的指针类型，注意：要指定为一个元组，即便是一个参数也要是元组</span></span><br><span class="line">lib.test1.argtypes = (POINTER(c_float), POINTER(c_float))</span><br><span class="line">lib.test1.restype = POINTER(c_float)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是和 restype 不同，argtypes 实际上是可以不要的</span></span><br><span class="line"><span class="comment"># 因为返回的默认是一个整型，我们才需要通过 restype 事先声明返回值的类型，这是有必要的</span></span><br><span class="line"><span class="comment"># 但是对于 argtypes 来说，我们传参的时候已经直接指定类型了，所以 argtypes 即便没有也是可以的</span></span><br><span class="line"><span class="comment"># 所以 argtypes 的作用就类似于其他静态语言中的类型声明，先把类型定好，如果你传的类型不对，直接给你报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这里第二个参数传c_int</span></span><br><span class="line">    res = lib.test1(byref(c_float(<span class="number">3.21</span>)), c_int(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 所以直接就给你报错了</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 2: &lt;class &#x27;TypeError&#x27;&gt;: expected LP_c_float instance instead of c_long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时正确执行</span></span><br><span class="line">res1 = lib.test1(byref(c_float(<span class="number">3.21</span>)), byref(c_float(<span class="number">666</span>)))</span><br><span class="line"><span class="built_in">print</span>(res1.contents.value)  <span class="comment"># 669.2100219726562</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200129161338513-2047487237.jpg" alt="img"></p>
<h3 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h3><p><strong>下面我们来看看如何使用 ctypes  传递数组，这里我们只讲传递，不讲返回。因为 C 语言返回数组给 Python  实际上会存在很多问题，比如：返回的数组的内存由谁来管理，不用了之后空间由谁来释放，事实上 ctypes  内部对于返回数组支持的也不是很好。因此我们一般不会向 Python 返回一个 C 语言中的数组，因为 C 语言中的数组传递给 Python  涉及到效率的问题，Python 中的列表传递直接传递一个引用即可，但是 C 语言中的数组过来肯定是要拷贝一份的，所以这里我们只讲 Python  如何通过 ctypes 给动态链接库传递数组，不再介绍动态链接库如何返回数组给 Python。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组，假设叫 [1, 2, 3, 4, 5]</span></span><br><span class="line">a5 = (c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a5)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x00000162428968C0&gt;</span></span><br><span class="line"><span class="comment"># 上面这种方式就得到了一个数组</span></span><br><span class="line"><span class="comment"># 当然下面的方式也是可以的</span></span><br><span class="line">a5 = (c_int * <span class="number">5</span>)(*<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(a5)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x0000016242896940&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>下面演示一下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符数组默认是以 \0 作为结束的，我们可以通过 strlen 来计算长度。</span></span><br><span class="line"><span class="comment">// 但是对于整型的数组来说我们不知道有多长</span></span><br><span class="line"><span class="comment">// 因此有两种声明参数的方式，一种是 int a[n]，指定数组的长度</span></span><br><span class="line"><span class="comment">// 另一种是通过指定 int *a 的同时，再指定一个参数 int size，调用函数的时候告诉函数这个数组有多长</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a[<span class="number">5</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能有人会问了，难道不能通过 sizeof 计算吗？答案是不能，无论是 int *a 还是 int a[n]</span></span><br><span class="line">    <span class="comment">// 数组作为函数的参数时会退化为指针，我们调用的时候，传递的都是指针，指针在 64 位机器上默认占 8 个字节。</span></span><br><span class="line">    <span class="comment">// 所以int a[] = &#123;...&#125;这种形式，如果直接在当前函数中计算的话，那么 sizeof(a) 就是数组里面所有元素的总大小，因为a是一个数组名</span></span><br><span class="line">    <span class="comment">// 但是当把 a 传递给一个函数的时候，那么等价于将 a 的首地址拷贝一份传过去，此时在新的函数中再计算 sizeof(a) 的时候就是一个指针的大小</span></span><br><span class="line">    <span class="comment">//至于 int *a 这种声明方式，不管在什么地方，sizeof(a) 都是一个指针的大小</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 创建 <span class="number">5</span> 个元素的数组，但是只给<span class="number">3</span>个元素</span><br><span class="line">arr = (c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"># 在动态链接库中，设置剩余两个元素</span><br><span class="line"># 所以如果没问题的话，结果应该是 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">10</span> + <span class="number">20</span></span><br><span class="line">print(lib.test1(arr))  # <span class="number">36</span></span><br></pre></td></tr></table></figure>

<h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><p><strong>有了前面的数据结构还不够，我们还要看看结构体是如何传递的，有了结构体的传递，我们就能发挥更强大的功能。那么我们来看看如何使用 ctypes 定义一个结构体：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于这样一个结构体应该如何定义呢？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">struct Girl &#123;</span></span><br><span class="line"><span class="string">  char *name;     // 姓名</span></span><br><span class="line"><span class="string">  int age;        // 年龄</span></span><br><span class="line"><span class="string">  char *gender;   //性别</span></span><br><span class="line"><span class="string">  int class;      //班级</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个类，必须继承自 ctypes.Structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    <span class="comment"># 创建一个 _fields_ 变量，必须是这个名字，注意开始和结尾都只有一个下划线</span></span><br><span class="line">    <span class="comment"># 然后就可以写结构体的字段了，具体怎么写估计一看就清晰了</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>我们向 C 中传递一个结构体，然后再返回：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> *gender;</span><br><span class="line">  <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个结构体，返回一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> Girl <span class="title function_">test1</span><span class="params">(<span class="keyword">struct</span> Girl g)</span>&#123;</span><br><span class="line">  g.name = <span class="string">&quot;古明地觉&quot;</span>;</span><br><span class="line">  g.age = <span class="number">17</span>;</span><br><span class="line">  g.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">  g.class = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Girl(Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时返回值类型就是一个 Girl 类型，另外我们这里的类型和 C 中结构体的名字不一样也是可以的</span><br><span class="line">lib.test1.restype = Girl</span><br><span class="line"># 传入一个实例，拿到返回值</span><br><span class="line">g = Girl()</span><br><span class="line">res = lib.test1(g)</span><br><span class="line">print(res, type(res))  # &lt;__main__.Girl object at <span class="number">0x0000015423A06840</span>&gt; &lt;class <span class="string">&#x27;__main__.Girl&#x27;</span>&gt;</span><br><span class="line">print(res.name, str(res.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># b<span class="string">&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89&#x27;</span> 古明地觉</span></span><br><span class="line">print(res.age)  # <span class="number">17</span></span><br><span class="line">print(res.gender)  <span class="meta"># b<span class="string">&#x27;female&#x27;</span></span></span><br><span class="line">print(getattr(res, <span class="string">&quot;class&quot;</span>))  # <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>如果是结构体指针呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> *gender;</span><br><span class="line">  <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个指针，返回一个指针</span></span><br><span class="line"><span class="keyword">struct</span> Girl *<span class="title function_">test1</span><span class="params">(<span class="keyword">struct</span> Girl *g)</span>&#123;</span><br><span class="line">  g -&gt; name = <span class="string">&quot;mashiro&quot;</span>;</span><br><span class="line">  g -&gt; age = <span class="number">17</span>;</span><br><span class="line">  g -&gt; gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">  g -&gt; <span class="class"><span class="keyword">class</span> =</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Girl(Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时指定为 Girl 类型的指针</span><br><span class="line">lib.test1.restype = POINTER(Girl)</span><br><span class="line"># 传入一个实例，拿到返回值</span><br><span class="line"># 但返回的是指针，我们还需要手动调用一个 contents 才可以拿到对应的值。</span><br><span class="line">g = Girl()</span><br><span class="line">res = lib.test1(byref(g))</span><br><span class="line">print(str(res.contents.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># mashiro</span></span><br><span class="line">print(res.contents.age)  # <span class="number">16</span></span><br><span class="line">print(res.contents.gender)  <span class="meta"># b<span class="string">&#x27;female&#x27;</span></span></span><br><span class="line">print(getattr(res.contents, <span class="string">&quot;class&quot;</span>))  # <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 另外我们不仅可以通过返回的 res 去调用，还可以通过 g 来调用，因为我们传递的是 g 的指针</span><br><span class="line"># 修改指针指向的内存就相当于修改g，所以我们通过g来调用也是可以的</span><br><span class="line">print(str(g.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># mashiro</span></span><br></pre></td></tr></table></figure>

<p><strong>因此对于结构体来说，我们先创建一个结构体（Girl）实例  g，如果动态链接库的函数中接收的是结构体，那么直接把 g 传进去等价于将 g 拷贝了一份，此时函数中进行任何修改都不会影响原来的  g。但如果函数中接收的是结构体指针，我们传入 byref(g) 相当于把 g 的指针拷贝了一份，在函数中修改是会影响 g 的。而返回的 res  也是一个指针，所以我们除了通过 res.contents 来获取结构体中的值之外，还可以通过 g 来获取。再举个栗子对比一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">struct Num &#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Num test1(struct Num n)&#123;</span><br><span class="line">  n.x += <span class="number">1</span>;</span><br><span class="line">  n.y += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Num *test2(struct Num *n)&#123;</span><br><span class="line">  n-&gt;x += <span class="number">1</span>;</span><br><span class="line">  n-&gt;y += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;x&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;y&quot;</span>, c_int),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们在创建的时候是可以传递参数的</span></span><br><span class="line">num = Num(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line">lib.test1.restype = Num</span><br><span class="line">res = lib.test1(num)</span><br><span class="line"><span class="comment"># 我们看到通过 res 得到的结果是修改之后的值</span></span><br><span class="line"><span class="comment"># 但是对于 num 来说没有变</span></span><br><span class="line"><span class="built_in">print</span>(res.x, res.y)  <span class="comment"># 2 3</span></span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 1 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为我们将 num 传进去之后，相当于将 num 拷贝了一份。</span></span><br><span class="line"><span class="string">函数里面的结构体和这里的 num 尽管长得一样，但是没有任何关系</span></span><br><span class="line"><span class="string">所以 res 获取的结果是自增之后的结果，但是 num 还是之前的 num</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们来试试传递指针，将 byref(num) 再传进去</span></span><br><span class="line">lib.test2.restype = POINTER(Num)</span><br><span class="line">res = lib.test2(byref(num))</span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 2 3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们看到将指针传进去之后，相当于把 num 的指针拷贝了一份。</span></span><br><span class="line"><span class="string">然后在函数中修改，相当于修改指针指向的内存，所以是会影响外面的 num 的</span></span><br><span class="line"><span class="string">而动态链接库的函数中返回的是参数中的结构体指针，而我们传递的 byref(num) 也是这里的num的指针</span></span><br><span class="line"><span class="string">尽管传递指针的时候也是拷贝了一份，两个指针本身来说虽然也没有任何联系，但是它们存储的地址是一样的</span></span><br><span class="line"><span class="string">那么通过 res.contents 获取到的内容就相当于是这里的 num</span></span><br><span class="line"><span class="string">因此此时我们通过 res.contents 获取和通过 num 来获取都是一样的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(res.contents.x, res.contents.y)  <span class="comment"># 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外还需要注意的一点就是：如果传递的是指针，一定要先创建一个变量</span></span><br><span class="line"><span class="comment"># 比如这里，一定是：先要 num = Num()，然后再 byref(num)，不可以直接就 byref(Num())</span></span><br><span class="line"><span class="comment"># 原因很简单，因为 Num() 这种形式在创建完 Num 实例之后就销毁了，因为没有变量保存它，那么此时再修改指针指向的内存就会有问题，因为内存的值已经被回收了</span></span><br><span class="line"><span class="comment"># 如果不是指针，那么可以直接传递 Num()，因为拷贝了一份</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在这里，C 中返回一个指针是没有问题的，因为它指向的对象是我们在 Python 中创建的，Python 会管理它。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200130022408720-967585017.jpg" alt="img"></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>在看回调函数之前，我们先看看如何把一个函数赋值给一个变量。准确的说，是让一个指针指向一个函数，这个指针叫做函数指针。通常我们说的指针变量是指向一个整型、字符型或数组等等，而函数指针是指向函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个指针变量 p，让 add 等于 p</span></span><br><span class="line">  <span class="comment">// 我们看到就类似声明函数一样，指定返回值类型和变量类型即可</span></span><br><span class="line">  <span class="comment">// 但是注意的是，中间一定是 *p，不是 p，因为这是一个函数指针，所以要有 *</span></span><br><span class="line">  <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1 + 3 = %d\n&quot;</span>, p(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//1 + 3 = 4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>除此之外我们还以使用 typedef。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于创建了一个类型，名字叫做 func，这个 func 表示的是一个函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 声明一个 func 类型的函数指针 p，等于 add</span></span><br><span class="line">  func p = add;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, p(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 2 + 3 = 5</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面来看看如何使用回调函数，说白了就是把一个函数指针作为函数的参数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">evaluate</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (score &lt; <span class="number">60</span> &amp;&amp; score &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;bad&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not bad&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">90</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;excellent&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;无效的成绩&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个整型和一个函数指针，指针指向的函数接收一个整型返回一个 char *</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">execute1</span><span class="params">(<span class="type">int</span> score, <span class="type">char</span> *(*f)(<span class="type">int</span>))</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了上面那种方式，我们还可以跟之前一样通过 typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *(*func)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 这样声明也是可以的。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">execute2</span><span class="params">(<span class="type">int</span> score, func f)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, execute1(<span class="number">88</span>, evaluate)); <span class="comment">// good</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, execute2(<span class="number">70</span>, evaluate)); <span class="comment">// not bad</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道了在 C 中传入一个函数，那么在 Python 中如何定义一个 C 语言可以识别的函数呢？毫无疑问，类似于结构体，我们肯定是要先定义一个 Python 的函数，然后再把 Python 的函数转化成 C 语言可以识别的函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> (*f)(<span class="type">int</span> *, <span class="type">int</span> *))</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们就以这个函数为例，add 函数返回一个 int，接收两个 int，和一个函数指针，那么我们如何在 Python 中定义这样的函数并传递呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接库中的函数接收的函数的参数是两个 int *，所以我们这里的 a 和 b 也是一个 pointer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们把 C 中的函数用 Python 表达了，但是这样肯定是不可能直接传递的，能传就见鬼了</span></span><br><span class="line"><span class="comment"># 那我们要如何转化呢？</span></span><br><span class="line"><span class="comment"># 可以通过 ctypes 里面的函数 CFUNCTYPE 转化一下，这个函数接收任意个参数</span></span><br><span class="line"><span class="comment"># 但是第一个参数是函数的返回值类型，然后函数的参数写在后面，有多少写多少。</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 int，接收两个 int *，所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值，那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t，此时的类型 t 就等同于 C 中的 typedef int (*t)(int*, int*);</span></span><br><span class="line"><span class="comment"># 将我们的函数传进去，就得到了 C 语言可以识别的函数 func</span></span><br><span class="line">func = t(add)</span><br><span class="line"><span class="comment"># 然后调用，别忘了定义返回值类型，当然这里是 int 就无所谓了</span></span><br><span class="line">lib.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">88</span>, <span class="number">96</span>, func))</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">59</span>, <span class="number">55</span>, func))</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">94</span>, <span class="number">105</span>, func))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">184</span></span><br><span class="line"><span class="string">114</span></span><br><span class="line"><span class="string">199</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200130160241362-1029015726.jpg" alt="img"></p>
<p><strong>以上便是 ctypes 的基本用法，但其实我们可以通过 ctypes  玩出更高级的花样，甚至可以串改内部的解释器。ctypes 内部提供了一个属性叫 pythonapi，它实际上就是加载了 Python  安装目录里面的 python38.dll。有兴趣可以自己去了解一下，需要你了解底层的 Python &#x2F; C API，当然我们也很少这么做。对于  ctypes 调用 C 库而言，我们目前算是介绍完了。</strong></p>
<h2 id="使用-C-x2F-C-为-Python-开发扩展模块"><a href="#使用-C-x2F-C-为-Python-开发扩展模块" class="headerlink" title="使用 C &#x2F; C++ 为 Python 开发扩展模块"></a>使用 C &#x2F; C++ 为 Python 开发扩展模块</h2><p><strong>我们上面介绍 ctypes，我们说这种方式它不涉及任何的 Python &#x2F; C API，但是它只能做一些简单的交互。而如果是编写扩展模块的话，那么它是可以被 Python 解释器识别的，也就是说我们可以通过 import 的方式进行导入。</strong></p>
<blockquote>
<p><strong>关于扩展模块，这里不得不再提一下 Cython，使用 Python &#x2F; C API 编写扩展不是一件轻松的事情，其实还是 C 语言本身比较底层吧。而 Cython 则是帮我们解决了这一点，Cython 代码和  Python 高度相似，而 cython 编译器会自动帮助我们将 Cython 代码翻译成C代码，所以Cython本质上也是使用了 Python &#x2F; C API。只不过它让我们不需要直接面对C，只要我们编写 Cython 代码即可，会自动帮我们转成 C 的代码。</strong></p>
<p><strong>所以随着 Cython 的出现，现在使用 Python &#x2F; C API 编写扩展算是越来越少了，不过话虽如此，使用 Python &#x2F; C API 编写可以极大的帮助我们熟悉 Python 的底层。</strong></p>
</blockquote>
<p><strong>那么废话不多说，直接开始吧。</strong></p>
<h3 id="编写扩展模块的基本骨架"><a href="#编写扩展模块的基本骨架" class="headerlink" title="编写扩展模块的基本骨架"></a>编写扩展模块的基本骨架</h3><p><strong>首先使用 C &#x2F; C++ 为 Python 编写扩展的话，是需要遵循一定套路的，而这个套路很固定。那么下面就来介绍一下整个流程：</strong></p>
<p><strong>Python 的扩展模块是需要被 import 进来的，那么它必然要有一个入口。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个 xxx 非常重要，这个是你最终生成的扩展模块的名字，前面的 PyInit 是写死的</span></span><br><span class="line">PyInit_xxx(<span class="type">void</span>)  <span class="comment">// 模块初始化入口</span></span><br></pre></td></tr></table></figure>

<p><strong>有了入口之后，我们还需要创建模块，创建模块使用下面这个函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyModule_Create  <span class="comment">// 创建模块</span></span><br></pre></td></tr></table></figure>

<p><strong>创建模块，那么总要有模块信息吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyModuleDef  <span class="comment">// 模块信息</span></span><br></pre></td></tr></table></figure>

<p><strong>那么模块信息里面都可以包含哪些信息呢？模块名算吧，模块里面有哪些函数算吧。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyMethodDef  <span class="comment">// 模块函数信息, 一个数组, 因为一个模块可以包含多个函数</span></span><br></pre></td></tr></table></figure>

<p><strong>而一个 Python 中的函数底层会对应一个结构体，这个结构体里面保存了 Python 函数的元信息，并且还保存了一个指向 C 函数的指针，这是显然的。</strong></p>
<p><strong>我们通过一个例子来说明以下吧，这样会更好理解一些，具体细节在编写代码的时候再补充。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>以上是非常简单的一个模块，里面只有两个简单的函数，但是我们知道当被导入时它就是一个 PyModuleObject 对象。里面除了我们定义的两个函数之外还有其它的属性，显然这是 Python  解释器在背后帮助我们完成的，具体流程也是我们上面说的那几步（省略了亿点点细节）。</strong></p>
<p><strong>那么我们如何使用 C 来进行编写呢？下面来操作一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编写 Python 扩展模块，需要引入 Python.h 这个头文件</span></span><br><span class="line"><span class="comment">该头文件在 Python 安装目录的 include 目录下，我们必须要导入它</span></span><br><span class="line"><span class="comment">当然这个头文件里面还导入了很多其它的头文件，我们也可以直接拿来用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编写我们之前的两个函数 f1 和 f2，必须返回 PyObject *</span></span><br><span class="line"><span class="comment">函数里面至少要接收一个 PyObject *self，而这个参数我们是不需要管的，当然不叫 self 也是可以的</span></span><br><span class="line"><span class="comment">显然跟方法里面的 self 是一个道理，所以对于 Python 调用者而言，f1 是一个不需要接收参数的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self, PyObject *a)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x;</span><br><span class="line">    <span class="comment">// 转成 C 中的 long，进行相加，然后再转成 Python 的 int; 或者调用 PyNumber_Add() 也可以</span></span><br><span class="line">    x = PyLong_AsLong(a);</span><br><span class="line">    PyObject *result = PyLong_FromLong(x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是注意：虽然我们定义了 f1 和 f2，但是它们是 C 中的函数，不是 Python 的</span></span><br><span class="line"><span class="comment">// Python 中的函数在 C 中对应的是一个结构体，里面会有函数指针，指向这里的 f1 和 f2</span></span><br><span class="line"><span class="comment">// 但除了函数指针，还有其它的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个结构体数组，结构体类型为 PyMethodDef，显然这个 PyMethodDef 就是 Python 中的函数</span></span><br><span class="line"><span class="comment">PyMethodDef 里面有四个成员，分别是：函数名、函数指针(需要转成PyCFunction)、函数参数标识、函数的doc</span></span><br><span class="line"><span class="comment">关于 PyMethodDef 我们后面会单独说</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_NOARGS, <span class="comment">// 后面单独说</span></span><br><span class="line">        <span class="string">&quot;this is a function named f1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f2&quot;</span>, (PyCFunction) f2, METH_O, <span class="string">&quot;this is a function named f2&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">// 结尾要有一个 &#123;NULL, NULL, 0, NULL&#125; 充当哨兵</span></span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们编写的 py 文件，解释器会自动把它变成一个模块，但是这里我们需要手动定义</span></span><br><span class="line"><span class="comment">下面定义一个 PyModuleDef 类型的结构体，它就是我们的模块信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    <span class="comment">// 头部信息，PyModuleDef_Base m_base，正如所有对象都有 PyObject 这个结构体一样</span></span><br><span class="line">    <span class="comment">// 而 Python.h 中提供了一个宏，#define PyModuleDef_HEAD_INIT PyModuleDef_Base m_base; 我们可以使用 PyModuleDef_HEAD_INIT 来代替</span></span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, <span class="comment">// 模块的名字</span></span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>, <span class="comment">// 模块的doc，没有的话直接写成NULL即可</span></span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// 模块的独立空间，这个不需要关心，直接写成 -1 即可</span></span><br><span class="line">    methods, <span class="comment">// 上面的 PyMethodDef 结构数组，必须写在这里，不然我们没法使用定义的函数</span></span><br><span class="line">    <span class="comment">// 下面直接写4个NULL即可</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上便是 PyModuleDef 结构体实例的创建过程，至于里面的一些细节我们后面说</span></span><br><span class="line"><span class="comment">// 到目前为止，前置工作就做完了，下面还差两步</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">扩展库入口函数，这是一个宏，Python 的源代码我们知道是使用 C 来编写的</span></span><br><span class="line"><span class="comment">但是编译的时候为了支持 C++ 的编译器也能编译，于是需要通过 extern &quot;C&quot; 定义函数</span></span><br><span class="line"><span class="comment">然后这样 C++ 编译器在编译的的时候就会按照 C 的标准来编译函数，这个宏就是干这件事情的，主要和 Python 中的函数保持一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模块初始化入口，注意：模块名叫 kagura_nana，那么下面就必须要写成 PyInit_kagura_nana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PyInit_kagura_nana(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 PyModuleDef 结构体实例的指针传递进去，然后返回得到 Python 中的模块</span></span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整体逻辑还是非常简单的，过程如下：</strong></p>
<ul>
<li><code>include &quot;Python.h&quot;，这个是必须的</code></li>
<li><code>定义我们函数，具体定义什么函数、里面写什么代码完全取决于你的业务</code></li>
<li><code>定义一个PyMethodDef结构体数组</code></li>
<li><code>定义一个PyModuleDef结构体</code></li>
<li><code>定义模块初始化入口，然后返回模块对象</code></li>
</ul>
<p><strong>那么如何将这个 C 文件变成扩展模块呢？显然要经过编译，而 Python 提供了 distutils 标准库，可以非常轻松地帮我们把 C 文件编译成扩展模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># 打包之后会有一个 egg_info，表示该模块的元信息信息，name 就表示打包之后的 egg 文件名</span></span><br><span class="line">    <span class="comment"># 显然和模块名是一致的</span></span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.11&quot;</span>, <span class="comment"># 版本号</span></span><br><span class="line">    author=<span class="string">&quot;古明地盆&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;66666@东方地灵殿.com&quot;</span>,</span><br><span class="line">    <span class="comment"># 关键来了，这里面接收一个类 Extension，类里面传入两个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数是我们的模块名，必须和 PyInit_xxx 中的 xxx 保持一致，否则报错</span></span><br><span class="line">    <span class="comment"># 第二个参数是一个列表，表示用到了哪些 C 文件，因为扩展模块对应的 C 文件不一定只有一个，我们这里的 C 文件还叫 main.c</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;kagura_nana&quot;</span>, [<span class="string">&quot;main.c&quot;</span>])]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>当前的 py 文件名叫做 1.py，我们在控制台中直接输入 python 1.py install 即可。注意：在介绍 ctypes 我用的是 gcc，但这里默认是使用 Visual Studio 2017 进行编译的。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015255393-47729497.png" alt="img"></p>
<p><strong>我们看到对应的 pyd 已经生成了，在你当前目录会有一个 build目录，然后 build 目录中 lib 开头的目录里面便存放了编译好的 pyd文件，并且还自动帮我们拷贝到了 site-packages 目录中。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015302384-381878609.png" alt="img"></p>
<p><strong>我们看到了 kagura_nana.cp38-win_amd64.pyd  文件，中间的部分表示解释器的版本，所以编写扩展模块的方式虽然可定制性更高，但它除了操作系统之外，还需要特定的解释器版本。因为中间是  cp38，所以只能 Python3.8 版本的解释器才可以导入它。然后还有一个 egg-info，它是我们编写的模块的元信息，我们打开看看。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015308135-1505296629.png" alt="img"></p>
<p><strong>有几个我们没有写，所以是 UNKNOW，当然这都不重要，重要的是我们能不能调用，试一试吧。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana)  <span class="comment"># &lt;module &#x27;kagura_nana&#x27; from &#x27;C:\\python38\\lib\\site-packages\\kagura_nana.cp38-win_amd64.pyd&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1())  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f2(<span class="number">123</span>))  <span class="comment"># 124</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到调用是没有任何问题的，最后再看一个神奇的东西，我们知道在 pycharm 这样的智能编辑器中，通过 Ctrl 加左键可以调到指定模块的指定位置。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015314973-369259813.png" alt="img"></p>
<p><strong>神奇的一幕出现了，我们点击进去居然还能跳转，其实我们在编译成扩展模块移动到 <code>site-packages</code> 之后，pycharm 会进行检测、然后将其抽象成一个普通的 py 文件，方便你查看。我们看到模块注释、函数的注释跟我们在 C  文件中指定的一样。但是注意：该文件只是 pycharm 方便你查看函数注释等信息而专门做的一个抽象，事实上你把这个文件删掉也是没有关系的。</strong></p>
<p><strong>因此我们可以再总结一下整体流程：</strong></p>
<p><strong>第一步：include “Python.h”，必须要引入这个头文件，这个头文件中还引入了 C 中的一些头文件，具体都引入了哪些库我们可以查阅。当然如果不确定但又懒得看，我们还可以手动再引入一次，反正 include 同一个头文件只会引入一次。</strong></p>
<p><strong>第二步：理论上这不是第二步，但是按照编写代码顺序我们就认为它是第二步吧，对，就是按照我们上面写的代码从上往下撸。这一步你需要编写函数，这个函数就是 C 语言中定义的函数，这个函数返回一个 PyObject * ，至少要接收一个PyObject *，我们一般叫它  self，这第一个参数你可以看成是必须的，无论我们传不传其他参数，这个参数是必需要有的。所以如果只有这一个参数，那么我们就认为这个函数不接收参数，因为我们在调用的时候没有传递。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f3</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设我们定义了这三个函数吧，三个函数都不接受参数</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：定义一个 PyMethodDef  类型的数组，这个数组也是我们后面的 PyModuleDef 对象中的一个参数，这个数组名字叫什么就无所谓了。至于  PyMethodDef，我们可以单独使用 PyMethodDef  创建实例，然后将变量写到数组中，也可以直接在数组中创建。如果是直接在数组中创建的话，那么就不需要再使用 PyMethodDef 定义了，直接在  {} 里面写成员信息即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef module_functions[] = &#123;</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">// 暴露给 Python 的函数名</span></span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        <span class="comment">// 函数指针，最好使用 PyCFunction 转一下，可以确保不出问题。</span></span><br><span class="line">        <span class="comment">// 如果不转，我自己测试没有问题，但是编译时候会给警告，最好还是按照标准，把指针的类型转换一下</span></span><br><span class="line">        <span class="comment">// 转换成 Python 底层识别的 PyCFunction</span></span><br><span class="line">        (PyCFunction) f1, </span><br><span class="line">        METH_NOARGS, <span class="comment">// 参数类型，至于怎么接收 *args 和 **kwargs 的参数，后面说</span></span><br><span class="line">        <span class="string">&quot;函数f1的注释&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f2&quot;</span>, (PyCFunction)f2, METH_NOARGS, <span class="string">&quot;函数f2的注释&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f3&quot;</span>, (PyCFunction)f3, METH_NOARGS, <span class="string">&quot;函数f3的注释&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">//别忘记，下面的 &#123;NULL, NULL, 0, NULL&#125;，充当哨兵</span></span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：定义 PyModuleDef 对象，这个变量的名字叫什么也没有要求。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyModuleDef m = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT, <span class="comment">// 头部信息</span></span><br><span class="line">    <span class="comment">// 模块名，这个是有讲究的，你要编译的扩展模块叫啥，这里就写啥</span></span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, </span><br><span class="line">    <span class="string">&quot;模块的注释&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// 模块的空间，这个是给子解释器调用的，我们不需要关心，直接写 -1 即可，表示不使用</span></span><br><span class="line">    module_functions, <span class="comment">// 然后是我们上面定义的数组名，里面放了一大堆的 PyMethodDef 结构体实例</span></span><br><span class="line">    <span class="comment">// 然后是四个 NULL，因为该结构还有其它成员，但我们不需要使用，所以指定 NULL 即可。当然有的编译器比较智能，你若不指定自动为 NULL</span></span><br><span class="line">    <span class="comment">// 但为了规范，我们还是手动写上，因为规范的做法就是给每个成员都赋上值</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：写上一个宏，其实把它单独拆分出来，有点小题大做了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="comment">// 一个宏，主要是保证函数按照 C 的标准，不用在意，写上就行</span></span><br></pre></td></tr></table></figure>

<p><strong>第六步：创建一个模块的入口函数，我们说编译的扩展模块叫 kagura_nana，那么这个函数名就要这么写。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyInit_kagura_nana(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 会根据上面定义的 PyModuleDef 实例，得到 Python 中的模块</span></span><br><span class="line">    <span class="comment">// PyModule_Create 就是用来创建 Python 中的模块的，直接将 PyModuleDef 定义的对象的指针扔进去</span></span><br><span class="line">    <span class="comment">// 便可得到 Python 中的模块，然后直接返回即可。</span></span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第七步：定义一个py文件，假设叫 xx.py，那么在里面写上如下内容，然后 python xx.py install 即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># 这是生成的 egg 文件名，也是里面的元信息中的 Name</span></span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="comment"># 版本号</span></span><br><span class="line">    version=<span class="string">&quot;10.22&quot;</span>,  </span><br><span class="line">    <span class="comment"># 作者</span></span><br><span class="line">    author=<span class="string">&quot;古明地觉&quot;</span>,  </span><br><span class="line">    <span class="comment"># 作者邮箱</span></span><br><span class="line">    author_email=<span class="string">&quot;东方地灵殿&quot;</span>,</span><br><span class="line">    <span class="comment"># 当然还有其它参数，作为元信息来描述模块，比如 description：模块介绍。</span></span><br><span class="line">    <span class="comment"># 有兴趣的话可以看函数的注释，或者根据已有的 egg 文件自己查看</span></span><br><span class="line">    <span class="comment"># 下面是扩展模块，Extension(&quot;yousa&quot;, [&quot;C源文件&quot;])</span></span><br><span class="line">    <span class="comment"># 我们说 Extension 里面的第一个参数也必须是你的扩展模块的名字，并且必须要和 PyInit_xxx 以及 PyModuleDef 中的第一个成员保持一致</span></span><br><span class="line">    <span class="comment"># 至于第二个参数就是一个列表，你需要用到哪些 C 源文件。</span></span><br><span class="line">    <span class="comment"># 而且我们看到这个 Extension 也在一个列表里面，因为我们也可以传入多个 Extension 同时生成多个扩展模块。</span></span><br><span class="line">    <span class="comment"># 我们可以写好一个生成一个，你也可以一次性写多个，然后只编译一次。</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;hanser&quot;</span>, [<span class="string">&quot;a.c&quot;</span>])]</span><br></pre></td></tr></table></figure>

<p><strong>以上便是编写扩展模块的基本流程，但是里面还有很多细节没有说。</strong></p>
<h4 id="PyMethodDef"><a href="#PyMethodDef" class="headerlink" title="PyMethodDef"></a>PyMethodDef</h4><p><strong>首先是 PyMethodDef，我们说它对应的是 Python 中的函数，那么我们肯定要来看看它的定义，藏身于 *Include&#x2F;methodobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 函数名 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_name;   </span><br><span class="line">    <span class="comment">/* 实现对应逻辑的 C 函数，但是需要转成 PyCFunction 类型，主要是为了更好的处理关键字参数 */</span></span><br><span class="line">    PyCFunction ml_meth;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 参数类型 </span></span><br><span class="line"><span class="comment">    #define METH_VARARGS  0x0001  扩展位置参数，*args</span></span><br><span class="line"><span class="comment">    #define METH_KEYWORDS 0x0002  扩展关键字参数，**kwargs</span></span><br><span class="line"><span class="comment">    #define METH_NOARGS   0x0004  不需要参数</span></span><br><span class="line"><span class="comment">    #define METH_O        0x0008  需要一个参数</span></span><br><span class="line"><span class="comment">    #define METH_CLASS    0x0010  被 classmethod 装饰</span></span><br><span class="line"><span class="comment">    #define METH_STATIC   0x0020  被 staticmethod 装饰   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>         ml_flags;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的 __doc__，没有的话传递 NULL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_doc; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不需要参数，那么 ml_flags 传入一个 METH_NOARGS；接收一个参数传入 METH_O；所以我们上面的 f1 对应的 ml_flags 是 METHOD_NOARGS，f2 对应的 ml_flags 是 METH_O。</strong></p>
<p><strong>如果是多个参数，那么直接写成 METH_VARAGRS 即可，也就是通过扩展位置参数的方式，但是这要如何解析呢？比如：有一个函数f3接收3个参数，这在C中要如何实现呢？别急我们后面会说。</strong></p>
<h3 id="引用计数和内存管理"><a href="#引用计数和内存管理" class="headerlink" title="引用计数和内存管理"></a>引用计数和内存管理</h3><p><strong>我们在最开始的时候就说过，PyObject  贯穿了我们的始终。我们说这里面存放了引用计数和类型指针，并且 Python 中所有对象底层对应的结构体都嵌套了 PyObject，因此  Python 中的所有对象都有引用计数和类型。并且 Python 的对象在底层，都可以看成是 PyObject 的一个扩展，因此参数、返回值都是 PyObject *，至于具体类型则是通过里面的 ob_type 动态判断。比如：之前使用的 PyLong_FromLong。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyLong_FromLong</span><span class="params">(<span class="type">long</span> ival)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *v;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此外 Python 还专门定义了几个宏，来看一下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Py_REFCNT(ob)           (((PyObject*)(ob))-&gt;ob_refcnt)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_SIZE(ob)             (((PyVarObject*)(ob))-&gt;ob_size)</span></span><br></pre></td></tr></table></figure>

<p><strong>Py_REFCNT：拿到对象的引用计数；Py_TYPE：拿到对象的类型；Py_SIZE：拿到对象的ob_size，也就是变长对象里面的元素个数。除此之外，Python 还提供了两个宏：Py_INCREF 和 Py_DECREF 来用于引用计数的增加和减少。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用计数增加很简单，就是找到 ob_refcnt，然后 ++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是减少的话，做的事情稍微多一些</span></span><br><span class="line"><span class="comment">// 其实主要就是判断引用计数是否为 0，如果为 0 直接调用 _Py_Dealloc 将对象销毁</span></span><br><span class="line"><span class="comment">// _Py_Dealloc 也是一个宏，会调用对应类型对象的 tp_dealloc，也就是析构方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                            \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><strong>当然这些东西我们在系列的最开始的时候就已经说过了，但是接下来我们要引出一个非常关键的地方，就是内存管理。到目前为止我们没有涉及到内存管理的操作，但我们知道 Python 中的对象都是申请在堆区的，这个是不会自动释放的。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;你好呀~~~&quot;</span>);</span><br><span class="line">    <span class="comment">// Py_None 就是 Python 中的 None, 同理还有 Py_True、Py_False，我们后面会继续提</span></span><br><span class="line">    <span class="comment">// 这里增加引用计数，至于为什么要增加，我们后面说</span></span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数不需要参数，如果我们写一个死循环不停的调用这个函数，你会发现内存的占用蹭蹭的往上涨。就是因为这个 PyUnicodeObject 是申请在堆区的，此时内部的引用计数为 1。函数执行完毕变量 s 被销毁了，但是 s  是一个指针，这个指针被销毁了是不假，但是它指向的内存并没有被销毁。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;hello~~~&quot;</span>);</span><br><span class="line">    Py_DECREF(s);</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们需要手动调用 Py_DECREF 这个宏，来将 s 指向的 PyUnicodeObject 的引用计数减 1，这样引用计数就为 0 了。不过有一个特例，那就是当这个指针作为返回值的时候，我们不需要手动减去引用计数，因为会自动减。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;hello~~~&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果我们把 s 给返回了，那么我们就不需要调用 Py_DECREF 了</span></span><br><span class="line">    <span class="comment">// 因为一旦作为返回值，那么会自动减去 1</span></span><br><span class="line">    <span class="comment">// 所以此时 C 中的对象是由 Python 来管理的，准确的说应该是作为返回值的指针指向的对象是由 Python 来管理的</span></span><br><span class="line">    <span class="keyword">return</span> s;	</span><br><span class="line">    <span class="comment">// 所以在返回 Py_None 的时候，我们需要手动将引用计数加 1，因为它作为了返回值。</span></span><br><span class="line">    <span class="comment">// 如果你不加 1，那么当你无限调用的时候，总会有那么一刻，Py_None 会被销毁，因为它的引用计数在不断减少</span></span><br><span class="line">    <span class="comment">// 但当销毁 Py_None 的时候，会出现 Fatal Python error: deallocating None，解释器异常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不过这里还存在一个问题，那就是我们在 C 中返回的是 Python 传过来的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//传递过来一个 PyObject *，然后原封不动的返回</span></span><br><span class="line">	<span class="keyword">return</span> val;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然上面 val 指向的内存不是在 C 中调用 api 创建的，而是  Python 创建然后传递过来的，也就是说这个 val 已经指向了一块合法的内存（和增加 Py_None  引用计数类似）。但是内存中的对象的引用计数是没有变化的，虽说有新的变量（这里的 val）指向它了，但是这个 val 是 C 中的变量不是  Python 中的变量，因此它的引用计数是没有变化的。然后作为返回值返回之后，指向对象的引用计数减一。所以你会发现在 Python  中，创建一个变量，然后传递到 f 中，执行完之后再进行打印就会发生段错误，因为对应的内存已经被回收了。如果能正常打印，说明在 Python  中这个变量的引用计数不为  1，也可能是小整数对象池、或者有多个变量引用，那么就创建一个大整数或者其他的对象多调用几次，因为作为返回值，每次调用引用计数都会减1。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 假设创建一个 PyListObject</span></span><br><span class="line">    PyObject *l1 = PyList_New(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 将 l1 赋值给 l2，但是不好意思，这两位老铁指向的 PyListObject 的引用计数还是 1</span></span><br><span class="line">    PyObject *l2 = l1;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们说，如果在 C 中创建一个 PyObject  的话，那么它的引用计数会是 1，因为对象被初始化了，引用计数默认是 1。至于传递，无论你在 C 中将创建 PyObject *  赋值给了多少个变量，它们指向的 PyObject 的引用计数都会是 1。因为这些变量是 C 中的变量，不是 Python 中的。</strong></p>
<p><strong>因此我们的问题就很好解释了，我们说当一个 PyObject *  作为返回值的时候，它指向的对象的引用计数会减去 1，那么当 Python 传递过来一个 PyObject *  指针的时候，由于它作为了返回值，因此调用之后会发现引用计数会减少了。因此当你在 Python  中调用扩展函数结束之后，这个变量指向的内存可能就被销毁了。如果你在 Python  传递过来的指针没有作为返回值，那么引用计数是不会发生变化的，但是一旦作为了返回值，引用计数会自动减 1，因此我们需要手动的加 1。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">    Py_INCREF(val);</span><br><span class="line">    <span class="keyword">return</span> val;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以得出如下结论：</strong></p>
<blockquote>
<p><strong>如果在 C 中，创建一个 PyObject *var，并且 var  已经指向了合法的内存，比如调用 PyList_New、PyDict_New 等等 api 返回的 PyObject *，总之就是已经存在了  PyObject。那么如果 var 没有作为返回值，我们必须手动地将 var 指向的对象的引用计数减  1，否则这个对象就会在堆区一直待着不会被回收。可能有人问，如果 PyObject *var2 &#x3D; var，我将 var  再赋值给一个变量呢？那么只需要对一个变量进行 Py_DECREF 即可，当然对哪个变量都是一样的，因为在 C  中变量的传递不会导致引用计数的增加。</strong></p>
<p><strong>如果 C 中创建的 PyObject * 作为返回值了，那么会自动将指向的对象的引用计数减 1，因此此时该指针指向的内存就由 Python 来管理了，就相当于在 Python 中创建了一个对象，我们不需要关心。</strong></p>
<p><strong>最后关键的一点，如果 C 中返回的指针指向的内存是 Python  中创建好的，假设我们在 Python 中创建了一个对象，然后把指针传递过来了，但是我们说这不会导致引用计数的增加，因为赋值的变量是 C  中的变量。如果 C  中用来接收参数的指针没有作为返回值，那么引用计数在扩展函数调用之前是多少、调用之后还是多少。然而一旦作为了返回值，我们说引用计数会自动减  1，因此假设你在调用扩展函数之前引用计数是  3，那么调用之后你会发现引用计数变成了2。为了防止段错误，一旦作为返回值，我们需要在返回之前手动地将引用计数加1。</strong></p>
</blockquote>
<p><strong>C中创建的：不作为返回值，引用计数手动减 1、作为返回值，不处理；Python 中创建传递过来的，不作为返回值，不处理、作为返回值，引用计数手动加 1。</strong></p>
<p><strong>而实现引用计数增加和减少所使用的宏就是 Py_INCREF  和 Py_DECREF，但它们要求传递的 PyObject * 不可以为 NULL。如果可能为 NULL 的话，那么建议使用 Py_XINCREF 和 Py_XDECREF。</strong></p>
<h3 id="参数的解析"><a href="#参数的解析" class="headerlink" title="参数的解析"></a>参数的解析</h3><p><strong>我们说，PyMethodDef 内部有一个 ml_flags 属性，表示此函数的参数类型，我们说有如下几种：</strong></p>
<p><strong>1. 不接受参数，METH_NOARGS，对应函数格式如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 接受一个参数，METH_O，对应函数格式如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">f(PyObject *self, PyObject *val)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 接受任意个位置参数，METH_VARARGS，对应函数格式如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 接受任意个位置参数和关键字参数，METH_VARARGS | METH_KEYWORDS，对应函数格式如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">f(PyObject *self, PyObject *args, PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一种和第二种显然都很简单，关键是第三种和第四种要怎么做呢？我们先来看看第三种，解析多个位置参数可以使用一个函数：PyArg_ParseTuple。</strong></p>
<h4 id="解析多个位置参数"><a href="#解析多个位置参数" class="headerlink" title="解析多个位置参数"></a>解析多个位置参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数原型：int PyArg_ParseTuple(PyObject *args, const char *format, ...); 位于 Python/getargs.c 中</span><br></pre></td></tr></table></figure>

<p><strong>所以重点就在 PyArg_ParseTuple 上面，我们注意到里面有一个 format，显然类似于 printf，里面肯定是一些占位符，那么都支持哪些占位符呢？常用的如下：</strong></p>
<ul>
<li><code>i：接收一个 Python 中的 int，然后解析成 C 的 int</code></li>
<li><code>l：接收一个 Python 中的 int，然后将传来的值解析成 C 的 long</code></li>
<li><code>f：接收一个 Python 中的 float，然后将传来的值解析成 C 的 float</code></li>
<li><code>d：接收一个 Python 中的 float，然后将传来的值解析成 C 的 double</code></li>
<li><code>s：接收一个 Python 中的 str，然后将传来的值解析成 C 的 char *</code></li>
<li><code>u：接收一个 Python 中的 str，然后将传来的值解析成 C 的 wchar_t *</code></li>
<li><code>O：接收一个 Python 中的 object，然后将传来的值解析成 C 的 PyObject *</code></li>
</ul>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 目前我们定义了一个 PyObject *args，如果是 METH_O，那么这个 args 就是对应的一个参数</span></span><br><span class="line">    <span class="comment">// 如果 METH_VARAGRS，还是只需要定义一个 *args 即可，只不过此时的 *args 是一个 PyTupleObject，我们需要将多个参数解析出来</span></span><br><span class="line">    <span class="comment">//假设此时我们这个函数是接收 3 个 int，然后相加    </span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面我们需要使用 PyArg_ParseTuple 进行解析，因为我们接收三个参数</span></span><br><span class="line"><span class="comment">    这个函数返回一个整型，如果失败会返回 0，成功返回非 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;iii&quot;</span>, &amp;a, &amp;b, &amp;c))&#123;</span><br><span class="line">        <span class="comment">// 失败我们需要返回 NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们还是编译一下，当然编译的过程我们就不显示了，跟之前是一样的。并且为了方便，我们的模块名就不改了，但是编译之后的 pyd 文件内容已经变了。不过需要注意的是，我们说编译之后会有一个 build 目录，然后会自动把里面的 pyd 文件拷贝到  site-packages  中，如果你修改了代码，但是模块名没有变的话，那么编译之后的文件名还和原来一样。如果一样的话，那么由于已经存在相同文件了，可能就不会再拷贝了。因此两种做法：要么你把模块名给改了，这样编译会生成新的模块。要么编译之前记得把上一次编译生成的 build 目录先删掉，我们推荐第二种做法，不然 site-packages 目录下会出现一大堆我们自己定义的模块。</strong></p>
<p><strong>然后我们将 ml_flags 改成 METH_VARARGS，来测试一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;iii&quot;</span>, &amp;a, &amp;b, &amp;c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f&quot;</span>,</span><br><span class="line">        (PyCFunction) f,</span><br><span class="line">        <span class="comment">// 这里需要改成 METH_VARAGRS，这个地方很重要，因为它表示了函数的参数类型。如果这个地方不修改的话，Python 在调用函数时会发生段错误</span></span><br><span class="line">        METH_VARARGS, </span><br><span class="line">        <span class="string">&quot;this is a function named f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, </span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>, </span><br><span class="line">    <span class="number">-1</span>, </span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们编译成扩展模块之后，来测试一下，但是注意，你在调用的时候 pycharm 可能会感到别扭。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015328074-1712286863.png" alt="img"></p>
<p><strong>因为在调用函数 f 的是给你飘黄了，原因就是我们上一次在生成 pyd  的时候，里面的函数是 f1 和 f2，并没有 f。而我们 pycharm 会将 pyd 抽象成一个普通的 py 文件让你查看，但同时它也是  pycharm 自动提示的依据。因为上一次 pycharm 已经抽象出来了这个文件，而里面没有 f  这个函数，所以这里会飘黄。但是不用管，因为我们调用的是生成的 pyd 文件，跟 pycharm 抽象出来的 py 文件无关。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传参不符合，自动给你报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f())</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (0 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (1 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>, <span class="string">&quot;xxx&quot;</span>, <span class="number">123</span>, <span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (4 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f(<span class="number">123</span>, <span class="number">123.0</span>, <span class="number">123</span>)  <span class="comment"># int: 123, long: 123, float: 123.000000, double: 123.000000</span></span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># integer argument expected, got float</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>))  <span class="comment"># 369</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很简单呢？当然 PyArg_ParseTuple 解析失败，Python 底层自动帮你报错了，告诉你缺了几个参数，或者哪个参数的类型错了。</strong></p>
<p><strong>我们这里是以 i 进行演示的，至于其它的几个占位符也是类似的。当然 O  比较特殊，因为它是转成 PyObject *，所以此时我们是可以传递元组、列表、字典等任意高阶对象的。而我们之前的 ctypes  则是不支持的，还是那句话，因为它没有涉及任何 Python &#x2F; C API 的调用，显然数据的表达能力有限。</strong></p>
<h4 id="解析成-PyObject"><a href="#解析成-PyObject" class="headerlink" title="解析成 PyObject *"></a>解析成 PyObject *</h4><p><strong>我们说 PyArg_ParseTuple 中的 i 代表 int、l 代表 long、f 代表 float、d 代表 double、s 代表 char*、u代表 wchar_t *，这些都比较简单。我们重点是 O，其实 O 也不难，无非就是后续的一些 Python &#x2F; C API 调用罢了。</strong></p>
<p><strong>我们还是以普通的 py 文件为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">lst: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    假设我们传递一个列表, 然后返回一个元组, 并且将里面的元素都设置成元素的类型</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>([<span class="built_in">type</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> lst])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, &#123;&#125;]))  <span class="comment"># (&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p><strong>如果使用 C 来编写扩展的话，要怎么做呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">foo</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *lst;  <span class="comment">// 首先我们这里要接收一个 PyObject *</span></span><br><span class="line">    <span class="comment">// 我们要修改 lst，让它指向我们传递的列表, 因此要传递一个二级指针进行修改</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O&quot;</span>, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算列表中的元素个数，申请同样大小的元组。</span></span><br><span class="line">    <span class="comment">// 其实还可以使用 PyList_Size，底层也是调用了 Py_SIZE，只是 PyList_Size 会进行类型检测，同理还有 PyTuple_Size 等等</span></span><br><span class="line">    Py_ssize_t arg_count = Py_SIZE(lst);</span><br><span class="line">    <span class="comment">// 申请完毕之后，里面的元素全部是 NULL，然后我们来进行设置</span></span><br><span class="line">    <span class="comment">// 但是这里我们故意多申请一个，我们看看 NULL 在 Python 中的表现是什么</span></span><br><span class="line">    PyObject *tpl = PyTuple_New(arg_count + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 申明类型对象、以及元素</span></span><br><span class="line">    PyObject *type, *val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arg_count; i++) &#123;</span><br><span class="line">        val = PyList_GetItem(lst, i);  <span class="comment">// 获取对应元素，赋值给 val</span></span><br><span class="line">        <span class="comment">// 获取对应的类型对象，但得到的是 PyTypeObject *，所以需要转成 PyObject *</span></span><br><span class="line">        <span class="comment">// 或者你使用 Py_TYPE 这个宏也可以，内部自动帮你转了</span></span><br><span class="line">        type = (PyObject *)val -&gt; ob_type;</span><br><span class="line">        <span class="comment">//设置到元组中</span></span><br><span class="line">        PyTuple_SetItem(tpl, i, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">        (PyCFunction) foo,</span><br><span class="line">        <span class="comment">// 记得这里写上 METH_VARARGS, 假设我们写的是 METH_NOARGS, 那么即便我们上面定义了参数也是没有意义的</span></span><br><span class="line">        <span class="comment">// 调用的时候 Python 会提示你: TypeError: foo() takes no arguments</span></span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后使用 Python 测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    kagura_nana.foo([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, &#123;&#125;])</span><br><span class="line">)  <span class="comment"># (&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;NULL&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到得到结果是一致的，并且我们多申请了一个空间，但是没有设置，所以结尾多了一个 &lt;NULL&gt;</span></span><br><span class="line"><span class="comment"># 但是注意：不要试图通过 kagura_nana.foo([1, 2, &quot;3&quot;, &#123;&#125;])[-1] 的方式来获取这个 NULL，会造成段错误</span></span><br><span class="line"><span class="comment"># 因为 Python 操作指针会自动操作指针指向的内存，而 NULL 是一个空指针，指向的内存是非法的</span></span><br><span class="line"><span class="comment"># 另外段错误是一种非常可怕的错误，它造成的结果就是解释器直接就异常退出了。</span></span><br><span class="line"><span class="comment"># 并且这不是异常捕获能解决的问题，异常捕获也是解释器正常运行的前提下。因此申请容器的时候，要保证元数个数相匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>从这里我们也能看出使用 C 来为 Python 写扩展是一件多么麻烦的事情，因此 Cython 的出现是一个福音。当然我们上面的代码只是演示，没有太大意义，完全可以用 Python 实现。</strong></p>
<h4 id="传递字符串"><a href="#传递字符串" class="headerlink" title="传递字符串"></a>传递字符串</h4><p><strong>然后我们再来看看字符串的传递，比较简单，说白了这些都是 Python &#x2F; C API 的调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 这里我们接受任意个字符串，然后将它们拼接在一起，最后放在列表中返回。</span></span><br><span class="line">   <span class="comment">// 由于是任意个，所以无法使用 PyArg_ParseTuple 了</span></span><br><span class="line">   <span class="comment">// 因为我们不知道占位符要写几个 O，但我们说 args 是一个元组，那么我们可以按照元组的方式进行解析</span></span><br><span class="line">   Py_ssize_t arg_count = Py_SIZE(args);  <span class="comment">// 计算元组的长度</span></span><br><span class="line">   PyObject *res = PyUnicode_FromWideChar(<span class="string">L&quot;&quot;</span>, <span class="number">0</span>);  <span class="comment">// 返回值，因为包含中文，所以是宽字符</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; arg_count; i++)&#123;</span><br><span class="line">       <span class="comment">// 将 res 和 里面的字符串依次拼接，等价于字符串的加法</span></span><br><span class="line">       res = PyUnicode_Concat(res, PyTuple_GetItem(args, i));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 我们上面这种做法比较笨，直接通过 PyUnicode_Join 直接拼接不香吗？我们目前先这么做，join 的话在下面的 f2 函数中</span></span><br><span class="line">   <span class="comment">// 然后创建一个列表，将结果放进去。我们申请列表，容量只需要为 1 即可</span></span><br><span class="line">   PyObject *lst = PyList_New(<span class="number">1</span>);</span><br><span class="line">   PyList_SetItem(lst, <span class="number">0</span>, res);</span><br><span class="line">   <span class="comment">// 我们说 lst 是在 C 中创建的, 但是它作为了返回值, 所以我们不需要关心它的引用计数, 因为会自动减一</span></span><br><span class="line">   <span class="comment">// 那 res 怎么办？它要不要减少引用计数，答案是不需要、也不能，因为它作为了容器的一个元素(这里面有很多细节，我们暂且不表，在后面介绍 PyDictObject 的时候再说)</span></span><br><span class="line">   <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里还可以指定连接的字符，这里就直接返回吧</span></span><br><span class="line">    PyObject *res = PyUnicode_Join(PyUnicode_FromWideChar(<span class="string">L&quot;||&quot;</span>, <span class="number">2</span>), args);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f2&quot;</span>,</span><br><span class="line">        (PyCFunction) f2,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 进行调用，看看结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;哼哼&quot;</span>, <span class="string">&quot;嘿嘿&quot;</span>, <span class="string">&quot;哈哈&quot;</span>))  <span class="comment"># [&#x27;哼哼嘿嘿哈哈&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f2(<span class="string">&quot;哼哼&quot;</span>, <span class="string">&quot;嘿嘿&quot;</span>, <span class="string">&quot;哈哈&quot;</span>))  <span class="comment"># 哼哼||嘿嘿||哈哈</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到结果是没有问题的，还是蛮有趣的。</strong></p>
<h3 id="类型检查和返回异常"><a href="#类型检查和返回异常" class="headerlink" title="类型检查和返回异常"></a>类型检查和返回异常</h3><p><strong>在 Python 中，当我们传递的类型不对时会报错。那么在底层我如何才能检测传递过来的参数是不是想要的类型呢？首先我们想到的是通过 ob_type，假设我们要求 val 是一个 int，那么：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 获取类型名称， 如果是字符串，那么 tp_name 就是 &quot;str&quot;，字典是 &quot;dict&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name = val -&gt; ob_type -&gt; tp_name;</span><br><span class="line">    <span class="type">char</span> *res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tp_name, <span class="string">&quot;int&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        res = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromString(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_O,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>))</span>  <span class="meta"># success</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="string">&quot;123&quot;</span>))</span>  <span class="meta"># failure</span></span><br></pre></td></tr></table></figure>

<p><strong>以上是一种判断方式，但是 Python 底层给我们提供了其它的 API 来进行判断。比如：</strong></p>
<ul>
<li><code>判断是否为整型: PyLong_Check</code></li>
<li><code>判断是否为字符串: PyUnicode_Check</code></li>
<li><code>判断是否为浮点型: PyFloat_Check</code></li>
<li><code>判断是否为复数: PyComplex_Check</code></li>
<li><code>判断是否为元组: PyTuple_Check</code></li>
<li><code>判断是否为列表: PyList_Check</code></li>
<li><code>判断是否为字典: PyDict_Check</code></li>
<li><code>判断是否为集合: PySet_Check</code></li>
<li><code>判断是否为字节串: PyBytes_Check</code></li>
<li><code>判断是否为函数: PyFunction_Check</code></li>
<li><code>判断是否为方法: PyMethod_Check</code></li>
<li><code>判断是否为实例对象: PyInstance_Check</code></li>
<li><code>判断是否为类(type的实例对象): PyType_Check</code></li>
<li><code>判断是否为可迭代对象: PyIter_Check</code></li>
<li><code>判断是否为数值: PyNumber_Check</code></li>
<li><code>判断是否为序列(实现 __getitem__ 和 __len__): PySequence_Check</code></li>
<li><code>判断是否为映射(必须实现 __getitem__、__len__ 和 __iter__): PyMapping_Check</code></li>
<li><code>判断是否为模块: PyModule_Check</code></li>
</ul>
<p><strong>写法非常固定，因此我们上面的判断逻辑就可以进行如下修改：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *res;</span><br><span class="line">    <span class="keyword">if</span> (PyLong_Check(val)) &#123;</span><br><span class="line">        res = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromString(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种写法是不是就简单多了呢？其它部分不需要动，然后你可以自己重新编译、并测试一下，看看结果是不是一样的。</strong></p>
<p><strong>然后问题来了，如果用户传递的参数个数不对，或者类型不对，那么我们应该返回一个 TypeError，或者说返回一个异常。那么在 C 中，要如何设置异常呢？其实设置异常，说白了就是把输出信息打印到 stderr 中，然后直接返回 NULL 即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t arg_count = Py_SIZE(args);</span><br><span class="line">    <span class="keyword">if</span> (arg_count != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是我们设置的异常, 其实参数个数不对的话, 我们可以借助于 PyArg_ParseTuple 来帮助我们</span></span><br><span class="line">        <span class="comment">// 因为指定的占位符已经表明了参数的个数</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but %d were given&quot;</span>, arg_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后我们要求第一个参数是整型, 第二个参数是字符串, 第三个参数是列表</span></span><br><span class="line">    PyObject *a, *b, *c;</span><br><span class="line">    <span class="comment">// 因为参数一定是三个, 否则逻辑不会执行到这里, 因此我们不需要判断了</span></span><br><span class="line">    PyArg_ParseTuple(args, <span class="string">&quot;OOO&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">// 检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyLong_Check(a)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 1th argument requires a int, but got %s&quot;</span>, Py_TYPE(a) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(b)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 2th argument requires a str, but got %s&quot;</span>, Py_TYPE(b) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(c)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 3th argument requires a list, but got %s&quot;</span>, Py_TYPE(c) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测成功之后, 我们将整数和字符串添加到列表中</span></span><br><span class="line">    PyList_Append(c, a);</span><br><span class="line">    PyList_Append(c, b);</span><br><span class="line">    <span class="comment">// 这里我们将列表给返回, 而它是 Python 传递过来的, 所以一旦返回、引用计数会减一, 因此我们需要手动加一</span></span><br><span class="line">    Py_INCREF(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以逻辑就是像上面那样，通过 PyErr_Format  来设置异常，这个会被 Python 端接收到，但是异常一旦设置，就必须要返回 NULL，否则会出现段错误。但反过来吗，返回 NULL  的话则不一定要设置异常，但如果你不设置，那么 Python 底层会默认帮你设置一个 SystemError，并且异常的 value  信息为：<built-in function f1> returned NULL without setting an  error，提示你返回了 NULL 但没有设置 error。因为返回 NULL 表示程序需要终止了，那么就应该把为什么需要终止的理由告诉使用者。</built-in></strong></p>
<p><strong>然后我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but 0 were given</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but 4 were given</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># The 2th argument requires a str, but got int</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;xx&quot;</span>, <span class="string">&quot;yy&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="string">&quot;123&quot;</span>, lst))  <span class="comment"># [&#x27;xx&#x27;, &#x27;yy&#x27;, 123, &#x27;123&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;xx&#x27;, &#x27;yy&#x27;, 123, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>所表现的一切，都和我们在底层设置的一样。另外我们再来看看这个函数的身份是什么：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1)  <span class="comment"># &lt;built-in function f1&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)  <span class="comment"># &lt;built-in function sum&gt;</span></span><br><span class="line"><span class="built_in">print</span>(foo)  <span class="comment"># &lt;function foo at 0x000001F1BAAF61F0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们居然实现了一个内置函数，怎么样是不是很神奇呢？因为扩展模块里面的函数和解释器内置的函数本质上都是一样的，所以它们都是 built-in。</strong></p>
<h3 id="返回布尔类型和-None"><a href="#返回布尔类型和-None" class="headerlink" title="返回布尔类型和 None"></a>返回布尔类型和 None</h3><p><strong>我们说函数都必须返回一个 PyObject  *，如果这个函数没有返回值，那么在 Python 中实际上返回的是一个 None，但是我们不能返回 NULL，None 和 NULL  是两码事。在扩展函数中，如果返回 NULL 就表示这个函数执行的时候，不符合某个逻辑，我们需要终止掉，不能再执行下去了。这是在底层，但是在  Python 的层面，你需要告诉使用者为什么不能执行了，或者说底层的哪一行代码不满足条件，因此这个时候我们会在 return NULL  之前需要手动设置一个异常，这样在 Python 代码中才知道为什么底层函数退出了。当然有时候会自动帮我们设置，比如们说的  PyArg_ParseTuple。</strong></p>
<p><strong>那么在底层如何返回一个 None 呢？既然要返回我们就需要知道它的结构是什么。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先在 Python 中，None 也是有类型的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">None</span>))  <span class="comment"># &lt;class &#x27;NoneType&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这个 NoneType 在底层对应的是 _PyNone_Type，至于 None 在底层对应的结构体是 _Py_NoneStruct，所以我们返回的时候应该返回这个结构体的指针。不过官方不推荐直接使用，而是给我们定义了一个宏，<code>#define Py_None (&amp;_Py_NoneStruct)</code>，我们直接返回 Py_None 即可。</strong></p>
<p><strong>不光是 None，我们说还有 True 和 False，True 和 False 对应的结构体是：_Py_FalseStruct，_Py_TrueStruct，它们本质上是 PyLongObject，Python 也不推荐直接返回，也是定义了两个宏。</strong></p>
<ul>
<li><code>#define Py_False ((PyObject *) &amp;_Py_FalseStruct)</code></li>
<li><code>#define Py_True ((PyObject *) &amp;_Py_TrueStruct)</code></li>
</ul>
<p><strong>推荐我们使用 Py_False 和 Py_True。</strong></p>
<p><strong>另外：</strong></p>
<ul>
<li><code>return Py_None; 等价于 Py_RETURN_NONE;</code></li>
<li><code>return Py_True; 等价于 Py_RETURN_TRUE;</code></li>
<li><code>return Py_False; 等价于 Py_RETURN_FALSE;</code></li>
</ul>
<p><strong>可以自己测试一下，比如条件满足返回 Py_True，不满足返回 Py_False 等等。</strong></p>
<h3 id="传递关键字参数"><a href="#传递关键字参数" class="headerlink" title="传递关键字参数"></a>传递关键字参数</h3><p><strong>我们上面的例子都是通过位置参数实现的，如果我们通过关键字参数传递呢？很明显是会报错的，因为我们参数名叫什么都不知道，所以上面的例子都不支持关键字参数。那么下面我们就来看看关键字参数要如何实现。</strong></p>
<p><strong>传递关键字参数的话，我们是通过 key&#x3D;value 的方式来实现，那么在 C 中我们如何解析呢？既然支持关键字的方式，那么是不是也可以实现默认参数呢？答案是肯定的，我们知道解析位置参数是通过  PyArg_ParseTuple，而解析关键字参数是通过 PyArg_ParseTupleAndKeywords。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数原型: int PyArg_ParseTupleAndKeywords(PyObject *args, PyObject *kw, const char *format, char *keywords[], ...) </span><br></pre></td></tr></table></figure>

<p><strong>我们看到相比原来的 PyArg_ParseTuple，多了一个 kw 和一个 char * 类型的数组，具体怎么用我们在编写代码的时候说。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们说函数既可以通过位置参数、还可以通过关键字参数传递，那么函数的参数类型就要变成 METH_VARARGS | METH_KEYWORDS</span></span><br><span class="line">    <span class="comment">// 参数 args 就是 PyTupleObject 对象, kwargs 就是 PyDictObject 对象</span></span><br><span class="line">    <span class="comment">// 假设我们定义了三个参数，name、age、place，这三个参数可以通过位置参数传递、也可以通过关键字参数传递</span></span><br><span class="line">    <span class="type">wchar_t</span> *name;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">17</span>;</span><br><span class="line">    <span class="type">wchar_t</span> *gender = <span class="string">L&quot;FEMALE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉 Python 解释器参数的名字，注意：里面字符串的顺序就是函数定义的参数顺序</span></span><br><span class="line">    <span class="comment">// 这里的字符串就是函数的参数名，上面的是变量名。其实变量名字叫什么无所谓，只是为了一致我们会起相同的名字</span></span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 注意结尾要有一个 NULL，否则会报出段错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数，我们看到 format 中本来应该是 uiu 的，但是中间出现了一个 |</span></span><br><span class="line">    <span class="comment">// 这就表示 | 后面的参数是可以不填的，如果不填会使用我们上面给出的默认值</span></span><br><span class="line">    <span class="comment">// 因此这里 name 就是必填的，因为它在 | 的前面，而 age 和 gender 可以不填，如果不填就用我们上面给出的默认值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  <span class="comment">// keys 就是函数的所以参数的名字，然后后面把指针传进去，注意顺序要和参数顺序保持一致</span></span><br><span class="line">    <span class="type">wchar_t</span> res[<span class="number">100</span>];</span><br><span class="line">    swprintf(res, <span class="number">100</span>, <span class="string">L&quot;name: %s, age: %d, gender: %s&quot;</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromWideChar(res, wcslen(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  <span class="comment">// 注意这里, 因为支持位置参数和关键字参数, 所以是 METH_VARARGS | METH_KEYWORDS</span></span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用 Python 来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 1 must be str, not int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>))  <span class="comment"># name: 古明地觉, age: 17, gender: FEMALE</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>))  <span class="comment"># name: 古明地恋, age: 16, gender: FEMALE</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;女&quot;</span>))  <span class="comment"># name: 古明地恋, age: 16, gender: 女</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一切都符合我们的预期，而且 PyArg_ParseTuple，和  PyArg_ParseTupleAndKeywords  可以自动帮我们检测参数是否合法，不合法抛出合理的异常。当然你也可以检测参数的个数，或者将参数一个一个获取、用 PyXxx_Check  系列检测函数进行判断，看看是否符合预期，当然这么做就比较麻烦了。</strong></p>
<p><strong>PyArg_ParseTuple 和 PyArg_ParseTupleAndKeywords 里面的占位符还可以接收一些特殊的符号，我们举个栗子。为了更好的说明，我们统一以 PyArg_ParseTupleAndKeywords 为例。</strong></p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符 :"></a>占位符 :</h4><p><strong>下面的是之前写的 C 代码，我们不做任何改动，来测试一下当参数传递错误时的报错信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wchar_t</span> *name;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">17</span>;</span><br><span class="line">    <span class="type">wchar_t</span> *gender = <span class="string">L&quot;FEMALE&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wchar_t</span> res[<span class="number">100</span>];</span><br><span class="line">    swprintf(res, <span class="number">100</span>, <span class="string">L&quot;name: %s, age: %d, gender: %s&quot;</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromWideChar(res,wcslen(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们用 Python 来测试一下，注意观察报错信息。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, xxx=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;xxx&#x27; is an invalid keyword argument for this function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, name=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument for function given by name (&#x27;name&#x27;) and position (1)</span></span><br></pre></td></tr></table></figure>

<p><strong>报错信息似乎没有什么特别的，但是注意了，我们来做一下改动。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu:abcdefg&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其它地方都不变，我们只在 format 字符串的结尾加上了一个 <code>:abcdefg</code>，然后编译再来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># abcdefg() missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, xxx=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;xxx&#x27; is an invalid keyword argument for abcdefg()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, name=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument for abcdefg() given by name (&#x27;name&#x27;) and position (1)</span></span><br></pre></td></tr></table></figure>

<p><strong>你看到了什么？没错，默认的报错信息使用的是 function，但我们通过在占位符中指定 <code>:xxx</code> ，可以将 function 变成我们指定的内容 xxx，一般和函数名保持一致。另外需要注意的是，<code>:xxx</code> 要出现在占位符的结尾，并且只能出现一次。如果这样的话会变成什么样子呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PyArg_ParseTupleAndKeywords(args, kwargs, &quot;u:aaa|iu:abcdefg&quot;, keys, &amp;name, &amp;age, &amp;gender)</span><br></pre></td></tr></table></figure>

<p><strong>显然这变成了只接受一个参数，然后我们将参数不对时、返回报错信息中的 function 换成了 <code>aaa|iu:abcdefg</code>。并且你在传递参数的时候还会报出如下错误：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SystemError: More keyword list entries (3) than format specifiers (1)</span><br></pre></td></tr></table></figure>

<p><strong>因为占位符中相当于只有一个 u，也就是接收一个参数，但是我们后面跟了 &amp;name、&amp;age、&amp;gender。关键字 entry 是 3，占位符是 1，两者不匹配。因此 <code>:xxx</code> 一定要出现在最后面，并且只能出现一次。</strong></p>
<p><strong>另外，即使函数不接收参数我们也是可以这么做的，比如：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 不接收参数</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;&quot;</span>, keys))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;xxx&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  <span class="meta"># function takes at most 0 arguments (1 given)</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们加上 <code>:xxx</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里还可以使用数字</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;:123&quot;</span>, keys))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;xxx&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  # <span class="number">123</span>() takes at most <span class="number">0</span> arguments (<span class="number">1</span> given)</span><br></pre></td></tr></table></figure>

<p><strong>我们看到返回信息也被我们修改了，以上就是 <code>:xxx</code> 的作用。所以目前我们看到了两个特殊符号，一个是 <code>|</code> 用来实现默认参数，一个是这里的 <code>:</code> 用来自定义报错信息中的函数名。</strong></p>
<h4 id="占位符-1"><a href="#占位符-1" class="headerlink" title="占位符 !"></a>占位符 !</h4><p><strong>我们说占位符 O 表示接收一个 Python 中的对象，但这个对象显然是没有限制的，可以是列表、可以是字典等等。我们之前是通过 Check 的方式进行检测，但是 Python 底层为我们提供更简便的做法，先来看一个常规的例子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;    </span><br><span class="line">    PyObject *val3;        </span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OOO&quot;</span>, keys, &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个例子很简单，就是接收三个 PyObject *，但如果我希望第一个参数的类型是浮点型，第三个参数的类型是字典，这个时候该怎么做呢？此时 ! 就派上用场了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="comment">// 我们希望限制第一个参数和第三个参数的类型, 那么在它们的后面加上 ! 即可</span></span><br><span class="line">    <span class="comment">// 但是注意: 一旦加上了 !, 那么 O! 就要对应两个位置(分别是类型和变量, 当然都是指针)</span></span><br><span class="line">    <span class="comment">// 我们说, 第一个参数是浮点型, 那么第一个 O! 对应 &amp;PyFloat_Type, &amp;val1</span></span><br><span class="line">    <span class="comment">// 第二个参数没有限制, 那么就是 &amp;val2</span></span><br><span class="line">    <span class="comment">// 第三个参数是字典, 那么最后一个 O! 对应 &amp;PyDict_Type, &amp;val3</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!OO!:my_func&quot;</span>, keys, </span><br><span class="line">                                     &amp;PyFloat_Type, &amp;val1, &amp;val2, &amp;PyDict_Type, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后其它地方不变，我们来编译测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="string">&quot;xx&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># my_func() argument 1 must be float, not int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123.0</span>, <span class="number">11</span>, <span class="string">&quot;xx&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># my_func() argument 3 must be dict, not str</span></span><br></pre></td></tr></table></figure>

<p><strong>这个功能就很方便了，可以让我们更加轻松地限制参数类型。但如果你用过 Cython 的话，你会发现我这里所说的方便实在是不敢恭维。如果你要写扩展，那么我强烈推荐 Cython，而且用 Cython 可以轻松的连接 C &#x2F; C++。</strong></p>
<blockquote>
<p><strong>注意：! 只能跟在 O 的后面。</strong></p>
</blockquote>
<h4 id="占位符-amp"><a href="#占位符-amp" class="headerlink" title="占位符 &amp;"></a>占位符 &amp;</h4><p><strong>&amp; 的话，对于我们编写扩展而言用的不是很多，首先 &amp; 和  上面说的 ! 用法类似，并且都只能跟在 O 的后面。O! 的话，我们说会对应一个类型指针和一个 PyObject  *（参数就会传递给它），会判断传递的参数的类型是否和指定的类型一致。但 O&amp;  的话，则是对应一个函数（convert）和一个任意类型的指针（address），会执行 <code>convert(object, address)</code>，这个 object 就是我们传递过来的参数。我们举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">convert</span><span class="params">(PyObject *object, <span class="type">long</span> *any)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 object 转成 long, 赋值给 *any</span></span><br><span class="line">    *any = PyLong_AsLong(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">long</span> any = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 我们传递一个 Python 中的整数(假设为 PyObject *val1), 那么这里就会执行 convert(val1, &amp;any) </span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O&amp;&quot;</span>, keys,</span><br><span class="line">                                     convert, &amp;any))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完毕之后, any 就会被改变, 为了方便我们就直接打印一下吧, 顺便加一个 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;any = %ld\n&quot;</span>, any + <span class="number">1</span>);</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">any = 124</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>效果大概就是这样，个人觉得对于我们编写扩展而言用处不是很大，了解一下即可。</strong></p>
<h4 id="占位符-2"><a href="#占位符-2" class="headerlink" title="占位符 ;"></a>占位符 ;</h4><p><strong>占位符 <code>;</code> 和 <code>:</code> 比较类似，但 <code>;</code> 更加粗暴。至于怎么个粗暴法，看个栗子就一目了然了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!;my name is van, i am a artist, a performance artist&quot;</span>, keys,</span><br><span class="line">                                    &amp;PyFloat_Type, &amp;val1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来调用试试，看看会有什么结果：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;val1&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes at most 1 argument (2 given)</span></span><br></pre></td></tr></table></figure>

<p><strong>目前来看的话，似乎一切正常，但是往下看：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015337660-882885515.png" alt="img"></p>
<p><strong>此时把整个报错信息都给修改了，因此这个符号也不是很常用。</strong></p>
<blockquote>
<p><strong>注意：<code>;</code> 同样需要放到结尾，并且和 <code>:</code> 相互排斥，两者不可同时出现。</strong></p>
</blockquote>
<h4 id="占位符-3"><a href="#占位符-3" class="headerlink" title="占位符 $"></a>占位符 $</h4><p><strong>老规矩，还是先来看一个常规的例子。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OOO&quot;</span>, keys,</span><br><span class="line">                                    &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(val1=<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br></pre></td></tr></table></figure>

<p><strong>以上都是没有问题的，可以通过位置参数传递、也可以通过关键字参数传递，只要位置参数在关键字参数之前即可。但如果我们希望某个参数只能通过关键字的方式传递呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="comment">// 指定一个 $, 那么 $ 后面只能通过关键字参数的方式传递</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OO$O&quot;</span>, keys,</span><br><span class="line">                                    &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重新编译然后测试：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(val1=<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="comment"># 以上仍然是正常的, 都会打印 None</span></span><br><span class="line"><span class="comment"># 但是下面不行了, 因为 val3 必须通过关键字参数的方式传递</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 2 positional arguments (3 given)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实这就等价于如下:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">val1, val2, *, val3</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>不过有一点需要注意，目前来说，如果 <code>|</code> 和 <code>$</code> 同时出现的话，那么 <code>|</code> 必须要在 <code>$</code> 的前面。所以如果既有仅限关键字参数、又有可选参数，那么仅限关键字参数必须同时也是可选参数，所以 <code>|</code> 要在 <code>$</code> 的前面。如果我们把 <code>|</code> 写在了 <code>$</code> 的后面，那么执行会抛异常。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015345658-963304683.png" alt="img"></p>
<p><strong>并且，即便仅限关键字参数和默认参数相同，那也应该这么写 <code>OO|$O</code>，而不能这么写 <code>OO$|O</code>。</strong></p>
<h4 id="占位符-4"><a href="#占位符-4" class="headerlink" title="占位符"></a>占位符</h4><p><strong>这个 # 不可以跟在 O 后面，它是跟在 s 或者 u 后面，用来限制长度，有兴趣自己去了解一下。</strong></p>
<h3 id="Py-BuildValue"><a href="#Py-BuildValue" class="headerlink" title="Py_BuildValue"></a>Py_BuildValue</h3><p><strong>下面介绍一个非常方便的函数 Py_BuildValue，专门用来对数据进行打包的，返回一个 PyObject *，同样是通过占位符的方式。</strong></p>
<p><strong>Py_BuildValue 的占位符和 PyArg_ParseTuple  里面的占位符是一致的，只不过功能相反。比如：i，PyArg_ParseTuple 是将 Python 中的 int 转成 C 中的 int，而  Py_BuildValue 是将 C 中的 int 打包成 Python 中的 int。所以它们的占位符一致，功能正好相反，并且我们在介绍  PyArg_ParseTuple 的时候只介绍一部分占位符，其实支持的占位符不止我们上面说的那些，下面就来罗列一下。</strong></p>
<blockquote>
<p><strong>再重复一次，PyArg_ParseTuple 和 Py_BuildValue 的占位符是一致的，但是功能相反。</strong></p>
</blockquote>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015355373-976625594.png" alt="img"></p>
<p><strong>我们只接用官方的栗子，因为官方给的栗子非常直观。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_BuildValue(<span class="string">&quot;&quot;</span>)                       		            None</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;i&quot;</span>, <span class="number">123</span>)</span>                                     123</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;iii&quot;</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>)</span>                         <span class="params">(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span>                                 &#x27;hello&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;y&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span>                                 b&#x27;hello&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;ss&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span>                       <span class="params">(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;s#&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4</span>)</span>                             &#x27;hell&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;y#&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4</span>)</span>                             b&#x27;hell&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;()&quot;</span>)</span>                                         <span class="params">()</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(i)&quot;</span>, <span class="number">123</span>)</span>                                   <span class="params">(<span class="number">123</span>,)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(ii)&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                             <span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(i,i)&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                            <span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;[i,i]&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                            [123, 456]</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;&#123;s:i,s:i&#125;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">123</span>, <span class="string">&quot;def&quot;</span>, <span class="number">456</span>)</span>          &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">456</span>&#125;</span><br><span class="line">Py_BuildValue(<span class="string">&quot;((ii)(ii)) (ii)&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)          (((<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)), (<span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p><strong>如果是多个符号，自动会变成一个元组。我们来测试一下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *lst = PyList_New(<span class="number">5</span>);</span><br><span class="line">    PyList_SetItem(lst, <span class="number">0</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;i&quot;</span>, <span class="number">123</span>));</span><br><span class="line">    PyList_SetItem(lst, <span class="number">1</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;is&quot;</span>, <span class="number">123</span>, <span class="string">&quot;hello matsuri&quot;</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">2</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;[i, i]&quot;</span>, <span class="number">123</span>, <span class="number">321</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">3</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;(s)s&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;matsuri&quot;</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">4</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;&#123;s: s&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;matsuri&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  </span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">from pprint import pprint</span><br><span class="line">import kagura_nana</span><br><span class="line"><span class="title function_">pprint</span><span class="params">(kagura_nana.f1())</span></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[123,</span><br><span class="line"> <span class="params">(<span class="number">123</span>, <span class="string">&#x27;hello matsuri&#x27;</span>)</span>,</span><br><span class="line"> [123, 321],</span><br><span class="line"> <span class="params">((<span class="string">&#x27;hello&#x27;</span>,), <span class="string">&#x27;matsuri&#x27;</span>)</span>,</span><br><span class="line"> &#123;<span class="string">&#x27;hello&#x27;</span>: <span class="string">&#x27;matsuri&#x27;</span>&#125;]</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到结果是符合我们的预期的，另外除了 Py_BuildValue 之外，还有一个 PyTuple_Pack，这两者是类似的，只不过后者只接收 PyObject *，举个栗子就很清晰了：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Py_BuildValue(&quot;OO&quot;, a, b) 等价于 PyTuple_Pack(2, a, b)</span><br></pre></td></tr></table></figure>

<p><strong>这个是固定打包成元组，而且第一个参数是个数，不是 format，因此它不支持通过占位符来指定元素类型，而是只接收 PyObject *。</strong></p>
<h3 id="操作-PyDictObject"><a href="#操作-PyDictObject" class="headerlink" title="操作 PyDictObject"></a>操作 PyDictObject</h3><p><strong>Python  中的字典在底层要如何读取、如何设置，这个我们必须要好好地说一说。像整型、浮点型、字符串、元组、列表、集合，它们都比较简单，我们就不详细说了。比如列表：Python 中插入元素是调用 insert，那么底层则是 PyList_Insert；追加元素是 append，那么底层则是  PyList_Append；设置元素是 __setitem__，那么底层则是 PyList_SetItem；同理获取元素是  PyList_GetItem，写法非常具有规范性。所以如果不知道某个 API 的话，可以去查看解释的源码，比如你想查看元组，那么就去  Include&#x2F;tupleobject.h 中查看：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015455511-312227169.png" alt="img"></p>
<p><strong>像这些凡是以 PyAPI 开头的都是可以直接用的，PyAPI_DATA  表示数据，PyAPI_FUNC 表示函数，至于它们的含义是什么，我们可以通过文档查看。在 Python 的安装目录的 Doc  目录下就有，点击通过关键字进行检索即可。当然基本数据类型的一些方法，相信通过函数名即可判断，比如：PyTuple_GetItem，很明显就是通过索引获取元素的。还是那句话，Python 解释器的整个工程，在命名方面都非常有规律。</strong></p>
<p><strong>所以我们的重点是字典的使用，因为字典比较特殊，它里面的键值对的形式，而列表、元组等容器里面的元素是单一独立的。</strong></p>
<h4 id="PyDictObject-的读取"><a href="#PyDictObject-的读取" class="headerlink" title="PyDictObject 的读取"></a>PyDictObject 的读取</h4><p><strong>先来介绍内部关于读取的一些 API：</strong></p>
<ul>
<li><code>PyDict_Contains(dic, key)：判断字典中是否具有某个 key</code></li>
<li><code>PyDict_GetItem(dic, key)：获取字典中某个 key 对应的 value</code></li>
<li><code>PyDict_GetItemString(dic, key)：和 PyDict_GetItem 作用相同，但这里的 key 是一个 char *</code></li>
<li><code>PyDict_Keys(dic)：获取所有的 key</code></li>
<li><code>PyDict_Values(dic)：获取所有的 value</code></li>
<li><code>PyDict_Items(dic)：获取所有的 key-value</code></li>
</ul>
<p><strong>下面我们来操作一波：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *res;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查是否包含 &quot;name&quot; 这个 key</span></span><br><span class="line">    PyObject *name = PyUnicode_FromString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Contains(dic, name))&#123;</span><br><span class="line">        res = PyUnicode_FromString(<span class="string">&quot;key `name` does not exists&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyDict_GetItem(dic, name);</span><br><span class="line">        <span class="comment">// 注意：这一步很关键，因为我们下面返回了 res，而这个 res 是从 Python 传递过来的字典中获取的</span></span><br><span class="line">        <span class="comment">// 因此它的引用计数不会加 1，只是指向了某个已存在的空间，因此返回之前我们需要将引用计数加 1</span></span><br><span class="line">        <span class="comment">// 至于 if 里面的 res，因为它是在 C 中创建了新的空间，所以不需要关心</span></span><br><span class="line">        Py_INCREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时我们能直接返回 res 吗? 很明显是不能的，因为我们上面还创建了一个 Python 的字符串 name</span></span><br><span class="line">    <span class="comment">// 这是在 C 中创建的，并且也没作为返回值，那么我们就必须要手动将其引用计数减 1</span></span><br><span class="line">    <span class="comment">// 因此这种时候更推荐使用 PyDict_GetItemString，它接收一个 C 字符串，函数结束时自动释放</span></span><br><span class="line">    <span class="comment">// 但是很明显这个函数局限性比较大</span></span><br><span class="line">    Py_DECREF(name);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  </span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  <span class="meta"># argument 1 must be dict, not str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(kagura_nana.f1(&#123;&#125;))  <span class="meta"># key `name` does not exists</span></span><br><span class="line">print(kagura_nana.f1(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;古明地觉&quot;</span>&#125;))  # 古明地觉</span><br></pre></td></tr></table></figure>

<h4 id="PyDictObject-的遍历"><a href="#PyDictObject-的遍历" class="headerlink" title="PyDictObject 的遍历"></a>PyDictObject 的遍历</h4><p><strong>首先我们说可以通过 PyDict_Keys、PyDict_Values、PyDict_Items 来进行遍历，下面演示一下。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *res = PyList_New(<span class="number">3</span>);  <span class="comment">// 返回值</span></span><br><span class="line">    PyList_SetItem(res, <span class="number">0</span>, PyDict_Keys(dic));</span><br><span class="line">    PyList_SetItem(res, <span class="number">1</span>, PyDict_Values(dic));</span><br><span class="line">    PyList_SetItem(res, <span class="number">2</span>, PyDict_Items(dic));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;satori&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;))</span></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[&#x27;name&#x27;, &#x27;age&#x27;], </span><br><span class="line"> [&#x27;satori&#x27;, 17], </span><br><span class="line"> [<span class="params">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;satori&#x27;</span>)</span>, <span class="params">(<span class="string">&#x27;age&#x27;</span>, <span class="number">17</span>)</span>]]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>而且我们看到 PyDict_Keys  等函数返回的是列表，这说明创建了一个新的空间，引用计数为 1。但我们没有调用  Py_DECREF，这是因为我们将其放在了一个新的列表中，如果作为某个容器的元素，那么引用计数也应该要增加。但对于  PyListObject、PyTupleObject 而言，通过 PyList_SetItem、PyTuple_SetItem  是不会增加指向对象的引用计数的，所以结果正好抵消，我们不需要对引用计数做任何处理。</strong></p>
<blockquote>
<p><strong>但如果我们是通过 PyList_Append 进行追加、或者  PyList_Insert 进行插入的话，那么是会增加引用计数的，这样引用计数就增加了 2，因此我们还需要减去  1。所以这一点比较烦人，因为你光知道何时增加引用计数、何时减少引用计数还是不够的，你还要看某一个操作到底有没有增加、或者减少。就拿我们这里设置元素为例，本来作为容器内的一个元素，理论上是要增加引用计数的，但是结果却没有增加。而添加和插入元素，也是作为容器的一个元素，但是这两个操作却增加了。所以还是推荐 Cython，再度安利一波，写扩展用 Cython 真的非常香。</strong></p>
</blockquote>
<p><strong>这里我们将元素都获取出来了，至于遍历也很简单，这里不测试了。</strong></p>
<h4 id="PyDictObject-的设置和删除"><a href="#PyDictObject-的设置和删除" class="headerlink" title="PyDictObject 的设置和删除"></a>PyDictObject 的设置和删除</h4><ul>
<li><code>PyDict_SetItem(dic, key, value)：设置元素</code></li>
<li><code>PyDict_DelItem(dic, key, value)：删除元素</code></li>
<li><code>PyDict_Clear(dic)：清空字典</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个 &quot;name&quot;: &quot;satori&quot;</span></span><br><span class="line">    PyObject *key = PyUnicode_FromString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    PyObject *value = PyUnicode_FromString(<span class="string">&quot;satori&quot;</span>);</span><br><span class="line">    PyDict_SetItem(dic, key, value);</span><br><span class="line">    <span class="comment">// 因为 key 和 value 是 C 中创建的，首先引用计数为 1</span></span><br><span class="line">    <span class="comment">// 然后它们又放到了字典里，对于字典而言，设置元素是会增加引用计数的，所以这里引用计数变成了 2</span></span><br><span class="line">    <span class="comment">// 因此我们需要手动将它们的引用计数减去 1，否则这个键值对永远不会被回收。</span></span><br><span class="line">    <span class="comment">// 所以最让人烦的就是这个引用计数，非常的讨厌，因为你不知道它到底有没有增加</span></span><br><span class="line">    Py_XDECREF(key);</span><br><span class="line">    Py_XDECREF(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 &quot;age&quot; 这个 key 就将其删掉</span></span><br><span class="line">    key = PyUnicode_FromString(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (PyDict_Contains(dic, key)) &#123;</span><br><span class="line">        PyDict_DelItem(dic, key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XDECREF(key); <span class="comment">// 同样减少引用计数</span></span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;mashiro&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">kagura_nana.f1(dic)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;satori&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然还有很多其它 API，可以查看源代码（Include&#x2F;dictobject.h）自己测试一下。</strong></p>
<h2 id="编写扩展类"><a href="#编写扩展类" class="headerlink" title="编写扩展类"></a>编写扩展类</h2><p><strong>我们之前在 C 中编写的都是函数，但光有函数显然是不够的，我们需要实现类。而在 C 中实现的类被称为扩展类，它和 Python 内置的类（int、dict、str等等）是等价的，都属于静态类，直接指向了 C 一级的数据结构。</strong></p>
<p><strong>下面来看看在 C 中如何实现扩展类，首先我们来实现一个最基本的扩展类，也就是只包含一些最关键的部分。然后再添加类参数、方法，以及继承等等。</strong></p>
<p><strong>当然最重要的一点，我们还要解决类的循环引用、以及自定义垃圾回收。像列表、元组、字典等容器，它们也都会发生循环引用。</strong></p>
<blockquote>
<p><strong>前面有一点我们没有提，当一个容器（比如列表）引用计数减一的时候，里面的元素（指向的对象）的引用计数是不会发生改变的。只有当一个容器的引用计数为 0 被销毁的时候，在销毁之前会先将内部元素的引用计数都减 1，然后再销毁这个容器。</strong></p>
</blockquote>
<p><strong>而循环引用是引用计数机制所面临的最大的痛点，所以 Python 中的 gc 就是来干这个事情的，通过分代技术根据对象的生命周期划分为三个链表，然后通过三色标记模型来找出那些具有循环引用的对象，改变它们的引用计数。所以在 Python 中一个对象是否要被回收，最终还是取决于它的引用计数是否为 0。如果是 Python  代码的话，我们在实现类的时候，解释器会自动帮我们处理这一点，但我们是做类扩展，因此这些东西就必须由我们来考虑了。</strong></p>
<h3 id="编写扩展类前奏曲"><a href="#编写扩展类前奏曲" class="headerlink" title="编写扩展类前奏曲"></a>编写扩展类前奏曲</h3><p><strong>我们之前编写了扩展函数，我们说首先要创建一个模块，这里也是一样的，因为类也要在模块里面。编写函数是有套路的，编写类也是一样，我们还是先看看大致的流程，具体细节会在慢慢补充。</strong></p>
<p><strong>首先我们需要了解以下内容：</strong></p>
<ul>
<li><code>1. 一个类要有类名、构造函数、析构函数</code></li>
<li><code>2. 所有的类在底层都是一个 PyTypeObject 实例，而且类也是一个对象</code></li>
<li><code>3. PyType_Ready 对类进行初始化，主要是进行属性字典的设置</code></li>
<li><code>4. PyModule_AddObject，将扩展类添加到模块中</code></li>
</ul>
<p><strong>那么一个类在底层都有哪些属性呢？很明显，我们说所有的类都是一个 PyTypeObject 实例，那么我们就把这个结构体拷贝出来看一下就知道了。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面我们来介绍一下内部成员都代表什么含义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头部信息，PyVarObject ob_base; 里面包含了引用计数、类型、ob_size</span></span><br><span class="line">    <span class="comment">// 而创建这个结构体实例的话，Python 提供了一个宏，PyVarObject_HEAD_INIT(type, size)</span></span><br><span class="line">    <span class="comment">// 传入类型和大小可以直接创建，至于引用计数则默认为 1</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">// 创建之后的类名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    <span class="comment">// 大小，用于申请空间的，注意了，这里是两个成员</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 析构方法__del__，当删除实例对象时会调用这个操作</span></span><br><span class="line">    <span class="comment">// typedef void (*destructor)(PyObject *); 函数接收一个PyObject *，没有返回值</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印其实例对象是调用的函数</span></span><br><span class="line">    <span class="comment">// typedef int (*printfunc)(PyObject *, FILE *, int); 函数接收一个PyObject *、FILE * 和 int</span></span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性，内部的 __getattr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getattrfunc)(PyObject *, char *);</span></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置属性,内部的 __setattr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef int (*setattrfunc)(PyObject *, char *, PyObject *);</span></span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 Python3.5之后才产生的，这个不需要关注。</span></span><br><span class="line">    <span class="comment">// 并且在其它类的注释中，这个写的都是tp_reserved</span></span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    <span class="comment">// 内部的 __repr__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一个对象作为数值所有拥有的方法</span></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    <span class="comment">// 一个对象作为序列所有拥有的方法</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    <span class="comment">// 一个对象作为映射所有拥有的方法</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//内部的 __hash__ 方法</span></span><br><span class="line">    <span class="comment">// typedef Py_hash_t (*hashfunc)(PyObject *);</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的 __call__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的 __repr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);</span></span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    <span class="comment">// typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//作为缓存，不需要关心</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    typedef struct &#123;</span></span><br><span class="line"><span class="comment">    	 getbufferproc bf_getbuffer;</span></span><br><span class="line"><span class="comment">     	releasebufferproc bf_releasebuffer;</span></span><br><span class="line"><span class="comment">	&#125; PyBufferProcs;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类的特点，比如：</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HEAPTYPE: 是否在堆区申请空间</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_BASETYPE: 是否允许这个类被其它类继承</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_IS_ABSTRACT: 是否为抽象类</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HAVE_GC: 是否被垃圾回收跟踪</span></span><br><span class="line">    <span class="comment">// 这里面有很多，具体可以去 object.h 中查看</span></span><br><span class="line">    <span class="comment">// 一般我们设置成 Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC 即可</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这个类的注释</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//用于检测是否出现循环引用，和下面的tp_clear是一组</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    class A:</span></span><br><span class="line"><span class="comment">    	pass</span></span><br><span class="line"><span class="comment">    a = A()</span></span><br><span class="line"><span class="comment">    a.attr = a</span></span><br><span class="line"><span class="comment">    此时就会出现循环引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// typedef int (*traverseproc)(PyObject *, visitproc, void *);</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除对包含对象的引用</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 富比较</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弱引用，不需要关心</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __iter__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getiterfunc) (PyObject *);</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    <span class="comment">// __next__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*iternextfunc) (PyObject *);</span></span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="comment">// 内部的方法，这个 PyMethodDef 不陌生了吧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="comment">// 内部的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="comment">// 一个结构体，包含了 name、get、set、doc、closure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承的基类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的属性字典</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述符，__get__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述符，__set__ 方法</span></span><br><span class="line">    <span class="comment">// typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成的实例对象是否有属性字典</span></span><br><span class="line">    <span class="comment">// 我们上一个例子中的实例对象显然是没有属性字典的，因为我们当时没有设置这个成员</span></span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">    <span class="comment">// typedef int (*initproc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    initproc tp_init;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为实例对象分配空间的函数</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);</span></span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __new__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);</span></span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    <span class="comment">// 我们一般设置到 tp_new 即可，剩下的就不需要管了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放一个实例对象</span></span><br><span class="line">    <span class="comment">// typedef void (*freefunc)(void *); 一般会在析构函数中调用</span></span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// typedef int (*inquiry)(PyObject *); 是否被 gc 跟踪</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承哪些类，这里可以指定继承多个类</span></span><br><span class="line">    <span class="comment">// 这个还是有必要的，因此这个可以单独设置</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的就不需要关心了</span></span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line">    destructor tp_finalize;</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里面我们看到有很多成员，如果有些成员我们不需要的话，那么就设置为 0  即可。不过即便设置为 0，但是有些成员我们在调用 PyType_Ready 初始化的时候，也会设置进去。比如  tp_dict，这个我们创建类的时候没有设置，但是这个类是有属性字典的，因为在 PyType_Ready 中设置了；但有的不会，比如  tp_dictoffset，这个我们没有设置，那么类在 PyType_Ready  中也不会设置，因此这个类的实例对象，就真的没有属性字典了。再比如 tp_free，我们也没有设置，但是是可以调用的，原因你懂的。</strong></p>
<p><strong>虽然里面的成员非常多，但是我们在实现的时候不一定每一个成员都要设置。如果只需要指定某几个成员的话，那么我们可以先创建一个 PyTypeObject 实例，然后针对指定的属性进行设置即可。</strong></p>
<p><strong>下面我们来编写一个简单的扩展类，具体细节在代码中体现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是直接定义一个类，它就是我们在 Python 中使用的类，这里采用 C++，因此我们编译时的文件要从 main.c 改成 main.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    PyObject_HEAD  <span class="comment">// 公共的头部信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">或者你直接使用结构体的方式也是可以的，这样源文件还叫 main.c 不需要修改</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    PyObject_HEAD  // 头部信息</span></span><br><span class="line"><span class="comment">&#125; MyClass;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们实现 Python 中的 __new__ 方法，这个 __new__ 方法接收哪些参数来着</span></span><br><span class="line"><span class="comment">// 一个类本身，以及 __init__ 中的参数，我们一般会这样写 def __new__(cls, *args, **kwargs):</span></span><br><span class="line"><span class="comment">// 所以这里的第一个参数就不再是 PyObject *了，而是 PyTypeObject *</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们说 Python 中的 __new__ 方法默认都干了哪些事来着</span></span><br><span class="line">    <span class="comment">// 为创建的实例对象开辟一份空间，然后会将这份空间的指针返回回去交给 self</span></span><br><span class="line">    <span class="comment">// 当然交给 __init__ 的还有其它参数，这些参数是 __init__ 需要使用的，__new__ 方法不需要关心</span></span><br><span class="line">    <span class="comment">// 但是毕竟要先经过 __new__ 方法，所以 __new__ 方法中要有参数位能够接收</span></span><br><span class="line">    <span class="comment">// 最终 __new__ 会将自身返回的 self 连同其它参数组合起来一块交给 __init__</span></span><br><span class="line">    <span class="comment">// 所以 __init__ 中 self 我们不需要关心，我们只需要传递 self 后面的参数即可，因为在 __new__ 会自动传递self</span></span><br><span class="line">    <span class="comment">// 另外多提一嘴：我们使用实例对象调用方法的时候，会自动传递 self，你有没有想过它为什么会自动传递呢？</span></span><br><span class="line">    <span class="comment">// 其实这个在底层是使用了描述符，至于底层是怎么实现的，我们在之前已经说过了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以我们这里要为 self 分配一个空间，self 也是一个指针，但是它已经有了明确的类型，所以我们需要转化一下</span></span><br><span class="line">    <span class="comment">// 当然这里不叫 self 也是可以的，只是我们按照官方的约定，不会引起歧义</span></span><br><span class="line">    <span class="comment">// 分配空间是通过调用 PyTypeObject 的 tp_alloc 方法，传入一个 PyTypeObject *，以及大小，这里是固定的所以是 0</span></span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);  <span class="comment">// 此时就由 Python 管理了</span></span><br><span class="line">    <span class="comment">// 记得返回 self，转成 PyObject *，当然我们这里是 __new__ 方法的默认实现，你也可以做一些其它的事情来控制一下类的实例化行为</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收三个 PyObject *, 但它返回的是一个 int, 0 表示成功、-1 表示失败</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设这个构造函数接收三个参数：name，age，gender</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *gender;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;sis&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="comment">// 这里失败了不能返回 NULL，而是返回 -1，__init__ 比较特殊</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至于如何设置到 self 当中，我们后面演示，这里先打印一下</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s, age = %d, gender = %s\n&quot;</span>, name, age, gender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们说结果为 0 返回成功，结果为 -1 返回失败，所以走到这里的话应该返回 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数, 返回值是 void，关于这些函数的参数和返回值的定义可以查看上面介绍的 PyTypeObject 结构体</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句话吧</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call __del__\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 拿到类型，调用 tp_free 释放，这个是释放实例对象所占空间的。所以 tp_alloc 是申请、tp_dealloc 是释放</span></span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT, <span class="comment">// 头部信息</span></span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>, <span class="comment">// 模块注释</span></span><br><span class="line">    <span class="number">-1</span>,  <span class="comment">// 模块空间</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">// 这里是 PyMethodDef 数组，但是我们这里没有 PyMethodDef，所以就是 0，也就是我们这里面没有定义函数</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建类的这些过程，我们也可以单独写，我们这里第一次演示就直接写在模块初始化函数里面了</span></span><br><span class="line">    <span class="comment">// 实例化一个 PyTypeObject，但是这里面的属性非常多，我们通过直接赋值的方式需要写一大堆，所以先定义，然后设置指定的属性</span></span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们知道 PyTypeObject 结构体的第一个参数就是 PyVarObject ob_base;</span></span><br><span class="line">    <span class="comment">// 需要引用计数(初始为1)、类型 &amp;PyType_Type、ob_size(不可变，写上0即可)</span></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;  <span class="comment">// 类的公共头部</span></span><br><span class="line">    <span class="comment">// 这里是类名，但是这个 MyClass 是 Python 中打印的时候显示的名字，或者说调用 __name__ 显示的名字</span></span><br><span class="line">    <span class="comment">// 假设我们上面的是 MyClass1，那么在 Python 中你就需要使用 MyClass1 来实例化</span></span><br><span class="line">    <span class="comment">// 但是使用 type 查看的时候显示的 MyClass，因为类名叫 MyClass，但是很明显这两者应该是一致的</span></span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);  <span class="comment">// 类的空间大小</span></span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>; <span class="comment">// 设置为 0</span></span><br><span class="line">    <span class="comment">// 设置类的 __new__ 方法、__init__ 方法、__del__ 方法</span></span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化类，调用 PyType_Ready,而且 Python 内部的类在创建完成之后也会调用这个方法进行初始化，它会对创建类进行一些属性的设置</span></span><br><span class="line">    <span class="comment">// 记得传入指针进去</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果结果小于0，说明设置失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是我们自己创建的类，所以需要手动增加引用计数</span></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    <span class="comment">// 加入到模块中，这个不需要在创建 PyModuleDef 的时候指定，而是可以单独添加</span></span><br><span class="line">    <span class="comment">// 我们需要先把模块创建出来，然后通过 PyModule_AddObject 将类添加进去</span></span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="comment">// 传入 创建的模块的指针 m、类名(这个类名要和我们上面设置的 tp_name 保持一致)、以及由 PyTypeObject * 转化得到的 PyObject *</span></span><br><span class="line">    <span class="comment">// 另外多提一嘴，这里的 m、和 cls 以及上面 module 都只是 C 中的变量，具体的模块名和类名是 kagura_nana 和 MyClass</span></span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m; <span class="comment">// 将模块对象返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后是用于编译的 py 文件：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.11&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;古明地盆&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;66666@东方地灵殿.com&quot;</span>,</span><br><span class="line">    <span class="comment"># 这里改成 main.cpp</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;kagura_nana&quot;</span>, [<span class="string">&quot;main.cpp&quot;</span>])],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：之前使用的都是自己住的地方的台式机，里面装了相应的环境，因为机器性能比较好。但是春节本人回家了，现在使用的是自己的笔记本，而笔记本里面没有装 Visual Studio 等环境，因此接下来环境会选择我阿里云上的 CentOS。</strong></p>
</blockquote>
<p><strong>编译的方式跟之前一样，只不过需要先执行一下 <code>yum install gcc-c++</code>，否则编译时会抛出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc: error trying to exec &#x27;cc1plus&#x27;: execvp: No such file or directory</span><br></pre></td></tr></table></figure>

<p><strong>如果你已经装了，那么是没有问题的，但也建议执行确认一下。下面操作一波：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kagura_nana</span><br><span class="line">&lt;module <span class="string">&#x27;kagura_nana&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/usr/local/lib64/python3.6/site-packages/kagura_nana.cpython-36m-x86_64-linux-gnu.so&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 然后实例化一个类</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 我们说这个类的构造函数中接收三个参数，我们先不传递，看看会有什么表现</span></span><br><span class="line"><span class="meta">... </span>    self = kagura_nana.MyClass()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">call __del__</span><br><span class="line">Required argument <span class="string">&#x27;name&#x27;</span> (pos <span class="number">1</span>) <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<p><strong>尽管实例化失败，但是这个对象在 <strong>new</strong> 方法中被创建了，所以依旧会调用 __del__。然后我们传递参数，但是我们在构造函数中只是打印，并没有设置到 self 中。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;mashiro&quot;</span>, <span class="number">16</span>, <span class="string">&quot;female&quot;</span>)</span><br><span class="line">name = mashiro, age = <span class="number">16</span>, gender = female</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;MyClass&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到调用失败了，因为我们没有设置到 self 中，然后再看看析构函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> self</span><br><span class="line">call __del__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>成功调用，然后里面的 printf 也成功执行。</strong></p>
<h3 id="给实例对象添加属性"><a href="#给实例对象添加属性" class="headerlink" title="给实例对象添加属性"></a>给实例对象添加属性</h3><p><strong>整体流程我们大致了解了，下面看看如何给实例对象添加属性。我们说 PyTypeObject 里面有一个 tp_members 属性，很明显它就是用来指定实例对象的属性的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span>  <span class="comment">// 添加成员需要导入这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="comment">// 添加成员，这里面的参数要和 __init__ 中的参数保持一致，你可以把 name、age、gender 看成是要通过 self. 的方式来设置的属性</span></span><br><span class="line">    <span class="comment">// 假设这里面没有 gender,那么即使 Python 中传了 gender 这个参数、并且解析出来了</span></span><br><span class="line">    <span class="comment">// 但是你仍然没办法设置，所以实例化的对象依旧无法访问</span></span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age;</span><br><span class="line">    PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 你仍然可以使用结构体的方式定义</span></span><br><span class="line"><span class="comment">typedef struct&#123;</span></span><br><span class="line"><span class="comment">	PyObject_HEAD</span></span><br><span class="line"><span class="comment">	PyObject *name;</span></span><br><span class="line"><span class="comment">	PyObject *age;</span></span><br><span class="line"><span class="comment">	PyObject *gender;</span></span><br><span class="line"><span class="comment">&#125;MyClass;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里不使用 C 的类型了，使用 PyObject *，参数和原来一样</span></span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 注意：上面申明的三个 PyObject * 变量叫什么名字其实是没有所谓的，重点是 MyClass 和 下面 keys</span></span><br><span class="line">    <span class="comment">// keys 里面的字符串就是 __init__ 中的参数名，MyClass 中的变量则是实例对象的属性名</span></span><br><span class="line">    <span class="comment">// 假设把 MyClass 这个类中的 name 改成 NAME，那么最终的形式就等价于 self.NAME = name</span></span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意: 有一个很关键的点，在 __init__ 函数调用结束之后，name、age、gender 的引用计数会减一</span></span><br><span class="line">    <span class="comment">// 而它们又是从 Python 传递过来的，所以为了保证不出现悬空指针，我们必须要将引用计数手动加 1</span></span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="comment">// 而 age 和 gender 是可以不传的，我们需要给一个默认值。</span></span><br><span class="line">    <span class="comment">// 当传递了 age，那么增加引用计数；没有传递 age，我们自己创建一个，由于是创建，引用计数初始为 1，所以此时就无需增加了。gender 也是同理</span></span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 这里就是设置 __init__ 属性的，将解析出来的参数设置到 __init__ 中</span></span><br><span class="line">    <span class="comment">// 注意 PyObject * 要转成 MyClass *，并且考虑优先级，我们需要使用括号括起来</span></span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="comment">// 此时我们的构造函数就设置完成了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同样的问题，当对象在销毁的时候，实例对象的成员的引用计数是不是也要减去 1 呢</span></span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; name);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; age);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; gender);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成员，这是一个 PyMemberDef 类型的数组，然后显然要把数组名放到类的 tp_members 中</span></span><br><span class="line">    <span class="comment">// PyNumberDef 结构体有以下成员：name type offset flags doc</span></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        <span class="comment">//这些成员具体值是什么？我们需要在 MyClass_init 中设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>, <span class="comment">// 成员名</span></span><br><span class="line">            T_OBJECT_EX, <span class="comment">// 类型，关于类型我们一会儿介绍</span></span><br><span class="line">            <span class="comment">// 接收结构体对象和一个成员</span></span><br><span class="line">            <span class="comment">// 获取对应值的偏移地址，由于 Python 中的类是动态变化的，所以 C 只能通过偏移的地址来找到对应的成员，offsetof 是一个宏</span></span><br><span class="line">            <span class="comment">// 而这里面的 name 就是我们定义的 MyClass 里面的 name，所以如果 MyClass 里面不设置，那么这里会报错</span></span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 变量的读取类型，设置为 0 表示可读写，设置为 1 表示只读</span></span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span> <span class="comment">//成员说明</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 这里将 age 设置为只读</span></span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">1</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;  <span class="comment">// 结尾有一个&#123;NULL&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置成员，这一步很关键，否则之前的相当于白做</span></span><br><span class="line">    cls.tp_members = members;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;古明地觉&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;萌妹子&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;美少女&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;古明地恋&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;美少女&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.gender = <span class="string">&quot;koishi&quot;</span>, <span class="string">&quot;びしょうじょ&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;koishi&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;びしょうじょ&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 我们看到一些都没有问题，但接下来重点来了</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age = <span class="number">16</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: readonly attribute</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>一切正常，并且我们看到 age 是只读的，因为我们在 PyMemberDef 中将其设置为只读，我们来看一下这个结构体。该结构体的定义藏身于 *Include&#x2F;structmember.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">// 实例属性的名字, 比如我们上面的 name、age、gender</span></span><br><span class="line">    <span class="type">int</span> type;		   <span class="comment">// 实例属性的类型, 这一点很关键, 支持的类型我们一会说</span></span><br><span class="line">    Py_ssize_t offset;  <span class="comment">// 实例属性的偏移量，通过 offsetof(TYPE, MEMBER) 这个宏来获取</span></span><br><span class="line">    <span class="type">int</span> flags;		   <span class="comment">// 设置为 0 表示可读可写, 设置为 1 表示只读</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *doc;    <span class="comment">// 属性说明</span></span><br><span class="line">&#125; PyMemberDef;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们重点看一下里面的 type 成员，它表示属性的类型，支持如下选项：</strong></p>
<ul>
<li><code>#define T_SHORT     0</code></li>
<li><code>#define T_INT       1</code></li>
<li><code>#define T_LONG      2</code></li>
<li><code>#define T_FLOAT     3</code></li>
<li><code>#define T_DOUBLE    4</code></li>
<li><code>#define T_STRING    5</code></li>
<li><code>#define T_OBJECT    6</code></li>
<li><code>#define T_CHAR      7</code></li>
<li><code>#define T_BYTE      8 </code></li>
<li><code>#define T_UBYTE     9</code></li>
<li><code>#define T_USHORT    10</code></li>
<li><code>#define T_UINT      11</code></li>
<li><code>#define T_ULONG     12</code></li>
<li><code>#define T_STRING_INPLACE    13</code></li>
<li><code>#define T_BOOL      14</code></li>
<li><code>#define T_OBJECT_EX 16</code></li>
<li><code>#define T_LONGLONG      17</code></li>
<li><code>#define T_ULONGLONG     18</code></li>
<li><code>#define T_PYSSIZET      19  </code></li>
<li><code>#define T_NONE          20  </code></li>
</ul>
<p><strong>我们的类（MyClass）中的成员应该是 PyObject  *，但是用来接收参数的变量可以不是，只不过在设置实例属性的时候需要再转成 PyObject *，如果接收的就是 PyObject  *，那么就不需要再转了。而上面这些描述的就是参数的类型，所以我们一般用 T_OBJECT_EX 即可，但是还有一个  T_OBJECT，这两者的区别是前者如果接收的是 NULL（没有接收到值），那么会引发一个 AttributeError。</strong></p>
<blockquote>
<p><strong>到目前为止，我们应该感受到使用 C&#x2F;C++ 来写扩展是一件多么痛苦的事情，特别是引用计数，一搞不好就出现内存泄漏或者悬空指针。因此，关键来了，再次安利一波 Cython。</strong></p>
</blockquote>
<p><strong>除了 <strong>init__、__new__、__del</strong> 之外，你还可以添加其它的方法，比如 tp_call、tp_getset 等等。</strong></p>
<h3 id="给类添加成员"><a href="#给类添加成员" class="headerlink" title="给类添加成员"></a>给类添加成员</h3><p><strong>一个类里面可以定义很多的函数，那么这在 C 中是如何实现的呢？很简单，和模块中定义函数是一致的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span>  <span class="comment">// 添加成员需要导入这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        public:</span><br><span class="line">        PyObject_HEAD</span><br><span class="line">        <span class="comment">// 添加成员，这里面的参数要和 __init__ 中的参数保持一致，你可以把 name、age、gender 看成是要通过 self. 的方式来设置的属性</span></span><br><span class="line">        <span class="comment">// 假设这里面没有 gender,那么即使 Python 中传了 gender 这个参数、并且解析出来了</span></span><br><span class="line">        <span class="comment">// 但是你仍然没办法设置，所以实例化的对象依旧无法访问</span></span><br><span class="line">        PyObject *name;</span><br><span class="line">        PyObject *age;</span><br><span class="line">        PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; name);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; age);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; gender);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面来给类添加成员函数啦，添加方法跟之前的创建函数是一样的</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">age_incr_1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((MyClass *)self) -&gt; age = PyNumber_Add(((MyClass *)self) -&gt; age, PyLong_FromLong(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建 PyMethodDef[], 方法和之前创建函数是一样的，但是这是类的方法，记得添加到类的 tp_methods 成员中</span></span><br><span class="line"><span class="type">static</span> PyMethodDef MyClass_methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;age_incr_1&quot;</span>, (PyCFunction)age_incr_1, METH_VARARGS | METH_KEYWORDS, <span class="string">&quot;method age_incr_1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">        PyModuleDef_HEAD_INIT,</span><br><span class="line">        <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">        <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">        <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            T_OBJECT_EX,</span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">0</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cls.tp_members = members;</span><br><span class="line">    <span class="comment">// 设置方法</span></span><br><span class="line">    cls.tp_methods = MyClass_methods;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到几乎没有任何区别，那么下面就来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;美少女&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age_incr_1()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<h3 id="循环引用造成的内存泄漏"><a href="#循环引用造成的内存泄漏" class="headerlink" title="循环引用造成的内存泄漏"></a>循环引用造成的内存泄漏</h3><p><strong>我们说 Python 的引用计数有一个重大缺陷，那就是它无法解决循环引用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    my = MyClass(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">    my.name = my</span><br></pre></td></tr></table></figure>

<p><strong>如果你执行上面这段代码的话，那么你会发现内存不断飙升，很明显我们上面在 C 中定义的类是没有考虑循环引用的，因为它没有被 GC 跟踪。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015512909-1991186827.png" alt="img"></p>
<p><strong>我们看到由于内存使用量不断增加，最后被操作系统强制 kill  掉了，主要就在于我们没有解决循环引用，导致实例对象不断被创建、但却没有被回收（引用计数最大的缺陷）。如果想要解决循环引用的话，那么就需要  Python 中的 GC 出马，而使用 GC 的前提是这个类的实例对象要被 GC 跟踪，因此我们还需要指定  tp_flags。除此之外，我们还要指定 tp_traverse（判断内部成员是否被循环引用）和  tp_clear（清理）两个函数，至于具体细节编写代码时有所体现。最后我们上面的那个类也是不允许被继承的，如果想被继承，同样需要指定  tp_flags。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>(kagura_nana.MyClass):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="built_in">type</span> <span class="string">&#x27;MyClass&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> an acceptable base <span class="built_in">type</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到 MyClass 不是一个可以被继承的类，那么下面我们来进行修改。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        public:</span><br><span class="line">        PyObject_HEAD</span><br><span class="line">        PyObject *name;</span><br><span class="line">        PyObject *age;</span><br><span class="line">        PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">age_incr_1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((MyClass *)self) -&gt; age = PyNumber_Add(((MyClass *)self) -&gt; age, PyLong_FromLong(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> PyMethodDef MyClass_methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;age_incr_1&quot;</span>, (PyCFunction)age_incr_1, METH_VARARGS | METH_KEYWORDS, <span class="string">&quot;method age_incr_1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否被循环引用，参数和返回的值的定义还是参考源码，这里面的参数名要固定</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MyClass_traverse</span><span class="params">(MyClass *self, visitproc visit, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">// 底层帮你提供了一个宏</span></span><br><span class="line">    Py_VISIT(self -&gt; name);</span><br><span class="line">    Py_VISIT(self -&gt; age);</span><br><span class="line">    Py_VISIT(self -&gt; gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MyClass_clear</span><span class="params">(MyClass *self)</span>&#123;</span><br><span class="line">    Py_CLEAR(self -&gt; name);</span><br><span class="line">    Py_CLEAR(self -&gt; age);</span><br><span class="line">    Py_CLEAR(self -&gt; gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们在 MyClass_clear 中使用了 Py_CLEAR，那么这里减少引用计数的逻辑就不需要了，直接调用 MyClass_clear 即可</span></span><br><span class="line">    MyClass_clear((MyClass *) self);</span><br><span class="line">    <span class="comment">// 我们说 Python 会跟踪创建的对象，如果被回收了，那么应该从链表中移除</span></span><br><span class="line">    PyObject_GC_UnTrack(self);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">        PyModuleDef_HEAD_INIT,</span><br><span class="line">        <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">        <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">        <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            T_OBJECT_EX,</span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">0</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cls.tp_members = members;</span><br><span class="line">    cls.tp_methods = MyClass_methods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决循环引用造成的内存泄漏，通过 Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC 开启垃圾回收，同时允许该类被继承</span></span><br><span class="line">    cls.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC;</span><br><span class="line">    <span class="comment">// 设置 tp_traverse 和 tp_clear</span></span><br><span class="line">    cls.tp_traverse = (traverseproc) MyClass_traverse;</span><br><span class="line">    cls.tp_clear = (inquiry) MyClass_clear;</span><br><span class="line">    <span class="comment">// 如果想指定继承的类的话，那么通过 tp_bases 指定即可，这里不再说了</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来继续测试一下，看看有没有问题：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015521571-1265763120.png" alt="img"></p>
<p><strong>可以看到，此时类可以被继承了，并且也没有出现循环引用导致的内存泄漏。</strong></p>
<p>​        <strong>真的想说，用 C  写扩展实在是太不容易了，很明显这还只是非常简单的，因为目前这个类基本没啥方法。如果加上描述符、自定义迭代器，或者我们再多写几个方法。方法之间互相调用，导入模块（目前还没有说）等等，绝对是让人头皮发麻的事情，所以写扩展我一般只用 Cython。</strong>    </p>
<h2 id="全局解释器锁"><a href="#全局解释器锁" class="headerlink" title="全局解释器锁"></a>全局解释器锁</h2><p><strong>我们使用 C &#x2F; C++ 写扩展除了增加效率之外，最大的特点就是能够释放掉 GIL，关于 GIL 也是一个老生常谈的问题。我在前面系列已经说过，这里不再赘述了。</strong></p>
<p><strong>那么问题来了，在 C 中如何获取 GIL 呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先 Python 中的线程是对 C 线程的一个封装，同时还会对应一个 PyThreadState(线程状态) 对象，用来对线程状态进行描述</span></span><br><span class="line"><span class="comment">// 而如果要使用 Python / C API 的话，那么就不能是 C 中的线程，而是 Python 中的线程</span></span><br><span class="line">Py_GILState_STATE gstate;</span><br><span class="line"><span class="comment">// 所以 Python 为了简便而提供了一个函数 PyGILState_Ensure，在 C 中创建了一个线程，那么调用这个函数后，C 线程就会被封装成 Python 中的线程</span></span><br><span class="line"><span class="comment">// 不然的话，我们要写好多代码。这一步会对 Python 中线程进行初始化创建一个 PyThreadState 对象，同时获取 GIL</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">gstate = PyGILState_Ensure(); </span><br><span class="line"><span class="comment">// 做一些其它操作，注意：一旦使用 Python / C API，那么必须要获取到 GIL</span></span><br><span class="line">call_some_function();</span><br><span class="line"><span class="comment">// 释放掉 GIL</span></span><br><span class="line">PyGILState_Release(gstate);</span><br></pre></td></tr></table></figure>

<p><strong>一旦在 C 中获取到 GIL，那么 Python  的其它线程都必须处于等待状态，并且当调用扩展模块中的函数时，解释器是没有权利迫使当前线程释放 GIL 的，因为调用的是 C 的代码，Python 解释器能控制的只有 Python 的字节码这一层。所以在一些操作执行结束后，必须要主动释放 GIL，否则 Python  的其它线程永远不会得到被调度的机会。</strong></p>
<p><strong>但有时我们做的是一些纯 C &#x2F; C++ 操作，不需要和 Python  进行交互，这个时候希望告诉 Python 解释器，其它的线程该执行执行，不用等我，这个时候怎么做呢？首先Python  底层给我们提供了两个宏：Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将当前线程状态给保存下来，然后其它线程就可以继续执行了，从名字上也能看出，开始允许多个线程并行执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_BEGIN_ALLOW_THREADS &#123; \</span></span><br><span class="line"><span class="meta">                        PyThreadState *_save; \</span></span><br><span class="line"><span class="meta">                        _save = PyEval_SaveThread();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复线程状态，回到解释器的 GIL 调用中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \</span></span><br><span class="line"><span class="meta">                 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>从宏定义中我们可以看出，这两个宏是需要成对出现的，当然你也可以使用更细的 API 自己控制。总之：当释放 GIL 的时候，一定不要和 Python 进行交互，或者说不能有任何 Python &#x2F; C API 的调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程调用的函数, 要求接受一个 void *、返回一个 void*</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">test</span><span class="params">(<span class="type">void</span> *lst)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于扩展而言，我们是通过 Python 调用里面的函数，所以调用它的是 Python 中的线程</span></span><br><span class="line">    <span class="comment">// 但这是我们使用 pthread 创建的子线程进行调用，不是 Python 中的，因此它不能和 Python 有任何的交互</span></span><br><span class="line">    <span class="comment">// 而我们是需要和 Python 交互的，这里面的参数 lst 就是由 PyObject * 转化得到的，因此我们需要封装成 Python 中的线程</span></span><br><span class="line">    PyGILState_STATE gstate;</span><br><span class="line">    gstate = PyGILState_Ensure();</span><br><span class="line">    <span class="comment">// 这里面和 Python 进行交互</span></span><br><span class="line">    PyObject *lst1 = (PyObject *) lst;</span><br><span class="line">    <span class="comment">// 我们往里面添加设置几个元素</span></span><br><span class="line">    PyObject *item = PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    <span class="comment">// 注意：以上引用计数变成了 2，我们需要再减去 1</span></span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    item = PyUnicode_FromString(<span class="string">&quot;hello matsuri&quot;</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    <span class="comment">// 假设我们以上 Python 的逻辑就调用完了，那么我们是不是要将 GIL 给释放掉呢？否则其它线程永远没有机会得到调度</span></span><br><span class="line">    <span class="comment">// 干脆我们就不释放了，看看效果吧</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    <span class="comment">// 假设我们接受一个 list</span></span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程 id</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="type">int</span> res = pthread_create(&amp;tid, <span class="literal">NULL</span>, test, (<span class="type">void</span> *)lst);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: error_code = %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015529203-1935981105.png" alt="img"></p>
<p><strong>我们看了程序就无法执行了，因为 Python 只能利用单核，我们在 C  中开启了子线程，然后创建对应的 Python 线程。此时就有两个 Python 线程，只不过一个是主线程，另一个是在 C  中创建的子线程，然后这个子线程通过 Python &#x2F; C API 获取了  GIL，但是用完了不释放，这就导致了主线程永远得不到机会执行。当然也无法接收 Ctrl + C 命令，因此我们需要新启一个终端 kill 掉它。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">test</span><span class="params">(<span class="type">void</span> *lst)</span> &#123;</span><br><span class="line">    PyGILState_STATE gstate;</span><br><span class="line">    gstate = PyGILState_Ensure();</span><br><span class="line">    PyObject *lst1 = (PyObject *) lst;</span><br><span class="line">    PyObject *item = PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    item = PyUnicode_FromString(<span class="string">&quot;hello matsuri&quot;</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    <span class="comment">// 这里将 GIL 释放掉</span></span><br><span class="line">    PyGILState_Release(gstate);</span><br><span class="line">    <span class="comment">// 然后下面就不可以再有任何 Python / C API 的出现了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> res = pthread_create(&amp;tid, <span class="literal">NULL</span>, test, (<span class="type">void</span> *)lst);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: error_code = %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们再来测试一下：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015537923-320854250.png" alt="img"></p>
<p><strong>我们看到此时就没有任何问题了，当 C 中的线程将 GIL  给释放掉之后，此时它和 Python 线程就没有关系了，它就是 C 的线程。那么下面可以写纯 C &#x2F; C++  代码，此时可以实现并行执行。但是能不用多线程就不用多线程，因为多线程出现 bug 之后难以调试。</strong></p>
<p><strong>另外我们目前是在 C 中创建的 Python 线程，但是很明显这需要你对 C 的多线程理解有一定要求。那么我也可以不在 C 中创建，而是在 Python 中创建子线程去调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时该函数要被 Python 的子线程进行调用，但是很明显默认还是受到 GIL 的限制的</span></span><br><span class="line">    Py_BEGIN_ALLOW_THREADS  <span class="comment">// 释放掉 GIL，此时调用该函数的 Python 线程将不再受到解释器的制约，从而实现并行执行</span></span><br><span class="line">    <span class="comment">// 但是很明显，这里面不可以有任何的 Python / C API 调用</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) a ++;  <span class="comment">// 不停的对 a 进行自增，显然程序会一直卡在这里</span></span><br><span class="line">    Py_END_ALLOW_THREADS  <span class="comment">// 获取 GIL，此时会回到解释器的线程调度中</span></span><br><span class="line">    <span class="comment">// 下面就可以包含 Python 逻辑了，如果再遇到纯 C / C++ 逻辑，那么就再通过这两个宏继续实现并行</span></span><br><span class="line">    <span class="comment">// 当然为了演示，我们上面是个死循环</span></span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们在 Python 中创建子线程去调用：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015548684-835884103.png" alt="img"></p>
<p><strong>我们开启了一个子线程，去调用扩展模块中的函数，然后主线程也写了一个死循环。下面看一下 CPU 的使用率：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015553378-2039892645.png" alt="img"></p>
<p><strong>我们看到成功利用了多核，此时我们就通过编写扩展的方式来绕过了解释器中 GIL 的限制。</strong></p>
<p><strong>所以对于一些 C &#x2F; C++ 逻辑，它们不需要和 Python  进行所谓的交互，那么我们就可以把 GIL 释放掉。因为 GIL 本来就是为了保护 Python 中的对象的，为了内存管理，CPython  的开发人员为了直接在解释器上面加上了一把超级大锁，但是当我们不需要和 Python 对象进行交互的时候，就可以把 GIL 给释放掉。</strong></p>
<blockquote>
<p><strong>GIL 是字节码级别互斥锁，当线程执行字节码的时候，如果自身已经获取到  GIL ，那么会判断是否有释放的 GIL 的请求（gil_drop_request）：有则释放、将 CPU  使用权交给其它线程，没有则直接执行字节码；如果自身没有获取到 GIL，那么会先判断 GIL  是否被别的线程获取，若被别的线程获取就一直申请、没有则拿到 GIL 执行字节码。</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>这一次我们聊了聊 Python 和 C&#x2F;C++ 联合编程，我们可以在  Python 中引入 C&#x2F;C++，也可以在 C&#x2F;C++ 中引入 Python，甚至还可以定制 Python 解释器。只不过笔者是主 Python 的，因此在 C&#x2F;C++ 中引入 Python 就不说了。</strong></p>
<p><strong>Python 引入 C&#x2F;C++ 主要是通过编写扩展的方式，这真的是一件痛苦的事情，需要你对 Python &#x2F; C API 有很深的了解，最后仍然安利一波 Cython。</strong></p>
]]></content>
      <tags>
        <tag>CPython</tag>
      </tags>
  </entry>
</search>
